{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NeqSim Documentation","text":"<p>NeqSim (Non-Equilibrium Simulator) is a comprehensive Java library for thermodynamic, physical property, and process simulation. This documentation covers all major packages and provides detailed guides for developing applications.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create a natural gas fluid\nSystemInterface gas = new SystemSrkEos(298.15, 50.0);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"propane\", 0.03);\ngas.addComponent(\"CO2\", 0.02);\ngas.setMixingRule(\"classic\");\n\n// Perform flash calculation\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\nops.TPflash();\n\n// Get properties\nSystem.out.println(\"Density: \" + gas.getDensity(\"kg/m3\") + \" kg/m\u00b3\");\nSystem.out.println(\"Compressibility: \" + gas.getZ());\n</code></pre>"},{"location":"#package-documentation","title":"Package Documentation","text":""},{"location":"#core-thermodynamics","title":"Core Thermodynamics","text":"Package Documentation Description <code>neqsim.thermo</code> thermo/ Thermodynamic systems, phases, components, equations of state, mixing rules, fluid characterization <code>neqsim.thermodynamicoperations</code> thermodynamicoperations/ Flash calculations, phase envelopes, saturation operations <code>neqsim.physicalproperties</code> physical_properties/ Transport properties: viscosity, thermal conductivity, diffusivity, interfacial tension"},{"location":"#process-simulation","title":"Process Simulation","text":"Package Documentation Description <code>neqsim.process</code> process/ Process equipment, unit operations, controllers, process systems, safety systems <code>neqsim.fluidmechanics</code> fluidmechanics/ Pipeline flow, pressure drop, two-phase flow, flow nodes"},{"location":"#pvt-and-reservoir","title":"PVT and Reservoir","text":"Package Documentation Description <code>neqsim.pvtsimulation</code> pvtsimulation/ PVT experiments: CME, CVD, DL, separator tests, swelling tests <code>neqsim.blackoil</code> blackoil/ Black oil model, PVT tables, Rs, Bo, Bg correlations"},{"location":"#chemical-reactions","title":"Chemical Reactions","text":"Package Documentation Description <code>neqsim.chemicalreactions</code> chemicalreactions/ Chemical equilibrium, reaction kinetics"},{"location":"#quality-standards","title":"Quality Standards","text":"Package Documentation Description <code>neqsim.standards</code> standards/ ISO 6976, ISO 6578, ISO 15403, ASTM D6377, sales contracts <code>neqsim.statistics</code> statistics/ Parameter fitting, Monte Carlo simulation, data analysis"},{"location":"#utilities","title":"Utilities","text":"Package Documentation Description <code>neqsim.util</code> util/ Database access, unit conversion, serialization, exceptions <code>neqsim.mathlib</code> mathlib/ Mathematical utilities, nonlinear solvers"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 README.md                      # This file - main index\n\u251c\u2500\u2500 modules.md                     # Module overview\n\u2502\n\u251c\u2500\u2500 thermo/                        # Thermodynamic package\n\u2502   \u251c\u2500\u2500 README.md                  # Package overview\n\u2502   \u251c\u2500\u2500 system/                    # EoS implementations\n\u2502   \u251c\u2500\u2500 phase/                     # Phase modeling\n\u2502   \u251c\u2500\u2500 component/                 # Component properties\n\u2502   \u251c\u2500\u2500 mixingrule/                # Mixing rules\n\u2502   \u2514\u2500\u2500 characterization/          # Plus fraction handling\n\u2502\n\u251c\u2500\u2500 thermodynamicoperations/       # Flash operations\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 physical_properties/           # Transport properties\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 process/                       # Process simulation\n\u2502   \u251c\u2500\u2500 README.md                  # Package overview\n\u2502   \u251c\u2500\u2500 equipment/                 # Equipment documentation\n\u2502   \u251c\u2500\u2500 processmodel/              # ProcessSystem, modules\n\u2502   \u2514\u2500\u2500 safety/                    # Safety systems\n\u2502\n\u251c\u2500\u2500 fluidmechanics/               # Pipe flow\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 pvtsimulation/                # PVT experiments\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 blackoil/                     # Black oil model\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 chemicalreactions/            # Reactions\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 standards/                    # Quality standards\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 statistics/                   # Statistics package\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 util/                         # Utilities\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 mathlib/                      # Math utilities\n\u2502   \u2514\u2500\u2500 README.md\n\u2502\n\u251c\u2500\u2500 safety/                       # Safety system guides\n\u2502   \u251c\u2500\u2500 ESD_BLOWDOWN_SYSTEM.md\n\u2502   \u251c\u2500\u2500 HIPPS_SUMMARY.md\n\u2502   \u251c\u2500\u2500 hipps_implementation.md\n\u2502   \u251c\u2500\u2500 sis_logic_implementation.md\n\u2502   \u251c\u2500\u2500 fire_blowdown_capabilities.md\n\u2502   \u251c\u2500\u2500 psv_dynamic_sizing_example.md\n\u2502   \u2514\u2500\u2500 alarm_system_guide.md\n\u2502\n\u251c\u2500\u2500 simulation/                   # Process simulation guides\n\u2502   \u251c\u2500\u2500 advanced_process_logic.md\n\u2502   \u251c\u2500\u2500 graph_based_process_simulation.md\n\u2502   \u251c\u2500\u2500 parallel_process_simulation.md\n\u2502   \u251c\u2500\u2500 recycle_acceleration_guide.md\n\u2502   \u251c\u2500\u2500 well_simulation_guide.md\n\u2502   \u2514\u2500\u2500 turboexpander_compressor_model.md\n\u2502\n\u251c\u2500\u2500 integration/                  # Integration guides\n\u2502   \u251c\u2500\u2500 ai_platform_integration.md\n\u2502   \u251c\u2500\u2500 ml_integration.md\n\u2502   \u251c\u2500\u2500 mpc_integration.md\n\u2502   \u251c\u2500\u2500 REAL_TIME_INTEGRATION_GUIDE.md\n\u2502   \u2514\u2500\u2500 dexpi-reader.md\n\u2502\n\u251c\u2500\u2500 development/                  # Developer guides\n\u2502   \u251c\u2500\u2500 DEVELOPER_SETUP.md\n\u2502   \u2514\u2500\u2500 contributing-structure.md\n\u2502\n\u251c\u2500\u2500 examples/                     # Code examples\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 wiki/                         # Additional wiki pages\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"#topic-guides","title":"Topic Guides","text":"<p>Specialized guides for advanced features and use cases:</p>"},{"location":"#safety-and-emergency-systems","title":"Safety and Emergency Systems","text":"Guide Description ESD_BLOWDOWN_SYSTEM.md Emergency shutdown and blowdown systems HIPPS_SUMMARY.md High Integrity Pressure Protection Systems hipps_implementation.md HIPPS implementation details hipps_safety_logic.md HIPPS safety logic INTEGRATED_SAFETY_SYSTEMS.md Integrated safety systems overview layered_safety_architecture.md Layered safety architecture sis_logic_implementation.md SIS logic implementation SAFETY_SIMULATION_ROADMAP.md Safety simulation roadmap"},{"location":"#process-logic-and-control","title":"Process Logic and Control","text":"Guide Description process_logic_framework.md Process logic framework ProcessLogicEnhancements.md Logic enhancements advanced_process_logic.md Advanced process logic alarm_system_guide.md Alarm system guide alarm_triggered_logic_example.md Alarm-triggered logic mpc_integration.md MPC integration"},{"location":"#dynamic-simulation","title":"Dynamic Simulation","text":"Guide Description fire_blowdown_capabilities.md Fire and blowdown simulation fire_heat_transfer_enhancements.md Fire heat transfer psv_dynamic_sizing_example.md PSV dynamic sizing rupture_disk_dynamic_behavior.md Rupture disk behavior turboexpander_compressor_model.md Turboexpander modeling"},{"location":"#well-and-reservoir","title":"Well and Reservoir","text":"Guide Description well_simulation_guide.md Well simulation guide well_and_choke_simulation.md Choke simulation field_development_engine.md Field development"},{"location":"#pvt-and-characterization","title":"PVT and Characterization","text":"Guide Description pvt_workflow.md PVT workflow blackoil_pvt_export.md Black oil PVT export whitson_pvt_reader.md Whitson PVT reader fluid_characterization_mathematics.md Characterization math"},{"location":"#advanced-features","title":"Advanced Features","text":"Guide Description parallel_process_simulation.md Parallel simulation recycle_acceleration_guide.md Recycle convergence graph_based_process_simulation.md Graph-based simulation differentiable_thermodynamics.md Auto-differentiation equipment_factory.md Equipment factory dexpi-reader.md DEXPI P&amp;ID reader"},{"location":"#integration","title":"Integration","text":"Guide Description ai_platform_integration.md AI/ML integration ml_integration.md Machine learning REAL_TIME_INTEGRATION_GUIDE.md Real-time systems QRA_INTEGRATION_GUIDE.md QRA integration"},{"location":"#development","title":"Development","text":"Guide Description DEVELOPER_SETUP.md Development environment setup contributing-structure.md Contributing guidelines"},{"location":"#equations-of-state-quick-reference","title":"Equations of State Quick Reference","text":"EoS Class Application SRK <code>SystemSrkEos</code> General hydrocarbon systems PR <code>SystemPrEos</code> General hydrocarbon systems PR-1978 <code>SystemPrEos1978</code> Improved liquid densities SRK-CPA <code>SystemSrkCPAstatoil</code> Associating fluids (water, alcohols, glycols) PC-SAFT <code>SystemPCSAFT</code> Polymers, associating fluids GERG-2008 <code>SystemGERG2008Eos</code> Natural gas reference EOS-CG <code>SystemEOSCGEos</code> CO\u2082-rich systems (CCS) UMR-PRU <code>SystemUMRPRUMCEos</code> Wide-range hydrocarbon systems"},{"location":"#process-equipment-quick-reference","title":"Process Equipment Quick Reference","text":"Category Equipment Class Separation 2-phase separator <code>Separator</code> 3-phase separator <code>ThreePhaseSeparator</code> Distillation column <code>DistillationColumn</code> Heat Transfer Heater <code>Heater</code> Cooler <code>Cooler</code> Heat exchanger <code>HeatExchanger</code> Compression Compressor <code>Compressor</code> Pump <code>Pump</code> Expander <code>Expander</code> Flow Control Valve <code>ThrottlingValve</code> Mixer <code>Mixer</code>, <code>StaticMixer</code> Splitter <code>Splitter</code> Well/Reservoir Well <code>SimpleWell</code> Choke <code>ChokeValve</code>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: Report bugs and request features</li> <li>Discussions: Ask questions and share knowledge</li> <li>API JavaDoc: Generated from source code</li> <li>Examples: See <code>examples/</code> and <code>notebooks/</code> directories</li> </ul>"},{"location":"#version-compatibility","title":"Version Compatibility","text":"<ul> <li>Java: 8+ (builds on 8, 11, 17, 21)</li> <li>Python: Via jpype (<code>neqsim-python</code> package)</li> <li>MATLAB: Via Java interface</li> </ul>"},{"location":"#related-resources","title":"Related Resources","text":"<ul> <li>NeqSim GitHub Repository</li> <li>neqsim-python</li> <li>Example Notebooks</li> </ul>"},{"location":"modules/","title":"NeqSim Base Modules","text":"<p>This document provides an overview of the seven foundational modules that make up NeqSim. Each module resides under <code>src/main/java/neqsim</code> and works together to support fluid characterization and process design.</p>"},{"location":"modules/#thermodynamic-routines","title":"Thermodynamic routines","text":"<ul> <li>Location: <code>thermo</code> and <code>thermodynamicoperations</code></li> <li>Features: fluid phase equilibria, equation-of-state implementations, flash and phase envelope calculations.</li> </ul>"},{"location":"modules/#physical-properties-routines","title":"Physical properties routines","text":"<ul> <li>Location: <code>physicalproperties</code></li> <li>Features: density, viscosity, heat capacity and other transport properties calculated from thermodynamic state.</li> </ul>"},{"location":"modules/#fluid-mechanic-routines","title":"Fluid mechanic routines","text":"<ul> <li>Location: <code>fluidmechanics</code></li> <li>Features: models for steady-state and transient flow, pipeline hydraulics, and flow node/leg modelling.</li> </ul>"},{"location":"modules/#unit-operations","title":"Unit operations","text":"<ul> <li>Location: <code>process/equipment</code></li> <li>Features: library of process equipment including separators, heat exchangers, valves and other common unit operations.</li> </ul>"},{"location":"modules/#chemical-reactions-routines","title":"Chemical reactions routines","text":"<ul> <li>Location: <code>chemicalreactions</code></li> <li>Features: equilibrium and kinetic reaction models with support for reaction mechanisms and kinetic rate expressions.</li> </ul>"},{"location":"modules/#parameter-fitting-routines","title":"Parameter fitting routines","text":"<ul> <li>Location: <code>statistics/parameterfitting</code></li> <li>Features: tools for regression and parameter estimation using experimental data, including Monte Carlo simulations.</li> </ul>"},{"location":"modules/#process-simulation-routines","title":"Process simulation routines","text":"<ul> <li>Location: <code>process</code></li> <li>Features: framework for assembling flowsheets and running dynamic or steady-state process simulations that couple unit operations and property packages.</li> </ul>"},{"location":"modules/#process-safety-simulation","title":"Process safety simulation","text":"<ul> <li>Location: <code>process/safety</code>, <code>process/equipment/tank</code>, <code>process/util/fire</code></li> <li>Features: comprehensive safety simulation capabilities including:</li> <li>Depressurization: Dynamic vessel blowdown with multiple thermodynamic modes (isothermal, isentropic, energy balance), fire case modeling, and transient wall heat transfer</li> <li>Relief valve sizing: API 520/521 compliant PSV sizing with dynamic fire scenarios</li> <li>Source term generation: Leak/rupture mass flow, jet velocity, and momentum calculations for consequence modeling (PHAST, FLACS, KFX export)</li> <li>Safety envelopes: Hydrate, WAX, CO2 freezing, and MDMT envelope calculations with operating point validation</li> <li>Risk framework: Monte Carlo and deterministic risk analysis with event trees, sensitivity analysis, and F-N curve generation</li> </ul>"},{"location":"blackoil/","title":"Black Oil Package","text":"<p>The <code>blackoil</code> package provides black oil model capabilities for reservoir engineering applications, including PVT table handling and flash calculations.</p>"},{"location":"blackoil/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Black Oil Model</li> <li>PVT Tables</li> <li>Flash Calculations</li> <li>Usage Examples</li> </ul>"},{"location":"blackoil/#overview","title":"Overview","text":"<p>Location: <code>neqsim.blackoil</code></p> <p>Purpose: - Black oil PVT modeling - Generate PVT tables from compositional models - Black oil flash calculations - Export to reservoir simulators</p>"},{"location":"blackoil/#package-structure","title":"Package Structure","text":"<pre><code>blackoil/\n\u251c\u2500\u2500 BlackOilFlash.java           # Black oil flash calculator\n\u251c\u2500\u2500 BlackOilFlashResult.java     # Flash results container\n\u251c\u2500\u2500 BlackOilPVTTable.java        # PVT table storage\n\u251c\u2500\u2500 BlackOilConverter.java       # Compositional to black oil conversion\n\u251c\u2500\u2500 SystemBlackOil.java          # Black oil system representation\n\u2502\n\u2514\u2500\u2500 io/                          # I/O utilities\n    \u2514\u2500\u2500 BlackOilTableExporter.java\n</code></pre>"},{"location":"blackoil/#black-oil-model","title":"Black Oil Model","text":""},{"location":"blackoil/#theory","title":"Theory","text":"<p>The black oil model describes reservoir fluids using three pseudo-components: - Oil (stock tank oil) - Gas (separator gas) - Water</p>"},{"location":"blackoil/#key-properties","title":"Key Properties","text":"Property Symbol Description Solution GOR Rs Gas dissolved in oil (Sm\u00b3/Sm\u00b3) Oil FVF Bo Oil formation volume factor Gas FVF Bg Gas formation volume factor Water FVF Bw Water formation volume factor Oil-in-Gas ratio Rv Oil vaporized in gas (Sm\u00b3/Sm\u00b3) Oil viscosity \u03bco Dynamic viscosity of oil Gas viscosity \u03bcg Dynamic viscosity of gas Water viscosity \u03bcw Dynamic viscosity of water"},{"location":"blackoil/#correlations","title":"Correlations","text":""},{"location":"blackoil/#standing-correlation-for-rs","title":"Standing Correlation for Rs","text":"\\[R_s = \\gamma_g \\left( \\frac{P}{18.2} \\cdot 10^{0.0125 \\cdot API - 0.00091 \\cdot T} \\right)^{1.2048}\\]"},{"location":"blackoil/#vasquez-beggs-for-bo","title":"Vasquez-Beggs for Bo","text":"\\[B_o = 1 + C_1 R_s + C_2 (T - 60) \\left( \\frac{API}{\\gamma_{g,100}} \\right) + C_3 R_s (T - 60) \\left( \\frac{API}{\\gamma_{g,100}} \\right)\\]"},{"location":"blackoil/#pvt-tables","title":"PVT Tables","text":""},{"location":"blackoil/#blackoilpvttable","title":"BlackOilPVTTable","text":"<pre><code>import neqsim.blackoil.BlackOilPVTTable;\n\n// Create PVT table\nBlackOilPVTTable pvtTable = new BlackOilPVTTable();\n\n// Set pressure points\ndouble[] pressures = {50, 100, 150, 200, 250, 300};\npvtTable.setPressures(pressures);\n\n// Set properties at each pressure\npvtTable.setRs(new double[]{80, 100, 120, 140, 160, 180});\npvtTable.setBo(new double[]{1.25, 1.30, 1.35, 1.40, 1.45, 1.50});\npvtTable.setBg(new double[]{0.010, 0.008, 0.006, 0.005, 0.004, 0.003});\npvtTable.setMuO(new double[]{1.5, 1.2, 1.0, 0.9, 0.8, 0.7});\npvtTable.setMuG(new double[]{0.015, 0.016, 0.017, 0.018, 0.019, 0.020});\n</code></pre>"},{"location":"blackoil/#interpolation","title":"Interpolation","text":"<pre><code>// Get properties at any pressure\ndouble P = 175.0;  // bar\ndouble Rs = pvtTable.Rs(P);\ndouble Bo = pvtTable.Bo(P);\ndouble Bg = pvtTable.Bg(P);\ndouble muO = pvtTable.mu_o(P);\ndouble muG = pvtTable.mu_g(P);\n</code></pre>"},{"location":"blackoil/#blackoilflash","title":"BlackOilFlash","text":""},{"location":"blackoil/#flash-calculator","title":"Flash Calculator","text":"<pre><code>import neqsim.blackoil.BlackOilFlash;\nimport neqsim.blackoil.BlackOilFlashResult;\n\n// Create flash calculator\ndouble rho_o_sc = 850.0;   // Oil density at SC, kg/m\u00b3\ndouble rho_g_sc = 0.85;    // Gas density at SC, kg/m\u00b3\ndouble rho_w_sc = 1000.0;  // Water density at SC, kg/m\u00b3\n\nBlackOilFlash flash = new BlackOilFlash(pvtTable, rho_o_sc, rho_g_sc, rho_w_sc);\n\n// Perform flash at reservoir conditions\ndouble P = 200.0;    // bar\ndouble T = 373.15;   // K (not used in simple model)\ndouble Otot_std = 1000.0;  // Stock tank oil, Sm\u00b3\ndouble Gtot_std = 150000.0; // Total gas, Sm\u00b3\ndouble W_std = 500.0;      // Water, Sm\u00b3\n\nBlackOilFlashResult result = flash.flash(P, T, Otot_std, Gtot_std, W_std);\n</code></pre>"},{"location":"blackoil/#flash-results","title":"Flash Results","text":"<pre><code>// Phase volumes at reservoir conditions\ndouble V_oil = result.V_o;   // Oil volume, m\u00b3\ndouble V_gas = result.V_g;   // Gas volume, m\u00b3\ndouble V_water = result.V_w; // Water volume, m\u00b3\n\n// Phase properties\ndouble rho_oil = result.rho_o;   // Oil density, kg/m\u00b3\ndouble rho_gas = result.rho_g;   // Gas density, kg/m\u00b3\ndouble rho_water = result.rho_w; // Water density, kg/m\u00b3\n\ndouble mu_oil = result.mu_o;     // Oil viscosity, cP\ndouble mu_gas = result.mu_g;     // Gas viscosity, cP\ndouble mu_water = result.mu_w;   // Water viscosity, cP\n\n// PVT properties used\ndouble Rs = result.Rs;   // Solution GOR\ndouble Bo = result.Bo;   // Oil FVF\ndouble Bg = result.Bg;   // Gas FVF\ndouble Bw = result.Bw;   // Water FVF\n</code></pre>"},{"location":"blackoil/#compositional-to-black-oil-conversion","title":"Compositional to Black Oil Conversion","text":""},{"location":"blackoil/#blackoilconverter","title":"BlackOilConverter","text":"<p>Generate black oil tables from compositional EoS model.</p> <pre><code>import neqsim.blackoil.BlackOilConverter;\n\n// Create compositional oil\nSystemInterface oil = new SystemPrEos(373.15, 300.0);\noil.addComponent(\"nitrogen\", 0.5);\noil.addComponent(\"CO2\", 2.0);\noil.addComponent(\"methane\", 35.0);\noil.addComponent(\"ethane\", 8.0);\noil.addComponent(\"propane\", 5.0);\noil.addComponent(\"n-butane\", 3.0);\noil.addComponent(\"n-pentane\", 2.5);\noil.addComponent(\"n-hexane\", 3.0);\noil.addTBPfraction(\"C7+\", 41.0, 220.0/1000.0, 0.85);\noil.setMixingRule(\"classic\");\noil.useVolumeCorrection(true);\n\n// Convert to black oil\nBlackOilConverter converter = new BlackOilConverter(oil);\nconverter.setTemperature(373.15, \"K\");\n\n// Define separator conditions\nconverter.setSeparatorTemperature(288.15, \"K\");\nconverter.setSeparatorPressure(1.01325, \"bara\");\n\n// Generate table\ndouble[] pressures = {1, 50, 100, 150, 200, 250, 300};\nconverter.setPressures(pressures, \"bara\");\nconverter.run();\n\n// Get black oil table\nBlackOilPVTTable boTable = converter.getBlackOilTable();\n</code></pre>"},{"location":"blackoil/#export-to-simulators","title":"Export to Simulators","text":""},{"location":"blackoil/#eclipse-format","title":"Eclipse Format","text":"<pre><code>import neqsim.blackoil.io.BlackOilTableExporter;\n\nBlackOilTableExporter exporter = new BlackOilTableExporter(boTable);\nexporter.setFormat(\"ECLIPSE\");\nexporter.exportToFile(\"PVTO.inc\");\n</code></pre>"},{"location":"blackoil/#example-pvto-output","title":"Example PVTO Output","text":"<pre><code>PVTO\n-- Rs      P       Bo      viscosity\n   50.0    50.0   1.250    1.50\n          100.0   1.248    1.55\n          150.0   1.246    1.60 /\n  100.0   100.0   1.350    1.20\n          150.0   1.347    1.25\n          200.0   1.345    1.30 /\n/\n</code></pre>"},{"location":"blackoil/#complete-example","title":"Complete Example","text":"<pre><code>import neqsim.blackoil.*;\nimport neqsim.pvtsimulation.simulation.*;\n\n// Step 1: Create compositional model\nSystemInterface oil = new SystemPrEos(373.15, 250.0);\noil.addComponent(\"nitrogen\", 0.3);\noil.addComponent(\"CO2\", 1.5);\noil.addComponent(\"methane\", 40.0);\noil.addComponent(\"ethane\", 7.0);\noil.addComponent(\"propane\", 4.5);\noil.addComponent(\"i-butane\", 1.0);\noil.addComponent(\"n-butane\", 2.5);\noil.addComponent(\"i-pentane\", 1.2);\noil.addComponent(\"n-pentane\", 1.8);\noil.addComponent(\"n-hexane\", 2.5);\noil.addTBPfraction(\"C7-C10\", 15.0, 120.0/1000.0, 0.78);\noil.addTBPfraction(\"C11-C15\", 10.0, 180.0/1000.0, 0.82);\noil.addTBPfraction(\"C16+\", 12.7, 350.0/1000.0, 0.90);\noil.setMixingRule(\"classic\");\noil.useVolumeCorrection(true);\n\n// Step 2: Run differential liberation\nDifferentialLiberation dl = new DifferentialLiberation(oil);\ndl.setTemperature(373.15, \"K\");\ndouble[] pressures = {250, 200, 150, 100, 75, 50, 25, 1.01325};\ndl.setPressures(pressures, \"bara\");\ndl.run();\n\n// Step 3: Create black oil table\nBlackOilPVTTable boTable = new BlackOilPVTTable();\nboTable.setPressures(pressures);\nboTable.setRs(dl.getRs());\nboTable.setBo(dl.getBo());\nboTable.setMuO(dl.getOilViscosity());\n\n// Add gas properties\nboTable.setBg(dl.getBg());\nboTable.setMuG(dl.getGasViscosity());\n\n// Step 4: Separator test for stock tank conditions\nSeparatorTest sep = new SeparatorTest(oil.clone());\nsep.setSeparatorConditions(\n    new double[]{323.15, 288.15},\n    new double[]{30.0, 1.01325}\n);\nsep.run();\n\ndouble rho_o_sc = sep.getOilDensity();\n\n// Step 5: Create flash calculator\nBlackOilFlash boFlash = new BlackOilFlash(boTable, rho_o_sc, 0.85, 1000.0);\n\n// Step 6: Calculate at different conditions\nSystem.out.println(\"P (bar)\\tRs\\tBo\\t\u03c1_oil\\t\u03bc_oil\");\nfor (double P : new double[]{50, 100, 150, 200}) {\n    BlackOilFlashResult r = boFlash.flash(P, 373.15, 1000.0, 150000.0, 0.0);\n    System.out.printf(\"%.0f\\t%.1f\\t%.4f\\t%.1f\\t%.3f%n\",\n        P, r.Rs, r.Bo, r.rho_o, r.mu_o);\n}\n</code></pre>"},{"location":"blackoil/#best-practices","title":"Best Practices","text":"<ol> <li>Validate against compositional - Compare black oil results with full EoS</li> <li>Use appropriate correlations - Match fluid type (light, medium, heavy oil)</li> <li>Check consistency - Ensure Rs and Bo are consistent at bubble point</li> <li>Include undersaturated region - Extend table above bubble point</li> <li>Document separator conditions - Record conditions used for conversion</li> </ol>"},{"location":"blackoil/#limitations","title":"Limitations","text":"<ul> <li>Temperature dependence not fully captured</li> <li>Compositional grading not modeled</li> <li>Gas condensate requires extended model (Rv)</li> <li>Near-critical fluids may need compositional treatment</li> </ul>"},{"location":"blackoil/#related-documentation","title":"Related Documentation","text":"<ul> <li>PVT Simulation - Laboratory experiments</li> <li>PVT Workflow - End-to-end workflow</li> <li>Black Oil PVT Export - Export details</li> </ul>"},{"location":"chemicalreactions/","title":"Chemical Reactions Package","text":"<p>The <code>chemicalreactions</code> package provides tools for chemical equilibrium calculations and reaction kinetics.</p>"},{"location":"chemicalreactions/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Chemical Equilibrium</li> <li>Reaction Kinetics</li> <li>Usage Examples</li> </ul>"},{"location":"chemicalreactions/#overview","title":"Overview","text":"<p>Location: <code>neqsim.chemicalreactions</code></p> <p>Purpose: - Calculate chemical equilibrium composition - Model reaction kinetics - Support reactive flash calculations - Handle simultaneous phase and chemical equilibrium</p>"},{"location":"chemicalreactions/#package-structure","title":"Package Structure","text":"<pre><code>chemicalreactions/\n\u251c\u2500\u2500 ChemicalReactionOperations.java   # Main operations class\n\u2502\n\u251c\u2500\u2500 chemicalequilibrium/              # Equilibrium calculations\n\u2502   \u251c\u2500\u2500 ChemicalEquilibrium.java      # Base class\n\u2502   \u251c\u2500\u2500 ChemEq.java                   # Equilibrium solver\n\u2502   \u251c\u2500\u2500 LinearProgrammingChemicalEquilibrium.java\n\u2502   \u2514\u2500\u2500 ReferencePotComparator.java\n\u2502\n\u251c\u2500\u2500 chemicalreaction/                 # Reaction definitions\n\u2502   \u251c\u2500\u2500 ChemicalReaction.java         # Single reaction\n\u2502   \u2514\u2500\u2500 ChemicalReactionList.java     # Reaction set\n\u2502\n\u2514\u2500\u2500 kinetics/                         # Kinetics models\n    \u2514\u2500\u2500 Kinetics.java                 # Kinetic rate calculations\n</code></pre>"},{"location":"chemicalreactions/#chemical-equilibrium","title":"Chemical Equilibrium","text":""},{"location":"chemicalreactions/#theory","title":"Theory","text":"<p>Chemical equilibrium is achieved when the Gibbs energy is minimized:</p> \\[\\min G = \\sum_i n_i \\mu_i\\] <p>Subject to element balance constraints:</p> \\[\\sum_i a_{ji} n_i = b_j \\quad \\text{for each element } j\\] <p>Where: - \\(n_i\\) = moles of species \\(i\\) - \\(\\mu_i\\) = chemical potential of species \\(i\\) - \\(a_{ji}\\) = atoms of element \\(j\\) in species \\(i\\) - \\(b_j\\) = total moles of element \\(j\\)</p>"},{"location":"chemicalreactions/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create reactive system\nSystemInterface reactive = new SystemSrkEos(700.0, 10.0);\nreactive.addComponent(\"methane\", 1.0);\nreactive.addComponent(\"water\", 2.0);\nreactive.addComponent(\"CO2\", 0.0);\nreactive.addComponent(\"CO\", 0.0);\nreactive.addComponent(\"hydrogen\", 0.0);\nreactive.setMixingRule(\"classic\");\n\n// Enable chemical reactions\nreactive.setChemicalReactions(true);\n\n// Perform equilibrium calculation\nThermodynamicOperations ops = new ThermodynamicOperations(reactive);\nops.calcChemicalEquilibrium();\n\n// Display results\nfor (int i = 0; i &lt; reactive.getNumberOfComponents(); i++) {\n    System.out.println(reactive.getComponent(i).getName() + \n        \": \" + reactive.getComponent(i).getNumberOfmable() + \" mol\");\n}\n</code></pre>"},{"location":"chemicalreactions/#supported-reactions","title":"Supported Reactions","text":""},{"location":"chemicalreactions/#steam-reforming","title":"Steam Reforming","text":"<pre><code>CH\u2084 + H\u2082O \u21cc CO + 3H\u2082\nCO + H\u2082O \u21cc CO\u2082 + H\u2082\n</code></pre>"},{"location":"chemicalreactions/#combustion","title":"Combustion","text":"<pre><code>CH\u2084 + 2O\u2082 \u2192 CO\u2082 + 2H\u2082O\nC\u2082H\u2086 + 3.5O\u2082 \u2192 2CO\u2082 + 3H\u2082O\n</code></pre>"},{"location":"chemicalreactions/#acid-gas-reactions","title":"Acid Gas Reactions","text":"<pre><code>CO\u2082 + H\u2082O \u21cc H\u2082CO\u2083\nH\u2082S + H\u2082O \u21cc HS\u207b + H\u2083O\u207a\nNH\u2083 + H\u2082O \u21cc NH\u2084\u207a + OH\u207b\n</code></pre>"},{"location":"chemicalreactions/#amine-reactions","title":"Amine Reactions","text":"<pre><code>CO\u2082 + 2RNH\u2082 \u21cc RNHCOO\u207b + RNH\u2083\u207a\nCO\u2082 + RNH\u2082 + H\u2082O \u21cc RNH\u2083\u207a + HCO\u2083\u207b\n</code></pre>"},{"location":"chemicalreactions/#chemicalreactionoperations","title":"ChemicalReactionOperations","text":""},{"location":"chemicalreactions/#main-class","title":"Main Class","text":"<pre><code>import neqsim.chemicalreactions.ChemicalReactionOperations;\n\nChemicalReactionOperations reactionOps = new ChemicalReactionOperations(fluid);\n\n// Add reactions\nreactionOps.addReaction(\"methane_reforming\");\nreactionOps.addReaction(\"water_gas_shift\");\n\n// Calculate equilibrium\nreactionOps.calcChemicalEquilibrium();\n\n// Get equilibrium constants\ndouble Keq = reactionOps.getEquilibriumConstant(\"methane_reforming\");\n</code></pre>"},{"location":"chemicalreactions/#reaction-kinetics","title":"Reaction Kinetics","text":"<p>For rate-limited reactions, use kinetic models.</p>"},{"location":"chemicalreactions/#kinetic-rate-expression","title":"Kinetic Rate Expression","text":"<p>General rate expression:</p> \\[r = k \\cdot \\prod_i C_i^{n_i}\\] <p>Where: - \\(k\\) = rate constant - \\(C_i\\) = concentration of species \\(i\\) - \\(n_i\\) = reaction order with respect to species \\(i\\)</p>"},{"location":"chemicalreactions/#temperature-dependence-arrhenius","title":"Temperature Dependence (Arrhenius)","text":"\\[k = A \\cdot \\exp\\left(-\\frac{E_a}{RT}\\right)\\] <p>Where: - \\(A\\) = pre-exponential factor - \\(E_a\\) = activation energy - \\(R\\) = gas constant - \\(T\\) = temperature</p>"},{"location":"chemicalreactions/#usage","title":"Usage","text":"<pre><code>import neqsim.chemicalreactions.kinetics.Kinetics;\n\nKinetics kinetics = new Kinetics(fluid);\n\n// Set reaction parameters\nkinetics.setPreExponentialFactor(1.0e10);  // 1/s\nkinetics.setActivationEnergy(80000.0);      // J/mol\n\n// Calculate rate at current conditions\ndouble rate = kinetics.getReactionRate();\n</code></pre>"},{"location":"chemicalreactions/#reactive-flash-calculations","title":"Reactive Flash Calculations","text":"<p>Combine phase equilibrium with chemical equilibrium.</p>"},{"location":"chemicalreactions/#tp-flash-with-reactions","title":"TP Flash with Reactions","text":"<pre><code>// Set up reactive system\nSystemInterface fluid = new SystemSrkEos(500.0, 20.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.addComponent(\"oxygen\", 0.5);\nfluid.addComponent(\"CO2\", 0.0);\nfluid.addComponent(\"water\", 0.0);\nfluid.setMixingRule(\"classic\");\nfluid.setChemicalReactions(true);\n\n// Reactive TP flash\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Results include both phase and chemical equilibrium\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\nfor (int i = 0; i &lt; fluid.getNumberOfComponents(); i++) {\n    System.out.println(fluid.getComponent(i).getName() + \n        \": \" + fluid.getComponent(i).getz() + \" mol/mol\");\n}\n</code></pre>"},{"location":"chemicalreactions/#gibbs-energy-minimization","title":"Gibbs Energy Minimization","text":""},{"location":"chemicalreactions/#linear-programming-method","title":"Linear Programming Method","text":"<p>For complex systems, use linear programming approach.</p> <pre><code>import neqsim.chemicalreactions.chemicalequilibrium.LinearProgrammingChemicalEquilibrium;\n\nLinearProgrammingChemicalEquilibrium lpEquil = \n    new LinearProgrammingChemicalEquilibrium(fluid);\nlpEquil.solve();\n\n// Get equilibrium composition\ndouble[] composition = lpEquil.getEquilibriumComposition();\n</code></pre>"},{"location":"chemicalreactions/#database-integration","title":"Database Integration","text":"<p>Chemical reactions and their parameters are stored in the database.</p>"},{"location":"chemicalreactions/#reaction-database","title":"Reaction Database","text":"Field Description name Reaction identifier reactants Reactant species products Product species stoichiometry Stoichiometric coefficients deltaH Enthalpy of reaction deltaG Gibbs energy of reaction Keq_A, Keq_B, Keq_C Equilibrium constant correlation"},{"location":"chemicalreactions/#loading-reactions","title":"Loading Reactions","text":"<pre><code>// Load reactions from database\nfluid.createChemicalReactions(true);\n\n// Or specify specific reactions\nfluid.addChemicalReaction(\"steam_reforming\");\nfluid.addChemicalReaction(\"water_gas_shift\");\n</code></pre>"},{"location":"chemicalreactions/#example-ammonia-synthesis","title":"Example: Ammonia Synthesis","text":"<pre><code>// Ammonia synthesis: N\u2082 + 3H\u2082 \u21cc 2NH\u2083\nSystemInterface syngas = new SystemSrkEos(673.15, 200.0);  // 400\u00b0C, 200 bar\nsyngas.addComponent(\"nitrogen\", 1.0);\nsyngas.addComponent(\"hydrogen\", 3.0);\nsyngas.addComponent(\"ammonia\", 0.0);\nsyngas.setMixingRule(\"classic\");\nsyngas.setChemicalReactions(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(syngas);\nops.calcChemicalEquilibrium();\n\ndouble NH3fraction = syngas.getComponent(\"ammonia\").getz();\ndouble conversion = 2 * NH3fraction / \n    (syngas.getComponent(\"nitrogen\").getz() + NH3fraction);\n\nSystem.out.println(\"NH\u2083 mole fraction: \" + NH3fraction);\nSystem.out.println(\"N\u2082 conversion: \" + (conversion * 100) + \"%\");\n</code></pre>"},{"location":"chemicalreactions/#example-co2-capture-with-amine","title":"Example: CO\u2082 Capture with Amine","text":"<pre><code>// CO\u2082 absorption in MEA solution\nSystemInterface solution = new SystemElectrolyteCPA(313.15, 1.01325);\nsolution.addComponent(\"CO2\", 0.05);\nsolution.addComponent(\"water\", 0.75);\nsolution.addComponent(\"MEA\", 0.20);\nsolution.setMixingRule(\"CPA_Statoil\");\nsolution.setChemicalReactions(true);\n\n// Flash with reactions\nThermodynamicOperations ops = new ThermodynamicOperations(solution);\nops.TPflash();\n\n// Get CO\u2082 loading\ndouble CO2loading = solution.getComponent(\"CO2\").getx() / \n    solution.getComponent(\"MEA\").getx();\nSystem.out.println(\"CO\u2082 loading: \" + CO2loading + \" mol CO\u2082/mol MEA\");\n</code></pre>"},{"location":"chemicalreactions/#best-practices","title":"Best Practices","text":"<ol> <li>Initialize products with small but non-zero amounts</li> <li>Check element balance before and after equilibrium</li> <li>Use appropriate thermodynamic model (electrolyte models for ionic reactions)</li> <li>Verify equilibrium constants against literature</li> <li>Consider kinetic limitations for slow reactions</li> </ol>"},{"location":"chemicalreactions/#limitations","title":"Limitations","text":"<ul> <li>Not all reactions are in the database</li> <li>Custom reactions require database extension</li> <li>Some complex reaction mechanisms not supported</li> <li>High-temperature kinetics may need external data</li> </ul>"},{"location":"chemicalreactions/#related-documentation","title":"Related Documentation","text":"<ul> <li>Thermodynamic Operations - Flash calculations</li> <li>Fluid Creation Guide - Creating reactive systems</li> <li>Electrolyte Models - Electrolyte CPA for ionic reactions</li> </ul>"},{"location":"development/","title":"Development Documentation","text":"<p>Guides for developers contributing to NeqSim.</p>"},{"location":"development/#overview","title":"Overview","text":"<p>This folder contains documentation for setting up development environments and contributing to the NeqSim project.</p>"},{"location":"development/#documentation-index","title":"Documentation Index","text":"Document Description DEVELOPER_SETUP.md Development environment setup contributing-structure.md Contributing guidelines and code structure"},{"location":"development/#quick-links","title":"Quick Links","text":"<ul> <li>NeqSim GitHub Repository</li> <li>Main Documentation</li> </ul>"},{"location":"development/DEVELOPER_SETUP/","title":"Developer Setup","text":"<p>This document summarizes the basic steps from the NeqSim wiki for setting up a local development environment. For additional details see the Getting started as a NeqSim developer wiki page.</p>"},{"location":"development/DEVELOPER_SETUP/#clone-the-repository","title":"Clone the repository","text":"<pre><code>git clone https://github.com/equinor/neqsim.git\ncd neqsim\n</code></pre>"},{"location":"development/DEVELOPER_SETUP/#build-the-project","title":"Build the project","text":"<p>NeqSim requires JDK\u00a08 or newer and uses the Maven build system. Use the provided Maven wrapper to build the code:</p> <pre><code>./mvnw install\n</code></pre> <p>(Windows users can run <code>mvnw.cmd</code>.)</p>"},{"location":"development/DEVELOPER_SETUP/#run-the-test-suite","title":"Run the test suite","text":"<p>Execute all unit tests with:</p> <pre><code>./mvnw test\n</code></pre> <p>To generate a code coverage report:</p> <pre><code>./mvnw jacoco:prepare-agent test install jacoco:report\n</code></pre>"},{"location":"development/DEVELOPER_SETUP/#static-analysis","title":"Static analysis","text":"<p>Checkstyle, SpotBugs, and PMD plugins are included in the Maven build and run during the <code>verify</code> phase. Run them locally with:</p> <pre><code>./mvnw checkstyle:check spotbugs:check pmd:check\n</code></pre> <p>The checks do not fail the build by default, but fixing any reported issues is encouraged.</p>"},{"location":"development/contributing-structure/","title":"Repository layout quick reference","text":"<p>Use this guide to place new files consistently across the repository.</p>"},{"location":"development/contributing-structure/#production-code","title":"Production code","text":"<ul> <li>Java sources live under <code>src/main/java</code> and follow the <code>com.equinor.neqsim</code> package root.</li> <li>Keep contributions inside the established functional modules:</li> <li><code>com.equinor.neqsim.thermo</code> \u2013 thermodynamic routines.</li> <li><code>com.equinor.neqsim.physicalproperties</code> \u2013 transport and thermophysical property models.</li> <li><code>com.equinor.neqsim.processsimulation</code> \u2013 unit operations, process models, and flowsheet orchestration.</li> <li><code>com.equinor.neqsim.chemicalreactions</code> \u2013 equilibrium and kinetic reactions.</li> <li><code>com.equinor.neqsim.parameterfitting</code> \u2013 parameter estimation tools.</li> <li>Shared helpers can go in <code>com.equinor.neqsim.util.*</code> when they are not domain-specific.</li> <li>Avoid inventing parallel hierarchies; extend the closest existing module instead.</li> </ul>"},{"location":"development/contributing-structure/#tests","title":"Tests","text":"<ul> <li>Place JUnit tests in <code>src/test/java</code>, mirroring the package of the code under test.</li> <li>Small fixtures and golden files belong in <code>src/test/resources</code> within the same package path.</li> <li>Integration-style examples that demonstrate APIs should stay in <code>examples/</code> rather than under <code>src/test/java</code>.</li> </ul>"},{"location":"development/contributing-structure/#resources-and-data","title":"Resources and data","text":"<ul> <li>Runtime resources (configuration templates, lookup tables) belong in <code>src/main/resources</code>.</li> <li>Test-only resources go in <code>src/test/resources</code>.</li> <li>Larger datasets or notebooks should live in <code>data/</code> or <code>notebooks/</code> to keep the packaged library lean.</li> <li>Runnable samples and tutorial code belong in <code>examples/</code> and should avoid depending on internal test fixtures.</li> </ul>"},{"location":"examples/comparesimulations_quickstart/","title":"Comparing process simulations with NeqSim (Java)","text":"<p>This guide shows how to reproduce the <code>comparesimulations.ipynb</code> Colab notebook using only the Java API. It walks through building the feed, assembling the flowsheet, running the model, and exporting a JSON report so you can align the results with HYSYS/DWSIM or other tools.</p>"},{"location":"examples/comparesimulations_quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 8+ and Maven (the repository includes the <code>./mvnw</code> wrapper).</li> <li>Access to the feed composition you want to benchmark (the Colab notebook links to the   composition from the DWSIM/HYSYS comparison paper).</li> </ul>"},{"location":"examples/comparesimulations_quickstart/#step-by-step-java-example","title":"Step-by-step Java example","text":"<pre><code>import neqsim.process.equipment.compressor.Compressor;\nimport neqsim.process.equipment.separator.ThreePhaseSeparator;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.processmodel.ProcessModel;\nimport neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.util.report.Report;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// 1) Build the feed to mirror the notebook composition\nSystemInterface wellFluid = new SystemSrkEos(310.0, 50.0); // T=310 K, p=50 bara\nwellFluid.addComponent(\"methane\", 0.8);\nwellFluid.addComponent(\"ethane\", 0.1);\nwellFluid.addComponent(\"propane\", 0.05);\nwellFluid.addComponent(\"n-butane\", 0.05);\nwellFluid.initProperties();\n\n// 2) Create the inlet process section (stream + three-phase separator)\nStream wellStreamHP = new Stream(\"HP well stream\", wellFluid);\nwellStreamHP.setFlowRate(10.0, \"MSm3/day\");\nThreePhaseSeparator firstStageSeparator =\n    new ThreePhaseSeparator(\"1st stage separator\", wellStreamHP);\n\nProcessSystem inletSection = new ProcessSystem();\ninletSection.add(wellStreamHP);\ninletSection.add(firstStageSeparator);\n\n// 3) Create the compressor section using the separator gas outlet\nStream compressorFeed = firstStageSeparator.getGasOutStream();\nCompressor compressor1 = new Compressor(\"Compressor1\", compressorFeed);\ncompressor1.setPolytropicEfficiency(0.56);\ncompressor1.setUsePolytropicCalc(true);\ncompressor1.setOutletPressure(100.0, \"bara\");\n\nProcessSystem compressorSection = new ProcessSystem();\ncompressorSection.add(compressorFeed);\ncompressorSection.add(compressor1);\n\n// 4) Combine the sections in a ProcessModel and run them sequentially\nProcessModel combinedProcess = new ProcessModel();\ncombinedProcess.add(\"feed process\", inletSection);\ncombinedProcess.add(\"compressor process\", compressorSection);\ncombinedProcess.setRunStep(true); // ensures each section runs in the order added\ncombinedProcess.run();\n\n// 5) Read results or export the JSON report used for cross-tool comparison\nSystem.out.printf(\"Gas flow after separator: %.3f MSm3/day%n\",\n    firstStageSeparator.getGasOutStream().getFlowRate(\"MSm3/day\"));\nSystem.out.printf(\"Compressor outlet temperature: %.2f C%n\",\n    compressor1.getOutletStream().getTemperature(\"C\"));\n\nReport reporter = new Report(combinedProcess);\nString jsonReport = reporter.generateJsonReport();\nSystem.out.println(jsonReport);\n</code></pre> <p>Tips when translating the notebook to Java:</p> <ul> <li>Keep the same feed composition, temperature, and pressure as your reference notebook   so downstream comparisons stay aligned.</li> <li>Enable sequential execution with <code>setRunStep(true)</code> to mirror the order in which the   Colab notebook runs each process section.\u3010F:src/test/java/neqsim/process/processmodel/CombinedModelsTest.java\u2020L87-L135\u3011</li> <li>Use <code>Report.generateJsonReport()</code> to create the same JSON structure stored on the   <code>ProcessModel</code> (<code>getReport_json()</code>), which you can compare directly against the   notebook outputs.\u3010F:src/test/java/neqsim/process/processmodel/CombinedModelsTest.java\u2020L135-L136\u3011</li> </ul>"},{"location":"examples/selective-logic-execution/","title":"Selective Logic Execution in ProcessScenarioRunner","text":"<p>The <code>ProcessScenarioRunner</code> provides multiple ways to control which logic sequences execute during a scenario.</p>"},{"location":"examples/selective-logic-execution/#method-1-add-only-what-you-need-simplest","title":"Method 1: Add Only What You Need (Simplest)","text":"<p>Only add the logic sequences you want to run:</p> <pre><code>ProcessScenarioRunner runner = new ProcessScenarioRunner(processSystem);\n\n// Only add ESD logic - HIPPS and startup won't run\nrunner.addLogic(esdLogic);\n\n// This scenario will only execute ESD logic\nrunner.runScenario(\"ESD Test\", scenario, 30.0, 1.0);\n</code></pre>"},{"location":"examples/selective-logic-execution/#method-2-addremove-logic-dynamically","title":"Method 2: Add/Remove Logic Dynamically","text":"<p>Add all logic initially, then remove what you don't need:</p> <pre><code>ProcessScenarioRunner runner = new ProcessScenarioRunner(processSystem);\n\n// Add all logic\nrunner.addLogic(hippsLogic);\nrunner.addLogic(esdLogic);\nrunner.addLogic(startupLogic);\n\n// For this scenario, remove HIPPS\nrunner.removeLogic(\"HIPPS Protection\");\n\n// This scenario will run ESD and startup, but not HIPPS\nrunner.runScenario(\"Test Without HIPPS\", scenario, 30.0, 1.0);\n\n// Re-add HIPPS for next scenario\nrunner.addLogic(hippsLogic);\n</code></pre>"},{"location":"examples/selective-logic-execution/#method-3-run-scenario-with-specific-logic-most-flexible","title":"Method 3: Run Scenario With Specific Logic (Most Flexible)","text":"<p>Register all logic once, then specify which to use per scenario:</p> <pre><code>ProcessScenarioRunner runner = new ProcessScenarioRunner(processSystem);\n\n// Register all logic sequences once\nrunner.addLogic(hippsLogic);      // \"HIPPS Protection\"\nrunner.addLogic(esdLogic);        // \"ESD Level 1\"\nrunner.addLogic(startupLogic);    // \"System Startup\"\n\n// Scenario 1: Test only HIPPS\nrunner.runScenarioWithLogic(\"HIPPS Test\", scenario1, 30.0, 1.0, \n    List.of(\"HIPPS Protection\"));\n\n// Scenario 2: Test ESD without HIPPS\nrunner.runScenarioWithLogic(\"ESD Test\", scenario2, 30.0, 1.0, \n    List.of(\"ESD Level 1\", \"System Startup\"));\n\n// Scenario 3: Run all logic (pass null or empty list)\nrunner.runScenarioWithLogic(\"Full Test\", scenario3, 30.0, 1.0, null);\n\n// Or use the standard method (runs all registered logic)\nrunner.runScenario(\"Full Test Alternative\", scenario3, 30.0, 1.0);\n</code></pre>"},{"location":"examples/selective-logic-execution/#method-4-clear-and-re-add-between-scenarios","title":"Method 4: Clear and Re-add Between Scenarios","text":"<pre><code>ProcessScenarioRunner runner = new ProcessScenarioRunner(processSystem);\n\n// Scenario 1: Only startup\nrunner.addLogic(startupLogic);\nrunner.runScenario(\"Startup Only\", scenario1, 30.0, 1.0);\nrunner.reset();\n\n// Scenario 2: Only ESD\nrunner.clearAllLogic();\nrunner.addLogic(esdLogic);\nrunner.runScenario(\"ESD Only\", scenario2, 30.0, 1.0);\nrunner.reset();\n\n// Scenario 3: All logic\nrunner.clearAllLogic();\nrunner.addLogic(hippsLogic);\nrunner.addLogic(esdLogic);\nrunner.addLogic(startupLogic);\nrunner.runScenario(\"All Logic\", scenario3, 30.0, 1.0);\n</code></pre>"},{"location":"examples/selective-logic-execution/#quick-reference","title":"Quick Reference","text":"Method Use Case <code>addLogic(logic)</code> Add a logic sequence to the runner <code>removeLogic(logic)</code> Remove a specific logic object <code>removeLogic(\"name\")</code> Remove logic by name <code>clearAllLogic()</code> Remove all registered logic <code>runScenario(...)</code> Run with all registered logic <code>runScenarioWithLogic(..., List.of(\"Logic1\", \"Logic2\"))</code> Run with specific logic by name <code>findLogic(\"name\")</code> Find a logic sequence by name <code>activateLogic(\"name\")</code> Activate a logic sequence by name"},{"location":"examples/selective-logic-execution/#best-practices","title":"Best Practices","text":"<ol> <li>Testing individual systems: Use <code>runScenarioWithLogic()</code> to test each safety system independently</li> <li>Performance: If a scenario doesn't need certain logic, excluding it reduces computation</li> <li>Safety validation: Test HIPPS and ESD independently, then together to verify independence</li> <li>Reset between scenarios: Always call <code>runner.reset()</code> between scenarios to clear logic states</li> </ol>"},{"location":"examples/transient_slug_separator_control_example/","title":"Transient slug separator control example","text":"<p>This example wires a terrain-affected transient flowline to an inlet separator that is controlled by independent liquid-level and gas-pressure loops. The flowline uses a sinusoidal elevation profile to shed slugs into the separator while a choke on the inlet protects separator pressure and a pair of throttling valves, each driven by a transmitter/PID loop, work to hold the separator liquid level and gas outlet pressure near their set points. The sample program reports slug statistics plus the final liquid level and gas outlet pressure once the transient run finishes.</p>"},{"location":"examples/transient_slug_separator_control_example/#key-setup","title":"Key setup","text":"<ul> <li>The inlet stream represents a rich gas with water, flowing at 10 kg/s and 80 bara. It feeds a 1.5 km, 0.2 m diameter transient pipe split into 20 sections and a sinusoidal elevation dip that forces intermittent liquid holdup and slug formation before the pipe outlet. \u3010F:src/main/java/neqsim/process/controllerdevice/TransientSlugSeparatorControlExample.java\u2020L55-L97\u3011</li> <li>A choke valve sits between the flowline and separator and is driven by a pressure controller to hold the separator near 70 bara while absorbing slug-induced surges. Downstream of the separator, a gas outlet valve uses its own pressure controller on the export stream, and the liquid valve is driven by a level transmitter/PID pair targeting a 45% level. \u3010F:src/main/java/neqsim/process/controllerdevice/TransientSlugSeparatorControlExample.java\u2020L99-L135\u3011</li> <li>After steady-state initialization, the process advances 10 transient steps at 0.5 s per step to give the pipe time to generate slugs and let the controllers react. The example returns the slug tracker summary string along with the separator level and gas outlet pressure observed at the end of these steps. \u3010F:src/main/java/neqsim/process/controllerdevice/TransientSlugSeparatorControlExample.java\u2020L120-L138\u3011</li> </ul>"},{"location":"examples/transient_slug_separator_control_example/#what-happens-to-level-and-pressure","title":"What happens to level and pressure","text":"<ul> <li>The flowline\u2019s sinusoidal dip causes alternating liquid accumulation and blowdown, so slug pockets intermittently hit the separator. As those pockets arrive, the level controller opens the liquid valve to drain the separator and then trims back toward the 45% target once the surge passes, keeping the level bounded around the set point rather than drifting. \u3010F:src/main/java/neqsim/process/controllerdevice/TransientSlugSeparatorControlExample.java\u2020L78-L138\u3011</li> <li>Gas-side disturbances from slug arrival are handled first by the inlet choke, whose pressure controller clips separator pressure excursions near 70 bara, and then by the export valve, which throttles based on the downstream stream pressure target. The reported gas outlet pressure at the end of the run shows how the combined control brings the system back toward the set points after slug-induced swings. \u3010F:src/main/java/neqsim/process/controllerdevice/TransientSlugSeparatorControlExample.java\u2020L99-L138\u3011</li> </ul>"},{"location":"examples/transient_slug_separator_control_example/#plotting-the-default-run","title":"Plotting the default run","text":"<p>The example records the separator liquid level and gas outlet pressure on every 0.5 s time step, and the <code>--series</code> flag prints those values as CSV for plotting. Over the ten-step transient, the separator level jumps toward 0.9 when the first slug reaches the vessel and stays elevated while the controller holds the outlet valve open, while the gas pressure peaks above 120 bara before decaying toward the 70 bara set point as the gas valve throttles. \u3010F:src/main/java/neqsim/process/controllerdevice/TransientSlugSeparatorControlExample.java\u2020L22-L138\u3011</p>"},{"location":"examples/transient_slug_separator_control_example/#how-to-run-it","title":"How to run it","text":"<p>Execute <code>TransientSlugSeparatorControlExample.main</code> to print the slug statistics, separator liquid level, and gas outlet pressure for the default 5 s transient run (10 steps \u00d7 0.5 s). Use the <code>--series</code> flag to emit comma-separated time, level, and gas pressure for plotting (as used to build the graph above). The accompanying JUnit test <code>TransientSlugSeparatorControlExampleTest</code> simply calls <code>runSimulation()</code> to verify the example produces populated slug statistics and non-zero separator conditions.</p>"},{"location":"fluidmechanics/","title":"Fluid Mechanics Package","text":"<p>The <code>fluidmechanics</code> package provides models for pipeline flow, pressure drop calculations, and transient flow simulation.</p>"},{"location":"fluidmechanics/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Flow Systems</li> <li>Flow Nodes</li> <li>Usage Examples</li> </ul>"},{"location":"fluidmechanics/#overview","title":"Overview","text":"<p>Location: <code>neqsim.fluidmechanics</code></p> <p>Purpose: - Single-phase and two-phase pipe flow modeling - Pressure drop calculations - Transient flow simulation - Flow regime identification - Heat transfer in pipelines</p>"},{"location":"fluidmechanics/#package-structure","title":"Package Structure","text":"<pre><code>fluidmechanics/\n\u251c\u2500\u2500 FluidMech.java                    # Package marker\n\u2502\n\u251c\u2500\u2500 flowsystem/                       # Flow system definitions\n\u2502   \u251c\u2500\u2500 FlowSystem.java               # Base flow system\n\u2502   \u251c\u2500\u2500 FlowSystemInterface.java      # Interface\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 onephaseflowsystem/           # Single-phase systems\n\u2502   \u2502   \u251c\u2500\u2500 OnePhaseFlowSystem.java\n\u2502   \u2502   \u2514\u2500\u2500 pipeflowsystem/\n\u2502   \u2502       \u2514\u2500\u2500 OnePhasePipeFlowSystem.java\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 twophaseflowsystem/           # Two-phase systems\n\u2502       \u251c\u2500\u2500 TwoPhaseFlowSystem.java\n\u2502       \u2514\u2500\u2500 pipeflowsystem/\n\u2502           \u251c\u2500\u2500 TwoPhasePipeFlowSystem.java\n\u2502           \u2514\u2500\u2500 stratifiedflowsystem/\n\u2502               \u2514\u2500\u2500 StratifiedFlowSystem.java\n\u2502\n\u251c\u2500\u2500 flownode/                         # Flow nodes\n\u2502   \u251c\u2500\u2500 FlowNode.java                 # Base node\n\u2502   \u251c\u2500\u2500 FlowNodeInterface.java        # Interface\n\u2502   \u251c\u2500\u2500 FlowNodeSelector.java         # Node selection\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 onephasenode/                 # Single-phase nodes\n\u2502   \u2502   \u251c\u2500\u2500 OnePhaseFlowNode.java\n\u2502   \u2502   \u2514\u2500\u2500 onephasepipeflownode/\n\u2502   \u2502       \u2514\u2500\u2500 OnePhasePipeFlowNode.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 twophasenode/                 # Two-phase nodes\n\u2502   \u2502   \u251c\u2500\u2500 TwoPhaseFlowNode.java\n\u2502   \u2502   \u2514\u2500\u2500 twophasepipeflownode/\n\u2502   \u2502       \u251c\u2500\u2500 TwoPhasePipeFlowNode.java\n\u2502   \u2502       \u251c\u2500\u2500 AnnularFlow.java\n\u2502   \u2502       \u251c\u2500\u2500 StratifiedFlow.java\n\u2502   \u2502       \u2514\u2500\u2500 DropletFlow.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 multiphasenode/               # Multi-phase nodes\n\u2502   \u2502   \u2514\u2500\u2500 MultiPhaseFlowNode.java\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 fluidboundary/                # Boundary conditions\n\u2502       \u251c\u2500\u2500 FluidBoundary.java\n\u2502       \u2514\u2500\u2500 InterphaseTransport.java\n\u2502\n\u251c\u2500\u2500 flowleg/                          # Pipe segments\n\u2502   \u251c\u2500\u2500 FlowLeg.java\n\u2502   \u2514\u2500\u2500 FlowLegInterface.java\n\u2502\n\u251c\u2500\u2500 flowsolver/                       # Numerical solvers\n\u2502   \u251c\u2500\u2500 FlowSolver.java\n\u2502   \u251c\u2500\u2500 FlowSolverInterface.java\n\u2502   \u251c\u2500\u2500 OnePhaseFlowSolver.java\n\u2502   \u2514\u2500\u2500 TwoPhaseFlowSolver.java\n\u2502\n\u251c\u2500\u2500 geometrydefinitions/              # Pipe geometry\n\u2502   \u251c\u2500\u2500 GeometryDefinition.java\n\u2502   \u251c\u2500\u2500 GeometryDefinitionInterface.java\n\u2502   \u251c\u2500\u2500 pipe/\n\u2502   \u2502   \u2514\u2500\u2500 PipeGeometry.java\n\u2502   \u2514\u2500\u2500 internalgeometry/\n\u2502       \u2514\u2500\u2500 InternalGeometry.java\n\u2502\n\u2514\u2500\u2500 util/                             # Utilities\n    \u251c\u2500\u2500 timeseries/\n    \u2502   \u2514\u2500\u2500 TimeSeries.java\n    \u2514\u2500\u2500 fluidmechanicsvisualization/\n        \u2514\u2500\u2500 flowsystemvisualization/\n            \u2514\u2500\u2500 FlowSystemVisualization.java\n</code></pre>"},{"location":"fluidmechanics/#flow-systems","title":"Flow Systems","text":""},{"location":"fluidmechanics/#single-phase-pipe-flow","title":"Single-Phase Pipe Flow","text":"<pre><code>import neqsim.fluidmechanics.flowsystem.FlowSystemInterface;\nimport neqsim.fluidmechanics.flowsystem.onephaseflowsystem.pipeflowsystem.OnePhasePipeFlowSystem;\nimport neqsim.fluidmechanics.geometrydefinitions.pipe.PipeGeometry;\n\n// Create fluid\nSystemInterface gas = new SystemSrkEos(300.0, 50.0);\ngas.addComponent(\"methane\", 0.95);\ngas.addComponent(\"ethane\", 0.05);\ngas.setMixingRule(\"classic\");\n\n// Create pipe geometry\nPipeGeometry pipe = new PipeGeometry(\"Pipeline\");\npipe.setDiameter(0.5, \"m\");        // 0.5 m inner diameter\npipe.setLength(10000.0, \"m\");      // 10 km length\npipe.setRoughness(0.00005, \"m\");   // Pipe roughness\n\n// Create flow system\nOnePhasePipeFlowSystem flowSystem = new OnePhasePipeFlowSystem();\nflowSystem.setInletFluid(gas);\nflowSystem.setGeometry(pipe);\nflowSystem.setInletPressure(50.0, \"bara\");\nflowSystem.setOutletPressure(40.0, \"bara\");\nflowSystem.setNumberOfNodes(100);\n\n// Initialize and solve\nflowSystem.init();\nflowSystem.solveTransient(1);\n\n// Get results\ndouble pressureDrop = flowSystem.getPressureDrop();\ndouble velocity = flowSystem.getFlowVelocity();\n</code></pre>"},{"location":"fluidmechanics/#two-phase-pipe-flow","title":"Two-Phase Pipe Flow","text":"<pre><code>import neqsim.fluidmechanics.flowsystem.twophaseflowsystem.pipeflowsystem.TwoPhasePipeFlowSystem;\n\n// Create two-phase fluid\nSystemInterface fluid = new SystemSrkEos(300.0, 30.0);\nfluid.addComponent(\"methane\", 0.80);\nfluid.addComponent(\"n-pentane\", 0.15);\nfluid.addComponent(\"n-decane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// Flash to get two phases\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Create two-phase flow system\nTwoPhasePipeFlowSystem twoPhaseFlow = new TwoPhasePipeFlowSystem();\ntwoPhaseFlow.setInletFluid(fluid);\ntwoPhaseFlow.setGeometry(pipe);\ntwoPhaseFlow.setNumberOfNodes(100);\n\n// Set inclination (positive = uphill)\ntwoPhaseFlow.setInclination(0.0);  // Horizontal\n\ntwoPhaseFlow.init();\ntwoPhaseFlow.solveTransient(1);\n\n// Get flow regime\nString flowRegime = twoPhaseFlow.getFlowRegime();\nSystem.out.println(\"Flow regime: \" + flowRegime);\n</code></pre>"},{"location":"fluidmechanics/#flow-nodes","title":"Flow Nodes","text":"<p>Flow nodes discretize the pipe and calculate local conditions.</p>"},{"location":"fluidmechanics/#node-properties","title":"Node Properties","text":"Property Description Pressure Local pressure Temperature Local temperature Velocity Phase velocities Holdup Liquid holdup Reynolds number Flow regime indicator Friction factor Wall friction"},{"location":"fluidmechanics/#flow-regimes-two-phase","title":"Flow Regimes (Two-Phase)","text":"Regime Class Description Stratified <code>StratifiedFlow</code> Separated gas-liquid layers Annular <code>AnnularFlow</code> Liquid film on wall, gas core Droplet/Mist <code>DropletFlow</code> Liquid droplets in gas Slug <code>SlugFlow</code> Intermittent gas-liquid slugs Bubble <code>BubbleFlow</code> Gas bubbles in liquid"},{"location":"fluidmechanics/#pressure-drop-correlations","title":"Pressure Drop Correlations","text":""},{"location":"fluidmechanics/#single-phase","title":"Single-Phase","text":"<pre><code>// Darcy-Weisbach equation\n// \u0394P = f * (L/D) * (\u03c1 * v\u00b2/2)\n\n// Friction factor correlations:\n// - Moody (explicit)\n// - Colebrook-White (implicit)\n// - Chen (explicit approximation)\n</code></pre>"},{"location":"fluidmechanics/#two-phase","title":"Two-Phase","text":"Correlation Application Beggs-Brill General two-phase Lockhart-Martinelli Separated flow Duns-Ros Vertical wells Hagedorn-Brown Vertical wells Gray Gas-condensate wells"},{"location":"fluidmechanics/#transient-flow-simulation","title":"Transient Flow Simulation","text":"<pre><code>// Set up transient simulation\nflowSystem.init();\n\ndouble simulationTime = 3600.0;  // 1 hour\ndouble timeStep = 1.0;           // 1 second\n\nfor (double t = 0; t &lt; simulationTime; t += timeStep) {\n    flowSystem.solveTransient(1);\n\n    // Get time series data\n    TimeSeries data = flowSystem.getTimeSeries();\n\n    // Log results\n    for (int i = 0; i &lt; flowSystem.getNumberOfNodes(); i++) {\n        double x = flowSystem.getNode(i).getPosition();\n        double P = flowSystem.getNode(i).getPressure();\n        double T = flowSystem.getNode(i).getTemperature();\n    }\n}\n</code></pre>"},{"location":"fluidmechanics/#heat-transfer","title":"Heat Transfer","text":"<pre><code>// Set ambient conditions\nflowSystem.setSurroundingTemperature(288.15);  // K\n\n// Set overall heat transfer coefficient\npipe.setOverallHeatTransferCoefficient(10.0);  // W/(m\u00b2\u00b7K)\n\n// Or specify insulation\npipe.setInsulationThickness(0.05, \"m\");\npipe.setInsulationConductivity(0.04);  // W/(m\u00b7K)\n\n// Solve with heat transfer\nflowSystem.setCalculateHeatTransfer(true);\nflowSystem.solveTransient(1);\n\n// Get temperature profile\nfor (int i = 0; i &lt; flowSystem.getNumberOfNodes(); i++) {\n    double T = flowSystem.getNode(i).getTemperature();\n}\n</code></pre>"},{"location":"fluidmechanics/#geometry-definitions","title":"Geometry Definitions","text":""},{"location":"fluidmechanics/#pipe-geometry","title":"Pipe Geometry","text":"<pre><code>PipeGeometry pipe = new PipeGeometry(\"Export Pipeline\");\n\n// Dimensions\npipe.setDiameter(0.4, \"m\");\npipe.setLength(50000.0, \"m\");  // 50 km\npipe.setRoughness(0.000045, \"m\");\n\n// Inclination profile (optional)\ndouble[] distances = {0, 10000, 20000, 30000, 40000, 50000};\ndouble[] elevations = {0, 50, 100, 80, 120, 150};\npipe.setElevationProfile(distances, elevations);\n</code></pre>"},{"location":"fluidmechanics/#internal-geometry","title":"Internal Geometry","text":"<p>For complex internal structures (coatings, deposits).</p> <pre><code>InternalGeometry internal = new InternalGeometry();\ninternal.setCoatingThickness(0.002, \"m\");\ninternal.setWaxThickness(0.001, \"m\");\npipe.setInternalGeometry(internal);\n</code></pre>"},{"location":"fluidmechanics/#flow-solver-options","title":"Flow Solver Options","text":"<pre><code>FlowSolverInterface solver = flowSystem.getSolver();\n\n// Solver settings\nsolver.setMaxIterations(100);\nsolver.setConvergenceCriteria(1e-6);\nsolver.setRelaxationFactor(0.8);\n</code></pre>"},{"location":"fluidmechanics/#integration-with-process-equipment","title":"Integration with Process Equipment","text":"<pre><code>import neqsim.process.equipment.pipeline.Pipeline;\n\n// Use Pipeline equipment in ProcessSystem\nPipeline pipeline = new Pipeline(\"Export Line\", inletStream);\npipeline.setLength(50.0, \"km\");\npipeline.setDiameter(0.5, \"m\");\npipeline.setOutletPressure(30.0, \"bara\");\npipeline.run();\n\nStream outlet = pipeline.getOutletStream();\ndouble Tout = outlet.getTemperature(\"C\");\n</code></pre>"},{"location":"fluidmechanics/#visualization","title":"Visualization","text":"<pre><code>// Get display interface\nFlowSystemVisualizationInterface display = flowSystem.getDisplay();\n\n// Plot pressure profile\ndisplay.plotPressureProfile();\n\n// Plot temperature profile\ndisplay.plotTemperatureProfile();\n\n// Plot holdup (two-phase)\ndisplay.plotHoldupProfile();\n</code></pre>"},{"location":"fluidmechanics/#example-gas-pipeline","title":"Example: Gas Pipeline","text":"<pre><code>// Natural gas pipeline simulation\nSystemInterface gas = new SystemSrkEos(288.15, 80.0);\ngas.addComponent(\"nitrogen\", 0.02);\ngas.addComponent(\"CO2\", 0.01);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"propane\", 0.02);\ngas.setMixingRule(\"classic\");\n\n// Set flow rate\ngas.setTotalFlowRate(50.0, \"MSm3/day\");\n\n// Pipeline geometry\nPipeGeometry pipe = new PipeGeometry(\"Gas Export\");\npipe.setDiameter(0.9, \"m\");\npipe.setLength(200000.0, \"m\");  // 200 km\npipe.setRoughness(0.00004, \"m\");\n\n// Flow system\nOnePhasePipeFlowSystem gasFlow = new OnePhasePipeFlowSystem();\ngasFlow.setInletFluid(gas);\ngasFlow.setGeometry(pipe);\ngasFlow.setInletPressure(80.0, \"bara\");\ngasFlow.setNumberOfNodes(200);\n\ngasFlow.init();\ngasFlow.solveTransient(1);\n\n// Results\nSystem.out.println(\"Inlet pressure: \" + gasFlow.getInletPressure() + \" bar\");\nSystem.out.println(\"Outlet pressure: \" + gasFlow.getOutletPressure() + \" bar\");\nSystem.out.println(\"Pressure drop: \" + gasFlow.getPressureDrop() + \" bar\");\nSystem.out.println(\"Flow velocity: \" + gasFlow.getFlowVelocity() + \" m/s\");\n</code></pre>"},{"location":"fluidmechanics/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate number of nodes - more nodes for accuracy, fewer for speed</li> <li>Check flow regime in two-phase calculations</li> <li>Validate against correlations for your specific application</li> <li>Consider elevation profile for long pipelines</li> <li>Include heat transfer for hot fluids or cold environments</li> </ol>"},{"location":"fluidmechanics/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Pipeline Equipment - Pipeline in process simulation</li> <li>Physical Properties - Viscosity and density models</li> </ul>"},{"location":"fluidmechanics/single_phase_pipe_flow/","title":"Single-Phase Gas Pipe Flow Simulation","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#overview","title":"Overview","text":"<p>NeqSim provides single-phase gas pipeline simulation capabilities through the <code>PipeFlowSystem</code> class, implementing a staggered grid finite volume method with TDMA (Tri-Diagonal Matrix Algorithm) solver.</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#architecture","title":"Architecture","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>FlowSystem (abstract)\n\u2514\u2500\u2500 OnePhaseFlowSystem (abstract)\n    \u2514\u2500\u2500 PipeFlowSystem (concrete)\n</code></pre>"},{"location":"fluidmechanics/single_phase_pipe_flow/#key-components","title":"Key Components","text":"Component Description <code>PipeFlowSystem</code> Main flow system for single-phase pipe flow <code>OnePhaseFixedStaggeredGrid</code> Staggered grid solver with TDMA <code>onePhasePipeFlowNode</code> Flow node for single-phase pipe segments <code>TimeSeries</code> Time-varying inlet conditions for transient simulation"},{"location":"fluidmechanics/single_phase_pipe_flow/#governing-equations","title":"Governing Equations","text":"<p>The solver implements the following conservation equations:</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#mass-conservation","title":"Mass Conservation","text":"\\[\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial (\\rho v)}{\\partial x} = 0\\]"},{"location":"fluidmechanics/single_phase_pipe_flow/#momentum-conservation","title":"Momentum Conservation","text":"\\[\\frac{\\partial (\\rho v)}{\\partial t} + \\frac{\\partial (\\rho v^2)}{\\partial x} = -\\frac{\\partial P}{\\partial x} - \\rho g \\sin(\\theta) - \\frac{f \\rho v |v|}{2D}\\] <p>where: - \\(\\rho\\) = density - \\(v\\) = velocity - \\(P\\) = pressure - \\(g\\) = gravitational acceleration - \\(\\theta\\) = pipe inclination angle - \\(f\\) = Darcy friction factor - \\(D\\) = pipe diameter</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#energy-conservation","title":"Energy Conservation","text":"\\[\\frac{\\partial (\\rho h)}{\\partial t} + \\frac{\\partial (\\rho v h)}{\\partial x} = Q_{wall} + \\rho v g \\sin(\\theta)\\] <p>where: - \\(h\\) = specific enthalpy - \\(Q_{wall}\\) = wall heat transfer rate</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#component-conservation","title":"Component Conservation","text":"<p>For each component \\(i\\):</p> \\[\\frac{\\partial (\\rho \\omega_i)}{\\partial t} + \\frac{\\partial (\\rho v \\omega_i)}{\\partial x} = 0\\] <p>where \\(\\omega_i\\) is the mass fraction of component \\(i\\).</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#numerical-method","title":"Numerical Method","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#staggered-grid-discretization","title":"Staggered Grid Discretization","text":"<p>The solver uses a staggered grid approach: - Pressure and temperature are stored at cell centers - Velocities are stored at cell faces</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#tdma-solver","title":"TDMA Solver","text":"<p>The Tri-Diagonal Matrix Algorithm efficiently solves the linearized system:</p> <pre><code>a[i] * \u03c6[i-1] + b[i] * \u03c6[i] + c[i] * \u03c6[i+1] = r[i]\n</code></pre>"},{"location":"fluidmechanics/single_phase_pipe_flow/#upwind-scheme","title":"Upwind Scheme","text":"<p>Convective terms use upwind differencing for stability:</p> <pre><code>a[i] = Math.max(Fw, 0);  // West face flux\nc[i] = Math.max(-Fe, 0); // East face flux\n</code></pre>"},{"location":"fluidmechanics/single_phase_pipe_flow/#solver-types","title":"Solver Types","text":"<p>The solver supports different levels of physics:</p> Type Description 0 Momentum only (isothermal, incompressible) 1 Momentum + mass (compressible) 10 Momentum + mass + energy 20 Momentum + mass + energy + composition"},{"location":"fluidmechanics/single_phase_pipe_flow/#usage-example","title":"Usage Example","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#steady-state-simulation","title":"Steady-State Simulation","text":"<pre><code>import neqsim.fluidmechanics.flowsystem.onephaseflowsystem.pipeflowsystem.PipeFlowSystem;\nimport neqsim.fluidmechanics.geometrydefinitions.pipe.PipeData;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create gas system\nSystemInterface gas = new SystemSrkEos(288.15, 100.0); // 15\u00b0C, 100 bar\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.10);\ngas.createDatabase(true);\ngas.init(0);\ngas.init(3);\ngas.initPhysicalProperties();\ngas.setTotalFlowRate(10.0, \"MSm3/day\");\n\n// Configure pipeline\nFlowSystemInterface pipe = new PipeFlowSystem();\npipe.setInletThermoSystem(gas);\npipe.setNumberOfLegs(10);\npipe.setNumberOfNodesInLeg(20);\n\n// Set geometry (10 segments)\ndouble[] heights = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\ndouble[] positions = {0, 10000, 20000, 30000, 40000, 50000, \n                      60000, 70000, 80000, 90000, 100000}; // meters\n\nGeometryDefinitionInterface[] geometry = new PipeData[11];\nfor (int i = 0; i &lt;= 10; i++) {\n    geometry[i] = new PipeData();\n    geometry[i].setDiameter(1.0);  // 1 meter diameter\n    geometry[i].setInnerSurfaceRoughness(1e-5);\n}\n\npipe.setEquipmentGeometry(geometry);\npipe.setLegHeights(heights);\npipe.setLegPositions(positions);\npipe.setLegOuterTemperatures(new double[]{278, 278, 278, 278, 278, 278, \n                                           278, 278, 278, 278, 278});\npipe.setLegWallHeatTransferCoefficients(new double[]{15, 15, 15, 15, 15, 15,\n                                                      15, 15, 15, 15, 15});\npipe.setLegOuterHeatTransferCoefficients(new double[]{5, 5, 5, 5, 5, 5,\n                                                       5, 5, 5, 5, 5});\n\n// Solve\npipe.createSystem();\npipe.init();\npipe.solveSteadyState(10);  // Type 10: with energy equation\n\n// Get results\ndouble pressureDrop = pipe.getTotalPressureDrop();\ndouble outletTemp = pipe.getNode(pipe.getTotalNumberOfNodes() - 1)\n    .getBulkSystem().getTemperature();\n</code></pre>"},{"location":"fluidmechanics/single_phase_pipe_flow/#dynamictransient-simulation","title":"Dynamic/Transient Simulation","text":"<p>The transient solver supports time-varying inlet conditions including changes in: - Temperature - Pressure - Flow rate - Composition</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#transient-simulation-example","title":"Transient Simulation Example","text":"<pre><code>// First solve steady state to initialize\npipe.createSystem();\npipe.init();\npipe.solveSteadyState(10);\n\n// Setup time series with varying inlet conditions\n// Note: times array has N points, systems array has N-1 entries (one per interval)\ndouble[] times = {0, 3000, 6000};  // 3 time points = 2 intervals\npipe.getTimeSeries().setTimes(times);\n\n// Initial cold gas\nSystemInterface coldGas = new SystemSrkEos(280.0, 100.0);\ncoldGas.addComponent(\"methane\", 0.90);\ncoldGas.addComponent(\"ethane\", 0.10);\ncoldGas.createDatabase(true);\ncoldGas.init(0);\ncoldGas.init(3);\ncoldGas.initPhysicalProperties();\ncoldGas.setTotalFlowRate(10.0, \"MSm3/day\");\n\n// Hot gas with different composition\nSystemInterface hotGas = new SystemSrkEos(320.0, 100.0);\nhotGas.addComponent(\"methane\", 0.80);\nhotGas.addComponent(\"ethane\", 0.20);\nhotGas.createDatabase(true);\nhotGas.init(0);\nhotGas.init(3);\nhotGas.initPhysicalProperties();\nhotGas.setTotalFlowRate(10.0, \"MSm3/day\");\n\n// 2 intervals: [0-3000] cold, [3000-6000] hot\nSystemInterface[] systems = {coldGas, hotGas};\npipe.getTimeSeries().setInletThermoSystems(systems);\npipe.getTimeSeries().setNumberOfTimeStepsInInterval(5);\n\n// Run transient simulation with full physics (type 20 = momentum + mass + energy + composition)\npipe.solveTransient(20);\n</code></pre>"},{"location":"fluidmechanics/single_phase_pipe_flow/#compositional-tracking","title":"Compositional Tracking","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#steady-state-composition","title":"Steady-State Composition","text":"<p>In steady-state single-phase flow, composition is uniform throughout the pipeline:</p> <ul> <li>Solver type 20 includes component conservation equations</li> <li>Mole fractions are solved using the same TDMA scheme</li> <li>Normalization ensures mole fractions sum to unity</li> </ul>"},{"location":"fluidmechanics/single_phase_pipe_flow/#dynamic-composition-tracking","title":"Dynamic Composition Tracking","text":"<p>Dynamic compositional tracking enables simulating slug flow, batch processing, and compositional transitions:</p> <ol> <li><code>oldComposition[component][node]</code> stores previous time step values</li> <li><code>setComponentConservationMatrix()</code> builds the discretized equations</li> <li><code>initComposition()</code> updates node compositions after each time step</li> </ol> <p>Example - Compositional Change at Inlet:</p> <pre><code>// Initial gas with ethane\nSystemInterface initialGas = new SystemSrkEos(298.0, 30.0);\ninitialGas.addComponent(\"methane\", 0.9);\ninitialGas.addComponent(\"ethane\", 0.1);\ninitialGas.initPhysicalProperties();\ninitialGas.setTotalFlowRate(10.0, \"MSm3/day\");\n\n// New gas (pure methane)\nSystemInterface newGas = initialGas.clone();\nnewGas.addComponent(\"methane\", 0.1);  // Shift to 100% methane\nnewGas.initPhysicalProperties();\n\n// TimeSeries with 2 intervals\nSystemInterface[] systems = {initialGas, newGas};\npipe.getTimeSeries().setInletThermoSystems(systems);\npipe.getTimeSeries().setNumberOfTimeStepsInInterval(10);\n\n// Run with compositional tracking (type 20)\npipe.solveTransient(20);\n</code></pre>"},{"location":"fluidmechanics/single_phase_pipe_flow/#physical-effects-captured","title":"Physical Effects Captured","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#pressure-drop","title":"Pressure Drop","text":"<ul> <li>Friction losses (Darcy-Weisbach)</li> <li>Gravitational head (for inclined pipes)</li> <li>Acceleration losses (compressible flow)</li> </ul>"},{"location":"fluidmechanics/single_phase_pipe_flow/#temperature-effects","title":"Temperature Effects","text":"<ul> <li>Wall heat transfer to surroundings</li> <li>Joule-Thomson cooling on expansion</li> <li>Gravitational work term</li> </ul>"},{"location":"fluidmechanics/single_phase_pipe_flow/#compressibility","title":"Compressibility","text":"<ul> <li>Real gas equation of state (SRK-EOS or other)</li> <li>Density variation with pressure and temperature</li> <li>Velocity increase as gas expands</li> </ul>"},{"location":"fluidmechanics/single_phase_pipe_flow/#validation-results","title":"Validation Results","text":"<p>The steady-state solver has been validated for:</p> Test Result Pressure monotonically decreases \u2713 Pass Temperature approaches surroundings \u2713 Pass Mass conservation (inlet \u2248 outlet) \u2713 Pass (within 15%) Reynolds number physically correct \u2713 Pass Friction factor in reasonable range \u2713 Pass Composition preserved \u2713 Pass Numerical stability (high flow) \u2713 Pass Inclined pipeline handling \u2713 Pass"},{"location":"fluidmechanics/single_phase_pipe_flow/#known-limitations","title":"Known Limitations","text":"<ol> <li>Single-phase only: No phase transition handling</li> <li>Composition drift: Small numerical drift (~1%) in composition over long pipelines</li> <li>TimeSeries API: Inlet systems array must have N-1 elements for N time points (one system per interval)</li> </ol>"},{"location":"fluidmechanics/single_phase_pipe_flow/#recommendations","title":"Recommendations","text":""},{"location":"fluidmechanics/single_phase_pipe_flow/#for-improved-mass-conservation","title":"For Improved Mass Conservation","text":"<p>Consider implementing: - Pressure-velocity coupling (SIMPLE algorithm) - Higher-order convection schemes - Adaptive time stepping for transient simulations</p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#timeseries-best-practices","title":"TimeSeries Best Practices","text":"<p>When setting up transient simulations: <pre><code>// CORRECT: 3 time points \u2192 2 systems (one per interval)\ndouble[] times = {0, 3000, 6000};\npipe.getTimeSeries().setOutletMolarFlowRates(times, \"kg/sec\");\n\nSystemInterface[] systems = {gasForInterval1, gasForInterval2};\npipe.getTimeSeries().setInletThermoSystems(systems);\n</code></pre></p>"},{"location":"fluidmechanics/single_phase_pipe_flow/#references","title":"References","text":"<ol> <li>Patankar, S.V. (1980). Numerical Heat Transfer and Fluid Flow. Hemisphere Publishing.</li> <li>Solbraa, E. (2002). Equilibrium and Non-Equilibrium Thermodynamics of Natural Gas Processing. PhD Thesis, NTNU.</li> </ol>"},{"location":"integration/","title":"Integration Guides","text":"<p>Documentation for integrating NeqSim with external systems and platforms.</p>"},{"location":"integration/#overview","title":"Overview","text":"<p>This folder contains guides for integrating NeqSim with machine learning platforms, model predictive control systems, real-time data systems, and P&amp;ID tools.</p>"},{"location":"integration/#documentation-index","title":"Documentation Index","text":""},{"location":"integration/#machine-learning-and-ai","title":"Machine Learning and AI","text":"Document Description ai_platform_integration.md AI platform integration guide ml_integration.md Machine learning integration"},{"location":"integration/#control-systems","title":"Control Systems","text":"Document Description mpc_integration.md Model Predictive Control integration neqsim_industrial_mpc_integration.md Industrial MPC integration"},{"location":"integration/#real-time-systems","title":"Real-Time Systems","text":"Document Description REAL_TIME_INTEGRATION_GUIDE.md Real-time systems integration QRA_INTEGRATION_GUIDE.md Quantitative Risk Assessment integration"},{"location":"integration/#pid-and-design","title":"P&amp;ID and Design","text":"Document Description dexpi-reader.md DEXPI P&amp;ID reader"},{"location":"integration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Process simulation</li> <li>Simulation Guides - Advanced simulation</li> </ul>"},{"location":"integration/QRA_INTEGRATION_GUIDE/","title":"NeqSim QRA Integration Guide","text":"<p>A comprehensive guide for integrating NeqSim thermodynamic calculations into Quantitative Risk Assessment (QRA) workflows.</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Where NeqSim Fits in the QRA Chain</li> <li>Workflow Map by Scenario Type</li> <li>Mapping to Common QRA Tool Interfaces</li> <li>Standard Output Schemas</li> <li>NeqSim Implementation Details</li> <li>Quality Controls for QRA Credibility</li> <li>End-to-End Example Workflow</li> <li>Tool-Specific Export Formats</li> </ol>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#1-where-neqsim-fits-in-the-qra-chain","title":"1. Where NeqSim Fits in the QRA Chain","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsims-role","title":"NeqSim's Role","text":"<p>NeqSim's primary role in QRA is to produce high-quality thermodynamics, phase behavior, and discharge conditions that become inputs (\"source terms\") to consequence modeling tools.</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#typical-qra-chain","title":"Typical QRA Chain","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                          QRA WORKFLOW CHAIN                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                        \u2502\n\u2502  \u2502 Process/Operating \u2502                                                       \u2502\n\u2502  \u2502 Case Definition   \u2502                                                       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                        \u2502\n\u2502           \u2502                                                                  \u2502\n\u2502           \u25bc                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502                        NeqSim                                 \u2502           \u2502\n\u2502  \u2502  \u2022 State at leak point (P, T, composition)                   \u2502           \u2502\n\u2502  \u2502  \u2022 Flash/expansion calculations                               \u2502           \u2502\n\u2502  \u2502  \u2022 Blowdown transients                                        \u2502           \u2502\n\u2502  \u2502  \u2022 Source term generation (mass flow, phase split, T, \u03c1)     \u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502           \u2502                                                                  \u2502\n\u2502           \u2502  Source Term Files (CSV/JSON)                                   \u2502\n\u2502           \u2502  \u2022 PHAST format                                                 \u2502\n\u2502           \u2502  \u2022 FLACS format                                                 \u2502\n\u2502           \u2502  \u2022 KFX format                                                   \u2502\n\u2502           \u2502  \u2022 OpenFOAM format                                              \u2502\n\u2502           \u25bc                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502              Consequence Modeling Tools                       \u2502           \u2502\n\u2502  \u2502  \u2022 PHAST / SAFETI / EFFECTS / ALOHA (dispersion)             \u2502           \u2502\n\u2502  \u2502  \u2022 FLACS / KFX / OpenFOAM (CFD)                              \u2502           \u2502\n\u2502  \u2502  \u2022 Fire modules (jet/pool/flash fire)                        \u2502           \u2502\n\u2502  \u2502  \u2022 Explosion models                                           \u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502           \u2502                                                                  \u2502\n\u2502           \u2502  Consequence Results                                            \u2502\n\u2502           \u2502  \u2022 Dispersion contours                                          \u2502\n\u2502           \u2502  \u2022 Radiation levels                                             \u2502\n\u2502           \u2502  \u2022 Overpressure contours                                        \u2502\n\u2502           \u25bc                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502                    QRA Platform                               \u2502           \u2502\n\u2502  \u2502  \u2022 Event frequencies (OREDA, company data)                   \u2502           \u2502\n\u2502  \u2502  \u2022 Ignition probabilities                                    \u2502           \u2502\n\u2502  \u2502  \u2022 Escalation logic                                          \u2502           \u2502\n\u2502  \u2502  \u2022 Risk integration (F-N curves, risk contours)              \u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-capabilities-summary","title":"NeqSim Capabilities Summary","text":"Capability NeqSim Package Description Fluid thermodynamics <code>neqsim.thermo</code> EoS calculations, phase equilibria Source term generation <code>neqsim.process.safety.release</code> <code>LeakModel</code>, <code>SourceTermResult</code> Depressurization/blowdown <code>neqsim.process.equipment.tank</code> <code>VesselDepressurization</code> Safety envelopes <code>neqsim.process.safety.envelope</code> <code>SafetyEnvelopeCalculator</code> Risk quantification <code>neqsim.process.safety.risk</code> <code>RiskModel</code>, Monte Carlo Relief valve sizing <code>neqsim.process.util.fire</code> <code>ReliefValveSizing</code>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#2-workflow-map-by-scenario-type","title":"2. Workflow Map by Scenario Type","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#a-continuous-leak-hole-from-pressurized-equipment","title":"A. Continuous Leak (Hole) from Pressurized Equipment","text":"<p>Goal: Mass release rate, phase split, release temperature, jet momentum.</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-outputs","title":"NeqSim Outputs","text":"Parameter Description NeqSim Source P, T, composition Upstream fluid state at leak node <code>SystemInterface</code> Z, MW, \u03c1 Real-gas properties <code>system.getZ()</code>, <code>system.getMolarMass()</code>, <code>system.getDensity()</code> Cp/Cv (\u03b3) Heat capacity ratio <code>system.getGamma()</code> JT coefficient Joule-Thomson coefficient <code>system.getJouleThomsonCoefficient()</code> Gas/liquid split Flash at near-field conditions <code>ThermodynamicOperations.TPflash()</code> mdot, T_release Mass flow and release temperature <code>LeakModel.calculateSourceTerm()</code>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-implementation","title":"NeqSim Implementation","text":"<pre><code>import neqsim.process.safety.release.*;\nimport neqsim.thermo.system.*;\n\n// Define upstream fluid\nSystemInterface fluid = new SystemSrkEos(350.0, 80.0); // 80 bara, 350 K\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// Create leak model\nLeakModel leak = LeakModel.builder()\n    .fluid(fluid)\n    .holeDiameter(25.0, \"mm\")\n    .dischargeCoefficient(0.62)\n    .vesselVolume(10.0)  // m\u00b3\n    .orientation(ReleaseOrientation.HORIZONTAL)\n    .scenarioName(\"Small Leak - Separator\")\n    .build();\n\n// Calculate source term (steady-state)\nSourceTermResult result = leak.calculateSourceTerm(600.0, 1.0); // 10 min, 1s step\n\n// Export for consequence tools\nresult.exportToPHAST(\"leak_phast.csv\");\nresult.exportToFLACS(\"leak_flacs.csv\");\nresult.exportToKFX(\"leak_kfx.csv\");\nresult.exportToOpenFOAM(\"/path/to/openfoam/case\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#hand-off-artifacts","title":"Hand-off Artifacts","text":"<p>CSV/JSON file per leak size containing:</p> <pre><code>time_s,mdot_total_kg_s,mdot_gas_kg_s,mdot_liquid_kg_s,T_release_K,P_release_bar,rho_gas_kg_m3,MW_gas,Z,gamma,velocity_m_s,momentum_N,choked\n0.0,5.23,5.23,0.0,285.4,1.013,1.15,17.2,0.998,1.31,412.5,2156.3,true\n1.0,5.21,5.21,0.0,285.2,1.013,1.15,17.2,0.998,1.31,411.8,2148.7,true\n...\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#b-rupture-full-bore-release-with-inventory-depletion","title":"B. Rupture / Full-Bore Release with Inventory Depletion","text":"<p>Goal: Release rate vs time, evolving phase split, minimum temperature (MDMT risk).</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-outputs_1","title":"NeqSim Outputs","text":"Parameter Description NeqSim Source Initial inventory Mass and phase split in vessel <code>VesselDepressurization.getInitialInventory()</code> P(t), T(t) Pressure and temperature vs time <code>runTransient()</code> results mdot(t) Mass flow rate vs time Transient output T_min Minimum temperature reached <code>getMinimumWallTemperatureReached()</code> Time to T_min When minimum occurs Transient output"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-implementation_1","title":"NeqSim Implementation","text":"<pre><code>import neqsim.process.equipment.tank.VesselDepressurization;\nimport neqsim.process.equipment.stream.Stream;\n\n// Setup vessel with initial conditions\nSystemInterface gas = new SystemSrkEos(300.0, 100.0); // 100 bara\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.07);\ngas.addComponent(\"propane\", 0.03);\ngas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"feed\", gas);\nfeed.setFlowRate(100.0, \"kg/hr\");\nfeed.run();\n\nVesselDepressurization vessel = new VesselDepressurization(\"Blowdown\", feed);\nvessel.setVolume(50.0);  // m\u00b3\nvessel.setOrificeDiameter(0.05);  // 50 mm orifice\nvessel.setCalculationType(VesselDepressurization.CalculationType.ENERGY_BALANCE);\nvessel.setMaxBlowdownTime(1800.0);  // 30 minutes max\n\n// Run transient blowdown\ndouble dt = 1.0;  // 1 second timestep\nUUID uuid = UUID.randomUUID();\nwhile (!vessel.isBlowdownComplete()) {\n    vessel.runTransient(dt, uuid);\n}\n\n// Export results\nvessel.exportResultsToCSV(\"blowdown_results.csv\");\nvessel.exportResultsToJSON(\"blowdown_results.json\");\n\n// Get summary for QRA documentation\ndouble peakRelease = vessel.getPeakMassFlowRate();\ndouble duration = vessel.getBlowdownDuration();\ndouble totalMass = vessel.getTotalMassReleased();\ndouble minTemp = vessel.getMinimumWallTemperatureReached();\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#hand-off-artifacts_1","title":"Hand-off Artifacts","text":"<p>Time-series file:</p> <pre><code>time_s,P_upstream_bar,T_upstream_K,mdot_total_kg_s,mdot_gas_kg_s,mdot_liquid_kg_s,T_release_K,vapor_fraction\n0.0,100.0,300.0,125.4,125.4,0.0,245.2,1.0\n1.0,98.5,298.2,123.1,123.1,0.0,244.8,1.0\n2.0,97.1,296.5,120.9,120.9,0.0,244.3,1.0\n...\n</code></pre> <p>Summary card for QRA documentation:</p> <pre><code>{\n  \"scenario\": \"HP Separator Blowdown\",\n  \"peak_release_kg_s\": 125.4,\n  \"duration_above_10kg_s\": 245.0,\n  \"total_mass_released_kg\": 15420.0,\n  \"minimum_temperature_K\": 198.5,\n  \"time_to_min_temp_s\": 312.0,\n  \"hydrate_risk\": true,\n  \"co2_freezing_risk\": false\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#c-psv-bdv-discharge-to-flare-or-vent","title":"C. PSV / BDV Discharge to Flare or Vent","text":"<p>Goal: Discharge composition, temperature, phase into flare network; two-phase risk; hydrate/ice risk.</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-outputs_2","title":"NeqSim Outputs","text":"Parameter Description NeqSim Source P_in, T_in PSV inlet conditions <code>SafetyValve.getInletPressure/Temperature()</code> mdot Relieving flow rate <code>ReliefValveSizing.calculateRequiredArea()</code> Composition Relieving fluid composition <code>SystemInterface.getComponent(i)</code> Quality Vapor fraction at discharge <code>system.getPhase(0).getBeta()</code> T_out Discharge temperature Flash calculation Hydrate indicators Hydrate formation risk <code>SafetyEnvelopeCalculator</code>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-implementation_2","title":"NeqSim Implementation","text":"<pre><code>import neqsim.process.util.fire.ReliefValveSizing;\nimport neqsim.process.safety.envelope.*;\n\n// Define relieving fluid\nSystemInterface fluid = new SystemSrkEos(400.0, 50.0);\nfluid.addComponent(\"methane\", 0.80);\nfluid.addComponent(\"ethane\", 0.15);\nfluid.addComponent(\"water\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// API 520 sizing\nReliefValveSizing sizing = new ReliefValveSizing(fluid);\nsizing.setReliefPressure(55.0);  // bara (set pressure + accumulation)\nsizing.setBackPressure(5.0);     // bara\ndouble requiredArea = sizing.calculateRequiredArea();\ndouble massFlow = sizing.getReliefMassFlow();\n\n// Check for hydrate risk in tailpipe\nSafetyEnvelopeCalculator envCalc = new SafetyEnvelopeCalculator(fluid);\nSafetyEnvelope hydrateEnv = envCalc.calculateHydrateEnvelope(1.0, 60.0, 20);\nboolean hydrateRisk = !hydrateEnv.isOperatingPointSafe(5.0, 280.0);\n\n// Generate relieving case table\nSystem.out.printf(\"P_in: %.1f bara, T_in: %.1f K, mdot: %.2f kg/s%n\",\n    50.0, 400.0, massFlow);\nSystem.out.printf(\"Quality: %.3f, T_out: %.1f K%n\",\n    fluid.getPhase(0).getBeta(), sizing.getDischargeTemperature());\nSystem.out.printf(\"Hydrate risk: %s%n\", hydrateRisk);\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#hand-off-artifacts_2","title":"Hand-off Artifacts","text":"<p>Relieving case table:</p> Case P_in (bara) T_in (K) mdot (kg/s) Composition Quality T_out (K) Hydrate Risk Fire 55.0 400 12.5 CH4/C2H6 0.98 285 No Blocked 52.0 380 8.2 CH4/C2H6 1.00 290 No Tube rupture 55.0 350 25.0 CH4/C2H6/H2O 0.85 275 Yes"},{"location":"integration/QRA_INTEGRATION_GUIDE/#d-pool-formation-liquid-release-rainout","title":"D. Pool Formation (Liquid Release, Rainout)","text":"<p>Goal: Whether liquid forms, how much, evaporation rate basis.</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-outputs_3","title":"NeqSim Outputs","text":"Parameter Description NeqSim Source Flash fraction Vapor vs liquid at ambient <code>ThermodynamicOperations.TPflash()</code> Liquid density kg/m\u00b3 <code>system.getPhase(\"oil\").getDensity()</code> Liquid viscosity Pa\u00b7s <code>system.getPhase(\"oil\").getViscosity()</code> Boiling range Temperature range Phase envelope calculation Volatility split Light vs heavy fractions Component distribution"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-implementation_3","title":"NeqSim Implementation","text":"<pre><code>import neqsim.thermo.system.*;\nimport neqsim.thermodynamicoperations.*;\n\n// Condensate release\nSystemInterface condensate = new SystemSrkEos(288.15, 1.01325); // Ambient P, T\ncondensate.addComponent(\"n-pentane\", 0.15);\ncondensate.addComponent(\"n-hexane\", 0.25);\ncondensate.addComponent(\"n-heptane\", 0.30);\ncondensate.addComponent(\"n-octane\", 0.20);\ncondensate.addComponent(\"n-nonane\", 0.10);\ncondensate.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(condensate);\nops.TPflash();\n\n// Get liquid properties for pool model\ndouble liquidFraction = 1.0 - condensate.getPhase(0).getBeta();\ndouble liquidDensity = condensate.getPhase(\"oil\").getDensity(\"kg/m3\");\ndouble liquidViscosity = condensate.getPhase(\"oil\").getViscosity(\"kg/msec\");\n\n// Estimate initial evaporation rate (simplified)\ndouble vaporPressure = condensate.getPhase(\"oil\").getAntoineVaporPressure(288.15);\ndouble evapRate = estimateEvaporationRate(vaporPressure, liquidDensity);\n\nSystem.out.printf(\"Liquid fraction: %.1f%%%n\", liquidFraction * 100);\nSystem.out.printf(\"Liquid density: %.1f kg/m\u00b3%n\", liquidDensity);\nSystem.out.printf(\"Initial evap rate: %.3f kg/m\u00b2/s%n\", evapRate);\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#hand-off-artifacts_3","title":"Hand-off Artifacts","text":"<pre><code>{\n  \"scenario\": \"Condensate Spill\",\n  \"liquid_rate_kg_s\": 5.2,\n  \"liquid_fraction\": 0.85,\n  \"liquid_density_kg_m3\": 680.5,\n  \"liquid_viscosity_Pa_s\": 0.00045,\n  \"vapor_rate_initial_kg_s\": 0.8,\n  \"boiling_range_K\": [309, 424],\n  \"pseudo_components\": [\n    {\"name\": \"C5-C6\", \"fraction\": 0.40, \"MW\": 78},\n    {\"name\": \"C7-C9\", \"fraction\": 0.60, \"MW\": 107}\n  ]\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#e-toxic-release-h2s-co2-nh3","title":"E. Toxic Release (H\u2082S, CO\u2082, NH\u2083)","text":"<p>Goal: Concentration vs distance from dispersion tool; NeqSim ensures correct density/phase.</p>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-outputs_4","title":"NeqSim Outputs","text":"Parameter Description NeqSim Source Mixture MW Molecular weight <code>system.getMolarMass()</code> Density At release conditions <code>system.getDensity()</code> Compressibility Z-factor <code>system.getZ()</code> Phase split For CO\u2082 dense phase Flash calculations Temperature Affects buoyancy <code>system.getTemperature()</code>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-implementation_4","title":"NeqSim Implementation","text":"<pre><code>import neqsim.process.safety.release.*;\nimport neqsim.process.safety.envelope.*;\n\n// CO2 with H2S (sour gas)\nSystemInterface sourGas = new SystemSrkEos(300.0, 80.0);\nsourGas.addComponent(\"CO2\", 0.90);\nsourGas.addComponent(\"H2S\", 0.05);\nsourGas.addComponent(\"methane\", 0.05);\nsourGas.setMixingRule(\"classic\");\n\n// Create leak model\nLeakModel leak = LeakModel.builder()\n    .fluid(sourGas)\n    .holeDiameter(50.0, \"mm\")\n    .dischargeCoefficient(0.62)\n    .orientation(ReleaseOrientation.HORIZONTAL)\n    .scenarioName(\"Sour Gas Leak\")\n    .build();\n\nSourceTermResult result = leak.calculateSourceTerm(300.0, 1.0);\n\n// Check for CO2 freezing / dense phase\nSafetyEnvelopeCalculator envCalc = new SafetyEnvelopeCalculator(sourGas);\nSafetyEnvelope co2Env = envCalc.calculateCO2FreezingEnvelope(10.0, 100.0, 10);\n\n// Dense gas flag for dispersion modeling\nboolean denseGas = sourGas.getDensity(\"kg/m3\") &gt; 1.5; // Heavier than air\n\n// Export with toxic flags\nresult.exportToPHAST(\"toxic_release_phast.csv\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#hand-off-artifacts_4","title":"Hand-off Artifacts","text":"<p>Same as leak source term, with additional toxic-specific fields:</p> <pre><code>time_s,mdot_total_kg_s,mdot_gas_kg_s,T_release_K,MW,rho_kg_m3,Z,dense_gas_flag,h2s_fraction,co2_fraction\n0.0,15.2,15.2,245.0,43.2,2.05,0.82,true,0.05,0.90\n...\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#3-mapping-to-common-qra-tool-interfaces","title":"3. Mapping to Common QRA Tool Interfaces","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#consequence-tool-requirements","title":"Consequence Tool Requirements","text":"Parameter PHAST FLACS KFX OpenFOAM ALOHA Upstream P, T \u2713 \u2713 \u2713 \u2713 \u2713 Composition \u2713 \u2713 \u2713 \u2713 Simplified Hole size + Cd \u2713 \u2713 \u2713 \u2713 \u2713 Orientation/height User input User input User input User input User input Choked flow info \u2713 \u2713 \u2713 \u2713 \u2713 Gas/liquid split \u2713 \u2713 \u2713 \u2713 Limited Release T \u2713 \u2713 \u2713 \u2713 \u2713 MW, \u03b3, Z \u2713 \u2713 \u2713 \u2713 \u2713"},{"location":"integration/QRA_INTEGRATION_GUIDE/#qra-platform-requirements","title":"QRA Platform Requirements","text":"Parameter Description NeqSim Source Release category Small/medium/large/rupture Hole diameter mapping Duration bins Time above threshold <code>LeakModel</code> transient Total mass released Per outcome branch Integration of mdot(t) Peak release rate For consequence scaling Max of mdot(t)"},{"location":"integration/QRA_INTEGRATION_GUIDE/#neqsim-mapping-layer","title":"NeqSim Mapping Layer","text":"<pre><code>import neqsim.process.safety.release.*;\n\n// NeqSim \u2192 SourceTerm DTO\npublic class SourceTermDTO {\n    // Identification\n    public String caseId;\n    public String nodeId;\n    public String scenarioType;\n    public double holeDiameter_m;\n\n    // Upstream conditions\n    public double P_upstream_bar;\n    public double T_upstream_K;\n    public Map&lt;String, Double&gt; composition;\n\n    // Discharge conditions\n    public double mdot_total_kg_s;\n    public double mdot_gas_kg_s;\n    public double mdot_liquid_kg_s;\n\n    // Thermodynamic properties\n    public double T_release_K;\n    public double P_release_bar;\n    public double Z;\n    public double MW_kg_kmol;\n    public double rho_gas_kg_m3;\n    public double gamma;\n    public double Cp_J_kgK;\n\n    // Flags\n    public boolean choked;\n    public boolean twoPhase;\n    public boolean hydrateRisk;\n    public boolean solidRisk;\n\n    // Convert from NeqSim SourceTermResult\n    public static SourceTermDTO fromNeqSim(SourceTermResult result, int timeIndex) {\n        SourceTermDTO dto = new SourceTermDTO();\n        dto.mdot_total_kg_s = result.getMassFlowRate()[timeIndex];\n        dto.T_release_K = result.getTemperature()[timeIndex];\n        // ... populate other fields\n        return dto;\n    }\n\n    // Export to various formats\n    public void exportToPHAST(String filename) { /* ... */ }\n    public void exportToFLACS(String filename) { /* ... */ }\n    public void exportToKFX(String filename) { /* ... */ }\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#4-standard-output-schemas","title":"4. Standard Output Schemas","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#single-release-steady-state-schema","title":"Single-Release (Steady-State) Schema","text":"<pre><code>{\n  \"identification\": {\n    \"case_id\": \"CASE-001\",\n    \"node_id\": \"SEP-V-101\",\n    \"scenario_type\": \"small_leak\",\n    \"hole_diameter_mm\": 25.0\n  },\n  \"upstream\": {\n    \"P_bar\": 80.0,\n    \"T_K\": 350.0,\n    \"composition\": {\n      \"methane\": 0.85,\n      \"ethane\": 0.10,\n      \"propane\": 0.05\n    }\n  },\n  \"discharge\": {\n    \"mdot_total_kg_s\": 5.23,\n    \"mdot_gas_kg_s\": 5.23,\n    \"mdot_liquid_kg_s\": 0.0\n  },\n  \"thermodynamics\": {\n    \"T_release_K\": 285.4,\n    \"P_release_bar\": 1.013,\n    \"Z\": 0.998,\n    \"MW_kg_kmol\": 17.2,\n    \"rho_gas_kg_m3\": 1.15,\n    \"gamma\": 1.31,\n    \"Cp_J_kgK\": 2250\n  },\n  \"flags\": {\n    \"choked\": true,\n    \"two_phase\": false,\n    \"hydrate_risk\": false,\n    \"solid_risk\": false\n  },\n  \"momentum\": {\n    \"velocity_m_s\": 412.5,\n    \"momentum_flux_N\": 2156.3\n  }\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#transient-release-schema","title":"Transient Release Schema","text":"<pre><code>{\n  \"header\": {\n    \"case_id\": \"CASE-002\",\n    \"node_id\": \"SEP-V-101\",\n    \"scenario_type\": \"blowdown\",\n    \"orifice_diameter_mm\": 50.0,\n    \"initial_inventory_kg\": 5420.0,\n    \"initial_P_bar\": 100.0,\n    \"initial_T_K\": 300.0\n  },\n  \"summary\": {\n    \"peak_release_kg_s\": 125.4,\n    \"duration_s\": 892.0,\n    \"total_mass_released_kg\": 5420.0,\n    \"min_temperature_K\": 198.5,\n    \"time_to_min_temp_s\": 312.0\n  },\n  \"timeseries\": [\n    {\n      \"t_s\": 0.0,\n      \"P_upstream_bar\": 100.0,\n      \"T_upstream_K\": 300.0,\n      \"mdot_total_kg_s\": 125.4,\n      \"mdot_gas_kg_s\": 125.4,\n      \"mdot_liquid_kg_s\": 0.0,\n      \"T_release_K\": 245.2,\n      \"vapor_fraction\": 1.0\n    },\n    {\n      \"t_s\": 1.0,\n      \"P_upstream_bar\": 98.5,\n      \"T_upstream_K\": 298.2,\n      \"mdot_total_kg_s\": 123.1,\n      \"mdot_gas_kg_s\": 123.1,\n      \"mdot_liquid_kg_s\": 0.0,\n      \"T_release_K\": 244.8,\n      \"vapor_fraction\": 1.0\n    }\n  ]\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#5-neqsim-implementation-details","title":"5. NeqSim Implementation Details","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#package-structure","title":"Package Structure","text":"<pre><code>neqsim.process.safety/\n\u251c\u2500\u2500 release/\n\u2502   \u251c\u2500\u2500 LeakModel.java              # Main leak/rupture calculator\n\u2502   \u251c\u2500\u2500 SourceTermResult.java       # Time-series container + export\n\u2502   \u251c\u2500\u2500 ReleaseOrientation.java     # HORIZONTAL, VERTICAL_UP, VERTICAL_DOWN\n\u2502   \u2514\u2500\u2500 package-info.java\n\u251c\u2500\u2500 risk/\n\u2502   \u251c\u2500\u2500 RiskModel.java              # Monte Carlo + event trees\n\u2502   \u251c\u2500\u2500 RiskEvent.java              # Individual risk event\n\u2502   \u251c\u2500\u2500 RiskResult.java             # F-N curves, risk indices\n\u2502   \u2514\u2500\u2500 SensitivityResult.java      # Tornado diagram data\n\u251c\u2500\u2500 envelope/\n\u2502   \u251c\u2500\u2500 SafetyEnvelopeCalculator.java  # Envelope generator\n\u2502   \u2514\u2500\u2500 SafetyEnvelope.java            # P-T curve container\n\u251c\u2500\u2500 InitiatingEvent.java            # Standard initiating events\n\u251c\u2500\u2500 BoundaryConditions.java         # Environmental conditions\n\u251c\u2500\u2500 ProcessSafetyScenario.java      # Scenario definition\n\u251c\u2500\u2500 ProcessSafetyAnalyzer.java      # Scenario execution\n\u2514\u2500\u2500 ProcessSafetyLoadCase.java      # Load case results\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#key-classes-and-methods","title":"Key Classes and Methods","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#leakmodel","title":"LeakModel","text":"<pre><code>LeakModel leak = LeakModel.builder()\n    .fluid(system)                          // SystemInterface\n    .holeDiameter(25.0, \"mm\")               // Leak size\n    .dischargeCoefficient(0.62)             // Cd\n    .vesselVolume(10.0)                     // m\u00b3 (for inventory depletion)\n    .orientation(ReleaseOrientation.HORIZONTAL)\n    .scenarioName(\"Description\")\n    .build();\n\n// Steady-state\ndouble mdot = leak.calculateMassFlowRate();\n\n// Transient (inventory depletion)\nSourceTermResult result = leak.calculateSourceTerm(duration, timestep);\n\n// Exports\nresult.exportToPHAST(filename);   // DNV PHAST format\nresult.exportToFLACS(filename);   // FLACS/Gexcon format\nresult.exportToKFX(filename);     // KFX format\nresult.exportToOpenFOAM(path);    // OpenFOAM boundary files\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#vesseldepressurization","title":"VesselDepressurization","text":"<pre><code>VesselDepressurization vessel = new VesselDepressurization(name, feed);\nvessel.setVolume(50.0);\nvessel.setOrificeDiameter(0.05);\nvessel.setCalculationType(CalculationType.ENERGY_BALANCE);\nvessel.setFireCase(true, 100.0);  // API 521 fire scenario\n\n// Run transient\nwhile (!vessel.isBlowdownComplete()) {\n    vessel.runTransient(dt, uuid);\n}\n\n// Results\ndouble tMin = vessel.getMinimumWallTemperatureReached();\nMap&lt;String, String&gt; risks = vessel.assessFlowAssuranceRisks();\n\n// Export\nvessel.exportResultsToCSV(filename);\nvessel.exportResultsToJSON(filename);\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#safetyenvelopecalculator","title":"SafetyEnvelopeCalculator","text":"<pre><code>SafetyEnvelopeCalculator calc = new SafetyEnvelopeCalculator(fluid);\n\n// Individual envelopes\nSafetyEnvelope hydrate = calc.calculateHydrateEnvelope(pMin, pMax, nPoints);\nSafetyEnvelope wax = calc.calculateWaxEnvelope(pMin, pMax, nPoints);\nSafetyEnvelope co2 = calc.calculateCO2FreezingEnvelope(pMin, pMax, nPoints);\nSafetyEnvelope mdmt = calc.calculateMDMTEnvelope(pMin, pMax, designT, nPoints);\n\n// Combined\nSafetyEnvelope[] all = calc.calculateAllEnvelopes(pMin, pMax, nPoints);\n\n// Safety checks\nboolean safe = hydrate.isOperatingPointSafe(P, T);\ndouble margin = hydrate.calculateMarginToLimit(P, T);\n\n// Export for DCS/historian\nhydrate.exportToCSV(filename);\nhydrate.exportToPIFormat(filename);\nhydrate.exportToSeeq(filename);\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#riskmodel","title":"RiskModel","text":"<pre><code>RiskModel model = new RiskModel(\"HP Separator Study\");\nmodel.setRandomSeed(42);\n\n// Add events with OREDA-style frequencies\nmodel.addInitiatingEvent(\"Small Leak\", 1e-3, ConsequenceCategory.MINOR);\nmodel.addInitiatingEvent(\"Medium Leak\", 1e-4, ConsequenceCategory.MODERATE);\nmodel.addInitiatingEvent(\"Large Rupture\", 1e-5, ConsequenceCategory.MAJOR);\n\n// Event tree branching\nRiskEvent leakEvent = model.getEvent(\"Small Leak\");\nRiskEvent fireEvent = RiskEvent.builder()\n    .name(\"Fire on Leak\")\n    .parentEvent(leakEvent)\n    .conditionalProbability(0.1)\n    .consequenceCategory(ConsequenceCategory.MAJOR)\n    .build();\nmodel.addEvent(fireEvent);\n\n// Analysis\nRiskResult result = model.runMonteCarloAnalysis(10000);\nSensitivityResult sensitivity = model.runSensitivityAnalysis(0.1, 10.0);\n\n// Export\nresult.exportToCSV(filename);\nresult.exportToJSON(filename);\nsensitivity.exportToCSV(filename);\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#6-quality-controls-for-qra-credibility","title":"6. Quality Controls for QRA Credibility","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#clear-assumptions-documentation","title":"Clear Assumptions Documentation","text":"Assumption Options Default Impact Expansion type Isenthalpic / Isentropic Isenthalpic Temperature at release Flash type Equilibrium / Non-equilibrium Equilibrium Phase split accuracy Two-phase model HEM / Slip HEM Mass flow rate Discharge coefficient 0.6 - 0.85 0.62 Mass flow rate"},{"location":"integration/QRA_INTEGRATION_GUIDE/#validation-cases","title":"Validation Cases","text":"<p>NeqSim source terms should be validated against:</p> <ol> <li>PHAST source term comparison for selected fluids</li> <li>API 520 / ISO 4126 critical flow for gas-only sanity checks</li> <li>Experimental data where available</li> </ol> <p>Example validation test:</p> <pre><code>@Test\nvoid validateAgainstAPI520() {\n    // Methane at 100 bara, 300 K through 25mm hole\n    SystemInterface methane = new SystemSrkEos(300.0, 100.0);\n    methane.addComponent(\"methane\", 1.0);\n    methane.setMixingRule(\"classic\");\n\n    LeakModel leak = LeakModel.builder()\n        .fluid(methane)\n        .holeDiameter(25.0, \"mm\")\n        .dischargeCoefficient(0.62)\n        .build();\n\n    double mdot = leak.calculateMassFlowRate();\n\n    // API 520 correlation for comparison\n    double mdotAPI520 = calculateAPI520CriticalFlow(methane, 0.025);\n\n    // Should agree within 5%\n    assertEquals(mdotAPI520, mdot, mdotAPI520 * 0.05);\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#sensitivity-ranges","title":"Sensitivity Ranges","text":"<p>Document sensitivity of results to:</p> Parameter Typical Range Sensitivity Discharge coefficient (Cd) 0.6 - 0.85 \u00b120% on mass flow Hole diameter \u00b110% \u00b121% on mass flow Upstream P uncertainty \u00b15% \u00b15% on mass flow Upstream T uncertainty \u00b15 K \u00b12% on mass flow Composition uncertainty \u00b15% per component Varies"},{"location":"integration/QRA_INTEGRATION_GUIDE/#7-end-to-end-example-workflow","title":"7. End-to-End Example Workflow","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#automated-qra-source-term-generation","title":"Automated QRA Source Term Generation","text":"<pre><code>import neqsim.process.safety.release.*;\nimport neqsim.process.safety.risk.*;\nimport java.util.*;\n\npublic class QRASourceTermGenerator {\n\n    // Standard hole sizes per NORSOK Z-013 / company practice\n    private static final double[] HOLE_SIZES_MM = {5.0, 25.0, 100.0};\n    private static final String[] SIZE_NAMES = {\"Small\", \"Medium\", \"Large\"};\n\n    public void generateSourceTerms(SystemInterface fluid, String nodeId) {\n        List&lt;SourceTermResult&gt; results = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; HOLE_SIZES_MM.length; i++) {\n            LeakModel leak = LeakModel.builder()\n                .fluid(fluid)\n                .holeDiameter(HOLE_SIZES_MM[i], \"mm\")\n                .dischargeCoefficient(0.62)\n                .vesselVolume(10.0)\n                .scenarioName(SIZE_NAMES[i] + \" Leak - \" + nodeId)\n                .build();\n\n            SourceTermResult result = leak.calculateSourceTerm(600.0, 1.0);\n            results.add(result);\n\n            // Export for each consequence tool\n            String baseName = nodeId + \"_\" + SIZE_NAMES[i].toLowerCase();\n            result.exportToPHAST(baseName + \"_phast.csv\");\n            result.exportToFLACS(baseName + \"_flacs.csv\");\n            result.exportToJSON(baseName + \".json\");\n        }\n\n        // Generate rupture case\n        VesselDepressurization rupture = createRuptureCase(fluid, nodeId);\n        rupture.exportResultsToCSV(nodeId + \"_rupture.csv\");\n\n        // Generate summary documentation\n        generateDocumentation(results, nodeId);\n    }\n\n    private void generateDocumentation(List&lt;SourceTermResult&gt; results, String nodeId) {\n        StringBuilder doc = new StringBuilder();\n        doc.append(\"# Source Term Summary - \").append(nodeId).append(\"\\n\\n\");\n        doc.append(\"| Scenario | Hole (mm) | mdot (kg/s) | T_rel (K) | Phase |\\n\");\n        doc.append(\"|----------|-----------|-------------|-----------|-------|\\n\");\n\n        for (int i = 0; i &lt; results.size(); i++) {\n            SourceTermResult r = results.get(i);\n            doc.append(String.format(\"| %s | %.0f | %.2f | %.1f | %s |\\n\",\n                SIZE_NAMES[i], HOLE_SIZES_MM[i],\n                r.getMassFlowRate()[0], r.getTemperature()[0],\n                r.getVaporFraction()[0] &gt; 0.99 ? \"Gas\" : \"Two-phase\"));\n        }\n\n        // Write to file\n        writeToFile(nodeId + \"_summary.md\", doc.toString());\n    }\n}\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#batch-processing-script","title":"Batch Processing Script","text":"<pre><code>// Process multiple nodes from process model\nList&lt;ProcessNode&gt; nodes = loadProcessNodes(\"plant_model.json\");\n\nQRASourceTermGenerator generator = new QRASourceTermGenerator();\n\nfor (ProcessNode node : nodes) {\n    SystemInterface fluid = node.getFluid();\n    generator.generateSourceTerms(fluid, node.getId());\n}\n\n// Run consequence tool batch\nexecuteConsequenceTool(\"PHAST\", \"output/*.csv\");\n\n// Import to QRA platform\nimportToQRAPlatform(\"Safeti\", \"consequence_results/\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#8-tool-specific-export-formats","title":"8. Tool-Specific Export Formats","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#phast-format","title":"PHAST Format","text":"<pre><code># PHAST Source Term Input\n# Generated by NeqSim\nScenario,HP_SEP_Small_Leak\nHole_Diameter_mm,25.0\nDischarge_Coefficient,0.62\nRelease_Rate_kg_s,5.23\nTemperature_K,285.4\nPressure_barg,0.0\nPhase,Gas\nMolecular_Weight,17.2\nSpecific_Heat_Ratio,1.31\nDuration_s,600.0\nInventory_kg,5000.0\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#flacs-format","title":"FLACS Format","text":"<pre><code>! FLACS Source Term Definition\n! Generated by NeqSim\n&amp;SOURCE\n  NAME = 'HP_SEP_Leak'\n  TYPE = 'JET'\n  POSITION = 10.0, 5.0, 2.0\n  DIRECTION = 1.0, 0.0, 0.0\n  DIAMETER = 0.025\n  MASS_FLOW = 5.23\n  TEMPERATURE = 285.4\n  VELOCITY = 412.5\n  SPECIES = 'METHANE'\n  DURATION = 600.0\n/\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#kfx-format","title":"KFX Format","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;kfx_source_term&gt;\n  &lt;scenario name=\"HP_SEP_Leak\"&gt;\n    &lt;release_type&gt;jet&lt;/release_type&gt;\n    &lt;position x=\"10.0\" y=\"5.0\" z=\"2.0\"/&gt;\n    &lt;direction dx=\"1.0\" dy=\"0.0\" dz=\"0.0\"/&gt;\n    &lt;mass_flow unit=\"kg/s\"&gt;5.23&lt;/mass_flow&gt;\n    &lt;temperature unit=\"K\"&gt;285.4&lt;/temperature&gt;\n    &lt;phase&gt;gas&lt;/phase&gt;\n    &lt;composition&gt;\n      &lt;species name=\"methane\" fraction=\"0.85\"/&gt;\n      &lt;species name=\"ethane\" fraction=\"0.10\"/&gt;\n      &lt;species name=\"propane\" fraction=\"0.05\"/&gt;\n    &lt;/composition&gt;\n    &lt;duration unit=\"s\"&gt;600.0&lt;/duration&gt;\n  &lt;/scenario&gt;\n&lt;/kfx_source_term&gt;\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#openfoam-format","title":"OpenFOAM Format","text":"<p>Generated files in case directory:</p> <pre><code>0/\n  U           # Velocity boundary conditions\n  T           # Temperature boundary conditions\n  p           # Pressure boundary conditions\n  CH4         # Species mass fraction\nconstant/\n  sourceTerms # Time-varying source definition\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#appendix-common-fluid-templates","title":"Appendix: Common Fluid Templates","text":""},{"location":"integration/QRA_INTEGRATION_GUIDE/#natural-gas-north-sea-typical","title":"Natural Gas (North Sea Typical)","text":"<pre><code>SystemInterface natGas = new SystemSrkEos(300.0, 80.0);\nnatGas.addComponent(\"nitrogen\", 0.01);\nnatGas.addComponent(\"CO2\", 0.02);\nnatGas.addComponent(\"methane\", 0.85);\nnatGas.addComponent(\"ethane\", 0.07);\nnatGas.addComponent(\"propane\", 0.03);\nnatGas.addComponent(\"i-butane\", 0.01);\nnatGas.addComponent(\"n-butane\", 0.01);\nnatGas.setMixingRule(\"classic\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#condensate","title":"Condensate","text":"<pre><code>SystemInterface condensate = new SystemSrkEos(320.0, 50.0);\ncondensate.addComponent(\"methane\", 0.05);\ncondensate.addComponent(\"ethane\", 0.10);\ncondensate.addComponent(\"propane\", 0.15);\ncondensate.addComponent(\"n-butane\", 0.15);\ncondensate.addComponent(\"n-pentane\", 0.20);\ncondensate.addComponent(\"n-hexane\", 0.20);\ncondensate.addComponent(\"n-heptane\", 0.15);\ncondensate.setMixingRule(\"classic\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#co2-rich-stream","title":"CO\u2082 Rich Stream","text":"<pre><code>SystemInterface co2Stream = new SystemSrkEos(310.0, 100.0);\nco2Stream.addComponent(\"CO2\", 0.95);\nco2Stream.addComponent(\"methane\", 0.03);\nco2Stream.addComponent(\"nitrogen\", 0.02);\nco2Stream.setMixingRule(\"classic\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#sour-gas-h2s","title":"Sour Gas (H\u2082S)","text":"<pre><code>SystemInterface sourGas = new SystemSrkEos(300.0, 60.0);\nsourGas.addComponent(\"methane\", 0.80);\nsourGas.addComponent(\"H2S\", 0.05);\nsourGas.addComponent(\"CO2\", 0.10);\nsourGas.addComponent(\"ethane\", 0.05);\nsourGas.setMixingRule(\"classic\");\n</code></pre>"},{"location":"integration/QRA_INTEGRATION_GUIDE/#references","title":"References","text":"<ul> <li>API 520: Sizing, Selection, and Installation of Pressure-Relieving Devices</li> <li>API 521: Pressure-relieving and Depressuring Systems</li> <li>NORSOK Z-013: Risk and emergency preparedness assessment</li> <li>ISO 4126: Safety devices for protection against excessive pressure</li> <li>DNV-RP-C208: Determination of structural capacity by non-linear FE analysis methods</li> <li>OGP Risk Assessment Data Directory (RADD)</li> </ul> <p>Document generated for NeqSim version 3.x Last updated: December 2024</p>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/","title":"NeqSim Real-Time Digitalization Integration Guide","text":""},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#overview","title":"Overview","text":"<p>This guide shows how to integrate NeqSim process simulations with your existing digitalization ecosystem, including live data feedback, SCADA/PLC interfaces, and historian systems.</p>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#integration-architecture","title":"Integration Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Plant/Field   \u2502    \u2502   Control Layer \u2502    \u2502 NeqSim Digital  \u2502\n\u2502   Instruments   \u2502\u25c4\u2500\u2500\u25ba\u2502   (PLC/SCADA)   \u2502\u25c4\u2500\u2500\u25ba\u2502     Twin        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                       \u2502\n         \u25bc                       \u25bc                       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   OPC UA/DA     \u2502    \u2502   PI Historian  \u2502    \u2502   Seeq/Analytics\u2502\n\u2502   Real-time     \u2502    \u2502   Time-series   \u2502    \u2502   Advanced      \u2502\n\u2502   Data Exchange \u2502    \u2502   Data Storage  \u2502    \u2502   Analytics     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#key-integration-points","title":"Key Integration Points","text":""},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#1-opc-uada-integration","title":"1. OPC UA/DA Integration","text":"<p>Connect to PLCs and SCADA systems for real-time data exchange:</p> <pre><code>// Subscribe to live plant data\nopcClient.subscribe(\"PLC.PI_101.Value\", this::updatePressureReading);\nopcClient.subscribe(\"PLC.TI_101.Value\", this::updateTemperatureReading);\n\n// Send predicted values back to control system\nopcClient.writeValue(\"PLC.PI_101.Predicted\", simulatedPressure);\n</code></pre> <p>Benefits: - Real-time model validation against plant data - Predictive control optimization - What-if scenario analysis with live conditions</p>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#2-piosisoft-historian-integration","title":"2. PI/OSIsoft Historian Integration","text":"<p>Store both actual and simulated values for analytics:</p> <pre><code>// Configure tags for both actual and simulated data\npiHistorian.configureTag(\"PLANT.V101.Pressure.Actual\", \"PI-101\");\npiHistorian.configureTag(\"NEQSIM.V101.Pressure.Simulated\", \"PI-101\");\n\n// Write comparison data\npiHistorian.writeValue(\"PLANT.V101.Pressure.Actual\", actualValue);\npiHistorian.writeValue(\"NEQSIM.V101.Pressure.Simulated\", simulatedValue);\n</code></pre> <p>Analytics Opportunities: - Model accuracy trending - Equipment performance degradation detection - Energy optimization opportunities - Maintenance planning support</p>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#3-scadadcs-integration","title":"3. SCADA/DCS Integration","text":"<p>Integrate with control room displays and alarm systems:</p> <pre><code>// Register process alarms\nscadaInterface.registerAlarm(\"HIGH_PRESSURE\", 55.0, this::triggerHighPressureAlarm);\n\n// Update operator displays with predictions\nscadaInterface.updateTrends(processSystem);\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#4-seeq-integration-pattern","title":"4. Seeq Integration Pattern","text":"<p>For advanced analytics and investigation:</p> <pre><code>public class SeeqIntegration {\n\n  public void publishAdvancedAnalytics() {\n    // Equipment efficiency calculations\n    double efficiency = calculateSeparatorEfficiency();\n    seeqClient.writeCalculation(\"V101.Efficiency\", efficiency);\n\n    // Energy optimization metrics\n    double energyIntensity = calculateEnergyIntensity();\n    seeqClient.writeCalculation(\"Process.EnergyIntensity\", energyIntensity);\n\n    // Predictive maintenance indicators\n    double foulingIndex = calculateFoulingIndex();\n    seeqClient.writeCalculation(\"V101.FoulingIndex\", foulingIndex);\n  }\n}\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#digital-twin-pattern","title":"Digital Twin Pattern","text":"<pre><code>public class ProcessDigitalTwin {\n  private ProcessSystem physicalModel;\n  private DataReconciliation reconciler;\n  private PredictiveController controller;\n\n  public void synchronizeWithPlant() {\n    // 1. Get live plant data\n    Map&lt;String, Double&gt; plantData = opcClient.readAllTags();\n\n    // 2. Update simulation with current conditions\n    updateModelWithPlantData(plantData);\n\n    // 3. Run simulation\n    physicalModel.run();\n\n    // 4. Compare predictions with reality\n    reconciler.validatePredictions(plantData);\n\n    // 5. Adjust model if needed\n    if (reconciler.hasSignificantDeviation()) {\n      reconciler.adjustModelParameters();\n    }\n\n    // 6. Generate predictions for control system\n    controller.generateOptimalSetpoints();\n  }\n}\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#model-predictive-control-integration","title":"Model Predictive Control Integration","text":"<pre><code>public class MPCIntegration {\n\n  public void optimizeControlActions() {\n    // Run multiple scenarios with NeqSim\n    List&lt;ProcessSafetyScenario&gt; scenarios = generateControlScenarios();\n\n    for (ProcessSafetyScenario scenario : scenarios) {\n      ScenarioExecutionSummary result = runner.runScenario(\n          scenario.getName(), scenario, 30.0, 1.0\n      );\n\n      // Evaluate economic objective function\n      double profit = calculateProfit(result);\n      double safety = evaluateSafetyMargins(result);\n      double emissions = calculateEmissions(result);\n\n      // Multi-objective optimization\n      double objectiveFunction = profit - safety_penalty - emissions_cost;\n\n      if (objectiveFunction &gt; bestObjective) {\n        bestControlActions = extractControlActions(scenario);\n      }\n    }\n\n    // Send optimal setpoints to control system\n    opcClient.writeValue(\"PLC.PV_101.Setpoint\", bestControlActions.valveOpening);\n  }\n}\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#real-time-optimization","title":"Real-Time Optimization","text":"<pre><code>public class RealTimeOptimizer {\n\n  public void continuousOptimization() {\n    while (true) {\n      try {\n        // 1. Get current plant state\n        ProcessState currentState = getCurrentPlantState();\n\n        // 2. Update NeqSim model\n        updateSimulationModel(currentState);\n\n        // 3. Run optimization scenarios\n        OptimizationResult optimal = findOptimalOperatingPoint();\n\n        // 4. Check if changes are beneficial\n        if (optimal.improvementPercent &gt; 2.0) {\n          // Send new setpoints to control system\n          implementOptimalSetpoints(optimal);\n\n          // Log optimization action\n          piHistorian.writeEvent(\"NEQSIM.Optimization\", \n              \"Improvement: \" + optimal.improvementPercent + \"%\");\n        }\n\n        Thread.sleep(60000); // Optimize every minute\n\n      } catch (Exception e) {\n        handleOptimizationError(e);\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#technology-stack-recommendations","title":"Technology Stack Recommendations","text":""},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#opc-connectivity","title":"OPC Connectivity","text":"<pre><code>&lt;!-- Eclipse Milo OPC UA Client --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.eclipse.milo&lt;/groupId&gt;\n    &lt;artifactId&gt;sdk-client&lt;/artifactId&gt;\n    &lt;version&gt;0.6.8&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#pi-system-integration","title":"PI System Integration","text":"<pre><code>&lt;!-- OSIsoft PI SDK (commercial license required) --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.osisoft&lt;/groupId&gt;\n    &lt;artifactId&gt;pi-web-api-client&lt;/artifactId&gt;\n    &lt;version&gt;1.13.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#mqtt-for-iot-integration","title":"MQTT for IoT Integration","text":"<pre><code>&lt;!-- Eclipse Paho MQTT Client --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.eclipse.paho&lt;/groupId&gt;\n    &lt;artifactId&gt;org.eclipse.paho.client.mqttv3&lt;/artifactId&gt;\n    &lt;version&gt;1.2.5&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#rest-api-integration","title":"REST API Integration","text":"<pre><code>&lt;!-- Spring Boot for REST APIs --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;version&gt;3.2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#data-flow-examples","title":"Data Flow Examples","text":""},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#1-live-process-monitoring","title":"1. Live Process Monitoring","text":"<pre><code>Plant Sensors \u2192 PLC \u2192 OPC Server \u2192 NeqSim \u2192 Model Validation \u2192 PI Historian\n                                         \u2193\n                                   Alarm Generation \u2192 SCADA Display\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#2-predictive-control","title":"2. Predictive Control","text":"<pre><code>Current State \u2192 NeqSim Scenarios \u2192 Optimization \u2192 Setpoint Updates \u2192 PLC\n                      \u2193\n               Performance Metrics \u2192 Seeq Analytics \u2192 KPI Dashboard\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#3-equipment-health-monitoring","title":"3. Equipment Health Monitoring","text":"<pre><code>Process Data \u2192 NeqSim Physics Model \u2192 Fouling Detection \u2192 Maintenance Alert\n                                               \u2193\n                                     Work Order System \u2192 CMMS\n</code></pre>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#benefits-of-integration","title":"Benefits of Integration","text":""},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#operational-excellence","title":"Operational Excellence","text":"<ul> <li>Real-time optimization: 2-5% efficiency improvements</li> <li>Predictive maintenance: 20-30% reduction in unplanned downtime  </li> <li>Energy optimization: 3-8% energy savings</li> <li>Quality prediction: Reduced off-spec production</li> </ul>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#safety-compliance","title":"Safety &amp; Compliance","text":"<ul> <li>What-if analysis: Evaluate scenarios before implementation</li> <li>Alarm rationalization: Physics-based alarm limits</li> <li>Emergency response: Validated emergency procedures</li> <li>Environmental compliance: Emissions prediction and control</li> </ul>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#digital-twin-capabilities","title":"Digital Twin Capabilities","text":"<ul> <li>Virtual sensors: Estimate unmeasured variables</li> <li>Model reconciliation: Automatic parameter adjustment</li> <li>Scenario planning: Test operational changes safely</li> <li>Training simulator: Operator training with real plant data</li> </ul>"},{"location":"integration/REAL_TIME_INTEGRATION_GUIDE/#getting-started","title":"Getting Started","text":"<ol> <li>Start Small: Begin with one unit operation and a few measurement points</li> <li>Validate Models: Ensure NeqSim predictions match plant performance</li> <li>Implement Gradually: Add more integration points as confidence builds</li> <li>Monitor Benefits: Track KPIs to demonstrate value</li> </ol> <p>The integration patterns shown here transform NeqSim from a standalone simulation tool into a live digital twin that continuously optimizes your process operations.</p>"},{"location":"integration/ai_platform_integration/","title":"AI Platform Integration Guide","text":"<p>This document describes the NeqSim extensions designed for integration with AI-based production optimization platforms and real-time digital twin systems.</p>"},{"location":"integration/ai_platform_integration/#overview","title":"Overview","text":"<p>Modern AI-based production optimization platforms typically require: - High-frequency data streaming (millions of data points per hour) - Hybrid physics-ML models combining first-principles with machine learning - Virtual Flow Meters (VFM) and soft sensors - Continuous auto-calibration for digital twin accuracy - Uncertainty quantification for risk-aware optimization - Well production allocation for reservoir management</p> <p>NeqSim provides dedicated packages to support these requirements.</p>"},{"location":"integration/ai_platform_integration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Streaming Data</li> <li>Virtual Flow Meters</li> <li>Soft Sensors</li> <li>Uncertainty Quantification</li> <li>ML Integration</li> <li>Online Calibration</li> <li>Well Allocation</li> <li>Event System</li> <li>Data Export</li> </ol>"},{"location":"integration/ai_platform_integration/#streaming-data","title":"Streaming Data","text":"<p>Package: <code>neqsim.process.streaming</code></p> <p>The streaming package enables real-time data publishing from NeqSim simulations to external platforms.</p>"},{"location":"integration/ai_platform_integration/#key-classes","title":"Key Classes","text":""},{"location":"integration/ai_platform_integration/#timestampedvalue","title":"TimestampedValue","text":"<p>Represents a value with timestamp, unit, and quality indicator.</p> <pre><code>import neqsim.process.streaming.TimestampedValue;\n\n// Create a timestamped value\nTimestampedValue value = new TimestampedValue(\n    100.5,                          // value\n    \"bara\",                         // unit\n    Instant.now(),                  // timestamp\n    TimestampedValue.Quality.GOOD   // quality\n);\n\n// Access properties\ndouble val = value.getValue();\nString unit = value.getUnit();\nInstant ts = value.getTimestamp();\nTimestampedValue.Quality quality = value.getQuality();\n</code></pre> <p>Quality Levels: - <code>GOOD</code> - Normal measurement - <code>UNCERTAIN</code> - Measurement with degraded confidence - <code>BAD</code> - Invalid or failed measurement - <code>SIMULATED</code> - Value from simulation - <code>ESTIMATED</code> - Interpolated or estimated value</p>"},{"location":"integration/ai_platform_integration/#processdatapublisher","title":"ProcessDataPublisher","text":"<p>Publishes process data from a ProcessSystem with subscription support.</p> <pre><code>import neqsim.process.streaming.ProcessDataPublisher;\nimport neqsim.process.processmodel.ProcessSystem;\n\n// Create publisher linked to process system\nProcessSystem process = new ProcessSystem();\n// ... add equipment ...\nProcessDataPublisher publisher = new ProcessDataPublisher(process);\n\n// Subscribe to updates\npublisher.subscribeToUpdates(\"Inlet.pressure\", value -&gt; {\n    System.out.println(\"Pressure: \" + value.getValue() + \" \" + value.getUnit());\n});\n\n// Publish current state\npublisher.publishFromProcessSystem();\n\n// Get state vector for ML models\ndouble[] stateVector = publisher.getStateVector();\n</code></pre>"},{"location":"integration/ai_platform_integration/#streamingdatainterface","title":"StreamingDataInterface","text":"<p>Interface for custom streaming implementations:</p> <pre><code>public interface StreamingDataInterface {\n    void subscribeToUpdates(String tagId, Consumer&lt;TimestampedValue&gt; callback);\n    void publishBatch(Map&lt;String, TimestampedValue&gt; values);\n    double[] getStateVector();\n    List&lt;TimestampedValue&gt; getHistory(String tagId, Duration period);\n}\n</code></pre>"},{"location":"integration/ai_platform_integration/#virtual-flow-meters","title":"Virtual Flow Meters","text":"<p>Package: <code>neqsim.process.measurementdevice.vfm</code></p> <p>Virtual Flow Meters calculate multiphase flow rates using thermodynamic models when physical meters are unavailable or unreliable.</p>"},{"location":"integration/ai_platform_integration/#virtualflowmeter","title":"VirtualFlowMeter","text":"<pre><code>import neqsim.process.measurementdevice.vfm.VirtualFlowMeter;\nimport neqsim.process.measurementdevice.vfm.VFMResult;\n\n// Create VFM from a stream\nStreamInterface wellStream = new Stream(\"Well-A\", fluid);\nwellStream.run();\n\nVirtualFlowMeter vfm = new VirtualFlowMeter(\"VFM-Well-A\", wellStream);\n\n// Calculate flow rates with uncertainty\nVFMResult result = vfm.calculate();\n\n// Access results\ndouble gasRate = result.getGasFlowRate();      // Sm3/day\ndouble oilRate = result.getOilFlowRate();      // Sm3/day\ndouble waterRate = result.getWaterFlowRate();  // Sm3/day\ndouble gor = result.getGOR();                  // Sm3/Sm3\ndouble waterCut = result.getWaterCut();        // fraction\n\n// Get uncertainties\nUncertaintyBounds gasUncertainty = result.getGasFlowRateUncertainty();\ndouble lower95 = gasUncertainty.getLower95();\ndouble upper95 = gasUncertainty.getUpper95();\n</code></pre>"},{"location":"integration/ai_platform_integration/#calibration","title":"Calibration","text":"<p>VFMs can be calibrated using well test data:</p> <pre><code>// Create calibration from well test\nVFMCalibration calibration = new VFMCalibration();\ncalibration.setWellTestGasRate(50000);   // Sm3/day\ncalibration.setWellTestOilRate(500);     // Sm3/day\ncalibration.setWellTestWaterRate(100);   // Sm3/day\ncalibration.setWellTestDate(Instant.now());\n\nvfm.setCalibration(calibration);\n</code></pre>"},{"location":"integration/ai_platform_integration/#vfmresult-builder","title":"VFMResult Builder","text":"<pre><code>VFMResult result = VFMResult.builder()\n    .gasFlowRate(45000)\n    .oilFlowRate(450)\n    .waterFlowRate(95)\n    .gasFlowRateUncertainty(new UncertaintyBounds(42000, 48000, 2000))\n    .timestamp(Instant.now())\n    .quality(VFMResult.Quality.GOOD)\n    .build();\n</code></pre>"},{"location":"integration/ai_platform_integration/#soft-sensors","title":"Soft Sensors","text":"<p>Package: <code>neqsim.process.measurementdevice.vfm</code></p> <p>Soft sensors estimate unmeasured properties from available measurements using thermodynamic models.</p>"},{"location":"integration/ai_platform_integration/#softsensor","title":"SoftSensor","text":"<pre><code>import neqsim.process.measurementdevice.vfm.SoftSensor;\n\n// Create soft sensor for GOR estimation\nSoftSensor gorSensor = new SoftSensor(\"GOR-Sensor\", stream, SoftSensor.PropertyType.GOR);\n\n// Get estimated value\ndouble gor = gorSensor.getMeasuredValue();\nString unit = gorSensor.getUnit();\n\n// Get sensitivity to input changes\ndouble sensitivity = gorSensor.getSensitivity(\"pressure\");\n</code></pre> <p>Available Property Types: - <code>GOR</code> - Gas-Oil Ratio - <code>WATER_CUT</code> - Water Cut - <code>DENSITY</code> - Fluid Density - <code>VISCOSITY</code> - Dynamic Viscosity - <code>MOLECULAR_WEIGHT</code> - Molecular Weight - <code>Z_FACTOR</code> - Compressibility Factor - <code>ENTHALPY</code> - Specific Enthalpy - <code>ENTROPY</code> - Specific Entropy - <code>HEAT_CAPACITY</code> - Heat Capacity</p>"},{"location":"integration/ai_platform_integration/#uncertainty-quantification","title":"Uncertainty Quantification","text":"<p>Package: <code>neqsim.process.util.uncertainty</code></p> <p>Propagates measurement uncertainties through thermodynamic calculations.</p>"},{"location":"integration/ai_platform_integration/#uncertaintyanalyzer","title":"UncertaintyAnalyzer","text":"<pre><code>import neqsim.process.util.uncertainty.UncertaintyAnalyzer;\nimport neqsim.process.util.uncertainty.UncertaintyResult;\n\n// Create analyzer for a process system\nProcessSystem process = new ProcessSystem();\n// ... configure process ...\n\nUncertaintyAnalyzer analyzer = new UncertaintyAnalyzer(process);\n\n// Define input uncertainties (relative)\nanalyzer.setInputUncertainty(\"inlet_pressure\", 0.01);      // 1%\nanalyzer.setInputUncertainty(\"inlet_temperature\", 0.005);  // 0.5%\nanalyzer.setInputUncertainty(\"inlet_flowrate\", 0.02);      // 2%\n\n// Perform analytical (linear) uncertainty propagation\nUncertaintyResult result = analyzer.analyzeAnalytical();\n\n// Get output uncertainties\nMap&lt;String, Double&gt; outputUncertainties = result.getOutputUncertainties();\n\n// Get sensitivity matrix\nSensitivityMatrix sensMatrix = result.getSensitivityMatrix();\ndouble dP_dT = sensMatrix.getSensitivity(\"outlet_pressure\", \"inlet_temperature\");\n</code></pre>"},{"location":"integration/ai_platform_integration/#monte-carlo-analysis","title":"Monte Carlo Analysis","text":"<p>For nonlinear systems, use Monte Carlo:</p> <pre><code>// Configure Monte Carlo\nanalyzer.setMonteCarloSamples(10000);\n\n// Run Monte Carlo uncertainty propagation\nUncertaintyResult mcResult = analyzer.analyzeMonteCarlo(1000);\n\n// Get percentiles\ndouble p05 = mcResult.getPercentile(\"outlet_pressure\", 0.05);\ndouble p95 = mcResult.getPercentile(\"outlet_pressure\", 0.95);\n</code></pre>"},{"location":"integration/ai_platform_integration/#sensitivitymatrix","title":"SensitivityMatrix","text":"<pre><code>import neqsim.process.util.uncertainty.SensitivityMatrix;\n\n// Get Jacobian matrix\nSensitivityMatrix matrix = new SensitivityMatrix(inputNames, outputNames);\n\n// Calculate sensitivities via finite differences\nfor (String input : inputNames) {\n    for (String output : outputNames) {\n        double sensitivity = calculateNumericalDerivative(input, output);\n        matrix.setSensitivity(output, input, sensitivity);\n    }\n}\n\n// Propagate input variances to output variances\nMap&lt;String, Double&gt; inputVariances = Map.of(\"pressure\", 0.01, \"temperature\", 0.0025);\nMap&lt;String, Double&gt; outputVariances = matrix.propagateUncertainty(inputVariances);\n</code></pre>"},{"location":"integration/ai_platform_integration/#ml-integration","title":"ML Integration","text":"<p>Package: <code>neqsim.process.integration.ml</code></p> <p>Interfaces for combining physics models with machine learning corrections.</p>"},{"location":"integration/ai_platform_integration/#hybridmodeladapter","title":"HybridModelAdapter","text":"<p>Wraps a NeqSim model with ML corrections:</p> <pre><code>import neqsim.process.integration.ml.HybridModelAdapter;\nimport neqsim.process.integration.ml.MLCorrectionInterface;\n\n// Create hybrid adapter\nProcessSystem physicsModel = new ProcessSystem();\n// ... configure model ...\n\nHybridModelAdapter hybrid = new HybridModelAdapter(physicsModel);\n\n// Add ML correction (implement MLCorrectionInterface)\nMLCorrectionInterface mlCorrection = new MyNeuralNetworkCorrection();\nhybrid.setCorrection(mlCorrection);\n\n// Set combination strategy\nhybrid.setCombinationStrategy(HybridModelAdapter.CombinationStrategy.ADDITIVE);\n\n// Run hybrid model\nhybrid.run();\n\n// Get corrected outputs\ndouble correctedPressure = hybrid.getCorrectedOutput(\"outlet_pressure\");\n</code></pre> <p>Combination Strategies: - <code>ADDITIVE</code> - Output = Physics + ML_Correction - <code>MULTIPLICATIVE</code> - Output = Physics \u00d7 ML_Factor - <code>REPLACEMENT</code> - Output = ML (physics as feature) - <code>WEIGHTED_AVERAGE</code> - Output = w \u00d7 Physics + (1-w) \u00d7 ML</p>"},{"location":"integration/ai_platform_integration/#mlcorrectioninterface","title":"MLCorrectionInterface","text":"<p>Implement this interface to connect external ML models:</p> <pre><code>public interface MLCorrectionInterface {\n    // Get correction for a specific output\n    double getCorrection(String outputName, Map&lt;String, Double&gt; inputs);\n\n    // Update model with new training data\n    void update(Map&lt;String, Double&gt; inputs, Map&lt;String, Double&gt; targets);\n\n    // Get model confidence (0-1)\n    double getConfidence();\n}\n</code></pre>"},{"location":"integration/ai_platform_integration/#featureextractor","title":"FeatureExtractor","text":"<p>Extract features from streams for ML models:</p> <pre><code>import neqsim.process.integration.ml.FeatureExtractor;\n\n// Create feature extractor\nFeatureExtractor extractor = new FeatureExtractor();\n\n// Extract features from a stream\nStreamInterface stream = process.getStream(\"inlet\");\ndouble[] features = extractor.extractFeatures(stream);\n\n// Get feature names\nString[] featureNames = extractor.getFeatureNames();\n\n// Normalize features\ndouble[] normalized = extractor.normalize(features);\n</code></pre>"},{"location":"integration/ai_platform_integration/#online-calibration","title":"Online Calibration","text":"<p>Package: <code>neqsim.process.calibration</code></p> <p>Continuously calibrates models using real-time data.</p>"},{"location":"integration/ai_platform_integration/#onlinecalibrator","title":"OnlineCalibrator","text":"<pre><code>import neqsim.process.calibration.OnlineCalibrator;\nimport neqsim.process.calibration.CalibrationResult;\nimport neqsim.process.calibration.CalibrationQuality;\n\n// Create calibrator for a process system\nProcessSystem process = new ProcessSystem();\nOnlineCalibrator calibrator = new OnlineCalibrator(process);\n\n// Configure tunable parameters\ncalibrator.setTunableParameters(Arrays.asList(\n    \"separator_efficiency\",\n    \"heat_exchanger_UA\",\n    \"compressor_polytropic_efficiency\"\n));\n\n// Set deviation threshold for triggering recalibration\ncalibrator.setDeviationThreshold(0.1);  // 10%\n\n// Record measurements and predictions\nMap&lt;String, Double&gt; measurements = Map.of(\n    \"outlet_pressure\", 45.2,\n    \"outlet_temperature\", 35.5\n);\nMap&lt;String, Double&gt; predictions = Map.of(\n    \"outlet_pressure\", 44.8,\n    \"outlet_temperature\", 36.1\n);\n\n// Check if recalibration is needed\nboolean needsRecalibration = calibrator.recordDataPoint(measurements, predictions);\n\n// Perform incremental update (fast, for real-time)\nCalibrationResult incrementalResult = calibrator.incrementalUpdate(measurements, predictions);\n\n// Or perform full recalibration (thorough, periodic)\nCalibrationResult fullResult = calibrator.fullRecalibration();\n\n// Check calibration quality\nCalibrationQuality quality = calibrator.getQualityMetrics();\nSystem.out.println(\"Quality Score: \" + quality.getOverallScore());\nSystem.out.println(\"Rating: \" + quality.getRating());\nSystem.out.println(\"Needs Recalibration: \" + quality.needsRecalibration());\n</code></pre>"},{"location":"integration/ai_platform_integration/#calibrationresult","title":"CalibrationResult","text":"<pre><code>CalibrationResult result = calibrator.fullRecalibration();\n\nif (result.isSuccessful()) {\n    Map&lt;String, Double&gt; params = result.getCalibratedParameters();\n    double improvement = result.getImprovementPercent();\n    System.out.println(\"Improved by \" + improvement + \"%\");\n}\n</code></pre>"},{"location":"integration/ai_platform_integration/#calibrationquality","title":"CalibrationQuality","text":"<pre><code>CalibrationQuality quality = calibrator.getQualityMetrics();\n\n// Metrics\ndouble rmse = quality.getRootMeanSquareError();\ndouble r2 = quality.getR2Score();\nint samples = quality.getSampleCount();\ndouble coverage = quality.getCoveragePercent();\n\n// Overall assessment\ndouble score = quality.getOverallScore();  // 0-100\nCalibrationQuality.Rating rating = quality.getRating();  // EXCELLENT, GOOD, FAIR, POOR\n\n// Check calibration age\nDuration age = quality.getCalibrationAge();\n</code></pre>"},{"location":"integration/ai_platform_integration/#well-allocation","title":"Well Allocation","text":"<p>Package: <code>neqsim.process.equipment.well.allocation</code></p> <p>Allocates commingled production back to individual wells.</p>"},{"location":"integration/ai_platform_integration/#wellproductionallocator","title":"WellProductionAllocator","text":"<pre><code>import neqsim.process.equipment.well.allocation.WellProductionAllocator;\nimport neqsim.process.equipment.well.allocation.AllocationResult;\n\n// Create allocator\nWellProductionAllocator allocator = new WellProductionAllocator(\"Field-A-Allocation\");\n\n// Add wells with test data\nWellProductionAllocator.WellData wellA = allocator.addWell(\"Well-A\");\nwellA.setTestRates(500, 50000, 100);  // oil, gas, water (Sm3/day)\nwellA.setVFMRates(480, 48000, 95);\nwellA.setChokePosition(0.75);\nwellA.setProductivityIndex(10.0);\nwellA.setReservoirPressure(250);\n\nWellProductionAllocator.WellData wellB = allocator.addWell(\"Well-B\");\nwellB.setTestRates(300, 30000, 200);\nwellB.setVFMRates(290, 29000, 195);\nwellB.setChokePosition(0.60);\nwellB.setProductivityIndex(8.0);\nwellB.setReservoirPressure(245);\n\n// Set allocation method\nallocator.setAllocationMethod(WellProductionAllocator.AllocationMethod.VFM_BASED);\n\n// Allocate total production\nAllocationResult result = allocator.allocate(\n    780,   // total oil (Sm3/day)\n    78000, // total gas (Sm3/day)\n    290    // total water (Sm3/day)\n);\n\n// Get allocated rates per well\ndouble wellAOil = result.getOilRate(\"Well-A\");\ndouble wellAGas = result.getGasRate(\"Well-A\");\ndouble wellAGOR = result.getGOR(\"Well-A\");\ndouble wellAWC = result.getWaterCut(\"Well-A\");\ndouble uncertainty = result.getUncertainty(\"Well-A\");\n\n// Check allocation balance\nboolean balanced = result.isBalanced();\ndouble error = result.getAllocationError();\n</code></pre> <p>Allocation Methods: - <code>WELL_TEST</code> - Based on periodic well test data - <code>VFM_BASED</code> - Based on virtual flow meter estimates - <code>CHOKE_MODEL</code> - Based on choke performance curves - <code>COMBINED</code> - Weighted combination of above methods</p>"},{"location":"integration/ai_platform_integration/#event-system","title":"Event System","text":"<p>Package: <code>neqsim.process.util.event</code></p> <p>Publish-subscribe system for process events.</p>"},{"location":"integration/ai_platform_integration/#processeventbus","title":"ProcessEventBus","text":"<pre><code>import neqsim.process.util.event.ProcessEventBus;\nimport neqsim.process.util.event.ProcessEvent;\nimport neqsim.process.util.event.ProcessEventListener;\n\n// Get event bus instance\nProcessEventBus eventBus = ProcessEventBus.getInstance();\n\n// Subscribe to all events\neventBus.subscribe(event -&gt; {\n    System.out.println(\"Event: \" + event.getDescription());\n});\n\n// Subscribe to specific event types\neventBus.subscribe(ProcessEvent.EventType.ALARM, event -&gt; {\n    // Handle alarm\n    sendAlarmNotification(event);\n});\n\n// Publish events\neventBus.publish(ProcessEvent.info(\"Compressor-1\", \"Startup complete\"));\neventBus.publish(ProcessEvent.warning(\"Separator-1\", \"Level approaching high limit\"));\neventBus.publish(ProcessEvent.alarm(\"Valve-V101\", \"Emergency shutdown activated\"));\n\n// Publish threshold crossing\neventBus.publish(ProcessEvent.thresholdCrossed(\n    \"Pressure-PT101\", \"pressure\", 52.5, 50.0, true  // value, threshold, above\n));\n\n// Publish model deviation\neventBus.publish(ProcessEvent.modelDeviation(\n    \"VFM-Well-A\", \"gas_rate\", 48500, 50000  // measured, predicted\n));\n</code></pre>"},{"location":"integration/ai_platform_integration/#processevent-properties","title":"ProcessEvent Properties","text":"<pre><code>ProcessEvent event = ProcessEvent.alarm(\"Source\", \"Description\");\n\n// Set custom properties\nevent.setProperty(\"priority\", 1);\nevent.setProperty(\"acknowledged\", false);\nevent.setProperty(\"operator\", \"John\");\n\n// Get properties\nint priority = event.getProperty(\"priority\", Integer.class);\n\n// Standard properties\nString eventId = event.getEventId();\nProcessEvent.EventType type = event.getType();\nString source = event.getSource();\nInstant timestamp = event.getTimestamp();\nProcessEvent.Severity severity = event.getSeverity();\n</code></pre>"},{"location":"integration/ai_platform_integration/#event-history","title":"Event History","text":"<pre><code>// Get recent events\nList&lt;ProcessEvent&gt; recent = eventBus.getRecentEvents(100);\n\n// Get events by type\nList&lt;ProcessEvent&gt; alarms = eventBus.getEventsByType(ProcessEvent.EventType.ALARM, 50);\n\n// Get events by severity\nList&lt;ProcessEvent&gt; critical = eventBus.getEventsBySeverity(ProcessEvent.Severity.ERROR, 20);\n</code></pre>"},{"location":"integration/ai_platform_integration/#data-export","title":"Data Export","text":"<p>Package: <code>neqsim.process.util.export</code></p> <p>Export simulation data for external analysis and ML training.</p>"},{"location":"integration/ai_platform_integration/#timeseriesexporter","title":"TimeSeriesExporter","text":"<pre><code>import neqsim.process.util.export.TimeSeriesExporter;\n\n// Create exporter\nProcessSystem process = new ProcessSystem();\nTimeSeriesExporter exporter = new TimeSeriesExporter(process);\n\n// Collect snapshots during simulation\nfor (int step = 0; step &lt; 1000; step++) {\n    process.run();\n    exporter.collectSnapshot();\n    Thread.sleep(1000);  // 1 second intervals\n}\n\n// Export to JSON (AI platform format)\nString json = exporter.exportToJson();\nFiles.writeString(Path.of(\"timeseries.json\"), json);\n\n// Export to CSV for ML training\nString csv = exporter.exportToCsv();\nFiles.writeString(Path.of(\"training_data.csv\"), csv);\n\n// Export as feature matrix for ML\ndouble[][] features = exporter.exportAsMatrix();\n</code></pre>"},{"location":"integration/ai_platform_integration/#processsnapshot","title":"ProcessSnapshot","text":"<pre><code>import neqsim.process.util.export.ProcessSnapshot;\n\n// Create snapshot\nProcessSnapshot snapshot = new ProcessSnapshot(\"snap-001\");\n\n// Add measurements\nsnapshot.setMeasurement(\"inlet_pressure\", 50.0, \"bara\");\nsnapshot.setMeasurement(\"inlet_temperature\", 25.0, \"C\");\nsnapshot.setMeasurement(\"outlet_flowrate\", 1000.0, \"kg/hr\");\n\n// Serialize\nString json = snapshot.toJson();\n\n// Restore\nProcessSnapshot restored = ProcessSnapshot.fromJson(json);\n</code></pre>"},{"location":"integration/ai_platform_integration/#processdelta","title":"ProcessDelta","text":"<p>Efficiently sync state changes:</p> <pre><code>import neqsim.process.util.export.ProcessDelta;\n\n// Create delta between snapshots\nProcessSnapshot before = exporter.createSnapshot(\"before\");\nprocess.run();\nProcessSnapshot after = exporter.createSnapshot(\"after\");\n\nProcessDelta delta = ProcessDelta.between(before, after);\n\n// Get changes\nMap&lt;String, Double&gt; changes = delta.getChangedValues();\ndouble pressureChange = delta.getChange(\"outlet_pressure\");\n\n// Apply delta to another snapshot\nProcessSnapshot updated = delta.applyTo(before);\n</code></pre>"},{"location":"integration/ai_platform_integration/#example-complete-integration","title":"Example: Complete Integration","text":"<pre><code>// Create process system\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\nStream inlet = new Stream(\"Inlet\", fluid);\ninlet.setFlowRate(10000, \"kg/hr\");\ninlet.run();\n\nProcessSystem process = new ProcessSystem();\nprocess.add(inlet);\n\n// Setup streaming\nProcessDataPublisher publisher = new ProcessDataPublisher(process);\n\n// Setup VFM\nVirtualFlowMeter vfm = new VirtualFlowMeter(\"VFM-1\", inlet);\n\n// Setup online calibration\nOnlineCalibrator calibrator = new OnlineCalibrator(process);\ncalibrator.setTunableParameters(Arrays.asList(\"efficiency\"));\ncalibrator.setDeviationThreshold(0.05);\n\n// Setup event bus\nProcessEventBus eventBus = ProcessEventBus.getInstance();\neventBus.subscribe(ProcessEvent.EventType.MODEL_DEVIATION, event -&gt; {\n    // Trigger recalibration on significant deviation\n    if (calibrator.getQualityMetrics().needsRecalibration()) {\n        calibrator.fullRecalibration();\n    }\n});\n\n// Setup data export\nTimeSeriesExporter exporter = new TimeSeriesExporter(process);\n\n// Real-time loop\nwhile (running) {\n    // Run simulation step\n    process.run();\n\n    // Publish streaming data\n    publisher.publishFromProcessSystem();\n\n    // Get VFM estimate\n    VFMResult vfmResult = vfm.calculate();\n\n    // Check for deviations\n    if (Math.abs(vfmResult.getGasFlowRate() - measuredGasRate) / measuredGasRate &gt; 0.1) {\n        eventBus.publish(ProcessEvent.modelDeviation(\n            \"VFM-1\", \"gas_rate\", measuredGasRate, vfmResult.getGasFlowRate()\n        ));\n    }\n\n    // Record for calibration\n    calibrator.recordDataPoint(measurements, predictions);\n\n    // Collect for export\n    exporter.collectSnapshot();\n\n    Thread.sleep(1000);\n}\n\n// Export training data\nString trainingData = exporter.exportToCsv();\n</code></pre>"},{"location":"integration/ai_platform_integration/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Streaming Frequency: ProcessDataPublisher can handle 1000+ updates/second</li> <li>History Buffer: Default 1000 points; adjust via <code>setMaxHistorySize()</code></li> <li>Monte Carlo Samples: Use 1000-10000 for uncertainty analysis</li> <li>Calibration: Incremental updates are O(1); full recalibration is O(n)</li> <li>Event Bus: Async delivery recommended for high-frequency events</li> </ol>"},{"location":"integration/ai_platform_integration/#thread-safety","title":"Thread Safety","text":"<ul> <li><code>ProcessDataPublisher</code> uses <code>ConcurrentHashMap</code> and <code>CopyOnWriteArrayList</code></li> <li><code>ProcessEventBus</code> supports async event delivery</li> <li><code>OnlineCalibrator</code> history is synchronized</li> <li>All classes are <code>Serializable</code> for persistence</li> </ul>"},{"location":"integration/ai_platform_integration/#integration-with-external-systems","title":"Integration with External Systems","text":"<p>For integration with AI-based production optimization platforms:</p> <ol> <li>Use <code>ProcessDataPublisher</code> to stream real-time data</li> <li>Export training data via <code>TimeSeriesExporter</code> in JSON format</li> <li>Implement <code>MLCorrectionInterface</code> to connect external ML models</li> <li>Use <code>HybridModelAdapter</code> to combine physics with ML corrections</li> <li>Subscribe to <code>ProcessEventBus</code> for real-time alerts and triggers</li> </ol>"},{"location":"integration/dexpi-reader/","title":"DEXPI XML reader","text":"<p>The <code>DexpiXmlReader</code> utility converts DEXPI XML P&amp;ID exports into <code>ProcessSystem</code> models. It recognises major equipment such as pumps, heat exchangers, tanks and control valves as well as complex reactors, compressors and inline analysers. Piping segments are imported as runnable <code>DexpiStream</code> units tagged with the source line number.</p>"},{"location":"integration/dexpi-reader/#usage","title":"Usage","text":"<pre><code>Path xmlFile = Paths.get(\"/path/to/dexpi.xml\");\nSystemSrkEos exampleFluid = new SystemSrkEos(298.15, 50.0);\nexampleFluid.addComponent(\"methane\", 0.9);\nexampleFluid.addComponent(\"ethane\", 0.1);\nexampleFluid.setMixingRule(2);\nexampleFluid.init(0);\n\nStream template = new Stream(\"feed\", exampleFluid);\ntemplate.setFlowRate(1.0, \"MSm3/day\");\ntemplate.setPressure(50.0, \"bara\");\ntemplate.setTemperature(30.0, \"C\");\n\nProcessSystem process = DexpiXmlReader.read(xmlFile.toFile(), template);\n\nDexpiProcessUnit feedPump = (DexpiProcessUnit) process.getUnit(\"P4711\");\nif (feedPump.getMappedEquipment() == EquipmentEnum.Pump) {\n  // handle pump metadata\n}\n</code></pre> <p>The reader also exposes <code>load</code> methods if you want to populate an existing process model instance. Each imported equipment item is represented as a lightweight <code>DexpiProcessUnit</code> that records the original DEXPI class together with the mapped <code>EquipmentEnum</code> category and contextual information like line numbers or fluid codes. Piping segments become <code>DexpiStream</code> objects that clone the pressure, temperature and flow settings from the template stream (or a built-in methane/ethane fallback). When available, the reader honours the recommended metadata exported by NeqSim so pressure, temperature and flow values embedded in DEXPI documents override the template defaults. The resulting <code>ProcessSystem</code> can therefore perform full thermodynamic calculations when <code>run()</code> is invoked without requiring downstream tooling to remap metadata.</p>"},{"location":"integration/dexpi-reader/#metadata-conventions","title":"Metadata conventions","text":"<p>Both the reader and writer share the <code>DexpiMetadata</code> constants that describe the recommended generic attributes for DEXPI exchanges. Equipment exports include tag names, line numbers and fluid codes, while piping segments also carry segment numbers and operating pressure/temperature/flow triples (together with their units). Downstream tools can consult <code>DexpiMetadata.recommendedStreamAttributes()</code> and <code>DexpiMetadata.recommendedEquipmentAttributes()</code> to understand the minimal metadata sets guaranteed by NeqSim.</p>"},{"location":"integration/dexpi-reader/#exporting-back-to-dexpi","title":"Exporting back to DEXPI","text":"<p>The companion <code>DexpiXmlWriter</code> can serialise a process system created from DEXPI data back into a lightweight DEXPI XML document. This is useful when you want to post-process the imported model with tooling such as pyDEXPI to produce graphical output.</p> <pre><code>ProcessSystem process = DexpiXmlReader.read(xmlFile.toFile(), template);\nPath exportPath = Paths.get(\"target\", \"dexpi-export.xml\");\nDexpiXmlWriter.write(process, exportPath.toFile());\n</code></pre> <p>The writer groups all discovered <code>DexpiStream</code> segments by line number (or fluid code when a line is not available) to generate simple <code>&lt;PipingNetworkSystem&gt;</code> elements with associated <code>&lt;PipingNetworkSegment&gt;</code> children. Equipment and valves are exported as <code>&lt;Equipment&gt;</code> and <code>&lt;PipingComponent&gt;</code> elements that preserve the original tag names, line numbers and fluid codes via <code>GenericAttribute</code> entries. Stream metadata is enriched with operating pressure, temperature and flow values (stored in the default NeqSim units, but accompanied by explicit <code>Unit</code> annotations) so that downstream thermodynamic simulators can reproduce NeqSim's state without bespoke mappings.</p> <p>Each piping network is also labelled with a <code>NeqSimGroupingKey</code> generic attribute so that visualisation libraries\u2014such as pyDEXPI or Graphviz exports\u2014can easily recreate line-centric layouts without additional heuristics.</p>"},{"location":"integration/dexpi-reader/#round-trip-profile","title":"Round-trip profile","text":"<p>To codify the minimal metadata required for reliable imports/exports NeqSim exposes the <code>DexpiRoundTripProfile</code> utility. The <code>minimalRunnableProfile</code> validates that a process contains runnable <code>DexpiStream</code> segments (with line/fluid references and operating conditions), tagged equipment and at least one piece of equipment alongside the piping network. Regression tests enforce this profile on the reference training case and the re-imported export artefacts to guarantee round-trip fidelity.</p>"},{"location":"integration/dexpi-reader/#security-considerations","title":"Security considerations","text":"<p>Both the reader and writer configure their XML factories with hardened defaults: secure-processing is enabled, external entity resolution is disabled and <code>ACCESS_EXTERNAL_DTD</code> / <code>ACCESS_EXTERNAL_SCHEMA</code> properties are cleared. These guardrails mirror the guidance in the regression tests and should be preserved if the parsing/serialisation logic is extended.</p>"},{"location":"integration/dexpi-reader/#tested-example","title":"Tested example","text":"<p>A regression test (<code>DexpiXmlReaderTest</code>) imports the <code>C01V04-VER.EX01.xml</code> training case provided by the DEXPI Training Test Cases repository and verifies that the expected equipment (two heat exchangers, two pumps, a tank, valves and piping segments) are discovered. The regression additionally seeds the import with an example NeqSim feed stream and confirms that the generated streams remain active after <code>process.run()</code>. Companion assertions enforce the <code>DexpiRoundTripProfile</code> and check that exported metadata (pressure, temperature, flow and units) survives a round-trip reload. A companion test exports the imported process with <code>DexpiXmlWriter</code>, then parses the generated XML with a hardened DOM builder to confirm that the document contains equipment, piping components and <code>PipingNetworkSystem</code>/ <code>PipingNetworkSegment</code> structures ready for downstream DEXPI tooling such as pyDEXPI.</p>"},{"location":"integration/ml_integration/","title":"NeqSim ML Integration Guide","text":"<p>This module provides infrastructure for integrating NeqSim with modern AI/ML systems including Reinforcement Learning, neural network surrogates, and multi-agent control.</p>"},{"location":"integration/ml_integration/#package-structure","title":"Package Structure","text":"<pre><code>neqsim.process.ml/\n\u251c\u2500\u2500 StateVector.java           - Normalized state representation\n\u251c\u2500\u2500 StateVectorProvider.java   - Interface for equipment state export\n\u251c\u2500\u2500 ActionVector.java          - Bounded action representation\n\u251c\u2500\u2500 Constraint.java            - Physical/safety constraints\n\u251c\u2500\u2500 ConstraintManager.java     - Unified constraint handling\n\u251c\u2500\u2500 RLEnvironment.java         - RL base class\n\u251c\u2500\u2500 GymEnvironment.java        - Gymnasium-compatible abstract class\n\u251c\u2500\u2500 EpisodeRunner.java         - Java-based episode execution &amp; benchmarking\n\u251c\u2500\u2500 EquipmentStateAdapter.java - Extract states from equipment\n\u251c\u2500\u2500 TrainingDataCollector.java - Surrogate model data export\n\u251c\u2500\u2500 controllers/\n\u2502   \u251c\u2500\u2500 Controller.java               - Controller interface\n\u2502   \u251c\u2500\u2500 ProportionalController.java   - P controller\n\u2502   \u251c\u2500\u2500 PIDController.java            - PID with anti-windup\n\u2502   \u251c\u2500\u2500 BangBangController.java       - On-off with hysteresis\n\u2502   \u2514\u2500\u2500 RandomController.java         - Random baseline\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 SeparatorLevelControlEnv.java         - RL example\n\u2502   \u251c\u2500\u2500 SeparatorGymEnv.java                  - Gym-compatible single agent\n\u2502   \u251c\u2500\u2500 SeparatorCompressorMultiAgentEnv.java - Multi-agent example\n\u2502   \u2514\u2500\u2500 FlashSurrogateDataGenerator.java      - Surrogate training\n\u2514\u2500\u2500 multiagent/\n    \u251c\u2500\u2500 Agent.java                    - Agent interface\n    \u251c\u2500\u2500 ProcessAgent.java             - Base process control agent\n    \u251c\u2500\u2500 SeparatorAgent.java           - Separator control agent\n    \u251c\u2500\u2500 CompressorAgent.java          - Compressor control agent\n    \u2514\u2500\u2500 MultiAgentEnvironment.java    - Multi-agent coordinator\n</code></pre>"},{"location":"integration/ml_integration/#design-principles","title":"Design Principles","text":"<ol> <li>Physics First - ML augments, never replaces, thermodynamic rigor</li> <li>Safety by Design - Constraints enforced before any action execution</li> <li>Explainability - All decisions traceable to physical constraints</li> <li>Multi-fidelity - Fast surrogates for training, full physics for deployment</li> <li>Gymnasium Compatible - Direct integration with Python RL frameworks</li> <li>Java-Testable - Test RL infrastructure without Python dependencies</li> </ol>"},{"location":"integration/ml_integration/#quick-start","title":"Quick Start","text":""},{"location":"integration/ml_integration/#1-gymnasium-compatible-environment","title":"1. Gymnasium-Compatible Environment","text":"<p>The <code>GymEnvironment</code> class provides a Gymnasium-compatible API that works directly with Python:</p> <pre><code>import neqsim.process.ml.examples.SeparatorGymEnv;\nimport neqsim.process.ml.GymEnvironment.ResetResult;\nimport neqsim.process.ml.GymEnvironment.StepResult;\n\n// Create environment\nSeparatorGymEnv env = new SeparatorGymEnv();\nenv.setMaxEpisodeSteps(500);\nenv.setLevelSetpoint(0.5);\n\n// Standard Gym API\nResetResult reset = env.reset();\ndouble[] obs = reset.observation;  // 8-dimensional state\n\nwhile (!env.isDone()) {\n    double[] action = new double[] {0.02};  // Valve position delta\n    StepResult result = env.step(action);\n\n    obs = result.observation;\n    double reward = result.reward;\n    boolean terminated = result.terminated;\n    boolean truncated = result.truncated;\n    Map&lt;String, Object&gt; info = result.info;\n}\n</code></pre> <p>Python Usage (via JPype):</p> <pre><code>import jpype\nfrom jpype import JClass\nimport numpy as np\n\njpype.startJVM(classpath=['neqsim.jar'])\n\nSeparatorGymEnv = JClass('neqsim.process.ml.examples.SeparatorGymEnv')\nenv = SeparatorGymEnv()\nenv.setMaxEpisodeSteps(500)\n\n# Gymnasium-compatible API\nreset_result = env.reset()\nobs = np.array(reset_result.observation)\n\ndone = False\ntotal_reward = 0\nwhile not done:\n    action = policy.predict(obs)  # Your RL policy\n    result = env.step([float(action)])\n\n    obs = np.array(result.observation)\n    reward = result.reward\n    done = result.terminated or result.truncated\n    total_reward += reward\n\nprint(f\"Episode reward: {total_reward}\")\n</code></pre>"},{"location":"integration/ml_integration/#2-multi-agent-environments","title":"2. Multi-Agent Environments","text":"<p>For coordinated control of multiple process units:</p> <pre><code>import neqsim.process.ml.examples.SeparatorCompressorMultiAgentEnv;\nimport neqsim.process.ml.multiagent.MultiAgentEnvironment;\nimport java.util.Map;\nimport java.util.HashMap;\n\n// Create multi-agent environment\nSeparatorCompressorMultiAgentEnv env = new SeparatorCompressorMultiAgentEnv();\nenv.setCoordinationMode(MultiAgentEnvironment.CoordinationMode.COOPERATIVE);\nenv.setMaxEpisodeSteps(1000);\n\n// Reset - get observations for all agents\nMap&lt;String, double[]&gt; obs = env.reset();\ndouble[] sepObs = obs.get(\"separator\");\ndouble[] compObs = obs.get(\"compressor\");\n\n// Training loop\nwhile (!env.isDone()) {\n    // Get actions from policies\n    Map&lt;String, double[]&gt; actions = new HashMap&lt;&gt;();\n    actions.put(\"separator\", separatorPolicy.predict(sepObs));\n    actions.put(\"compressor\", compressorPolicy.predict(compObs));\n\n    // Step\n    var result = env.step(actions);\n\n    // Get rewards (shared in cooperative mode)\n    double sepReward = result.rewards.get(\"separator\");\n    double compReward = result.rewards.get(\"compressor\");\n\n    // Next observations\n    sepObs = result.observations.get(\"separator\");\n    compObs = result.observations.get(\"compressor\");\n}\n</code></pre> <p>Coordination Modes:</p> Mode Description <code>INDEPENDENT</code> Each agent has local reward <code>COOPERATIVE</code> All agents share team reward <code>CTDE</code> Centralized training, decentralized execution <code>COMMUNICATING</code> Agents exchange messages before acting"},{"location":"integration/ml_integration/#3-custom-process-agent","title":"3. Custom Process Agent","text":"<pre><code>import neqsim.process.ml.multiagent.ProcessAgent;\nimport neqsim.process.ml.StateVector;\n\npublic class MyValveAgent extends ProcessAgent {\n    private ThrottlingValve valve;\n\n    public MyValveAgent(String id, ThrottlingValve valve) {\n        super(id, valve);\n        this.valve = valve;\n\n        // Define spaces\n        observationNames = new String[]{\"upstream_pressure\", \"downstream_pressure\", \"flow\"};\n        actionNames = new String[]{\"valve_delta\"};\n        actionLow = new double[]{-0.1};\n        actionHigh = new double[]{0.1};\n\n        // Set control setpoint\n        setSetpoint(\"downstream_pressure\", 50.0, 10.0);\n    }\n\n    @Override\n    public double[] getLocalObservation(StateVector globalState) {\n        return new double[]{\n            globalState.getValue(\"upstream_pressure\") / 100.0,\n            globalState.getValue(\"downstream_pressure\") / 100.0,\n            globalState.getValue(\"flow\") / 1000.0\n        };\n    }\n\n    @Override\n    public void applyAction(double[] action) {\n        double currentPos = valve.getPercentValveOpening() / 100.0;\n        double newPos = Math.max(0, Math.min(1, currentPos + action[0]));\n        valve.setPercentValveOpening(newPos * 100.0);\n    }\n}\n</code></pre>"},{"location":"integration/ml_integration/#2-surrogate-model-training-data","title":"2. Surrogate Model Training Data","text":"<pre><code>import neqsim.process.ml.TrainingDataCollector;\n\n// Create collector\nTrainingDataCollector collector = new TrainingDataCollector(\"flash_model\");\ncollector.defineInput(\"temperature\", \"K\", 200.0, 500.0);\ncollector.defineInput(\"pressure\", \"bar\", 1.0, 100.0);\ncollector.defineOutput(\"vapor_fraction\", \"mole_frac\", 0.0, 1.0);\n\n// Collect samples\nfor (double T = 200; T &lt;= 500; T += 10) {\n    for (double P = 1; P &lt;= 100; P += 5) {\n        // Run flash calculation\n        fluid.setTemperature(T, \"K\");\n        fluid.setPressure(P, \"bar\");\n        ops.TPflash();\n\n        // Record\n        collector.startSample();\n        collector.recordInput(\"temperature\", T);\n        collector.recordInput(\"pressure\", P);\n        collector.recordOutput(\"vapor_fraction\", fluid.getPhase(\"gas\").getBeta());\n        collector.endSample();\n    }\n}\n\n// Export for Python\ncollector.exportCSV(\"training_data.csv\");\n</code></pre>"},{"location":"integration/ml_integration/#3-constraint-management","title":"3. Constraint Management","text":"<pre><code>import neqsim.process.ml.ConstraintManager;\nimport neqsim.process.ml.Constraint;\nimport neqsim.process.ml.StateVector;\n\n// Setup constraints\nConstraintManager cm = new ConstraintManager();\ncm.addHardRange(\"max_pressure\", \"pressure\", 0.0, 150.0, \"bar\");\ncm.addSoftRange(\"optimal_temp\", \"temperature\", 280.0, 320.0, \"K\");\n\n// Evaluate against state\nStateVector state = ...;  // From equipment\ncm.evaluate(state);\n\n// Check for violations\nif (cm.hasHardViolation()) {\n    System.out.println(\"SAFETY VIOLATION: \" + cm.explainViolations());\n}\n\n// Get penalty for RL reward\ndouble penalty = cm.getTotalViolationPenalty();\n</code></pre>"},{"location":"integration/ml_integration/#python-integration","title":"Python Integration","text":"<p>The Java classes are designed to work with neqsim-python via JPype:</p> <pre><code>import jpype\nimport jpype.imports\nfrom jpype.types import *\n\n# Start JVM with NeqSim\njpype.startJVM(classpath=['path/to/neqsim.jar'])\n\nfrom neqsim.process.ml.examples import SeparatorLevelControlEnv\nfrom neqsim.process.ml import StateVector, ActionVector\n\n# Create environment\nenv = SeparatorLevelControlEnv()\n\n# Use with stable-baselines3 (requires wrapper)\nobs = env.reset()\nobs_array = obs.toNormalizedArray()\n\n# ... training loop ...\n</code></pre>"},{"location":"integration/ml_integration/#creating-custom-rl-environments","title":"Creating Custom RL Environments","text":"<p>Extend <code>RLEnvironment</code> and override:</p> <pre><code>public class MyControlEnv extends RLEnvironment {\n\n    @Override\n    protected void applyAction(ActionVector action) {\n        // Apply control action to equipment\n        double valvePos = action.get(\"valve\");\n        myValve.setOpening(valvePos);\n    }\n\n    @Override\n    protected StateVector getObservation() {\n        StateVector state = new StateVector();\n        state.add(\"level\", separator.getLevel(), 0.0, 1.0, \"fraction\");\n        state.add(\"pressure\", separator.getPressure(), 0.0, 100.0, \"bar\");\n        return state;\n    }\n\n    @Override\n    protected double computeReward(StateVector state, ActionVector action, StepInfo info) {\n        double reward = super.computeReward(state, action, info);\n\n        // Add task-specific reward\n        double levelError = state.getValue(\"level\") - setpoint;\n        reward -= 10.0 * levelError * levelError;\n\n        return reward;\n    }\n}\n</code></pre>"},{"location":"integration/ml_integration/#architecture-for-production","title":"Architecture for Production","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Python Agent                         \u2502\n\u2502  (stable-baselines3, RLlib, custom algorithms)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 JPype/Py4J\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   neqsim.process.ml                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502RLEnvironment\u2502  \u2502StateVector  \u2502  \u2502ConstraintMgr   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502         \u2502                \u2502                  \u2502           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502              ProcessSystem                        \u2502  \u2502\n\u2502  \u2502  (Separator, Valve, Stream, etc.)                \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502           Thermodynamic Engine                     \u2502 \u2502\n\u2502  \u2502  (SRK, PR, CPA equations of state)                \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/ml_integration/#next-steps","title":"Next Steps","text":"<ol> <li>Implement <code>StateVectorProvider</code> - \u2705 Added to Separator, Compressor, HeatExchanger</li> <li>Gymnasium-compatible API - \u2705 <code>GymEnvironment</code> base class</li> <li>Multi-agent infrastructure - \u2705 <code>multiagent</code> package with cooperative/CTDE modes</li> <li>Java-only testing - \u2705 <code>controllers</code> package with P, PID, BangBang, Random + EpisodeRunner</li> <li>Python wrapper (neqsim-gym) - Create PyPI package wrapping Java RL environments</li> <li>Dynamic simulation integration - Connect to time-stepping solver</li> <li>More example environments - Distillation column control, heat integration</li> <li>Pre-trained surrogates - Ship common surrogate models (flash, property estimation)</li> </ol>"},{"location":"integration/ml_integration/#multi-agent-architecture","title":"Multi-Agent Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Python Multi-Agent Framework              \u2502\n\u2502           (MAPPO, QMIX, MADDPG via RLlib/EPyMARL)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502 JPype/Py4J\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 MultiAgentEnvironment                        \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502SeparatorAgent\u2502  \u2502CompressorAgent\u2502  \u2502SharedConstraints \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502         \u2502                \u2502                   \u2502               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502                  ProcessSystem                         \u2502  \u2502\n\u2502  \u2502      Separator \u2500\u2500\u2500\u2500\u25ba Compressor \u2500\u2500\u2500\u2500\u25ba Cooler          \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/ml_integration/#equipment-with-statevectorprovider","title":"Equipment with StateVectorProvider","text":"<p>The following equipment classes implement <code>StateVectorProvider</code>:</p>"},{"location":"integration/ml_integration/#separator","title":"Separator","text":"State Variable Unit Description pressure bar Separator pressure temperature K Separator temperature liquid_level fraction Liquid level (0-1) gas_density kg/m\u00b3 Gas phase density liquid_density kg/m\u00b3 Liquid phase density gas_flow kg/s Gas outlet flow liquid_flow kg/s Liquid outlet flow gas_load_factor - Gas load factor"},{"location":"integration/ml_integration/#compressor","title":"Compressor","text":"State Variable Unit Description inlet_pressure bar Inlet pressure outlet_pressure bar Outlet pressure inlet_temperature K Inlet temperature outlet_temperature K Outlet temperature compression_ratio - Compression ratio polytropic_efficiency fraction Polytropic efficiency isentropic_efficiency fraction Isentropic efficiency power kW Shaft power speed rpm Rotational speed surge_fraction fraction Distance from surge polytropic_head kJ/kg Polytropic head inlet_flow kg/s Inlet mass flow"},{"location":"integration/ml_integration/#heatexchanger","title":"HeatExchanger","text":"State Variable Unit Description hot_inlet_temp K Hot side inlet temperature hot_outlet_temp K Hot side outlet temperature cold_inlet_temp K Cold side inlet temperature cold_outlet_temp K Cold side outlet temperature duty kW Heat duty ua_value W/K UA value effectiveness fraction Thermal effectiveness hot_flow kg/s Hot side mass flow cold_flow kg/s Cold side mass flow"},{"location":"integration/ml_integration/#java-only-testing-no-python-required","title":"Java-Only Testing (No Python Required)","text":"<p>For testing and benchmarking RL environments without Python dependencies, NeqSim provides simple controllers and an episode runner entirely in Java.</p>"},{"location":"integration/ml_integration/#available-controllers","title":"Available Controllers","text":"<p>The <code>neqsim.process.ml.controllers</code> package provides:</p> Controller Description Use Case <code>ProportionalController</code> P control: u = -Kp \u00d7 error Simple feedback <code>PIDController</code> Full PID with anti-windup Industrial control baseline <code>BangBangController</code> On-off with hysteresis Simple thermostatic control <code>RandomController</code> Uniform random actions Baseline for RL comparison"},{"location":"integration/ml_integration/#controller-interface","title":"Controller Interface","text":"<pre><code>public interface Controller {\n    String getName();\n    double[] computeAction(double[] observation);\n    void reset();\n}\n</code></pre>"},{"location":"integration/ml_integration/#example-pid-controller","title":"Example: PID Controller","text":"<pre><code>import neqsim.process.ml.controllers.*;\nimport neqsim.process.ml.examples.SeparatorGymEnv;\n\n// Create environment\nSeparatorGymEnv env = new SeparatorGymEnv();\n\n// Create PID controller\n// Args: name, observationIndex (level error=6), Kp, Ki, Kd, actionMin, actionMax, dt\nPIDController pid = new PIDController(\"LevelPID\", 6, 0.3, 0.1, 0.05, -0.1, 0.1, 1.0);\n\n// Run one step\nGymEnvironment.ResetResult reset = env.reset();\ndouble[] action = pid.computeAction(reset.observation.toNormalizedArray());\nGymEnvironment.StepResult step = env.step(action);\n</code></pre>"},{"location":"integration/ml_integration/#episoderunner-for-benchmarking","title":"EpisodeRunner for Benchmarking","text":"<p>The <code>EpisodeRunner</code> class runs complete episodes and collects statistics:</p> <pre><code>import neqsim.process.ml.EpisodeRunner;\nimport neqsim.process.ml.EpisodeRunner.*;\n\n// Create runner\nEpisodeRunner runner = new EpisodeRunner(env);\n\n// Run single episode\nEpisodeResult result = runner.runEpisode(pid, 500);\nSystem.out.printf(\"Episode: reward=%.2f, steps=%d%n\", \n    result.totalReward, result.steps);\n\n// Benchmark with statistics\nBenchmarkResult benchmark = runner.benchmark(pid, 10, 500);\nSystem.out.printf(\"Benchmark: mean=%.2f, std=%.2f%n\",\n    benchmark.meanReward, benchmark.stdReward);\n</code></pre>"},{"location":"integration/ml_integration/#comparing-controllers","title":"Comparing Controllers","text":"<pre><code>import java.util.*;\n\n// Create multiple controllers\nList&lt;Controller&gt; controllers = Arrays.asList(\n    new ProportionalController(\"P-only\", 6, 0.5, -0.1, 0.1),\n    new PIDController(\"PID\", 6, 0.3, 0.1, 0.05, -0.1, 0.1, 1.0),\n    new BangBangController(\"BangBang\", 6, 0.1, 0.05, -0.05, 1.0),\n    new RandomController(\"Random\", 1, -0.1, 0.1)\n);\n\n// Compare all controllers\nList&lt;BenchmarkResult&gt; results = runner.compareControllers(controllers, 10, 500);\nEpisodeRunner.printComparison(results);\n</code></pre> <p>Sample Output: <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                          Controller Comparison Results                        \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 Controller    \u2551 Mean Reward\u2551 Std Reward\u2551 Mean Steps \u2551 Terminations \u2551 Best Run \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551 PID           \u2551    247.34  \u2551    12.45  \u2551    500.0   \u2551   0 / 10  \u2551   268.21  \u2551\n\u2551 P-only        \u2551    189.23  \u2551    34.67  \u2551    498.2   \u2551   1 / 10  \u2551   231.45  \u2551\n\u2551 BangBang      \u2551    156.78  \u2551    45.23  \u2551    487.5   \u2551   2 / 10  \u2551   198.34  \u2551\n\u2551 Random        \u2551     23.45  \u2551    78.90  \u2551    234.7   \u2551   8 / 10  \u2551    89.12  \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre></p>"},{"location":"integration/ml_integration/#testing-without-python","title":"Testing Without Python","text":"<p>This enables: - Unit testing - Verify environments work correctly in pure Java - Baseline comparison - Compare RL agents against classical controllers - Performance profiling - Benchmark simulation speed without Python overhead - CI/CD integration - Run tests in Maven without Python setup</p>"},{"location":"integration/ml_integration/#references","title":"References","text":"<ul> <li>Gymnasium (Gym) API</li> <li>stable-baselines3</li> <li>NeqSim Documentation</li> <li>Physics-Informed Neural Networks</li> </ul>"},{"location":"integration/mpc_integration/","title":"MPC Integration for NeqSim Process Systems","text":"<p>This document describes the Model Predictive Control (MPC) integration package for NeqSim, which bridges the gap between rigorous process simulation and advanced control systems.</p>"},{"location":"integration/mpc_integration/#overview","title":"Overview","text":"<p>The <code>neqsim.process.mpc</code> package provides seamless integration between NeqSim's thermodynamic process simulation (<code>ProcessSystem</code>) and Model Predictive Control. It enables:</p> <ul> <li>Automatic Model Identification - Calculate Jacobian matrices or step responses directly from the simulation</li> <li>Variable Binding - Link MPC variables (MVs, CVs, DVs) to process equipment properties</li> <li>Nonlinear Prediction - Use full NeqSim simulation for multi-step prediction</li> <li>Model Export - Export state-space models to JSON, CSV, or MATLAB format</li> </ul>"},{"location":"integration/mpc_integration/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                           ProcessLinkedMPC                                   \u2502\n\u2502       (High-level bridge between ProcessSystem and MPC)                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502 Manipulated \u2502  \u2502 Controlled  \u2502  \u2502 Disturbance \u2502  \u2502    State    \u2502         \u2502\n\u2502  \u2502  Variable   \u2502  \u2502  Variable   \u2502  \u2502  Variable   \u2502  \u2502  Variable   \u2502         \u2502\n\u2502  \u2502    (MV)     \u2502  \u2502    (CV)     \u2502  \u2502    (DV)     \u2502  \u2502   (SVR)     \u2502         \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2502\n\u2502         \u2502                \u2502                \u2502                \u2502                 \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n\u2502                                    \u2502                                         \u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502         \u25bc                          \u25bc                          \u25bc              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502  \u2502 ProcessLinear-  \u2502  \u2502    StepResponse-        \u2502  \u2502   Nonlinear-    \u2502      \u2502\n\u2502  \u2502     izer        \u2502  \u2502      Generator          \u2502  \u2502   Predictor     \u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502           \u2502                       \u2502                          \u2502               \u2502\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2502\n\u2502                                   \u25bc                                          \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                             \u2502\n\u2502                    \u2502   LinearizationResult     \u2502                             \u2502\n\u2502                    \u2502  (Gain matrices + OP)     \u2502                             \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2502\n\u2502                                  \u2502                                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502                               \u2502                               \u2502           \u2502\n\u2502  \u25bc                               \u25bc                               \u25bc           \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502 \u2502 StateSpace-  \u2502  \u2502 IndustrialMPC-         \u2502  \u2502   SubrModl-        \u2502        \u2502\n\u2502 \u2502  Exporter    \u2502  \u2502   Exporter             \u2502  \u2502    Exporter        \u2502        \u2502\n\u2502 \u2502(JSON/MATLAB) \u2502  \u2502(Step Response/Config)  \u2502  \u2502 (Nonlinear Model)  \u2502        \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502\n\u2502                               \u2502                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502  \u2502                                                         \u2502                 \u2502\n\u2502  \u25bc                                                         \u25bc                 \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502 \u2502 ControllerDataExchange  \u2502               \u2502   SoftSensorExporter    \u2502       \u2502\n\u2502 \u2502   (Real-time PCS I/O)   \u2502               \u2502  (Estimator Configs)    \u2502       \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                   \u2502\n                                   \u25bc\n                        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502   ProcessSystem     \u2502\n                        \u2502  (NeqSim Simulation)\u2502\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/mpc_integration/#quick-start","title":"Quick Start","text":""},{"location":"integration/mpc_integration/#basic-mpc-setup","title":"Basic MPC Setup","text":"<pre><code>import neqsim.process.mpc.*;\nimport neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.valve.ThrottlingValve;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create fluid\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"ethane\", 0.15);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// Build process\nProcessSystem process = new ProcessSystem();\n\nStream feed = new Stream(\"feed\", fluid);\nfeed.setFlowRate(1000.0, \"kg/hr\");\nfeed.setTemperature(25.0, \"C\");\nfeed.setPressure(50.0, \"bara\");\n\nThrottlingValve valve = new ThrottlingValve(\"inlet_valve\", feed);\nvalve.setOutletPressure(30.0);\n\nSeparator separator = new Separator(\"separator\", valve.getOutletStream());\n\nprocess.add(feed);\nprocess.add(valve);\nprocess.add(separator);\nprocess.run();\n\n// Create linked MPC\nProcessLinkedMPC mpc = new ProcessLinkedMPC(\"pressureController\", process);\n\n// Define variables\nmpc.addMV(\"inlet_valve\", \"opening\", 0.0, 1.0);  // Valve opening 0-100%\nmpc.addCV(\"separator\", \"pressure\", 30.0);        // Control to 30 bar\n\n// Configure controller\nmpc.setSampleTime(60.0);          // 60 second sample time\nmpc.setPredictionHorizon(20);     // 20 samples = 20 minutes\nmpc.setControlHorizon(5);         // 5 control moves\n\n// Identify model\nmpc.identifyModel(60.0);\n\n// Control loop\nfor (int step = 0; step &lt; 100; step++) {\n    double[] moves = mpc.step();\n    System.out.printf(\"Step %d: MV=%.3f CV=%.2f%n\", \n        step, moves[0], mpc.getCurrentCVs()[0]);\n}\n</code></pre>"},{"location":"integration/mpc_integration/#variable-types","title":"Variable Types","text":""},{"location":"integration/mpc_integration/#manipulated-variables-mvs","title":"Manipulated Variables (MVs)","text":"<p>MVs are process inputs that the controller can adjust:</p> <pre><code>// Create MV with basic bounds\nManipulatedVariable mv = mpc.addMV(\"valve\", \"opening\", 0.0, 1.0);\n\n// Create MV with rate limit\nManipulatedVariable mv2 = mpc.addMV(\"heater\", \"duty\", 0.0, 1000.0, 100.0);\n// Rate limit: max 100 kW change per sample\n\n// Set move suppression cost\nmpc.setMoveSuppressionWeight(\"valve.opening\", 0.5);\n</code></pre> <p>Supported MV Properties: - <code>opening</code> - Valve opening (0-1) - <code>duty</code> - Heater/cooler duty (kW) - <code>flowRate</code> - Stream flow rate - <code>speed</code> - Compressor/pump speed - <code>outletPressure</code> - Pressure controller setpoint</p>"},{"location":"integration/mpc_integration/#controlled-variables-cvs","title":"Controlled Variables (CVs)","text":"<p>CVs are process outputs that we want to control:</p> <pre><code>// Setpoint control\nControlledVariable cv = mpc.addCV(\"separator\", \"pressure\", 30.0);\ncv.setWeight(1.0);  // CV priority\n\n// Zone control (CV only needs to stay within bounds)\nControlledVariable cv2 = mpc.addCVZone(\"separator\", \"liquidLevel\", 30.0, 70.0);\n\n// Hard constraints\nmpc.setConstraint(\"separator\", \"pressure\", 25.0, 35.0);\n</code></pre> <p>Supported CV Properties: - <code>pressure</code> - Equipment pressure (bar) - <code>temperature</code> - Stream/equipment temperature (\u00b0C or K) - <code>liquidLevel</code> - Separator liquid level (%) - <code>flowRate</code> - Stream flow rate - <code>quality</code> - Vapor fraction</p>"},{"location":"integration/mpc_integration/#disturbance-variables-dvs","title":"Disturbance Variables (DVs)","text":"<p>DVs are measured but uncontrolled disturbances for feedforward:</p> <pre><code>DisturbanceVariable dv = mpc.addDV(\"feed\", \"flowRate\");\n</code></pre>"},{"location":"integration/mpc_integration/#model-identification","title":"Model Identification","text":""},{"location":"integration/mpc_integration/#linearization-method","title":"Linearization Method","text":"<p>Fast identification using finite differences:</p> <pre><code>mpc.identifyModel(60.0);  // 60 second sample time\n\n// Access results\nLinearizationResult result = mpc.getLinearizationResult();\ndouble[][] gains = result.getGainMatrix();\ndouble gain = result.getGain(\"separator.pressure\", \"valve.opening\");\n</code></pre>"},{"location":"integration/mpc_integration/#step-response-method","title":"Step Response Method","text":"<p>More accurate for highly nonlinear processes:</p> <pre><code>mpc.identifyModelFromStepTests(\n    60.0,    // Sample time (seconds)\n    600.0,   // Test duration per step (seconds)\n    5.0      // Step size (% of range)\n);\n</code></pre>"},{"location":"integration/mpc_integration/#direct-linearizer-access","title":"Direct Linearizer Access","text":"<p>For more control over the identification process:</p> <pre><code>ProcessLinearizer linearizer = new ProcessLinearizer(process);\nlinearizer.setRelativePerturbation(0.01);  // 1% perturbation\nlinearizer.setUseCentralDifference(true);\n\n// Add variables\nlinearizer.addMV(new ManipulatedVariable(\"valve.opening\", valve, \"opening\"));\nlinearizer.addCV(new ControlledVariable(\"sep.pressure\", separator, \"pressure\"));\n\n// Linearize\nLinearizationResult result = linearizer.linearize();\n\n// Check linearity\nboolean isLinear = linearizer.checkLinearity(0.05);  // 5% tolerance\n</code></pre>"},{"location":"integration/mpc_integration/#model-export","title":"Model Export","text":"<p>Export models for external MPC systems:</p> <pre><code>StateSpaceExporter exporter = mpc.exportModel();\n\n// Generate discrete state-space model\nStateSpaceExporter.StateSpaceModel model = exporter.toDiscreteStateSpace(60.0);\n\n// Export to JSON (for Python)\nexporter.exportJSON(\"process_model.json\");\n\n// Export to MATLAB\nexporter.exportMATLAB(\"process_model.m\");\n\n// Export to CSV\nexporter.exportCSV(\"model_\");  // Creates model_A.csv, model_B.csv, etc.\n</code></pre>"},{"location":"integration/mpc_integration/#json-format","title":"JSON Format","text":"<pre><code>{\n  \"sampleTime\": 60.0,\n  \"sampleTimeUnit\": \"seconds\",\n  \"numStates\": 2,\n  \"numInputs\": 1,\n  \"numOutputs\": 2,\n  \"inputNames\": [\"valve.opening\"],\n  \"outputNames\": [\"separator.pressure\", \"separator.liquidLevel\"],\n  \"A\": [[0.95, 0.0], [0.0, 0.98]],\n  \"B\": [[0.5], [0.1]],\n  \"C\": [[1.0, 0.0], [0.0, 1.0]],\n  \"D\": [[0.0], [0.0]]\n}\n</code></pre>"},{"location":"integration/mpc_integration/#matlab-format","title":"MATLAB Format","text":"<pre><code>% NeqSim State-Space Model Export\nA = [0.95 0.0; 0.0 0.98];\nB = [0.5; 0.1];\nC = [1.0 0.0; 0.0 1.0];\nD = [0.0; 0.0];\nTs = 60.0;\n\nsys = ss(A, B, C, D, Ts);\nsys.InputName = {'valve.opening'};\nsys.OutputName = {'separator.pressure', 'separator.liquidLevel'};\n</code></pre>"},{"location":"integration/mpc_integration/#nonlinear-prediction","title":"Nonlinear Prediction","text":"<p>For highly nonlinear processes, use full NeqSim simulation for prediction:</p> <pre><code>// Enable nonlinear prediction\nmpc.setUseNonlinearPrediction(true);\nmpc.identifyModel(60.0);\n\n// Now calculate() uses full simulation\ndouble[] moves = mpc.calculate();\n</code></pre>"},{"location":"integration/mpc_integration/#direct-predictor-access","title":"Direct Predictor Access","text":"<pre><code>NonlinearPredictor predictor = new NonlinearPredictor(process, 60.0, 20);\n\n// Add variables\npredictor.addMV(new ManipulatedVariable(\"valve.opening\", valve, \"opening\"));\npredictor.addCV(new ControlledVariable(\"sep.pressure\", separator, \"pressure\"));\n\n// Create trajectory\nNonlinearPredictor.MVTrajectory trajectory = new NonlinearPredictor.MVTrajectory();\ndouble[] valveTrajectory = new double[20];\nArrays.fill(valveTrajectory, 0.6);  // Constant 60% opening\ntrajectory.addMV(\"valve.opening\", valveTrajectory);\n\n// Predict\nNonlinearPredictor.PredictionResult result = predictor.predict(trajectory);\ndouble[] pressurePrediction = result.getCVTrajectory(\"separator.pressure\");\n</code></pre>"},{"location":"integration/mpc_integration/#advanced-features","title":"Advanced Features","text":""},{"location":"integration/mpc_integration/#model-updating","title":"Model Updating","text":"<p>Enable automatic model updates during operation:</p> <pre><code>mpc.setModelUpdateInterval(100);  // Re-linearize every 100 steps\n</code></pre>"},{"location":"integration/mpc_integration/#constraint-handling","title":"Constraint Handling","text":"<pre><code>// CV hard constraints (must be satisfied)\nControlledVariable cv = mpc.getControlledVariables().get(0);\ncv.setHardConstraints(true);\ncv.setMinValue(25.0);\ncv.setMaxValue(35.0);\n\n// CV soft constraints (penalty-based)\ncv.setHardConstraints(false);\ncv.setConstraintViolationCost(100.0);\n</code></pre>"},{"location":"integration/mpc_integration/#zone-control","title":"Zone Control","text":"<pre><code>// CV only penalized when outside zone\nControlledVariable cv = mpc.addCVZone(\"tank\", \"level\", 30.0, 70.0);\n// Controller only acts when level leaves 30-70% zone\n</code></pre>"},{"location":"integration/mpc_integration/#step-response-generator","title":"Step Response Generator","text":"<p>For detailed model identification:</p> <pre><code>StepResponseGenerator generator = new StepResponseGenerator(process);\n\n// Add variables\ngenerator.addMV(mv);\ngenerator.addCV(cv);\n\n// Configure\ngenerator.setStepDuration(600.0);     // 10 minutes per test\ngenerator.setStepSize(0.05);          // 5% steps\ngenerator.setSampleInterval(10.0);    // 10 second samples\ngenerator.setBidirectional(true);     // Test both directions\n\n// Generate all responses\nStepResponseGenerator.StepResponseMatrix matrix = generator.generateAllResponses();\n\n// Access individual responses\nStepResponse response = matrix.get(\"separator.pressure\", \"valve.opening\");\ndouble gain = response.getGain();\ndouble timeConstant = response.getTimeConstant();\ndouble deadTime = response.getDeadTime();\n\n// Export for DMC\nStateSpaceExporter exporter = new StateSpaceExporter(matrix);\nexporter.exportStepCoefficients(\"dmc_model.csv\", 60);\n</code></pre>"},{"location":"integration/mpc_integration/#integration-with-ai-platforms","title":"Integration with AI Platforms","text":"<p>The MPC integration package is designed for seamless integration with AI/ML platforms:</p>"},{"location":"integration/mpc_integration/#python-integration-via-neqsim-python","title":"Python Integration via neqsim-python","text":"<pre><code>import jpype\nimport neqsim\n\n# Access MPC classes\nProcessLinkedMPC = jpype.JClass('neqsim.process.mpc.ProcessLinkedMPC')\nStateSpaceExporter = jpype.JClass('neqsim.process.mpc.StateSpaceExporter')\n\n# Create MPC (assuming process is already set up)\nmpc = ProcessLinkedMPC(\"controller\", process)\nmpc.addMV(\"valve\", \"opening\", 0.0, 1.0)\nmpc.addCV(\"separator\", \"pressure\", 30.0)\nmpc.identifyModel(60.0)\n\n# Export model\nexporter = mpc.exportModel()\nexporter.exportJSON(\"model.json\")\n\n# Load in Python for custom optimization\nimport json\nwith open(\"model.json\") as f:\n    model = json.load(f)\n\nA = np.array(model['A'])\nB = np.array(model['B'])\n# Use with scipy.signal, python-control, or custom MPC\n</code></pre>"},{"location":"integration/mpc_integration/#real-time-control-loop","title":"Real-Time Control Loop","text":"<pre><code>// Configure for real-time\nmpc.setSampleTime(1.0);  // 1 second\nmpc.setPredictionHorizon(60);\nmpc.setControlHorizon(10);\nmpc.identifyModel(1.0);\n\n// Real-time loop\nScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\nexecutor.scheduleAtFixedRate(() -&gt; {\n    try {\n        // Read current measurements (from OPC, etc.)\n        updateProcessMeasurements(process);\n\n        // Calculate and apply control\n        mpc.step();\n\n        // Write outputs (to OPC, etc.)\n        writeProcessOutputs(mpc.getLastMoves());\n    } catch (Exception e) {\n        logger.error(\"Control error\", e);\n    }\n}, 0, 1000, TimeUnit.MILLISECONDS);\n</code></pre>"},{"location":"integration/mpc_integration/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Start with linearization - Use <code>identifyModel()</code> first; only switch to step response testing if needed for accuracy.</p> </li> <li> <p>Check linearity - Use <code>ProcessLinearizer.checkLinearity()</code> to validate the linearization accuracy.</p> </li> <li> <p>Conservative tuning - Start with larger prediction horizons and move suppression weights, then tighten.</p> </li> <li> <p>Model updates - Enable periodic re-linearization for processes with significant nonlinearity.</p> </li> <li> <p>Constraint margins - Leave margin between operational constraints and safety limits.</p> </li> <li> <p>Test in simulation - Validate controller behavior thoroughly before connecting to real equipment.</p> </li> </ol>"},{"location":"integration/mpc_integration/#package-structure","title":"Package Structure","text":"<pre><code>neqsim/process/mpc/\n\u251c\u2500\u2500 package-info.java           # Package documentation\n\u251c\u2500\u2500 MPCVariable.java            # Base class for MPC variables\n\u251c\u2500\u2500 ManipulatedVariable.java    # Manipulated variable (MV)\n\u251c\u2500\u2500 ControlledVariable.java     # Controlled variable (CV)\n\u251c\u2500\u2500 DisturbanceVariable.java    # Disturbance variable (DV)\n\u251c\u2500\u2500 StateVariable.java          # State variable (SVR) for nonlinear MPC\n\u251c\u2500\u2500 ProcessLinearizer.java      # Automatic Jacobian calculation\n\u251c\u2500\u2500 LinearizationResult.java    # Gain matrices container\n\u251c\u2500\u2500 StepResponse.java           # Single MV-CV step response\n\u251c\u2500\u2500 StepResponseGenerator.java  # Automated step testing\n\u251c\u2500\u2500 NonlinearPredictor.java     # Full simulation prediction\n\u251c\u2500\u2500 StateSpaceExporter.java     # Model export (JSON/CSV/MATLAB)\n\u251c\u2500\u2500 ProcessLinkedMPC.java       # Main bridge class\n\u251c\u2500\u2500 IndustrialMPCExporter.java  # Step response &amp; config export for industrial MPC\n\u251c\u2500\u2500 ControllerDataExchange.java # Real-time data exchange interface\n\u251c\u2500\u2500 SoftSensorExporter.java     # Soft-sensor/estimator configurations\n\u2514\u2500\u2500 SubrModlExporter.java       # Nonlinear model export (SubrModl format)\n</code></pre>"},{"location":"integration/mpc_integration/#industrial-control-system-integration","title":"Industrial Control System Integration","text":"<p>The MPC package includes comprehensive support for integration with industrial MPC platforms.</p>"},{"location":"integration/mpc_integration/#step-response-model-export","title":"Step Response Model Export","text":"<p>Export models in formats compatible with industrial MPC systems:</p> <pre><code>IndustrialMPCExporter exporter = mpc.createIndustrialExporter();\nexporter.setTagPrefix(\"UNIT1.separator\");\nexporter.setApplicationName(\"GasProcessing\");\n\n// Export step response coefficients in CSV format\nexporter.exportStepResponseCSV(\"step_responses.csv\");\n\n// Export gain matrix\nexporter.exportGainMatrix(\"gains.csv\");\n\n// Export complete object structure for configuration\nexporter.exportObjectStructure(\"controller_config.json\");\n\n// Export comprehensive configuration with all model data\nexporter.exportComprehensiveConfiguration(\"mpc_config.json\");\n</code></pre>"},{"location":"integration/mpc_integration/#real-time-data-exchange","title":"Real-Time Data Exchange","text":"<p>Interface with Process Control Systems (PCS) using standardized data exchange:</p> <pre><code>ControllerDataExchange exchange = mpc.createDataExchange();\nexchange.setTagPrefix(\"UNIT1.MPC\");\n\n// Control loop with external controller\nwhile (running) {\n    // Update inputs from process measurements\n    exchange.updateInputs(mvValues, cvValues, dvValues);\n    exchange.updateSetpoints(setpoints);\n    exchange.updateLimits(cvLowLimits, cvHighLimits, mvLowLimits, mvHighLimits);\n\n    // Execute and get outputs\n    exchange.execute();\n    ControllerDataExchange.ControllerOutput output = exchange.getOutputs();\n\n    // Check quality and status\n    if (output.getStatus() == ControllerDataExchange.ExecutionStatus.SUCCESS) {\n        applyMVs(output.getMvTargets());\n    }\n}\n</code></pre> <p>Quality Flags: - <code>GOOD</code> - Valid measurement - <code>BAD</code> - Invalid/failed measurement - <code>UNCERTAIN</code> - Quality questionable - <code>MANUAL</code> - Manually entered value - <code>CLAMPED</code> - Value at limit</p> <p>Execution Status: - <code>READY</code> - Controller ready for execution - <code>SUCCESS</code> - Execution completed successfully - <code>WARNING</code> - Completed with warnings - <code>FAILED</code> - Execution failed - <code>MODEL_STALE</code> - Model needs update</p>"},{"location":"integration/mpc_integration/#soft-sensor-export","title":"Soft Sensor Export","text":"<p>Export soft-sensor configurations for industrial calculation engines:</p> <pre><code>SoftSensorExporter softExporter = new SoftSensorExporter(process);\nsoftExporter.setTagPrefix(\"UNIT1\");\nsoftExporter.setApplicationName(\"GasProcessing\");\n\n// Add sensors for thermodynamic properties\nsoftExporter.addDensitySensor(\"sep_gas_density\", \"separator\", \"gas outlet\");\nsoftExporter.addViscositySensor(\"sep_oil_visc\", \"separator\", \"oil outlet\");\nsoftExporter.addPhaseFractionSensor(\"sep_gas_frac\", \"separator\");\nsoftExporter.addCompositionEstimator(\"sep_comp\", \"separator\", \"gas outlet\",\n    new String[]{\"methane\", \"ethane\", \"propane\"});\n\n// Export in JSON and CVT formats\nsoftExporter.exportConfiguration(\"soft_sensors.json\");\nsoftExporter.exportCVTFormat(\"soft_sensors.cvt\");\n</code></pre>"},{"location":"integration/mpc_integration/#nonlinear-mpc-with-state-variables","title":"Nonlinear MPC with State Variables","text":"<p>For nonlinear MPC systems that use programmed model objects:</p> <pre><code>// Create MPC with state variables\nProcessLinkedMPC mpc = new ProcessLinkedMPC(\"wellController\", process);\nmpc.addMV(\"choke\", \"opening\", 0.0, 1.0);\nmpc.addCV(\"well\", \"pressure\", 50.0);\nmpc.addDV(\"reservoir\", \"pressure\");\n\n// Add state variables (SVR) for internal model states\nStateVariable flowIn = mpc.addSVR(\"well\", \"flowIn\", \"qin\");\nStateVariable flowOut = mpc.addSVR(\"well\", \"flowOut\", \"qout\");\nmpc.addSVR(\"choke\", \"cv\", \"cv\");\n\n// Configure bias handling for state estimation\nflowIn.setBiasTfilt(30.0);   // 30 second filter on bias\nflowIn.setBiasTpred(120.0);  // 2 minute prediction decay\n\n// Export for nonlinear MPC system\nSubrModlExporter exporter = mpc.createSubrModlExporter();\nexporter.setModelName(\"WellModel\");\nexporter.addParameter(\"Volume\", 100.0, \"m3\");\nexporter.addParameter(\"Height\", 2000.0, \"m\");\nexporter.addParameter(\"Density\", 700.0, \"kg/m3\");\nexporter.addParameter(\"Compressibility\", 500.0, \"bar\");\nexporter.addParameter(\"ProductionIndex\", 8.0, \"m3/h/bar\");\n\n// Export configuration files\nexporter.exportConfiguration(\"well_config.txt\");\nexporter.exportMPCConfiguration(\"mpc_config.txt\", true); // true = SQP solver\nexporter.exportIndexTable(\"well_ixid.cpp\");\nexporter.exportJSON(\"well_model.json\");\n</code></pre> <p>Generated Configuration Example:</p> <pre><code>WellModelProc:    NonlinearSQP\n         Volume=  100\n         Height=  2000\n        Density=  700\nCompressibility=  500\nProductionIndex=  8\n\n  SubrXvr:       Pdownhole\n         Text1=  \"Downhole pressure\"\n         Text2=  \"\"\n         DtaIx=  \"pdh\"\n          Init=  147.7\n\n  SubrXvr:       Pwellhead\n         Text1=  \"Wellhead pressure\"\n         Text2=  \"\"\n         DtaIx=  \"pwh\"\n          Init=  10.4\n</code></pre> <p>MPC Configuration Parameters:</p> Parameter Description Typical Value SteadySolver Steady-state solver type SQP or QP IterOpt Enable iterative optimization ON/OFF IterNewSens Recalculate sensitivities each iteration ON/OFF IterQpMax Maximum QP iterations 10 IterLineMax Maximum line search iterations 10 LinErrorLim Linearization error limit 0.2 MajItLim Major iteration limit (SQP) 200 FuncPrec Function precision 1e-08 FeTol Constraint feasibility tolerance 1e-03 OptimTol Optimality tolerance 1e-05"},{"location":"integration/mpc_integration/#see-also","title":"See Also","text":"<ul> <li>ModelPredictiveController - Underlying MPC implementation</li> <li>ProcessSystem - NeqSim process simulation</li> <li>AI Platform Integration - Broader AI integration guide</li> </ul>"},{"location":"integration/neqsim_industrial_mpc_integration/","title":"NeqSim Industrial MPC Integration Guide","text":"<p>This document describes how NeqSim thermodynamic and process simulation capabilities can be integrated with industrial Model Predictive Control (MPC) systems for real-time optimization and production optimization.</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Integration Architecture</li> <li>Model Generation Workflow</li> <li>Integration Patterns</li> <li>Production Optimization</li> <li>Bottleneck Analysis and Resolution</li> <li>Soft Sensor Integration</li> <li>Gain Scheduling</li> <li>Model Validation</li> <li>Implementation Examples</li> </ol>"},{"location":"integration/neqsim_industrial_mpc_integration/#overview","title":"Overview","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#the-complementary-roles","title":"The Complementary Roles","text":"<p>NeqSim and industrial MPC systems serve complementary roles in process control and optimization:</p> Aspect NeqSim Industrial MPC Primary Function Rigorous thermodynamic calculations Real-time control execution Execution Time Seconds to minutes Milliseconds Model Type First-principles, nonlinear Linear/simplified nonlinear Usage Offline analysis, model generation Online control, optimization Accuracy High-fidelity physics Operational accuracy"},{"location":"integration/neqsim_industrial_mpc_integration/#integration-benefits","title":"Integration Benefits","text":"<ul> <li>Physics-Based Models: NeqSim provides thermodynamically rigorous models for MPC</li> <li>Automatic Linearization: Generate step response models at any operating point</li> <li>Property Estimation: Accurate phase behavior, densities, enthalpies for soft sensors</li> <li>Operating Envelope: Define safe operating regions based on thermodynamic limits</li> <li>Production Optimization: Maximize throughput while respecting constraints</li> </ul>"},{"location":"integration/neqsim_industrial_mpc_integration/#integration-architecture","title":"Integration Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        ENGINEERING WORKSTATION                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502   NeqSim        \u2502\u2500\u2500\u2500\u25b6\u2502  Model Export    \u2502\u2500\u2500\u2500\u25b6\u2502  MPC Config      \u2502   \u2502\n\u2502  \u2502   Process       \u2502    \u2502  (Step Response, \u2502    \u2502  Files           \u2502   \u2502\n\u2502  \u2502   Simulation    \u2502    \u2502   SubrModl, etc) \u2502    \u2502                  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                            \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502              INDUSTRIAL MPC SYSTEM                  \u2502\n                    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502  \u2502              MPC Controller                  \u2502   \u2502\n                    \u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n                    \u2502  \u2502  \u2502 Linear   \u2502  \u2502 Nonlinear\u2502  \u2502 Production\u2502  \u2502   \u2502\n                    \u2502  \u2502  \u2502 MPC      \u2502  \u2502 MPC      \u2502  \u2502 Optimizer \u2502  \u2502   \u2502\n                    \u2502  \u2502  \u2502 (ExprModl\u2502  \u2502 (SubrModl\u2502  \u2502           \u2502  \u2502   \u2502\n                    \u2502  \u2502  \u2502  style)  \u2502  \u2502  style)  \u2502  \u2502           \u2502  \u2502   \u2502\n                    \u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n                    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2502                         \u2502                          \u2502\n                    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502  \u2502            Soft Sensors / Estimators         \u2502   \u2502\n                    \u2502  \u2502  (Property tables, correlations from NeqSim) \u2502   \u2502\n                    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                 PROCESS CONTROL SYSTEM            \u2502\n                    \u2502           (DCS / PLC / Safety Systems)            \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                    PROCESS PLANT                   \u2502\n                    \u2502  (Separators, Compressors, Heat Exchangers, etc)  \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#model-generation-workflow","title":"Model Generation Workflow","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#step-1-build-neqsim-process-model","title":"Step 1: Build NeqSim Process Model","text":"<pre><code>// Create thermodynamic system\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// Build process flowsheet\nProcessSystem process = new ProcessSystem();\nStream feed = new Stream(\"Feed\", fluid);\nfeed.setFlowRate(100.0, \"kg/hr\");\n\nSeparator separator = new Separator(\"HP Separator\", feed);\nprocess.add(feed);\nprocess.add(separator);\nprocess.run();\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#step-2-configure-mpc-variables","title":"Step 2: Configure MPC Variables","text":"<pre><code>// Create MPC bridge\nProcessLinkedMPC mpc = new ProcessLinkedMPC(\"HP_Separator_MPC\", process);\n\n// Define manipulated variables (MVs)\nmpc.addMV(\"Feed_Flow\", feed, \"flowRate\", 50.0, 150.0, \"kg/hr\");\nmpc.addMV(\"Separator_Pressure\", separator, \"pressure\", 30.0, 70.0, \"bara\");\n\n// Define controlled variables (CVs)\nmpc.addCV(\"Gas_Rate\", separator.getGasOutStream(), \"flowRate\", 40.0, 60.0, \"kg/hr\");\nmpc.addCV(\"Liquid_Level\", separator, \"liquidLevel\", 0.3, 0.7, \"fraction\");\n\n// Define disturbance variables (DVs)\nmpc.addDV(\"Feed_Temperature\", feed, \"temperature\", \"C\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#step-3-generate-step-response-models","title":"Step 3: Generate Step Response Models","text":"<pre><code>// Configure linearization\nmpc.setLinearizationStepSize(0.05);  // 5% step\nmpc.setSettlingTime(600.0);           // 10 minutes\nmpc.setSamplingTime(10.0);            // 10 seconds\n\n// Generate step responses\nmpc.generateStepResponses();\n\n// Export for industrial MPC\nIndustrialMPCExporter exporter = mpc.createIndustrialExporter();\nexporter.exportStepResponseModel(\"separator_mpc_model.csv\");\nexporter.exportMPCConfiguration(\"separator_mpc_config.json\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#integration-patterns","title":"Integration Patterns","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#pattern-1-offline-model-generation-online-execution","title":"Pattern 1: Offline Model Generation \u2192 Online Execution","text":"<p>The most common integration pattern where NeqSim generates models offline that are executed in real-time by the industrial MPC.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     Model Files      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     NeqSim      \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6  \u2502  Industrial MPC   \u2502\n\u2502 (Engineering)   \u2502  CSV, JSON, Config  \u2502  (Real-time)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     Offline                                   Online\n   (minutes)                               (milliseconds)\n</code></pre> <p>Use Cases: - Initial MPC commissioning - Model updates during turnarounds - Operating point changes</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#pattern-2-property-table-lookup","title":"Pattern 2: Property Table Lookup","text":"<p>NeqSim pre-calculates property tables that industrial soft sensors use for fast lookups.</p> <pre><code>// Generate property table\nSoftSensorExporter softSensor = mpc.createSoftSensorExporter();\n\n// Configure property grid\nsoftSensor.addPropertyDimension(\"pressure\", 20.0, 80.0, 10);    // 10 points\nsoftSensor.addPropertyDimension(\"temperature\", 273.0, 373.0, 10);\n\n// Export lookup tables\nsoftSensor.exportLookupTable(\"density\", \"density_table.csv\");\nsoftSensor.exportLookupTable(\"viscosity\", \"viscosity_table.csv\");\nsoftSensor.exportLookupTable(\"enthalpy\", \"enthalpy_table.csv\");\n</code></pre> <p>Advantages: - Sub-millisecond property lookups - No real-time NeqSim dependency - Validated thermodynamic accuracy</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#pattern-3-gain-scheduling","title":"Pattern 3: Gain Scheduling","text":"<p>Different operating regions require different model gains. NeqSim calculates models at multiple operating points.</p> <pre><code>// Define operating points\ndouble[] pressures = {30.0, 50.0, 70.0};  // bara\ndouble[] temperatures = {280.0, 300.0, 320.0};  // K\n\n// Generate models at each operating point\nfor (double P : pressures) {\n    for (double T : temperatures) {\n        feed.setPressure(P, \"bara\");\n        feed.setTemperature(T, \"K\");\n        process.run();\n\n        mpc.generateStepResponses();\n        String filename = String.format(\"model_P%.0f_T%.0f.csv\", P, T);\n        exporter.exportStepResponseModel(filename);\n    }\n}\n</code></pre> <p>The industrial MPC selects the appropriate model based on current operating conditions.</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#pattern-4-nonlinear-mpc-with-steady-state-solver","title":"Pattern 4: Nonlinear MPC with Steady-State Solver","text":"<p>For nonlinear MPC applications, NeqSim can provide steady-state solutions.</p> <pre><code>// Configure for nonlinear MPC\nSubrModlExporter subrModl = mpc.createSubrModlExporter();\n\n// Add state variables for estimation\nmpc.addSVR(\"Liquid_Composition\", separator, \"liquidComposition\", 0.0, 1.0);\n\n// Export SubrModl configuration\nsubrModl.exportConfiguration(\"separator_subrmodl.cnf\");\nsubrModl.exportMPCConfiguration(\"separator_smpc.json\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#production-optimization","title":"Production Optimization","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#overview_1","title":"Overview","text":"<p>Industrial MPC systems excel at production optimization - maximizing throughput while respecting all process constraints. NeqSim provides the physics-based models that enable accurate constraint handling.</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#optimization-hierarchy","title":"Optimization Hierarchy","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    PRODUCTION OPTIMIZATION                       \u2502\n\u2502                    (Economic Objective)                          \u2502\n\u2502         Maximize: Revenue - Operating Costs                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    INDUSTRIAL MPC                                \u2502\n\u2502                    (Constraint Handling)                         \u2502\n\u2502         Subject to: Equipment limits, Quality specs,            \u2502\n\u2502                     Safety constraints, Environmental           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NEQSIM MODELS                                 \u2502\n\u2502                    (Physical Constraints)                        \u2502\n\u2502         Provides: Thermodynamic limits, Phase boundaries,       \u2502\n\u2502                   Property calculations, Equipment models       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#optimization-variables","title":"Optimization Variables","text":"<p>The industrial MPC optimizes by pushing the process toward constraints while maintaining stability:</p> Variable Type NeqSim Contribution MPC Usage Throughput Maximum flow capacity Maximize within limits Quality Composition calculations Constraint satisfaction Energy Enthalpy, heat duties Cost minimization Efficiency Compressor curves, pump efficiency Optimal setpoints"},{"location":"integration/neqsim_industrial_mpc_integration/#example-separator-train-optimization","title":"Example: Separator Train Optimization","text":"<pre><code>// Define economic objective\nmpc.setOptimizationObjective(OptimizationType.MAXIMIZE_THROUGHPUT);\n\n// NeqSim provides constraint models:\n// 1. Maximum gas velocity (flooding limit)\ndouble maxGasVelocity = separator.getMaxGasVelocity();  // m/s\n\n// 2. Minimum residence time\ndouble minResidenceTime = separator.getMinResidenceTime();  // seconds\n\n// 3. Liquid carryover limit\ndouble maxLiquidInGas = separator.getMaxLiquidCarryover();  // ppm\n\n// Export constraints to MPC\nexporter.addConstraint(\"Gas_Velocity\", 0, maxGasVelocity, \"m/s\");\nexporter.addConstraint(\"Residence_Time\", minResidenceTime, 1e6, \"s\");\nexporter.addConstraint(\"Liquid_Carryover\", 0, maxLiquidInGas, \"ppm\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#bottleneck-analysis-and-resolution","title":"Bottleneck Analysis and Resolution","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#what-is-bottleneck-analysis","title":"What is Bottleneck Analysis?","text":"<p>Bottleneck analysis identifies which constraints are limiting production and quantifies the value of relaxing each constraint.</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#neqsims-role-in-bottleneck-analysis","title":"NeqSim's Role in Bottleneck Analysis","text":"<ol> <li>Equipment Capacity Modeling</li> <li>Separator flooding velocity</li> <li>Compressor surge/choke limits</li> <li>Heat exchanger duty limits</li> <li> <p>Pump cavitation limits</p> </li> <li> <p>Thermodynamic Constraints</p> </li> <li>Phase envelope boundaries</li> <li>Hydrate formation curves</li> <li>Dew point specifications</li> <li> <p>Flash point limits</p> </li> <li> <p>Quality Specifications</p> </li> <li>Composition targets</li> <li>Water content limits</li> <li>H2S specifications</li> <li>Heating value requirements</li> </ol>"},{"location":"integration/neqsim_industrial_mpc_integration/#bottleneck-resolution-workflow","title":"Bottleneck Resolution Workflow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Step 1: IDENTIFY ACTIVE CONSTRAINTS                            \u2502\n\u2502   Industrial MPC reports which constraints are limiting          \u2502\n\u2502   production (shadow prices / Lagrange multipliers)              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Step 2: ANALYZE WITH NEQSIM                                    \u2502\n\u2502   Use rigorous simulation to understand constraint physics:      \u2502\n\u2502   - What causes the limit?                                       \u2502\n\u2502   - How sensitive is it to operating conditions?                 \u2502\n\u2502   - What would happen if constraint is violated?                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Step 3: EVALUATE DEBOTTLENECKING OPTIONS                       \u2502\n\u2502   NeqSim simulates \"what-if\" scenarios:                          \u2502\n\u2502   - Increase equipment size                                      \u2502\n\u2502   - Change operating pressure                                    \u2502\n\u2502   - Add parallel equipment                                       \u2502\n\u2502   - Modify feed conditions                                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Step 4: UPDATE MPC MODELS                                      \u2502\n\u2502   After physical changes, regenerate models with NeqSim          \u2502\n\u2502   and deploy updated MPC configuration                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#example-compressor-bottleneck","title":"Example: Compressor Bottleneck","text":"<pre><code>// Identify compressor as bottleneck\nCompressor compressor = (Compressor) process.getUnit(\"Export_Compressor\");\n\n// Analyze compressor performance\nCompressorChart chart = compressor.getCompressorChart();\ndouble surgeLimit = chart.getSurgeFlow();\ndouble chokeLimit = chart.getChokeFlow();\ndouble currentFlow = compressor.getInletStream().getFlowRate(\"kg/hr\");\n\n// Calculate margin to constraints\ndouble surgeMargin = (currentFlow - surgeLimit) / surgeLimit * 100;  // %\ndouble chokeMargin = (chokeLimit - currentFlow) / chokeLimit * 100;  // %\n\n// If near choke (bottleneck), simulate options:\nif (chokeMargin &lt; 10) {\n    System.out.println(\"Compressor approaching choke limit!\");\n\n    // Option 1: Increase inlet pressure\n    double newInletPressure = compressor.getInletPressure() * 1.1;\n    compressor.setInletPressure(newInletPressure);\n    process.run();\n    double newChokeMargin = // recalculate\n\n    // Option 2: Cool the inlet gas\n    // Option 3: Install parallel compressor\n}\n\n// Generate updated MPC model with new operating point\nmpc.generateStepResponses();\nexporter.exportStepResponseModel(\"compressor_updated.csv\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#bottleneck-value-calculation","title":"Bottleneck Value Calculation","text":"<p>The industrial MPC calculates the economic value (shadow price) of each constraint:</p> Constraint Shadow Price Interpretation Compressor Power $500/MW Each additional MW enables $500/hr more production Separator Pressure $100/bar Relaxing pressure by 1 bar gains $100/hr Export Quality $200/ppm Each ppm H2S relaxation worth $200/hr <p>NeqSim can validate these shadow prices by simulating the actual production gain when constraints are relaxed.</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#soft-sensor-integration","title":"Soft Sensor Integration","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#phase-properties","title":"Phase Properties","text":"<pre><code>// Calculate phase properties for soft sensor\nThermodynamicOperations thermoOps = new ThermodynamicOperations(fluid);\nthermoOps.TPflash();\n\ndouble gasCompressibility = fluid.getPhase(\"gas\").getZ();\ndouble liquidDensity = fluid.getPhase(\"oil\").getDensity(\"kg/m3\");\ndouble gasViscosity = fluid.getPhase(\"gas\").getViscosity(\"cP\");\ndouble surfaceTension = fluid.getInterphaseProperties().getSurfaceTension(\"mN/m\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#molecular-weight-estimation","title":"Molecular Weight Estimation","text":"<pre><code>// Export molecular weight correlation\nSoftSensorExporter exporter = mpc.createSoftSensorExporter();\nexporter.setFluid(fluid);\n\n// Generate MW as function of composition and conditions\nexporter.exportCorrelation(\"molecularWeight\", \n    new String[]{\"C1_fraction\", \"C2_fraction\", \"temperature\", \"pressure\"},\n    \"mw_correlation.csv\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#heating-value-calculation","title":"Heating Value Calculation","text":"<pre><code>// Calculate heating values for gas sales\ndouble GCV = fluid.getPhase(\"gas\").getGCV();  // Gross calorific value\ndouble NCV = fluid.getPhase(\"gas\").getNCV();  // Net calorific value\ndouble wobbeIndex = fluid.getPhase(\"gas\").getWobbeIndex();\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#gain-scheduling","title":"Gain Scheduling","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#operating-point-identification","title":"Operating Point Identification","text":"<pre><code>// Define key operating variables that affect gains\nList&lt;OperatingPoint&gt; operatingPoints = new ArrayList&lt;&gt;();\n\n// Low throughput\noperatingPoints.add(new OperatingPoint(\n    \"Low_Rate\", 50.0, 40.0, 290.0));  // flow, pressure, temp\n\n// Normal operation\noperatingPoints.add(new OperatingPoint(\n    \"Normal\", 100.0, 50.0, 300.0));\n\n// High throughput\noperatingPoints.add(new OperatingPoint(\n    \"High_Rate\", 150.0, 60.0, 310.0));\n\n// Generate model at each point\nfor (OperatingPoint op : operatingPoints) {\n    configureProcess(process, op);\n    mpc.generateStepResponses();\n    exporter.exportStepResponseModel(\"model_\" + op.getName() + \".csv\");\n}\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#model-selection-logic","title":"Model Selection Logic","text":"<p>The industrial MPC uses operating conditions to select the appropriate model:</p> <pre><code>IF (flow &lt; 75 kg/hr) THEN\n    USE model_Low_Rate\nELSE IF (flow &lt; 125 kg/hr) THEN\n    USE model_Normal\nELSE\n    USE model_High_Rate\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#model-validation","title":"Model Validation","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#continuous-model-monitoring","title":"Continuous Model Monitoring","text":"<p>A background service can use NeqSim to validate MPC model predictions:</p> <pre><code>// Compare MPC prediction with NeqSim simulation\npublic class ModelValidator {\n    private ProcessSystem neqsimModel;\n    private double[] mpcPrediction;\n\n    public ValidationResult validate(ProcessData currentData) {\n        // Apply current conditions to NeqSim model\n        applyConditions(neqsimModel, currentData);\n        neqsimModel.run();\n\n        // Compare outputs\n        double[] neqsimOutput = getOutputs(neqsimModel);\n        double[] errors = new double[neqsimOutput.length];\n\n        for (int i = 0; i &lt; errors.length; i++) {\n            errors[i] = Math.abs(neqsimOutput[i] - mpcPrediction[i]);\n        }\n\n        return new ValidationResult(errors, isModelValid(errors));\n    }\n}\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#bias-detection","title":"Bias Detection","text":"<pre><code>// State variable with bias tracking\nStateVariable liquidLevel = new StateVariable(\"Liquid_Level\", \n    separator, \"liquidLevel\", 0.0, 1.0, \"fraction\");\n\n// Configure bias estimation\nliquidLevel.setBiasTfilt(300.0);   // 5-minute filter\nliquidLevel.setBiasTpred(600.0);   // 10-minute prediction horizon\n\n// Monitor bias evolution\nif (Math.abs(liquidLevel.getBias()) &gt; 0.05) {\n    System.out.println(\"Significant model bias detected - consider model update\");\n}\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#implementation-examples","title":"Implementation Examples","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#complete-separator-control-example","title":"Complete Separator Control Example","text":"<pre><code>import neqsim.process.ProcessSystem;\nimport neqsim.process.equipment.*;\nimport neqsim.process.mpc.*;\nimport neqsim.thermo.system.*;\n\npublic class SeparatorMPCIntegration {\n\n    public static void main(String[] args) {\n        // 1. Build process model\n        SystemInterface fluid = new SystemSrkEos(298.15, 50.0);\n        fluid.addComponent(\"methane\", 0.80);\n        fluid.addComponent(\"ethane\", 0.10);\n        fluid.addComponent(\"propane\", 0.05);\n        fluid.addComponent(\"n-butane\", 0.03);\n        fluid.addComponent(\"n-pentane\", 0.02);\n        fluid.setMixingRule(\"classic\");\n\n        ProcessSystem process = new ProcessSystem();\n\n        Stream feed = new Stream(\"Feed\", fluid);\n        feed.setFlowRate(500.0, \"kg/hr\");\n        feed.setTemperature(25.0, \"C\");\n        feed.setPressure(50.0, \"bara\");\n\n        Separator hpSep = new Separator(\"HP_Separator\", feed);\n        hpSep.setInternalDiameter(1.5);\n\n        process.add(feed);\n        process.add(hpSep);\n        process.run();\n\n        // 2. Configure MPC\n        ProcessLinkedMPC mpc = new ProcessLinkedMPC(\"HP_Sep_MPC\", process);\n\n        // Manipulated Variables\n        mpc.addMV(\"Feed_Flow\", feed, \"flowRate\", 200.0, 800.0, \"kg/hr\");\n        mpc.addMV(\"Operating_Pressure\", hpSep, \"pressure\", 30.0, 70.0, \"bara\");\n\n        // Controlled Variables\n        mpc.addCV(\"Gas_Production\", hpSep.getGasOutStream(), \n                  \"flowRate\", 100.0, 400.0, \"kg/hr\");\n        mpc.addCV(\"Liquid_Level\", hpSep, \n                  \"liquidLevel\", 0.3, 0.7, \"fraction\");\n\n        // Disturbance Variables\n        mpc.addDV(\"Feed_Temperature\", feed, \"temperature\", \"C\");\n        mpc.addDV(\"Feed_Composition_C1\", feed, \"methane_fraction\", \"mol/mol\");\n\n        // 3. Generate models\n        mpc.setLinearizationStepSize(0.05);\n        mpc.setSettlingTime(600.0);\n        mpc.setSamplingTime(10.0);\n        mpc.generateStepResponses();\n\n        // 4. Export for industrial MPC\n        IndustrialMPCExporter exporter = mpc.createIndustrialExporter();\n        exporter.setModelName(\"HP_Separator\");\n        exporter.setDescription(\"High Pressure Separator MPC Model\");\n\n        // Step response model\n        exporter.exportStepResponseModel(\"hp_sep_model.csv\");\n\n        // MPC configuration\n        exporter.setPredictionHorizon(30);\n        exporter.setControlHorizon(10);\n        exporter.setExecutionInterval(10.0);\n        exporter.exportMPCConfiguration(\"hp_sep_config.json\");\n\n        // 5. Export soft sensors\n        SoftSensorExporter softSensor = mpc.createSoftSensorExporter();\n        softSensor.setFluid(fluid);\n        softSensor.exportCalculation(\"gas_density\", \"gas_density_calc.csv\");\n        softSensor.exportCalculation(\"liquid_density\", \"liquid_density_calc.csv\");\n\n        // 6. Export for nonlinear MPC (optional)\n        SubrModlExporter subrModl = mpc.createSubrModlExporter();\n        subrModl.setModelName(\"HP_Sep_NL\");\n        subrModl.exportConfiguration(\"hp_sep_subrmodl.cnf\");\n\n        System.out.println(\"MPC integration files generated successfully!\");\n    }\n}\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#production-optimization-setup","title":"Production Optimization Setup","text":"<pre><code>// Configure for production optimization\npublic class ProductionOptimization {\n\n    public static void configureOptimization(ProcessLinkedMPC mpc) {\n        // Set optimization objective\n        mpc.setOptimizationObjective(OptimizationType.MAXIMIZE_THROUGHPUT);\n\n        // Define economic weights\n        mpc.setEconomicWeight(\"Gas_Production\", 1.0);    // $/kg\n        mpc.setEconomicWeight(\"Oil_Production\", 1.5);    // $/kg\n        mpc.setEconomicWeight(\"Power_Consumption\", -0.1); // $/kWh\n\n        // Configure constraints for optimizer\n        mpc.setConstraintPriority(\"Safety_Limits\", Priority.HARD);\n        mpc.setConstraintPriority(\"Environmental\", Priority.HARD);\n        mpc.setConstraintPriority(\"Quality_Specs\", Priority.SOFT);\n        mpc.setConstraintPriority(\"Equipment_Limits\", Priority.SOFT);\n\n        // Export optimization configuration\n        IndustrialMPCExporter exporter = mpc.createIndustrialExporter();\n        exporter.setOptimizationEnabled(true);\n        exporter.exportOptimizationConfig(\"production_opt.json\");\n    }\n}\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#derivative-calculation-for-ai-and-mpc","title":"Derivative Calculation for AI and MPC","text":""},{"location":"integration/neqsim_industrial_mpc_integration/#the-derivative-challenge","title":"The Derivative Challenge","text":"<p>AI software and MPC systems typically require derivatives (gradients, Jacobians) of process variables for: - Gradient-based optimization: Finding optimal setpoints - Model Predictive Control: Computing control moves - Sensitivity analysis: Understanding process behavior - Machine learning: Training neural networks with physics-informed gradients</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#why-analytical-derivatives-are-difficult","title":"Why Analytical Derivatives Are Difficult","text":"<p>In thermodynamic simulators like NeqSim, analytical derivatives are impractical because:</p> <ol> <li>Complex equation chains: Fugacity \u2192 Activity Coefficient \u2192 Compressibility \u2192 Mixing Rules \u2192 Pure Component Parameters</li> <li>Iterative algorithms: Flash calculations use iterative solvers where derivatives require implicit function theorem</li> <li>Phase transitions: Discontinuities at phase boundaries</li> <li>Conditional logic: Different correlations for different phases</li> </ol>"},{"location":"integration/neqsim_industrial_mpc_integration/#neqsims-derivative-calculator","title":"NeqSim's Derivative Calculator","text":"<p>NeqSim provides an efficient numerical derivative calculator optimized for process simulations:</p> <pre><code>import neqsim.process.mpc.ProcessDerivativeCalculator;\n\n// Create calculator\nProcessDerivativeCalculator calc = new ProcessDerivativeCalculator(process);\n\n// Define input variables (what we perturb)\ncalc.addInputVariable(\"Feed.flowRate\", \"kg/hr\");\ncalc.addInputVariable(\"Feed.pressure\", \"bara\");\ncalc.addInputVariable(\"Feed.temperature\", \"K\");\n\n// Define output variables (what we measure)\ncalc.addOutputVariable(\"Separator.gasOutStream.flowRate\", \"kg/hr\");\ncalc.addOutputVariable(\"Separator.liquidLevel\", \"fraction\");\n\n// Calculate full Jacobian matrix\ndouble[][] jacobian = calc.calculateJacobian();\n// jacobian[i][j] = \u2202output_i / \u2202input_j\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#derivative-methods","title":"Derivative Methods","text":"Method Formula Accuracy Cost Forward Difference (f(x+h) - f(x)) / h O(h) N+1 evaluations Central Difference (f(x+h) - f(x-h)) / 2h O(h\u00b2) 2N evaluations 5-Point Stencil Higher-order formula O(h\u2074) 4N evaluations <pre><code>// Select derivative method\ncalc.setMethod(ProcessDerivativeCalculator.DerivativeMethod.CENTRAL_DIFFERENCE);\n\n// Adjust step size (relative)\ncalc.setRelativeStepSize(1e-4);  // 0.01% perturbation\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#automatic-step-size-selection","title":"Automatic Step Size Selection","text":"<p>The calculator automatically selects appropriate step sizes based on variable type:</p> Variable Type Minimum Step Rationale Pressure 0.01 bar Avoid numerical noise Temperature 0.1 K Sufficient for property changes Flow Rate 0.001 kg/hr Very small flows need care Composition 1e-6 Mole fractions are small numbers"},{"location":"integration/neqsim_industrial_mpc_integration/#single-derivative","title":"Single Derivative","text":"<pre><code>// Get one specific derivative\ndouble dGasFlow_dFeedFlow = calc.getDerivative(\n    \"Separator.gasOutStream.flowRate\",  // output\n    \"Feed.flowRate\"                      // input\n);\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#gradient-one-output-all-inputs","title":"Gradient (One Output, All Inputs)","text":"<pre><code>// Get gradient of one output w.r.t. all inputs\ndouble[] gradient = calc.getGradient(\"Separator.gasOutStream.flowRate\");\n// gradient[0] = \u2202gasFlow/\u2202feedFlow\n// gradient[1] = \u2202gasFlow/\u2202feedPressure\n// gradient[2] = \u2202gasFlow/\u2202feedTemperature\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#hessian-second-derivatives","title":"Hessian (Second Derivatives)","text":"<pre><code>// Get Hessian matrix for optimization\ndouble[][] hessian = calc.calculateHessian(\"Separator.gasOutStream.flowRate\");\n// hessian[i][j] = \u2202\u00b2gasFlow / \u2202input_i \u2202input_j\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#export-for-external-systems","title":"Export for External Systems","text":"<pre><code>// Export Jacobian to JSON for AI/ML systems\nString json = calc.exportJacobianToJSON();\n\n// Export to CSV for spreadsheet analysis\ncalc.exportJacobianToCSV(\"jacobian.csv\");\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#json-output-format","title":"JSON Output Format","text":"<pre><code>{\n  \"inputs\": [\"Feed.flowRate\", \"Feed.pressure\"],\n  \"outputs\": [\"Separator.gasOutStream.flowRate\", \"Separator.liquidLevel\"],\n  \"baseInputValues\": [100.0, 50.0],\n  \"baseOutputValues\": [85.2, 0.45],\n  \"jacobian\": [\n    [0.852, -0.023],\n    [0.001, 0.015]\n  ]\n}\n</code></pre>"},{"location":"integration/neqsim_industrial_mpc_integration/#best-practices-for-ai-integration","title":"Best Practices for AI Integration","text":"<ol> <li>Cache derivatives: Recompute only when operating point changes significantly</li> <li>Use central differences: More accurate than forward differences</li> <li>Validate step sizes: Too small causes numerical noise, too large causes truncation error</li> <li>Monitor for phase changes: Derivatives may jump at phase boundaries</li> <li>Smooth gradients: For ML training, consider averaging over nearby operating points</li> </ol>"},{"location":"integration/neqsim_industrial_mpc_integration/#summary","title":"Summary","text":"<p>The integration of NeqSim with industrial MPC systems creates a powerful combination for process control and optimization:</p> Capability NeqSim Role Industrial MPC Role Model Generation Create physics-based models Execute models in real-time Constraint Handling Define thermodynamic limits Satisfy constraints online Production Optimization Quantify capacity limits Push to optimal constraints Bottleneck Analysis Identify physical causes Calculate economic value Soft Sensors Provide property calculations Fast lookup/interpolation Model Validation Rigorous reference Bias detection/correction <p>This complementary approach combines the accuracy of first-principles thermodynamic modeling with the speed and robustness of industrial control systems.</p>"},{"location":"integration/neqsim_industrial_mpc_integration/#references","title":"References","text":"<ul> <li>NeqSim Documentation: https://equinor.github.io/neqsim/</li> <li>NeqSim MPC Package: <code>neqsim.process.mpc</code></li> <li>Example notebooks: <code>docs/examples/MPC_Integration_Tutorial.ipynb</code></li> </ul> <p>Document Version: 1.0 Last Updated: December 2024</p>"},{"location":"mathlib/","title":"Mathematical Library Package","text":"<p>The <code>mathlib</code> package provides mathematical utilities, nonlinear solvers, and numerical methods.</p>"},{"location":"mathlib/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Nonlinear Solvers</li> <li>General Math</li> <li>Usage Examples</li> </ul>"},{"location":"mathlib/#overview","title":"Overview","text":"<p>Location: <code>neqsim.mathlib</code></p> <p>Purpose: - Nonlinear equation solving - Matrix operations - Numerical differentiation - Root finding algorithms - Optimization routines</p>"},{"location":"mathlib/#package-structure","title":"Package Structure","text":"<pre><code>mathlib/\n\u251c\u2500\u2500 generalmath/                  # General mathematical utilities\n\u2502   \u251c\u2500\u2500 GeneralMath.java          # Common math functions\n\u2502   \u251c\u2500\u2500 TDMAsolve.java            # Tridiagonal matrix solver\n\u2502   \u2514\u2500\u2500 SplineInterpolation.java  # Spline interpolation\n\u2502\n\u2514\u2500\u2500 nonlinearsolver/              # Nonlinear equation solvers\n    \u251c\u2500\u2500 NonLinearSolver.java      # Base solver\n    \u251c\u2500\u2500 NewtonRaphson.java        # Newton-Raphson method\n    \u251c\u2500\u2500 Brent.java                # Brent's method\n    \u251c\u2500\u2500 Bisection.java            # Bisection method\n    \u2514\u2500\u2500 NumericalDerivative.java  # Numerical derivatives\n</code></pre>"},{"location":"mathlib/#nonlinear-solvers","title":"Nonlinear Solvers","text":""},{"location":"mathlib/#newton-raphson-method","title":"Newton-Raphson Method","text":"<p>Iterative method for finding roots of functions.</p> \\[x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}\\] <pre><code>import neqsim.mathlib.nonlinearsolver.NewtonRaphson;\n\n// Define function to solve: f(x) = x\u00b2 - 2 (find \u221a2)\nFunction&lt;Double, Double&gt; f = x -&gt; x * x - 2.0;\nFunction&lt;Double, Double&gt; df = x -&gt; 2.0 * x;\n\nNewtonRaphson solver = new NewtonRaphson();\nsolver.setFunction(f);\nsolver.setDerivative(df);\nsolver.setInitialGuess(1.0);\nsolver.setTolerance(1e-10);\nsolver.setMaxIterations(100);\n\ndouble root = solver.solve();\nSystem.out.println(\"\u221a2 = \" + root);  // 1.4142135623...\n</code></pre>"},{"location":"mathlib/#brents-method","title":"Brent's Method","text":"<p>Robust root-finding combining bisection, secant, and inverse quadratic interpolation.</p> <pre><code>import neqsim.mathlib.nonlinearsolver.Brent;\n\nFunction&lt;Double, Double&gt; f = x -&gt; x * x * x - x - 2.0;\n\nBrent solver = new Brent();\nsolver.setFunction(f);\nsolver.setBracket(1.0, 2.0);  // Root is in [1, 2]\nsolver.setTolerance(1e-10);\n\ndouble root = solver.solve();\nSystem.out.println(\"Root: \" + root);\n</code></pre>"},{"location":"mathlib/#bisection-method","title":"Bisection Method","text":"<p>Simple but robust root-finding.</p> <pre><code>import neqsim.mathlib.nonlinearsolver.Bisection;\n\nFunction&lt;Double, Double&gt; f = x -&gt; Math.sin(x) - 0.5;\n\nBisection solver = new Bisection();\nsolver.setFunction(f);\nsolver.setBracket(0.0, Math.PI);\nsolver.setTolerance(1e-8);\n\ndouble root = solver.solve();\nSystem.out.println(\"arcsin(0.5) = \" + root);  // \u03c0/6 \u2248 0.5236\n</code></pre>"},{"location":"mathlib/#numerical-derivatives","title":"Numerical Derivatives","text":""},{"location":"mathlib/#forward-difference","title":"Forward Difference","text":"\\[f'(x) \\approx \\frac{f(x+h) - f(x)}{h}\\]"},{"location":"mathlib/#central-difference","title":"Central Difference","text":"\\[f'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}\\] <pre><code>import neqsim.mathlib.nonlinearsolver.NumericalDerivative;\n\nFunction&lt;Double, Double&gt; f = x -&gt; Math.exp(x);\n\nNumericalDerivative deriv = new NumericalDerivative();\nderiv.setFunction(f);\nderiv.setStepSize(1e-6);\n\ndouble df = deriv.centralDifference(1.0);\nSystem.out.println(\"d/dx(e^x) at x=1: \" + df);  // \u2248 e \u2248 2.718\n</code></pre>"},{"location":"mathlib/#general-math","title":"General Math","text":""},{"location":"mathlib/#tdmasolve-thomas-algorithm","title":"TDMAsolve (Thomas Algorithm)","text":"<p>Efficient solver for tridiagonal systems.</p> \\[\\begin{bmatrix} b_1 &amp; c_1 \\\\ a_2 &amp; b_2 &amp; c_2 \\\\ &amp; \\ddots &amp; \\ddots &amp; \\ddots \\\\ &amp; &amp; a_{n-1} &amp; b_{n-1} &amp; c_{n-1} \\\\ &amp; &amp; &amp; a_n &amp; b_n \\end{bmatrix} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_{n-1} \\\\ x_n \\end{bmatrix} = \\begin{bmatrix} d_1 \\\\ d_2 \\\\ \\vdots \\\\ d_{n-1} \\\\ d_n \\end{bmatrix}\\] <pre><code>import neqsim.mathlib.generalmath.TDMAsolve;\n\n// Coefficients\ndouble[] a = {0, 1, 1, 1};    // Lower diagonal\ndouble[] b = {4, 4, 4, 4};    // Main diagonal\ndouble[] c = {1, 1, 1, 0};    // Upper diagonal\ndouble[] d = {5, 5, 5, 5};    // Right-hand side\n\ndouble[] x = TDMAsolve.solve(a, b, c, d);\n</code></pre>"},{"location":"mathlib/#spline-interpolation","title":"Spline Interpolation","text":"<p>Cubic spline interpolation for smooth curves.</p> <pre><code>import neqsim.mathlib.generalmath.SplineInterpolation;\n\ndouble[] xData = {0, 1, 2, 3, 4, 5};\ndouble[] yData = {0, 1, 4, 9, 16, 25};  // y = x\u00b2\n\nSplineInterpolation spline = new SplineInterpolation(xData, yData);\n\n// Interpolate at any point\ndouble y = spline.interpolate(2.5);  // \u2248 6.25\n</code></pre>"},{"location":"mathlib/#common-math-functions","title":"Common Math Functions","text":"<pre><code>import neqsim.mathlib.generalmath.GeneralMath;\n\n// Safe logarithm (handles near-zero)\ndouble logVal = GeneralMath.safeLog(x);\n\n// Polynomial evaluation\ndouble[] coeffs = {1, 2, 3};  // 1 + 2x + 3x\u00b2\ndouble polyVal = GeneralMath.polynomial(x, coeffs);\n\n// Linear interpolation\ndouble y = GeneralMath.linearInterpolate(x, x1, y1, x2, y2);\n</code></pre>"},{"location":"mathlib/#matrix-operations","title":"Matrix Operations","text":"<p>For matrix operations, NeqSim uses external libraries: - EJML (Efficient Java Matrix Library) - Apache Commons Math - JAMA</p> <pre><code>import org.ejml.simple.SimpleMatrix;\n\n// Matrix multiplication\nSimpleMatrix A = new SimpleMatrix(new double[][] {\n    {1, 2}, {3, 4}\n});\nSimpleMatrix B = new SimpleMatrix(new double[][] {\n    {5, 6}, {7, 8}\n});\nSimpleMatrix C = A.mult(B);\n\n// Solve linear system Ax = b\ndouble[][] bData = { {1}, {2} };\nSimpleMatrix b = new SimpleMatrix(bData);\nSimpleMatrix x = A.solve(b);\n\n// Eigenvalue decomposition\nSimpleEVD evd = A.eig();\n</code></pre>"},{"location":"mathlib/#usage-in-neqsim","title":"Usage in NeqSim","text":""},{"location":"mathlib/#flash-calculations","title":"Flash Calculations","text":"<p>Newton-Raphson used in flash convergence:</p> <pre><code>// Simplified flash iteration\nwhile (error &gt; tolerance) {\n    // Calculate fugacities\n    double[] fugL = calculateLiquidFugacity();\n    double[] fugV = calculateVaporFugacity();\n\n    // Newton-Raphson update for K-values\n    for (int i = 0; i &lt; nc; i++) {\n        K[i] = K[i] * fugL[i] / fugV[i];\n    }\n\n    // Rachford-Rice equation\n    beta = solveRachfordRice(K, z);\n    error = calculateError();\n}\n</code></pre>"},{"location":"mathlib/#phase-envelope","title":"Phase Envelope","text":"<p>Continuation methods for phase boundary tracking:</p> <pre><code>// Predictor-corrector method\nwhile (pressure &lt; maxPressure) {\n    // Predict next point\n    double[] predicted = predictNextPoint(direction, stepSize);\n\n    // Correct using Newton-Raphson\n    double[] corrected = correctPoint(predicted);\n\n    // Update direction for next step\n    direction = updateDirection(corrected);\n}\n</code></pre>"},{"location":"mathlib/#optimization","title":"Optimization","text":""},{"location":"mathlib/#minimization","title":"Minimization","text":"<pre><code>// Golden section search for minimum\nFunction&lt;Double, Double&gt; f = x -&gt; (x - 2) * (x - 2) + 1;\n\ndouble a = 0, b = 5;\ndouble tolerance = 1e-6;\ndouble phi = (1 + Math.sqrt(5)) / 2;\n\nwhile ((b - a) &gt; tolerance) {\n    double x1 = b - (b - a) / phi;\n    double x2 = a + (b - a) / phi;\n\n    if (f.apply(x1) &lt; f.apply(x2)) {\n        b = x2;\n    } else {\n        a = x1;\n    }\n}\ndouble minimum = (a + b) / 2;  // \u2248 2.0\n</code></pre>"},{"location":"mathlib/#multidimensional-optimization","title":"Multidimensional Optimization","text":"<p>For parameter fitting, NeqSim uses: - Levenberg-Marquardt - Simplex (Nelder-Mead) - BFGS</p>"},{"location":"mathlib/#convergence-criteria","title":"Convergence Criteria","text":""},{"location":"mathlib/#absolute-tolerance","title":"Absolute Tolerance","text":"\\[|x_{n+1} - x_n| &lt; \\epsilon\\]"},{"location":"mathlib/#relative-tolerance","title":"Relative Tolerance","text":"\\[\\frac{|x_{n+1} - x_n|}{|x_n|} &lt; \\epsilon\\]"},{"location":"mathlib/#function-value-tolerance","title":"Function Value Tolerance","text":"\\[|f(x_n)| &lt; \\epsilon\\]"},{"location":"mathlib/#best-practices","title":"Best Practices","text":"<ol> <li>Choose appropriate solver - Newton for fast convergence, Brent for robustness</li> <li>Provide good initial guess - Improves convergence</li> <li>Set reasonable tolerances - Balance accuracy vs speed</li> <li>Check convergence - Verify solver actually converged</li> <li>Handle edge cases - Division by zero, negative values for log</li> </ol>"},{"location":"mathlib/#related-documentation","title":"Related Documentation","text":"<ul> <li>Flash Calculations - Flash solver internals</li> <li>Physical Properties - Property correlations</li> </ul>"},{"location":"physical_properties/","title":"Physical Properties Package","text":"<p>This documentation covers NeqSim's physical properties calculation system, including transport properties (viscosity, thermal conductivity, diffusivity), interfacial properties (surface tension), and density correlations.</p>"},{"location":"physical_properties/#contents","title":"Contents","text":"<ul> <li>Overview (this page) - Package architecture and basic usage</li> <li>Viscosity Models - Dynamic viscosity calculation methods</li> <li>Thermal Conductivity Models - Thermal conductivity methods</li> <li>Diffusivity Models - Binary and multicomponent diffusion coefficients</li> <li>Interfacial Properties - Surface tension and related calculations</li> <li>Density Models - Liquid density correlations</li> </ul>"},{"location":"physical_properties/#package-architecture","title":"Package Architecture","text":"<p>The physical properties package follows a modular design with clear separation between:</p> <ol> <li>Property Handlers - Manage which models to use for each phase type</li> <li>Physical Properties System - Phase-specific property containers</li> <li>Methods - Individual calculation models (viscosity, conductivity, etc.)</li> <li>Mixing Rules - Combine pure component properties into mixture properties</li> <li>Interface Properties - Surface/interfacial tension calculations</li> </ol> <pre><code>physicalproperties/\n\u251c\u2500\u2500 PhysicalPropertyHandler.java    # Main entry point\n\u251c\u2500\u2500 PhysicalPropertyType.java       # Property type enum\n\u251c\u2500\u2500 system/\n\u2502   \u251c\u2500\u2500 PhysicalProperties.java     # Abstract base class\n\u2502   \u251c\u2500\u2500 PhysicalPropertyModel.java  # Model selection enum\n\u2502   \u251c\u2500\u2500 gasphysicalproperties/      # Gas phase implementations\n\u2502   \u251c\u2500\u2500 liquidphysicalproperties/   # Liquid phase implementations\n\u2502   \u2514\u2500\u2500 solidphysicalproperties/    # Solid phase implementations\n\u251c\u2500\u2500 methods/\n\u2502   \u251c\u2500\u2500 gasphysicalproperties/\n\u2502   \u2502   \u251c\u2500\u2500 viscosity/\n\u2502   \u2502   \u251c\u2500\u2500 conductivity/\n\u2502   \u2502   \u2514\u2500\u2500 diffusivity/\n\u2502   \u251c\u2500\u2500 liquidphysicalproperties/\n\u2502   \u2502   \u251c\u2500\u2500 viscosity/\n\u2502   \u2502   \u251c\u2500\u2500 conductivity/\n\u2502   \u2502   \u251c\u2500\u2500 diffusivity/\n\u2502   \u2502   \u2514\u2500\u2500 density/\n\u2502   \u2514\u2500\u2500 commonphasephysicalproperties/\n\u2502       \u251c\u2500\u2500 viscosity/              # Models valid for all phases\n\u2502       \u251c\u2500\u2500 conductivity/\n\u2502       \u2514\u2500\u2500 diffusivity/\n\u251c\u2500\u2500 mixingrule/\n\u2502   \u2514\u2500\u2500 PhysicalPropertyMixingRule.java\n\u2514\u2500\u2500 interfaceproperties/\n    \u251c\u2500\u2500 InterfaceProperties.java\n    \u2514\u2500\u2500 surfacetension/\n</code></pre>"},{"location":"physical_properties/#basic-usage","title":"Basic Usage","text":""},{"location":"physical_properties/#initializing-physical-properties","title":"Initializing Physical Properties","text":"<p>Physical properties are calculated after thermodynamic equilibrium has been established:</p> <pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create fluid and run flash\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"ethane\", 0.1);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Initialize physical properties\nfluid.initPhysicalProperties();\n\n// Access properties\ndouble gasViscosity = fluid.getPhase(\"gas\").getViscosity(\"kg/msec\");\ndouble gasConductivity = fluid.getPhase(\"gas\").getThermalConductivity(\"W/mK\");\ndouble gasDensity = fluid.getPhase(\"gas\").getDensity(\"kg/m3\");\n</code></pre>"},{"location":"physical_properties/#physical-property-models","title":"Physical Property Models","text":"<p>NeqSim provides several pre-configured physical property model sets:</p> Model Description Best For <code>DEFAULT</code> Standard models for oil/gas General hydrocarbon systems <code>WATER</code> Water-specific correlations Aqueous systems <code>SALT_WATER</code> Salt water correlations Brine systems <code>GLYCOL</code> Glycol-specific models Glycol dehydration <code>AMINE</code> Amine solution models Gas sweetening <code>CO2WATER</code> CO\u2082-water system models CCS applications <code>BASIC</code> Minimal calculations Fast approximations <pre><code>// Set physical property model\nfluid.initPhysicalProperties(\"GLYCOL\");\n\n// Or use the enum directly\nimport neqsim.physicalproperties.system.PhysicalPropertyModel;\nfluid.initPhysicalProperties(PhysicalPropertyModel.AMINE);\n</code></pre>"},{"location":"physical_properties/#selecting-individual-models","title":"Selecting Individual Models","text":"<p>You can override specific property models while keeping others at defaults:</p>"},{"location":"physical_properties/#viscosity-model-selection","title":"Viscosity Model Selection","text":"<pre><code>fluid.initPhysicalProperties();\n\n// Set viscosity model for a specific phase\nfluid.getPhase(\"gas\").getPhysicalProperties().setViscosityModel(\"friction theory\");\nfluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"LBC\");\n</code></pre> <p>Available viscosity models: - <code>\"polynom\"</code> - Polynomial correlation - <code>\"friction theory\"</code> - Qui\u00f1ones-Cisneros friction theory - <code>\"LBC\"</code> - Lohrenz-Bray-Clark (tunable) - <code>\"PFCT\"</code> - Pedersen corresponding states - <code>\"PFCT-Heavy-Oil\"</code> - Pedersen for heavy oils - <code>\"KTA\"</code> - KTA method - <code>\"Muzny\"</code> - Muzny (for hydrogen) - <code>\"CO2Model\"</code> - CO\u2082 reference - <code>\"MethaneModel\"</code> - Methane reference</p>"},{"location":"physical_properties/#thermal-conductivity-model-selection","title":"Thermal Conductivity Model Selection","text":"<pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setConductivityModel(\"Chung\");\nfluid.getPhase(\"oil\").getPhysicalProperties().setConductivityModel(\"PFCT\");\n</code></pre> <p>Available conductivity models: - <code>\"Chung\"</code> - Chung method (gases) - <code>\"PFCT\"</code> - Pedersen corresponding states - <code>\"polynom\"</code> - Polynomial correlation - <code>\"CO2Model\"</code> - CO\u2082 reference</p>"},{"location":"physical_properties/#diffusivity-model-selection","title":"Diffusivity Model Selection","text":"<pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setDiffusionCoefficientModel(\"Wilke Lee\");\nfluid.getPhase(\"oil\").getPhysicalProperties().setDiffusionCoefficientModel(\"Siddiqi Lucas\");\n</code></pre> <p>Available diffusivity models: - <code>\"Wilke Lee\"</code> - Wilke-Lee (gases) - <code>\"Siddiqi Lucas\"</code> - Siddiqi-Lucas (liquids) - <code>\"CSP\"</code> - Corresponding states - <code>\"Alkanol amine\"</code> - Amine solutions</p>"},{"location":"physical_properties/#density-model-selection-liquids","title":"Density Model Selection (Liquids)","text":"<pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setDensityModel(\"Costald\");\n</code></pre> <p>Available density models: - <code>\"Peneloux volume shift\"</code> - EoS with volume translation - <code>\"Costald\"</code> - COSTALD correlation</p>"},{"location":"physical_properties/#model-tuning","title":"Model Tuning","text":"<p>Several models support parameter tuning for better match with experimental data:</p>"},{"location":"physical_properties/#lbc-viscosity-tuning","title":"LBC Viscosity Tuning","text":"<p>The LBC model has 5 tunable parameters for the dense-fluid contribution:</p> <pre><code>// Set all parameters at once\ndouble[] lbcParams = {0.1023, 0.023364, 0.058533, -0.040758, 0.0093324};\nfluid.getPhase(\"oil\").getPhysicalProperties().setLbcParameters(lbcParams);\n\n// Or set individual parameters\nfluid.getPhase(\"oil\").getPhysicalProperties().setLbcParameter(0, 0.105);\n</code></pre>"},{"location":"physical_properties/#friction-theory-constants","title":"Friction Theory Constants","text":"<p>For non-SRK/PR equations of state:</p> <pre><code>FrictionTheoryViscosityMethod viscModel = \n    (FrictionTheoryViscosityMethod) fluid.getPhase(\"oil\")\n        .getPhysicalProperties().getViscosityModel();\n\nviscModel.setFrictionTheoryConstants(\n    kapac,    // Attractive constant\n    kaprc,    // Repulsive constant\n    kaprrc,   // Repulsive-repulsive constant\n    kapa,     // Attractive matrix (3x3)\n    kapr,     // Repulsive matrix (3x3)\n    kaprr     // Repulsive-repulsive constant\n);\n</code></pre>"},{"location":"physical_properties/#accessing-calculated-properties","title":"Accessing Calculated Properties","text":"<p>After initialization, properties are available through the phase interface:</p>"},{"location":"physical_properties/#per-phase-properties","title":"Per-Phase Properties","text":"<pre><code>// Viscosity\ndouble viscosity = fluid.getPhase(\"gas\").getViscosity();           // Pa\u00b7s\ndouble viscosity_cP = fluid.getPhase(\"gas\").getViscosity(\"cP\");    // cP\n\n// Thermal conductivity\ndouble k = fluid.getPhase(\"gas\").getThermalConductivity();         // W/(m\u00b7K)\ndouble k_alt = fluid.getPhase(\"gas\").getThermalConductivity(\"W/mK\");\n\n// Density\ndouble rho = fluid.getPhase(\"gas\").getDensity();                   // kg/m\u00b3\ndouble rho_alt = fluid.getPhase(\"gas\").getDensity(\"kg/m3\");\n\n// Kinematic viscosity\ndouble nu = fluid.getPhase(\"gas\").getKinematicViscosity();         // m\u00b2/s\n\n// Binary diffusion coefficients\ndouble[][] Dij = fluid.getPhase(\"gas\").getPhysicalProperties()\n    .getDiffusivityCalc().getBinaryDiffusionCoefficients();        // m\u00b2/s\n</code></pre>"},{"location":"physical_properties/#pure-component-properties","title":"Pure Component Properties","text":"<pre><code>// Pure component viscosity (for mixing rule debugging)\ndouble pureVisc = fluid.getPhase(\"gas\").getPhysicalProperties()\n    .getPureComponentViscosity(0);\n</code></pre>"},{"location":"physical_properties/#interfacial-properties","title":"Interfacial Properties","text":"<pre><code>// Surface tension between phases\nfluid.initPhysicalProperties();\ndouble sigma = fluid.getInterphaseProperties().getSurfaceTension(0, 1);  // N/m\n</code></pre>"},{"location":"physical_properties/#adding-new-models","title":"Adding New Models","text":"<p>To add a custom physical property model:</p>"},{"location":"physical_properties/#1-create-the-model-class","title":"1. Create the Model Class","text":"<pre><code>package neqsim.physicalproperties.methods.liquidphysicalproperties.viscosity;\n\nimport neqsim.physicalproperties.system.PhysicalProperties;\n\npublic class MyCustomViscosityModel extends Viscosity {\n\n    public MyCustomViscosityModel(PhysicalProperties phase) {\n        super(phase);\n    }\n\n    @Override\n    public double calcViscosity() {\n        // Your implementation here\n        double viscosity = 0.0;\n\n        // Access phase properties\n        double T = phase.getPhase().getTemperature();  // K\n        double P = phase.getPhase().getPressure();     // bar\n        double rho = phase.getPhase().getDensity();    // kg/m\u00b3\n\n        // Access component properties\n        for (int i = 0; i &lt; phase.getPhase().getNumberOfComponents(); i++) {\n            double x = phase.getPhase().getComponent(i).getx();\n            double Tc = phase.getPhase().getComponent(i).getTC();\n            // ... calculate contribution\n        }\n\n        return viscosity;  // Pa\u00b7s\n    }\n\n    @Override\n    public double getPureComponentViscosity(int i) {\n        // Return pure component viscosity for component i\n        return 0.0;\n    }\n}\n</code></pre>"},{"location":"physical_properties/#2-register-in-physicalproperties","title":"2. Register in PhysicalProperties","text":"<p>Add to <code>setViscosityModel()</code> in <code>PhysicalProperties.java</code>:</p> <pre><code>public void setViscosityModel(String model) {\n    // ... existing models ...\n    else if (\"MyCustomModel\".equals(model)) {\n        viscosityCalc = new MyCustomViscosityModel(this);\n    }\n}\n</code></pre>"},{"location":"physical_properties/#3-use-the-model","title":"3. Use the Model","text":"<pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"MyCustomModel\");\n</code></pre>"},{"location":"physical_properties/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Lazy Initialization: Properties are only calculated when <code>initPhysicalProperties()</code> is called</li> <li>Selective Updates: Use <code>init(phase, PropertyType)</code> to update only specific properties</li> <li>Reuse Systems: Clone fluids rather than recreating for sensitivity studies</li> </ol> <pre><code>// Efficient property sweep\nSystemInterface baseFluid = createFluid();\nbaseFluid.initPhysicalProperties();\n\nfor (double T : temperatures) {\n    SystemInterface fluid = baseFluid.clone();\n    fluid.setTemperature(T, \"K\");\n    ops.TPflash();\n    fluid.initPhysicalProperties();\n    // ... use properties\n}\n</code></pre>"},{"location":"physical_properties/#see-also","title":"See Also","text":"<ul> <li>Fluid Creation Guide - Creating thermodynamic systems</li> <li>Flash Calculations Guide - Phase equilibrium calculations</li> <li>Thermodynamic Operations - Property calculation workflow</li> </ul>"},{"location":"physical_properties/density_models/","title":"Density Models","text":"<p>This guide documents the density correction models available in NeqSim for improving volumetric predictions.</p>"},{"location":"physical_properties/density_models/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Equation of State Density</li> <li>Volume Translation Methods</li> <li>Peneloux Volume Shift</li> <li>Component-Specific Corrections</li> <li>Liquid Density Correlations</li> <li>Costald</li> <li>Rackett Equation</li> <li>Usage Examples</li> <li>Model Selection Guide</li> </ul>"},{"location":"physical_properties/density_models/#overview","title":"Overview","text":"<p>Density predictions from cubic equations of state (SRK, PR) often have systematic errors: - Liquid density: Typically underpredicted by 5-15% - Vapor density: Generally accurate - Critical region: Poor accuracy</p> <p>NeqSim provides volume translation and correlation-based methods to improve liquid density predictions.</p> <p>Basic density access: <pre><code>fluid.init(3);  // Initialize with derivatives\nfluid.initPhysicalProperties();\n\ndouble density = fluid.getPhase(1).getDensity(\"kg/m3\");  // Liquid phase\ndouble molarVolume = fluid.getPhase(1).getMolarVolume();  // m\u00b3/mol\n</code></pre></p>"},{"location":"physical_properties/density_models/#equation-of-state-density","title":"Equation of State Density","text":""},{"location":"physical_properties/density_models/#direct-eos-calculation","title":"Direct EoS Calculation","text":"<p>Cubic equations of state calculate compressibility factor \\(Z\\):</p> \\[PV = ZnRT\\] <p>Molar volume is then: $\\(V_m = \\frac{ZRT}{P}\\)$</p> <p>Density: $\\(\\rho = \\frac{PM_w}{ZRT}\\)$</p> <p>Issue with cubic EoS: At the critical point, \\(Z_c^{SRK} = 0.333\\) and \\(Z_c^{PR} = 0.307\\), while real hydrocarbons have \\(Z_c \\approx 0.26\\). This causes systematic liquid volume overprediction.</p>"},{"location":"physical_properties/density_models/#volume-translation-methods","title":"Volume Translation Methods","text":""},{"location":"physical_properties/density_models/#peneloux-volume-shift","title":"Peneloux Volume Shift","text":"<p>The Peneloux correction adds a constant shift to the EoS molar volume:</p> \\[V_{corrected} = V_{EoS} - c\\] <p>where \\(c\\) is the volume shift parameter.</p> <p>Class: <code>Peneloux</code></p> <p>Mixture shift: $\\(c_{mix} = \\sum_i x_i c_i\\)$</p> <p>Component shift correlation: $\\(c_i = 0.40768 \\frac{RT_{c,i}}{P_{c,i}} \\left( 0.29441 - Z_{RA,i} \\right)\\)$</p> <p>where \\(Z_{RA}\\) is the Rackett compressibility factor (from COMP database).</p> <p>Setting shift parameters: <pre><code>// Enable Peneloux correction (default for SRK)\nfluid.setDensityModel(\"Peneloux\");\n\n// Or set component-specific shifts\nfluid.getPhase(0).getComponent(\"methane\").setVolumeCorrectionConst(0.0);\nfluid.getPhase(1).getComponent(\"n-heptane\").setVolumeCorrectionConst(-0.0105);\n</code></pre></p> <p>Advantages: - Simple to implement - Preserves vapor-liquid equilibrium - Works for mixtures</p> <p>Limitations: - Temperature independent - May not work well at extreme conditions - Single parameter per component</p>"},{"location":"physical_properties/density_models/#component-specific-corrections","title":"Component-Specific Corrections","text":"<p>NeqSim stores volume correction constants in the COMP database. For heavy hydrocarbons or polar compounds, these may need tuning.</p> <p>Accessing correction constants: <pre><code>// Get current volume correction\ndouble vc = fluid.getPhase(1).getComponent(\"n-decane\").getVolumeCorrectionConst();\n\n// Modify correction\nfluid.getPhase(1).getComponent(\"n-decane\").setVolumeCorrectionConst(-0.015);\n</code></pre></p> <p>Temperature-dependent shift (Jhaveri-Youngren): Some systems require temperature-dependent corrections:</p> \\[c(T) = c_0 + c_1 (T - T_{ref})\\] <p>This is implemented in specific component models.</p>"},{"location":"physical_properties/density_models/#liquid-density-correlations","title":"Liquid Density Correlations","text":""},{"location":"physical_properties/density_models/#costald","title":"Costald","text":"<p>The COSTALD (COrreSponding STAtes Liquid Density) correlation predicts saturated liquid volumes.</p> <p>Class: <code>Costald</code></p> <p>Equation: $\\(V_s = V^* V_R^{(0)} \\left[ 1 - \\omega_{SRK} V_R^{(\\delta)} \\right]\\)$</p> <p>where: - \\(V^*\\) is the characteristic volume - \\(V_R^{(0)}, V_R^{(\\delta)}\\) are functions of reduced temperature - \\(\\omega_{SRK}\\) is the acentric factor</p> <p>Reduced volume functions: $\\(V_R^{(0)} = 1 + a(1-T_r)^{1/3} + b(1-T_r)^{2/3} + c(1-T_r) + d(1-T_r)^{4/3}\\)$</p> \\[V_R^{(\\delta)} = \\frac{e + fT_r + gT_r^2 + hT_r^3}{T_r - 1.00001}\\] <p>Constants: - a = -1.52816 - b = 1.43907 - c = -0.81446 - d = 0.190454 - e = -0.296123 - f = 0.386914 - g = -0.0427258 - h = -0.0480645</p> <p>Mixing rules: $\\(V^*_{mix} = \\frac{1}{4} \\left[ \\sum_i x_i V^*_i + 3 \\left(\\sum_i x_i V^{*2/3}_i\\right) \\left(\\sum_i x_i V^{*1/3}_i\\right) \\right]\\)$</p> \\[\\omega_{mix} = \\sum_i x_i \\omega_i\\] <p>Usage: <pre><code>fluid.setDensityModel(\"Costald\");\nfluid.initPhysicalProperties();\n\ndouble liquidDensity = fluid.getPhase(1).getDensity(\"kg/m3\");\n</code></pre></p> <p>Best for: - Pure component liquid density - Hydrocarbon mixtures at saturation - Temperature range: 0.25 &lt; Tr &lt; 1.0</p>"},{"location":"physical_properties/density_models/#rackett-equation","title":"Rackett Equation","text":"<p>A simple corresponding states correlation for saturated liquid density.</p> <p>Equation: $\\(V_s = \\frac{RT_c}{P_c} Z_{RA}^{[1 + (1-T_r)^{2/7}]}\\)$</p> <p>where \\(Z_{RA}\\) is the Rackett compressibility factor.</p> <p>Spencer-Danner modification: Uses optimized \\(Z_{RA}\\) values from experimental data rather than critical compressibility.</p> <p>For mixtures: $\\(Z_{RA,mix} = \\sum_i x_i Z_{RA,i}\\)$ $\\(T_{c,mix} = \\sum_i x_i T_{c,i}\\)$</p> <p>Usage: <pre><code>// Access Rackett parameter\ndouble Zra = fluid.getPhase(1).getComponent(\"n-pentane\").getRacketZ();\n\n// Rackett is used internally for volume correction\n</code></pre></p>"},{"location":"physical_properties/density_models/#usage-examples","title":"Usage Examples","text":""},{"location":"physical_properties/density_models/#comparing-density-models","title":"Comparing Density Models","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\nSystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.1);\nfluid.addComponent(\"n-pentane\", 0.9);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// EoS density (no correction)\ndouble densityEoS = fluid.getPhase(1).getDensity(\"kg/m3\");\nSystem.out.println(\"EoS only: \" + densityEoS + \" kg/m\u00b3\");\n\n// With Peneloux correction (default for SRK)\nfluid.initPhysicalProperties();\ndouble densityPeneloux = fluid.getPhase(1).getDensity(\"kg/m3\");\nSystem.out.println(\"Peneloux: \" + densityPeneloux + \" kg/m\u00b3\");\n\n// With Costald\nfluid.setDensityModel(\"Costald\");\nfluid.initPhysicalProperties();\ndouble densityCostald = fluid.getPhase(1).getDensity(\"kg/m3\");\nSystem.out.println(\"Costald: \" + densityCostald + \" kg/m\u00b3\");\n</code></pre>"},{"location":"physical_properties/density_models/#tuning-liquid-density","title":"Tuning Liquid Density","text":"<pre><code>// Create fluid with known experimental density\nSystemInterface fluid = new SystemSrkEos(293.15, 1.01325);\nfluid.addComponent(\"n-hexane\", 1.0);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\ndouble expDensity = 659.0;  // kg/m\u00b3 at 20\u00b0C\ndouble calcDensity = fluid.getPhase(1).getDensity(\"kg/m3\");\ndouble error = (calcDensity - expDensity) / expDensity * 100;\nSystem.out.println(\"Initial error: \" + error + \"%\");\n\n// Adjust volume correction to match experimental\ndouble molarMass = fluid.getPhase(1).getMolarMass() * 1000;  // kg/kmol\ndouble calcMolarVolume = molarMass / calcDensity;  // m\u00b3/kmol\ndouble expMolarVolume = molarMass / expDensity;    // m\u00b3/kmol\ndouble correction = (calcMolarVolume - expMolarVolume) / 1000;  // m\u00b3/mol\n\nfluid.getPhase(1).getComponent(\"n-hexane\").setVolumeCorrectionConst(correction);\nfluid.initPhysicalProperties();\n\ndouble newDensity = fluid.getPhase(1).getDensity(\"kg/m3\");\nSystem.out.println(\"Tuned density: \" + newDensity + \" kg/m\u00b3\");\n</code></pre>"},{"location":"physical_properties/density_models/#density-vs-temperature","title":"Density vs Temperature","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 10.0);\nfluid.addComponent(\"n-heptane\", 1.0);\nfluid.setMixingRule(\"classic\");\n\ndouble[] temps = {280, 300, 320, 340, 360, 380};\n\nfor (double T : temps) {\n    fluid.setTemperature(T, \"K\");\n\n    ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n    ops.TPflash();\n\n    if (fluid.getPhase(1).getPhaseTypeName().equals(\"oil\")) {\n        fluid.initPhysicalProperties();\n        double rho = fluid.getPhase(1).getDensity(\"kg/m3\");\n        System.out.println(\"T=\" + T + \" K: \u03c1=\" + rho + \" kg/m\u00b3\");\n    }\n}\n</code></pre>"},{"location":"physical_properties/density_models/#high-pressure-density","title":"High-Pressure Density","text":"<pre><code>// Compressed liquid density at high pressure\nSystemInterface fluid = new SystemSrkEos(300.0, 500.0);  // 500 bar\nfluid.addComponent(\"n-decane\", 1.0);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\ndouble rho = fluid.getPhase(0).getDensity(\"kg/m3\");\nSystem.out.println(\"High-P density: \" + rho + \" kg/m\u00b3\");\n\n// For high-pressure liquids, Peneloux may be insufficient\n// Consider using PC-SAFT or adjusting correction\n</code></pre>"},{"location":"physical_properties/density_models/#model-selection-guide","title":"Model Selection Guide","text":"Situation Recommended Model Notes General hydrocarbons Peneloux Default, good accuracy Near saturation Costald Better for sat. liquids Polar compounds PC-SAFT or CPA Better fundamental basis High pressure Peneloux with tuning May need adjustment Critical region GERG-2008 If available Quick estimate EoS only 5-15% error typical"},{"location":"physical_properties/density_models/#expected-accuracy","title":"Expected Accuracy","text":"Method Liquid Density Error Vapor Density Error SRK (no correction) 5-15% 1-3% SRK + Peneloux 1-3% 1-3% PR (no correction) 3-10% 1-3% PR + Peneloux 1-3% 1-3% Costald 1-2% N/A GERG-2008 0.1-0.5% 0.1-0.5%"},{"location":"physical_properties/density_models/#api-reference","title":"API Reference","text":""},{"location":"physical_properties/density_models/#setting-density-model","title":"Setting Density Model","text":"<pre><code>// Set density model for all phases\nfluid.setDensityModel(\"Peneloux\");  // or \"Costald\"\n\n// The model affects initPhysicalProperties() calls\nfluid.initPhysicalProperties();\n</code></pre>"},{"location":"physical_properties/density_models/#accessing-density","title":"Accessing Density","text":"<pre><code>// Mass density\ndouble rhoMass = phase.getDensity(\"kg/m3\");\ndouble rhoMass2 = phase.getDensity(\"lb/ft3\");\n\n// Molar density\ndouble rhoMolar = phase.getDensity(\"mol/m3\");\n\n// Molar volume\ndouble Vm = phase.getMolarVolume();  // m\u00b3/mol\n</code></pre>"},{"location":"physical_properties/density_models/#volume-correction-parameters","title":"Volume Correction Parameters","text":"<pre><code>// Get/set volume correction constant\ndouble c = component.getVolumeCorrectionConst();\ncomponent.setVolumeCorrectionConst(newValue);\n\n// Get Rackett parameter\ndouble Zra = component.getRacketZ();\n</code></pre>"},{"location":"physical_properties/density_models/#references","title":"References","text":"<ol> <li>Peneloux, A., Rauzy, E., Freze, R. (1982). A Consistent Correction for Redlich-Kwong-Soave Volumes. Fluid Phase Equilib.</li> <li>Hankinson, R.W., Thomson, G.H. (1979). A New Correlation for Saturated Densities of Liquids and Their Mixtures. AIChE J.</li> <li>Rackett, H.G. (1970). Equation of State for Saturated Liquids. J. Chem. Eng. Data.</li> <li>Spencer, C.F., Danner, R.P. (1972). Improved Equation for Prediction of Saturated Liquid Density. J. Chem. Eng. Data.</li> <li>Jhaveri, B.S., Youngren, G.K. (1988). Three-Parameter Modification of the Peng-Robinson Equation of State. SPE Reservoir Eng.</li> </ol>"},{"location":"physical_properties/diffusivity_models/","title":"Diffusivity Models","text":"<p>This guide documents the diffusion coefficient calculation methods available in NeqSim for gas and liquid systems.</p>"},{"location":"physical_properties/diffusivity_models/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Types of Diffusion Coefficients</li> <li>Available Models</li> <li>Wilke-Lee (Gases)</li> <li>Siddiqi-Lucas (Liquids)</li> <li>Corresponding States (CSP)</li> <li>Amine Diffusivity</li> <li>Model Selection Guide</li> <li>Usage Examples</li> </ul>"},{"location":"physical_properties/diffusivity_models/#overview","title":"Overview","text":"<p>Diffusion coefficients describe the rate of molecular transport due to concentration gradients. They are essential for: - Mass transfer calculations - Absorption/desorption modeling - Reaction kinetics in multiphase systems - Pipeline corrosion modeling</p> <p>Units: - Default output: m\u00b2/s</p> <p>Setting a diffusivity model: <pre><code>fluid.initPhysicalProperties();\nfluid.getPhase(\"gas\").getPhysicalProperties().setDiffusionCoefficientModel(\"Wilke Lee\");\nfluid.getPhase(\"oil\").getPhysicalProperties().setDiffusionCoefficientModel(\"Siddiqi Lucas\");\n</code></pre></p>"},{"location":"physical_properties/diffusivity_models/#types-of-diffusion-coefficients","title":"Types of Diffusion Coefficients","text":""},{"location":"physical_properties/diffusivity_models/#binary-diffusion-coefficient-d_ij","title":"Binary Diffusion Coefficient (\\(D_{ij}\\))","text":"<p>The diffusion coefficient for species \\(i\\) moving through species \\(j\\) at infinite dilution.</p>"},{"location":"physical_properties/diffusivity_models/#effective-diffusion-coefficient-d_ieff","title":"Effective Diffusion Coefficient (\\(D_i^{eff}\\))","text":"<p>The effective diffusivity of species \\(i\\) in a multicomponent mixture:</p> \\[D_i^{eff} = \\frac{1 - x_i}{\\sum_{j \\neq i} \\frac{x_j}{D_{ij}}}\\]"},{"location":"physical_properties/diffusivity_models/#maxwell-stefan-diffusion-coefficients","title":"Maxwell-Stefan Diffusion Coefficients","text":"<p>The fundamental diffusion coefficients describing molecular interactions, related to Fick diffusion through thermodynamic factors.</p>"},{"location":"physical_properties/diffusivity_models/#available-models","title":"Available Models","text":""},{"location":"physical_properties/diffusivity_models/#wilke-lee-gases","title":"Wilke-Lee (Gases)","text":"<p>The Wilke-Lee method is based on Chapman-Enskog kinetic theory for gases.</p> <p>Class: <code>WilkeLeeDiffusivity</code></p> <p>Equation: $\\(D_{ij} = \\frac{(1.084 - 0.249\\sqrt{1/M_i + 1/M_j}) \\times 10^{-4} T^{1.5} \\sqrt{1/M_i + 1/M_j}}{P \\sigma_{ij}^2 \\Omega_D}\\)$</p> <p>where: - \\(T\\) is temperature (K) - \\(P\\) is pressure (bar) - \\(M_i, M_j\\) are molar masses (g/mol) - \\(\\sigma_{ij}\\) is the Lennard-Jones collision diameter (\u00c5) - \\(\\Omega_D\\) is the collision integral</p> <p>Collision diameter combining rule: $\\(\\sigma_{ij} = \\frac{\\sigma_i + \\sigma_j}{2}\\)$</p> <p>Collision integral approximation: $\\(\\Omega_D = \\frac{A}{(T^*)^B} + \\frac{C}{\\exp(DT^*)} + \\frac{E}{\\exp(FT^*)} + \\frac{G}{\\exp(HT^*)}\\)$</p> <p>where \\(T^* = k_B T / \\epsilon_{ij}\\).</p> <p>Applicable phases: Gas</p> <p>Best for: - Gas-phase binary diffusion - Light gases (H\u2082, CO\u2082, CH\u2084, etc.) - Moderate pressures</p> <p>Usage: <pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setDiffusionCoefficientModel(\"Wilke Lee\");\n</code></pre></p>"},{"location":"physical_properties/diffusivity_models/#siddiqi-lucas-liquids","title":"Siddiqi-Lucas (Liquids)","text":"<p>The Siddiqi-Lucas method is designed for liquid-phase binary diffusion.</p> <p>Class: <code>SiddiqiLucasMethod</code></p> <p>Aqueous systems: $\\(D_{ij} = 2.98 \\times 10^{-7} \\frac{T}{\\eta_j^{1.026} V_i^{0.5473}}\\)$</p> <p>Non-aqueous systems: $\\(D_{ij} = 9.89 \\times 10^{-8} \\frac{T}{\\eta_j^{0.907} V_i^{0.45} V_j^{-0.265}}\\)$</p> <p>where: - \\(T\\) is temperature (K) - \\(\\eta_j\\) is solvent viscosity (cP) - \\(V_i, V_j\\) are molar volumes at normal boiling point (cm\u00b3/mol)</p> <p>Applicable phases: Liquid (aqueous and organic)</p> <p>Best for: - Liquid-phase diffusion - Aqueous and organic solvents - Dilute solutions</p> <p>Usage: <pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setDiffusionCoefficientModel(\"Siddiqi Lucas\");\n</code></pre></p>"},{"location":"physical_properties/diffusivity_models/#corresponding-states-csp","title":"Corresponding States (CSP)","text":"<p>A generalized corresponding states method for both gas and liquid diffusion.</p> <p>Class: <code>CorrespondingStatesDiffusivity</code></p> <p>Principle: Uses reduced temperature and density to correlate diffusion:</p> \\[D^* = D \\cdot \\frac{\\sigma^2}{(M/N_A) \\sqrt{k_B T / M}}\\] <p>The reduced diffusivity is correlated against reduced temperature and density.</p> <p>Applicable phases: Gas, Liquid</p> <p>Best for: - Wide temperature/pressure ranges - When specific models aren't available - Consistent with thermodynamic model</p> <p>Usage: <pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setDiffusionCoefficientModel(\"CSP\");\n</code></pre></p>"},{"location":"physical_properties/diffusivity_models/#amine-diffusivity","title":"Amine Diffusivity","text":"<p>Specialized correlations for amine solutions used in gas treating.</p> <p>Class: <code>AmineDiffusivity</code></p> <p>Includes: - CO\u2082 in amine solutions - H\u2082S in amine solutions - Amine in water</p> <p>Applicable phases: Aqueous amine solutions</p> <p>Best for: - Gas sweetening processes - Amine regeneration - CO\u2082 capture</p> <p>Usage: <pre><code>fluid.getPhase(\"aqueous\").getPhysicalProperties()\n    .setDiffusionCoefficientModel(\"Alkanol amine\");\n</code></pre></p>"},{"location":"physical_properties/diffusivity_models/#model-selection-guide","title":"Model Selection Guide","text":"Application Recommended Model Notes Gas phase Wilke Lee Based on kinetic theory Aqueous liquids Siddiqi Lucas Validated for water Organic liquids Siddiqi Lucas Use non-aqueous correlation Wide P-T range CSP Corresponding states Amine systems Alkanol amine Specialized for gas treating CO\u2082 in water CO2water model Specific correlation"},{"location":"physical_properties/diffusivity_models/#usage-examples","title":"Usage Examples","text":""},{"location":"physical_properties/diffusivity_models/#accessing-binary-diffusion-coefficients","title":"Accessing Binary Diffusion Coefficients","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create and flash fluid\nSystemInterface fluid = new SystemSrkEos(300.0, 10.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"ethane\", 0.05);\nfluid.addComponent(\"CO2\", 0.05);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Initialize physical properties\nfluid.initPhysicalProperties();\n\n// Get binary diffusion coefficients\ndouble[][] Dij = fluid.getPhase(\"gas\").getPhysicalProperties()\n    .getDiffusivityCalc().getBinaryDiffusionCoefficients();\n\n// Print diffusion matrix\nint n = fluid.getPhase(\"gas\").getNumberOfComponents();\nfor (int i = 0; i &lt; n; i++) {\n    for (int j = 0; j &lt; n; j++) {\n        System.out.println(\"D[\" + i + \"][\" + j + \"] = \" + Dij[i][j] + \" m\u00b2/s\");\n    }\n}\n</code></pre>"},{"location":"physical_properties/diffusivity_models/#effective-diffusivity","title":"Effective Diffusivity","text":"<pre><code>// Get effective diffusion coefficient\ndouble[] Deff = fluid.getPhase(\"gas\").getPhysicalProperties()\n    .getDiffusivityCalc().getEffectiveDiffusionCoefficient();\n\nfor (int i = 0; i &lt; n; i++) {\n    String name = fluid.getPhase(\"gas\").getComponent(i).getName();\n    System.out.println(\"D_eff[\" + name + \"] = \" + Deff[i] + \" m\u00b2/s\");\n}\n</code></pre>"},{"location":"physical_properties/diffusivity_models/#comparing-gas-and-liquid-diffusivity","title":"Comparing Gas and Liquid Diffusivity","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"CO2\", 0.1);\nfluid.addComponent(\"n-octane\", 0.9);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\n// Compare gas and liquid diffusivities\nif (fluid.hasPhaseType(\"gas\")) {\n    double[][] Dgas = fluid.getPhase(\"gas\").getPhysicalProperties()\n        .getDiffusivityCalc().getBinaryDiffusionCoefficients();\n    System.out.println(\"Gas D_CO2-octane: \" + Dgas[0][1] + \" m\u00b2/s\");\n}\n\nif (fluid.hasPhaseType(\"oil\")) {\n    double[][] Dliq = fluid.getPhase(\"oil\").getPhysicalProperties()\n        .getDiffusivityCalc().getBinaryDiffusionCoefficients();\n    System.out.println(\"Liquid D_CO2-octane: \" + Dliq[0][1] + \" m\u00b2/s\");\n}\n// Gas diffusivity is typically 10,000x larger than liquid\n</code></pre>"},{"location":"physical_properties/diffusivity_models/#diffusivity-in-amine-solutions","title":"Diffusivity in Amine Solutions","text":"<pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(313.15, 1.0);\nfluid.addComponent(\"CO2\", 0.1);\nfluid.addComponent(\"water\", 0.7);\nfluid.addComponent(\"MDEA\", 0.2);\nfluid.setMixingRule(10);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Use amine-specific diffusivity model\nfluid.initPhysicalProperties(\"AMINE\");\n\ndouble[][] D = fluid.getPhase(\"aqueous\").getPhysicalProperties()\n    .getDiffusivityCalc().getBinaryDiffusionCoefficients();\n\nSystem.out.println(\"D_CO2 in amine: \" + D[0][1] + \" m\u00b2/s\");\n</code></pre>"},{"location":"physical_properties/diffusivity_models/#physical-background","title":"Physical Background","text":""},{"location":"physical_properties/diffusivity_models/#pressure-dependence","title":"Pressure Dependence","text":"<p>Gases: $\\(D \\propto \\frac{1}{P}\\)$</p> <p>At constant temperature, gas diffusivity is inversely proportional to pressure.</p> <p>Liquids: Weak pressure dependence; can often be neglected.</p>"},{"location":"physical_properties/diffusivity_models/#temperature-dependence","title":"Temperature Dependence","text":"<p>Gases: $\\(D \\propto T^{1.5}\\)$</p> <p>Liquids: $\\(D \\propto T / \\eta\\)$</p> <p>Since viscosity decreases with temperature, liquid diffusivity increases.</p>"},{"location":"physical_properties/diffusivity_models/#typical-values","title":"Typical Values","text":"Phase Diffusivity Range Gas (1 bar) 10\u207b\u2075 to 10\u207b\u2074 m\u00b2/s Gas (100 bar) 10\u207b\u2077 to 10\u207b\u2076 m\u00b2/s Liquid 10\u207b\u00b9\u2070 to 10\u207b\u2079 m\u00b2/s Supercritical 10\u207b\u2078 to 10\u207b\u2077 m\u00b2/s"},{"location":"physical_properties/diffusivity_models/#multicomponent-diffusion","title":"Multicomponent Diffusion","text":"<p>For multicomponent systems, the flux of species \\(i\\) depends on gradients of all components:</p> \\[J_i = -c_t \\sum_{j=1}^{n} D_{ij} \\nabla x_j\\] <p>NeqSim calculates: 1. Binary Maxwell-Stefan coefficients from pure component properties 2. Effective diffusivities using the Wilke approximation 3. Fick diffusion matrix (optional) including thermodynamic factors</p>"},{"location":"physical_properties/diffusivity_models/#references","title":"References","text":"<ol> <li>Wilke, C.R., Lee, C.Y. (1955). Estimation of Diffusion Coefficients for Gases and Vapors. I&amp;EC.</li> <li>Siddiqi, M.A., Lucas, K. (1986). Correlations for Prediction of Diffusion in Liquids. Can. J. Chem. Eng.</li> <li>Fuller, E.N., et al. (1966). New Method for Prediction of Binary Gas-Phase Diffusion Coefficients. I&amp;EC.</li> <li>Poling, B.E., et al. (2001). The Properties of Gases and Liquids, 5<sup>th</sup> Ed.</li> </ol>"},{"location":"physical_properties/interfacial_properties/","title":"Interfacial Properties","text":"<p>This guide documents the interfacial property calculations available in NeqSim, including surface tension and related phenomena.</p>"},{"location":"physical_properties/interfacial_properties/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Surface Tension Models</li> <li>Parachor (Macleod-Sugden)</li> <li>Gradient Theory (GT)</li> <li>Linear Gradient Theory (LGT)</li> <li>Firozabadi-Ramley</li> <li>Model Selection by Interface Type</li> <li>Usage Examples</li> <li>Adsorption Calculations</li> <li>Mathematical Background</li> </ul>"},{"location":"physical_properties/interfacial_properties/#overview","title":"Overview","text":"<p>Interfacial tension (IFT) describes the energy required to create a unit area of interface between two phases. It is critical for: - Capillary pressure calculations - Droplet/bubble formation - Mass transfer at interfaces - Enhanced oil recovery studies - Separator design</p> <p>Units: - Default output: N/m (Newtons per meter) - Alternative: mN/m (milliNewtons per meter = dyne/cm)</p> <p>Basic usage: <pre><code>fluid.initPhysicalProperties();\ndouble sigma = fluid.getInterphaseProperties().getSurfaceTension(0, 1);  // N/m\n</code></pre></p>"},{"location":"physical_properties/interfacial_properties/#surface-tension-models","title":"Surface Tension Models","text":""},{"location":"physical_properties/interfacial_properties/#parachor-macleod-sugden","title":"Parachor (Macleod-Sugden)","text":"<p>The Parachor method is an empirical correlation relating surface tension to density difference and component parachors.</p> <p>Class: <code>ParachorSurfaceTension</code></p> <p>Equation: $\\(\\sigma^{1/4} = \\sum_i P_i \\left( \\frac{\\rho_L x_i}{M_{mix,L}} - \\frac{\\rho_V y_i}{M_{mix,V}} \\right)\\)$</p> <p>where: - \\(P_i\\) is the parachor of component \\(i\\) (from COMP database) - \\(\\rho\\) is molar density (mol/m\u00b3) - \\(x_i, y_i\\) are liquid and vapor mole fractions - \\(M_{mix}\\) is mixture molar mass</p> <p>Parachor values: - Stored in COMP database as <code>PARACHOR</code> column - For CPA models, use <code>PARACHOR_CPA</code></p> <p>Applicable interfaces: Gas-liquid, Gas-aqueous</p> <p>Best for: - Hydrocarbon systems - Quick estimates - When parachor values are available</p> <p>Usage: <pre><code>fluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"oil\", \"Parachor\");\n</code></pre></p>"},{"location":"physical_properties/interfacial_properties/#gradient-theory-gt","title":"Gradient Theory (GT)","text":"<p>The Gradient Theory is a rigorous thermodynamic approach based on density functional theory.</p> <p>Classes: - <code>GTSurfaceTension</code> - Full gradient theory (most rigorous) - <code>GTSurfaceTensionSimple</code> - Simplified version - <code>GTSurfaceTensionODE</code> - ODE-based solver</p> <p>Physical basis:</p> <p>Near an interface, the Helmholtz energy depends on density gradients:</p> \\[A = \\int_{-\\infty}^{\\infty} \\left[ a_0(\\boldsymbol{n}) + \\frac{1}{2}\\sum_i\\sum_j c_{ij} \\frac{dn_i}{dz}\\frac{dn_j}{dz} \\right] dz\\] <p>where: - \\(a_0\\) is the homogeneous fluid Helmholtz energy - \\(c_{ij}\\) are the influence parameters - \\(n_i\\) is the number density of component \\(i\\) - \\(z\\) is the spatial coordinate</p> <p>Surface tension calculation: $\\(\\sigma = \\int_{-\\infty}^{\\infty} \\sum_i\\sum_j c_{ij} \\frac{dn_i}{dz}\\frac{dn_j}{dz} dz\\)$</p> <p>Influence parameter correlation: $\\(c_i = (A_i t_i + B_i) a_i b_i^{2/3}\\)$</p> <p>where: - \\(t_i = 1 - T/T_{c,i}\\) - \\(a_i, b_i\\) are EoS parameters - \\(A_i, B_i\\) are component-specific constants</p> <p>Applicable interfaces: All phase pairs</p> <p>Best for: - High accuracy requirements - Near-critical conditions - When EoS is well-calibrated</p> <p>Usage: <pre><code>// Full gradient theory\nfluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"oil\", \"Full Gradient Theory\");\n\n// Simplified version (faster)\nfluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"oil\", \"Simple Gradient Theory\");\n</code></pre></p>"},{"location":"physical_properties/interfacial_properties/#linear-gradient-theory-lgt","title":"Linear Gradient Theory (LGT)","text":"<p>A linearized approximation of gradient theory that is computationally efficient.</p> <p>Class: <code>LGTSurfaceTension</code></p> <p>Approximation: Assumes linear density profile between bulk phases:</p> \\[n_i(z) = n_i^L + \\frac{n_i^V - n_i^L}{L} z\\] <p>This allows analytical integration:</p> \\[\\sigma = \\sum_i\\sum_j c_{ij} \\frac{(n_i^V - n_i^L)(n_j^V - n_j^L)}{L}\\] <p>where \\(L\\) is optimized to minimize Helmholtz energy.</p> <p>Applicable interfaces: Gas-liquid</p> <p>Best for: - Balance of accuracy and speed - Parametric studies - When full GT is too slow</p> <p>Usage: <pre><code>fluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"oil\", \"Linear Gradient Theory\");\n</code></pre></p>"},{"location":"physical_properties/interfacial_properties/#firozabadi-ramley","title":"Firozabadi-Ramley","text":"<p>A correlation specifically designed for liquid-liquid interfaces (oil-water).</p> <p>Class: <code>FirozabadiRamleyInterfaceTension</code></p> <p>Equation: $\\(\\sigma_{ow} = \\sigma_o + \\sigma_w - 2\\sqrt{\\sigma_o \\sigma_w} \\phi\\)$</p> <p>where: - \\(\\sigma_o, \\sigma_w\\) are oil and water surface tensions - \\(\\phi\\) is an interaction parameter</p> <p>Applicable interfaces: Oil-water (liquid-liquid)</p> <p>Best for: - Oil-water systems - When aqueous phase is present - Three-phase systems</p> <p>Usage: <pre><code>fluid.getInterphaseProperties().setInterfacialTensionModel(\"oil\", \"aqueous\", \"Firozabadi Ramley\");\n</code></pre></p>"},{"location":"physical_properties/interfacial_properties/#model-selection-by-interface-type","title":"Model Selection by Interface Type","text":"<p>NeqSim automatically selects models based on phase types, but you can override:</p>"},{"location":"physical_properties/interfacial_properties/#using-model-numbers","title":"Using Model Numbers","text":"<pre><code>// Set interfacial tension model set by number\nfluid.getInterphaseProperties().setInterfacialTensionModel(0);  // Default set\n</code></pre> Number Gas-Oil Gas-Aqueous Oil-Aqueous 0 Parachor Parachor Firozabadi-Ramley 1 Full GT Simple GT Simple GT 2 LGT LGT LGT 3 Parachor Parachor Firozabadi-Ramley 4 Simple GT Parachor LGT 5 Parachor Parachor Firozabadi-Ramley"},{"location":"physical_properties/interfacial_properties/#using-named-models","title":"Using Named Models","text":"<pre><code>// Set specific models per interface\nfluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"oil\", \"Full Gradient Theory\");\nfluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"aqueous\", \"Parachor\");\nfluid.getInterphaseProperties().setInterfacialTensionModel(\"oil\", \"aqueous\", \"Firozabadi Ramley\");\n</code></pre> <p>Available model names: - <code>\"Parachor\"</code> or <code>\"Weinaug-Katz\"</code> - <code>\"Full Gradient Theory\"</code> - <code>\"Simple Gradient Theory\"</code> - <code>\"Linear Gradient Theory\"</code> - <code>\"Firozabadi Ramley\"</code></p>"},{"location":"physical_properties/interfacial_properties/#usage-examples","title":"Usage Examples","text":""},{"location":"physical_properties/interfacial_properties/#basic-surface-tension","title":"Basic Surface Tension","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create and flash fluid\nSystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"n-decane\", 0.2);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Initialize physical properties\nfluid.initPhysicalProperties();\n\n// Get surface tension between phase 0 and 1\ndouble sigma = fluid.getInterphaseProperties().getSurfaceTension(0, 1);\nSystem.out.println(\"Surface tension: \" + sigma * 1000 + \" mN/m\");\n</code></pre>"},{"location":"physical_properties/interfacial_properties/#comparing-surface-tension-models","title":"Comparing Surface Tension Models","text":"<pre><code>String[] models = {\"Parachor\", \"Full Gradient Theory\", \"Linear Gradient Theory\"};\n\nSystemInterface baseFluid = createTwoPhaseFluid();\nThermodynamicOperations ops = new ThermodynamicOperations(baseFluid);\nops.TPflash();\nbaseFluid.initPhysicalProperties();\n\nfor (String model : models) {\n    SystemInterface fluid = baseFluid.clone();\n    fluid.getInterphaseProperties().setInterfacialTensionModel(\"gas\", \"oil\", model);\n    fluid.initPhysicalProperties();\n\n    double sigma = fluid.getInterphaseProperties().getSurfaceTension(0, 1) * 1000;\n    System.out.println(model + \": \" + sigma + \" mN/m\");\n}\n</code></pre>"},{"location":"physical_properties/interfacial_properties/#surface-tension-vs-pressure-approaching-critical","title":"Surface Tension vs Pressure (Approaching Critical)","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(350.0, 10.0);\nfluid.addComponent(\"methane\", 0.5);\nfluid.addComponent(\"n-pentane\", 0.5);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\ndouble[] pressures = {10, 30, 50, 70, 90, 100, 110};\n\nfor (double P : pressures) {\n    fluid.setPressure(P, \"bar\");\n\n    ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n    ops.TPflash();\n\n    if (fluid.getNumberOfPhases() &gt;= 2) {\n        fluid.initPhysicalProperties();\n        double sigma = fluid.getInterphaseProperties().getSurfaceTension(0, 1) * 1000;\n        System.out.println(\"P=\" + P + \" bar: \u03c3=\" + sigma + \" mN/m\");\n    } else {\n        System.out.println(\"P=\" + P + \" bar: Single phase\");\n    }\n}\n// Surface tension approaches zero at critical point\n</code></pre>"},{"location":"physical_properties/interfacial_properties/#three-phase-system","title":"Three-Phase System","text":"<pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(300.0, 30.0);\nfluid.addComponent(\"methane\", 0.6);\nfluid.addComponent(\"n-heptane\", 0.3);\nfluid.addComponent(\"water\", 0.1);\nfluid.setMixingRule(10);\nfluid.setMultiPhaseCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\n// Get all interfacial tensions\nint nPhases = fluid.getNumberOfPhases();\nfor (int i = 0; i &lt; nPhases; i++) {\n    for (int j = i + 1; j &lt; nPhases; j++) {\n        double sigma = fluid.getInterphaseProperties().getSurfaceTension(i, j);\n        System.out.println(\"Phase \" + i + \" - Phase \" + j + \": \" + \n            sigma * 1000 + \" mN/m\");\n    }\n}\n</code></pre>"},{"location":"physical_properties/interfacial_properties/#adsorption-calculations","title":"Adsorption Calculations","text":"<p>NeqSim also supports adsorption calculations at solid surfaces.</p>"},{"location":"physical_properties/interfacial_properties/#setup","title":"Setup","text":"<pre><code>// Initialize adsorption\nfluid.getInterphaseProperties().initAdsorption();\n\n// Set adsorbent material\nfluid.getInterphaseProperties().setSolidAdsorbentMaterial(\"ite\");\n\n// Calculate adsorption\nfluid.getInterphaseProperties().calcAdsorption();\n</code></pre>"},{"location":"physical_properties/interfacial_properties/#access-results","title":"Access Results","text":"<pre><code>AdsorptionInterface ads = fluid.getInterphaseProperties().getAdsorptionCalc(\"gas\");\n// Access adsorption quantities per component\n</code></pre>"},{"location":"physical_properties/interfacial_properties/#mathematical-background","title":"Mathematical Background","text":""},{"location":"physical_properties/interfacial_properties/#thermodynamic-definition","title":"Thermodynamic Definition","text":"<p>Surface tension is defined as:</p> \\[\\sigma = \\left( \\frac{\\partial G}{\\partial A} \\right)_{T,P,n}\\] <p>where \\(G\\) is Gibbs energy and \\(A\\) is interfacial area.</p>"},{"location":"physical_properties/interfacial_properties/#young-laplace-equation","title":"Young-Laplace Equation","text":"<p>The pressure difference across a curved interface:</p> \\[\\Delta P = \\sigma \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)\\] <p>where \\(R_1, R_2\\) are the principal radii of curvature.</p>"},{"location":"physical_properties/interfacial_properties/#temperature-dependence","title":"Temperature Dependence","text":"<p>Surface tension typically decreases with temperature:</p> \\[\\sigma = \\sigma_0 \\left( 1 - T/T_c \\right)^n\\] <p>where \\(n \\approx 1.26\\) (Guggenheim exponent).</p> <p>At the critical point: \\(\\sigma \\rightarrow 0\\).</p>"},{"location":"physical_properties/interfacial_properties/#pressure-dependence","title":"Pressure Dependence","text":"<p>Surface tension generally decreases with increasing pressure because: 1. Density difference decreases 2. Phases become more similar as pressure increases</p> <p>Near the critical point, \\(\\sigma \\propto (\\rho_L - \\rho_V)^{3.9}\\).</p>"},{"location":"physical_properties/interfacial_properties/#typical-values","title":"Typical Values","text":"Interface Temperature Typical IFT Methane-Water 25\u00b0C, 100 bar 50-70 mN/m Crude Oil-Gas Reservoir 5-30 mN/m Crude Oil-Water 25\u00b0C 20-30 mN/m n-Hexane-Air 25\u00b0C 18 mN/m Water-Air 25\u00b0C 72 mN/m Near critical - 0-1 mN/m"},{"location":"physical_properties/interfacial_properties/#references","title":"References","text":"<ol> <li>Macleod, D.B. (1923). On a Relation between Surface Tension and Density. Trans. Faraday Soc.</li> <li>Sugden, S. (1924). The Variation of Surface Tension with Temperature and Some Related Functions. J. Chem. Soc.</li> <li>Cahn, J.W., Hilliard, J.E. (1958). Free Energy of a Nonuniform System. J. Chem. Phys.</li> <li>Miqueu, C., et al. (2004). Modelling of the Surface Tension of Pure Components with the Gradient Theory. Fluid Phase Equilib.</li> <li>Firozabadi, A., Ramey, H.J. (1988). Surface Tension of Water-Hydrocarbon Systems at Reservoir Conditions. JCPT.</li> </ol>"},{"location":"physical_properties/thermal_conductivity_models/","title":"Thermal Conductivity Models","text":"<p>This guide documents the thermal conductivity calculation methods available in NeqSim for gas, liquid, and multiphase systems.</p>"},{"location":"physical_properties/thermal_conductivity_models/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Available Models</li> <li>PFCT (Pedersen)</li> <li>Chung Method</li> <li>Polynomial Correlation</li> <li>CO\u2082 Reference</li> <li>Model Selection Guide</li> <li>Usage Examples</li> </ul>"},{"location":"physical_properties/thermal_conductivity_models/#overview","title":"Overview","text":"<p>Thermal conductivity (\\(\\lambda\\) or \\(k\\)) describes a material's ability to conduct heat. It is essential for: - Heat exchanger design - Pipeline heat loss calculations - Thermal simulation of process equipment</p> <p>Units: - Default output: W/(m\u00b7K) (Watts per meter-Kelvin)</p> <p>Setting a conductivity model: <pre><code>fluid.initPhysicalProperties();\nfluid.getPhase(\"gas\").getPhysicalProperties().setConductivityModel(\"Chung\");\nfluid.getPhase(\"oil\").getPhysicalProperties().setConductivityModel(\"PFCT\");\n</code></pre></p>"},{"location":"physical_properties/thermal_conductivity_models/#available-models","title":"Available Models","text":""},{"location":"physical_properties/thermal_conductivity_models/#pfct-pedersen","title":"PFCT (Pedersen)","text":"<p>The Pedersen Corresponding States method uses methane as a reference fluid with molecular weight corrections.</p> <p>Class: <code>PFCTConductivityMethodMod86</code></p> <p>Principle: Uses corresponding states with methane as reference:</p> \\[\\lambda_{mix} = \\lambda_{ref}(T_0, P_0) \\cdot \\frac{\\alpha_{mix}}{\\alpha_0}\\] <p>where: - \\(\\lambda_{ref}\\) is methane thermal conductivity at corresponding conditions - \\(T_0, P_0\\) are the corresponding temperature and pressure - \\(\\alpha\\) are molecular weight correction factors</p> <p>Corresponding state mapping: $\\(T_0 = T \\cdot \\frac{T_{c,ref}}{T_{c,mix}} \\cdot \\frac{\\alpha_0}{\\alpha_{mix}}\\)$</p> \\[P_0 = P \\cdot \\frac{P_{c,ref}}{P_{c,mix}} \\cdot \\frac{\\alpha_0}{\\alpha_{mix}}\\] <p>Applicable phases: Gas, Oil</p> <p>Best for: - Petroleum mixtures - Wide pressure-temperature ranges - Systems with characterized fractions</p> <p>Usage: <pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setConductivityModel(\"PFCT\");\n</code></pre></p>"},{"location":"physical_properties/thermal_conductivity_models/#chung-method","title":"Chung Method","text":"<p>The Chung method (1988) is a corresponding states correlation based on kinetic theory.</p> <p>Class: <code>ChungConductivityMethod</code></p> <p>Equation (dilute gas): $\\(\\lambda_0 = \\frac{7.452 \\eta_0 \\Psi}{M}\\)$</p> <p>where: - \\(\\eta_0\\) is the dilute gas viscosity - \\(\\Psi\\) is a correction factor - \\(M\\) is molar mass</p> <p>The correction factor accounts for: - Polyatomic structure - Polar effects - Association</p> <p>Dense fluid correction: $\\(\\lambda = \\lambda_0 \\cdot G_2(T^*, \\rho^*) + B_1 q B_2\\)$</p> <p>where \\(G_2\\) and \\(B\\) terms account for density effects.</p> <p>Applicable phases: Primarily gas phase</p> <p>Best for: - Gas-phase calculations - Polar gases - As baseline correlation</p> <p>Usage: <pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setConductivityModel(\"Chung\");\n</code></pre></p>"},{"location":"physical_properties/thermal_conductivity_models/#polynomial-correlation","title":"Polynomial Correlation","text":"<p>Uses component-specific polynomial coefficients from the database.</p> <p>Class: <code>Conductivity</code> (in liquid package)</p> <p>Equation: $\\(\\lambda = A + BT + CT^2\\)$</p> <p>where A, B, C are component-specific parameters.</p> <p>Database columns: <code>LIQUIDCONDUCTIVITY1</code>, <code>LIQUIDCONDUCTIVITY2</code>, <code>LIQUIDCONDUCTIVITY3</code></p> <p>Mixing rule: $\\(\\lambda_{mix} = \\sum_i x_i \\lambda_i\\)$</p> <p>Applicable phases: Liquid</p> <p>Best for: - Pure components with available parameters - Simple liquid mixtures</p> <p>Usage: <pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setConductivityModel(\"polynom\");\n</code></pre></p>"},{"location":"physical_properties/thermal_conductivity_models/#co2-reference","title":"CO\u2082 Reference","text":"<p>High-accuracy thermal conductivity for CO\u2082 based on the Vesovic et al. correlation.</p> <p>Class: <code>CO2ConductivityMethod</code></p> <p>Coverage: - Temperature: 200-1500 K - Pressure: Up to 300 MPa - All phases (gas, liquid, supercritical)</p> <p>Best for: - Pure CO\u2082 systems - CCS applications - Reference calculations</p> <p>Usage: <pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setConductivityModel(\"CO2Model\");\n</code></pre></p>"},{"location":"physical_properties/thermal_conductivity_models/#model-selection-guide","title":"Model Selection Guide","text":"Application Recommended Model Notes Petroleum mixtures PFCT Corresponding states with MW correction Gas processing Chung Good for gases Simple liquid mixtures polynom Uses database parameters Pure CO\u2082 CO2Model High accuracy Wide P-T range PFCT Robust extrapolation Polar systems Chung Includes polar corrections"},{"location":"physical_properties/thermal_conductivity_models/#usage-examples","title":"Usage Examples","text":""},{"location":"physical_properties/thermal_conductivity_models/#basic-conductivity-calculation","title":"Basic Conductivity Calculation","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create and flash fluid\nSystemInterface fluid = new SystemSrkEos(350.0, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Initialize physical properties\nfluid.initPhysicalProperties();\n\n// Get thermal conductivity\ndouble gasConductivity = fluid.getPhase(\"gas\").getThermalConductivity(\"W/mK\");\nSystem.out.println(\"Gas thermal conductivity: \" + gasConductivity + \" W/(m\u00b7K)\");\n</code></pre>"},{"location":"physical_properties/thermal_conductivity_models/#comparing-conductivity-models","title":"Comparing Conductivity Models","text":"<pre><code>String[] models = {\"PFCT\", \"Chung\"};\n\nfor (String model : models) {\n    SystemInterface fluid = createFluid();\n    ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n    ops.TPflash();\n    fluid.initPhysicalProperties();\n\n    fluid.getPhase(\"gas\").getPhysicalProperties().setConductivityModel(model);\n    fluid.initPhysicalProperties();\n\n    double k = fluid.getPhase(\"gas\").getThermalConductivity(\"W/mK\");\n    System.out.println(model + \": \" + k + \" W/(m\u00b7K)\");\n}\n</code></pre>"},{"location":"physical_properties/thermal_conductivity_models/#conductivity-vs-pressure","title":"Conductivity vs Pressure","text":"<pre><code>SystemInterface baseFluid = new SystemSrkEos(350.0, 10.0);\nbaseFluid.addComponent(\"methane\", 1.0);\nbaseFluid.setMixingRule(\"classic\");\n\ndouble[] pressures = {10, 50, 100, 150, 200};  // bar\n\nfor (double P : pressures) {\n    SystemInterface fluid = baseFluid.clone();\n    fluid.setPressure(P, \"bar\");\n\n    ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n    ops.TPflash();\n    fluid.initPhysicalProperties();\n\n    double k = fluid.getPhase(0).getThermalConductivity(\"W/mK\");\n    System.out.println(\"P=\" + P + \" bar: \" + k + \" W/(m\u00b7K)\");\n}\n</code></pre>"},{"location":"physical_properties/thermal_conductivity_models/#two-phase-system","title":"Two-Phase System","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(280.0, 30.0);\nfluid.addComponent(\"methane\", 0.5);\nfluid.addComponent(\"n-pentane\", 0.5);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\nif (fluid.hasPhaseType(\"gas\")) {\n    System.out.println(\"Gas k: \" + \n        fluid.getPhase(\"gas\").getThermalConductivity(\"W/mK\") + \" W/(m\u00b7K)\");\n}\nif (fluid.hasPhaseType(\"oil\")) {\n    System.out.println(\"Oil k: \" + \n        fluid.getPhase(\"oil\").getThermalConductivity(\"W/mK\") + \" W/(m\u00b7K)\");\n}\n</code></pre>"},{"location":"physical_properties/thermal_conductivity_models/#physical-background","title":"Physical Background","text":""},{"location":"physical_properties/thermal_conductivity_models/#kinetic-theory-dilute-gas","title":"Kinetic Theory (Dilute Gas)","text":"<p>For dilute gases, thermal conductivity is related to viscosity through:</p> \\[\\lambda = \\frac{f \\cdot \\eta \\cdot C_v}{M}\\] <p>where: - \\(f\\) is the Eucken factor (typically 1.32 for monoatomic, 1.77 for polyatomic) - \\(\\eta\\) is dynamic viscosity - \\(C_v\\) is heat capacity at constant volume - \\(M\\) is molar mass</p>"},{"location":"physical_properties/thermal_conductivity_models/#mixing-rules","title":"Mixing Rules","text":"<p>For mixtures, thermal conductivity is typically calculated using:</p> <p>Mass fraction weighting: $\\(\\lambda_{mix} = \\sum_i w_i \\lambda_i\\)$</p> <p>Molar weighting with interaction: $\\(\\lambda_{mix} = \\sum_i \\sum_j \\frac{x_i x_j \\lambda_{ij}}{\\sum_k x_k \\phi_{ik}}\\)$</p> <p>where \\(\\lambda_{ij}\\) is a combining rule and \\(\\phi_{ik}\\) is an interaction factor.</p>"},{"location":"physical_properties/thermal_conductivity_models/#pressure-effects","title":"Pressure Effects","text":"<p>Thermal conductivity increases with pressure, particularly in dense fluids:</p> <ul> <li>At low pressures: \\(\\lambda \\approx \\lambda_0(T)\\)</li> <li>At high pressures: \\(\\lambda = \\lambda_0 + \\Delta\\lambda(\\rho)\\)</li> </ul> <p>The PFCT method accounts for this through corresponding states mapping to reference fluid behavior.</p>"},{"location":"physical_properties/thermal_conductivity_models/#temperature-and-pressure-dependence","title":"Temperature and Pressure Dependence","text":""},{"location":"physical_properties/thermal_conductivity_models/#gases","title":"Gases","text":"<ul> <li>Conductivity increases with temperature (~\\(T^{0.8}\\))</li> <li>Weak pressure dependence at low-moderate pressures</li> <li>Significant increase at high pressures (dense gas)</li> </ul>"},{"location":"physical_properties/thermal_conductivity_models/#liquids","title":"Liquids","text":"<ul> <li>Conductivity typically decreases with temperature</li> <li>Slight increase with pressure</li> <li>Water is an exception (increases with T up to ~130\u00b0C)</li> </ul>"},{"location":"physical_properties/thermal_conductivity_models/#references","title":"References","text":"<ol> <li>Pedersen, K.S., et al. (1989). Thermal Conductivity of Crude Oils. Chem. Eng. Sci.</li> <li>Chung, T.H., et al. (1988). Generalized Multiparameter Correlation. I&amp;EC Res.</li> <li>Vesovic, V., et al. (1990). The Transport Properties of Carbon Dioxide. J. Phys. Chem. Ref. Data.</li> <li>Poling, B.E., et al. (2001). The Properties of Gases and Liquids, 5<sup>th</sup> Ed.</li> </ol>"},{"location":"physical_properties/viscosity_models/","title":"Viscosity Models","text":"<p>This guide documents the viscosity calculation methods available in NeqSim for gas, liquid, and multiphase systems.</p>"},{"location":"physical_properties/viscosity_models/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Available Models</li> <li>LBC (Lohrenz-Bray-Clark)</li> <li>Friction Theory</li> <li>PFCT (Pedersen)</li> <li>Chung Method</li> <li>Polynomial Correlation</li> <li>Reference Fluid Methods</li> <li>Model Selection Guide</li> <li>Tuning Parameters</li> <li>Usage Examples</li> </ul>"},{"location":"physical_properties/viscosity_models/#overview","title":"Overview","text":"<p>Viscosity describes a fluid's resistance to flow. NeqSim provides several viscosity models suitable for different applications:</p> <p>Units: - Default output: Pa\u00b7s (Pascal-seconds) - Alternative: cP (centipoise), where 1 cP = 0.001 Pa\u00b7s</p> <p>Setting a viscosity model: <pre><code>fluid.initPhysicalProperties();\nfluid.getPhase(\"gas\").getPhysicalProperties().setViscosityModel(\"friction theory\");\nfluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"LBC\");\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#available-models","title":"Available Models","text":""},{"location":"physical_properties/viscosity_models/#lbc-lohrenz-bray-clark","title":"LBC (Lohrenz-Bray-Clark)","text":"<p>The Lohrenz-Bray-Clark (1964) method is widely used in reservoir simulation. It combines a dilute gas correlation with a dense fluid polynomial correction.</p> <p>Class: <code>LBCViscosityMethod</code></p> <p>Equation: $\\(\\eta = \\eta^* + \\frac{(\\eta_r - 0.0001)^4}{\\xi}\\)$</p> <p>where: - \\(\\eta^*\\) is the dilute gas viscosity - \\(\\eta_r\\) is a function of reduced density - \\(\\xi\\) is the inverse viscosity parameter</p> <p>The dense fluid contribution uses a polynomial: $\\(\\eta_r = a_0 + a_1\\rho_r + a_2\\rho_r^2 + a_3\\rho_r^3 + a_4\\rho_r^4\\)$</p> <p>Default parameters: <code>{0.10230, 0.023364, 0.058533, -0.040758, 0.0093324}</code></p> <p>Applicable phases: Gas, Oil</p> <p>Best for: - Reservoir simulation - Light to medium oils - Systems where tuning to lab data is available</p> <p>Usage: <pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"LBC\");\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#friction-theory","title":"Friction Theory","text":"<p>The Qui\u00f1ones-Cisneros and Firoozabadi (2000) friction theory relates viscosity to the repulsive and attractive pressure contributions from the equation of state.</p> <p>Class: <code>FrictionTheoryViscosityMethod</code></p> <p>Equation: $\\(\\eta = \\eta_0 + \\kappa_a P_a + \\kappa_{aa} P_a^2 + \\kappa_r P_r + \\kappa_{rr} P_r^2\\)$</p> <p>where: - \\(\\eta_0\\) is the dilute gas viscosity (Chung correlation) - \\(P_a\\) is the attractive pressure from EoS - \\(P_r\\) is the repulsive pressure from EoS - \\(\\kappa\\) are friction coefficients (EoS-dependent)</p> <p>Applicable phases: Gas, Oil (any EoS-based phase)</p> <p>Best for: - Wide pressure/temperature ranges - Near-critical conditions - When using SRK or PR EoS</p> <p>Automatic EoS detection: The method automatically selects SRK or PR constants based on the phase type.</p> <p>Usage: <pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"friction theory\");\n</code></pre></p> <p>Custom constants (for other EoS): <pre><code>FrictionTheoryViscosityMethod viscModel = \n    (FrictionTheoryViscosityMethod) fluid.getPhase(\"oil\")\n        .getPhysicalProperties().getViscosityModel();\n\n// Set custom friction theory constants\nviscModel.setFrictionTheoryConstants(kapac, kaprc, kaprrc, kapa, kapr, kaprr);\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#pfct-pedersen","title":"PFCT (Pedersen)","text":"<p>The Pedersen Friction Corresponding States Theory uses methane as a reference fluid with shape factors for mixture calculations.</p> <p>Classes: - <code>PFCTViscosityMethodMod86</code> - Standard Pedersen method (1987) - <code>PFCTViscosityMethodHeavyOil</code> - Extended for heavy oils</p> <p>Equation: $\\(\\eta_{mix} = \\eta_{ref} \\cdot \\frac{f_\\eta \\cdot \\alpha_{mix}}{\\alpha_0}\\)$</p> <p>where: - \\(\\eta_{ref}\\) is the reference fluid (methane) viscosity - \\(f_\\eta\\) is the shape factor ratio - \\(\\alpha\\) are molecular weight correction factors</p> <p>Applicable phases: Gas, Oil</p> <p>Best for: - Petroleum mixtures with characterized fractions - Heavy oil systems (use <code>\"PFCT-Heavy-Oil\"</code>) - Wide-range predictions</p> <p>Usage: <pre><code>// Standard Pedersen\nfluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"PFCT\");\n\n// Heavy oil variant\nfluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"PFCT-Heavy-Oil\");\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#chung-method","title":"Chung Method","text":"<p>The Chung method (1984, 1988) is a corresponding states method for dilute gas and dense fluid viscosity.</p> <p>Class: <code>ChungViscosityMethod</code></p> <p>Equation (dilute gas): $\\(\\eta_0 = \\frac{40.785 F_c \\sqrt{M T}}{\\Omega_v V_c^{2/3}}\\)$</p> <p>where: - \\(F_c\\) is the correction factor for polar/associating fluids - \\(\\Omega_v\\) is the collision integral - \\(V_c\\) is critical volume - \\(M\\) is molar mass</p> <p>Applicable phases: Primarily gas phase</p> <p>Best for: - Dilute gas mixtures - Polar gases - As baseline for other methods</p> <p>Usage: <pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setViscosityModel(\"Chung\");\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#polynomial-correlation","title":"Polynomial Correlation","text":"<p>Uses component-specific polynomial coefficients from the database.</p> <p>Class: <code>Viscosity</code> (liquid), <code>GasViscosity</code> (gas)</p> <p>Equation: $\\(\\ln(\\eta) = A + \\frac{B}{T} + C\\ln(T) + DT\\)$</p> <p>where A, B, C, D are component-specific parameters from COMP database.</p> <p>Database columns: <code>LIQVISC1</code>, <code>LIQVISC2</code>, <code>LIQVISC3</code>, <code>LIQVISC4</code></p> <p>Applicable phases: Primarily liquid</p> <p>Best for: - Pure components with available parameters - Simple mixtures with mixing rules</p> <p>Usage: <pre><code>fluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"polynom\");\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#reference-fluid-methods","title":"Reference Fluid Methods","text":"<p>Specialized high-accuracy methods for specific fluids:</p>"},{"location":"physical_properties/viscosity_models/#methane-reference","title":"Methane (Reference)","text":"<p>Class: <code>MethaneViscosityMethod</code> - Uses Setzmann &amp; Wagner reference equation - High accuracy for pure methane - Used as reference in PFCT calculations</p>"},{"location":"physical_properties/viscosity_models/#co2","title":"CO\u2082","text":"<p>Class: <code>CO2ViscosityMethod</code> - Fenghour et al. correlation - Covers gas, liquid, and supercritical regions</p>"},{"location":"physical_properties/viscosity_models/#hydrogen","title":"Hydrogen","text":"<p>Classes: <code>MuznyViscosityMethod</code>, <code>MuznyModViscosityMethod</code> - High-accuracy hydrogen viscosity - Important for hydrogen energy applications</p> <p>Usage: <pre><code>fluid.getPhase(\"gas\").getPhysicalProperties().setViscosityModel(\"MethaneModel\");\nfluid.getPhase(\"gas\").getPhysicalProperties().setViscosityModel(\"CO2Model\");\nfluid.getPhase(\"gas\").getPhysicalProperties().setViscosityModel(\"Muzny\");\n</code></pre></p>"},{"location":"physical_properties/viscosity_models/#model-selection-guide","title":"Model Selection Guide","text":"Application Recommended Model Notes Reservoir simulation LBC Tunable, industry standard Wide P-T range Friction Theory Good near critical Heavy oils PFCT-Heavy-Oil Extended for high MW Characterized crudes PFCT Works with pseudo-components Gas processing Chung Good for gases Pure CO\u2082 CO2Model High accuracy Pure H\u2082 Muzny Reference accuracy Aqueous systems Salt Water Water correlation"},{"location":"physical_properties/viscosity_models/#tuning-parameters","title":"Tuning Parameters","text":""},{"location":"physical_properties/viscosity_models/#lbc-parameter-tuning","title":"LBC Parameter Tuning","text":"<p>The LBC method is commonly tuned to match laboratory viscosity data:</p> <pre><code>// Get current parameters\nLBCViscosityMethod lbc = (LBCViscosityMethod) \n    fluid.getPhase(\"oil\").getPhysicalProperties().getViscosityModel();\n\n// Set all 5 parameters\ndouble[] params = {0.1023, 0.023364, 0.058533, -0.040758, 0.0093324};\nfluid.getPhase(\"oil\").getPhysicalProperties().setLbcParameters(params);\n\n// Or tune individual parameters\nfluid.getPhase(\"oil\").getPhysicalProperties().setLbcParameter(0, 0.105);\n</code></pre> <p>Tuning procedure: 1. Measure viscosity at multiple P-T conditions 2. Run flash and calculate properties 3. Adjust parameters to minimize error 4. Validate at other conditions</p>"},{"location":"physical_properties/viscosity_models/#usage-examples","title":"Usage Examples","text":""},{"location":"physical_properties/viscosity_models/#basic-viscosity-calculation","title":"Basic Viscosity Calculation","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create and flash fluid\nSystemInterface fluid = new SystemSrkEos(350.0, 150.0);\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.addComponent(\"n-heptane\", 0.10);\nfluid.addComponent(\"n-decane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Initialize physical properties\nfluid.initPhysicalProperties();\n\n// Get viscosities\ndouble gasVisc = fluid.getPhase(\"gas\").getViscosity(\"cP\");\ndouble oilVisc = fluid.getPhase(\"oil\").getViscosity(\"cP\");\n\nSystem.out.println(\"Gas viscosity: \" + gasVisc + \" cP\");\nSystem.out.println(\"Oil viscosity: \" + oilVisc + \" cP\");\n</code></pre>"},{"location":"physical_properties/viscosity_models/#comparing-viscosity-models","title":"Comparing Viscosity Models","text":"<pre><code>String[] models = {\"LBC\", \"friction theory\", \"PFCT\"};\n\nfor (String model : models) {\n    SystemInterface fluid = createFluid();\n    ops.TPflash();\n    fluid.initPhysicalProperties();\n\n    fluid.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(model);\n    fluid.initPhysicalProperties();\n\n    double visc = fluid.getPhase(\"oil\").getViscosity(\"cP\");\n    System.out.println(model + \": \" + visc + \" cP\");\n}\n</code></pre>"},{"location":"physical_properties/viscosity_models/#viscosity-vs-temperature","title":"Viscosity vs Temperature","text":"<pre><code>SystemInterface baseFluid = createFluid();\nbaseFluid.initPhysicalProperties();\n\ndouble[] temps = {300, 320, 340, 360, 380, 400};  // K\n\nfor (double T : temps) {\n    SystemInterface fluid = baseFluid.clone();\n    fluid.setTemperature(T, \"K\");\n\n    ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n    ops.TPflash();\n    fluid.initPhysicalProperties();\n\n    double visc = fluid.getPhase(\"oil\").getViscosity(\"cP\");\n    System.out.println(\"T=\" + (T-273.15) + \"\u00b0C: \" + visc + \" cP\");\n}\n</code></pre>"},{"location":"physical_properties/viscosity_models/#mathematical-details","title":"Mathematical Details","text":""},{"location":"physical_properties/viscosity_models/#dilute-gas-viscosity-chapman-enskog","title":"Dilute Gas Viscosity (Chapman-Enskog)","text":"<p>For dilute gases, viscosity is calculated from kinetic theory:</p> \\[\\eta_0 = \\frac{5}{16} \\frac{\\sqrt{\\pi m k_B T}}{\\pi \\sigma^2 \\Omega^{(2,2)*}}\\] <p>where: - \\(m\\) is molecular mass - \\(\\sigma\\) is Lennard-Jones diameter - \\(\\Omega^{(2,2)*}\\) is the collision integral</p>"},{"location":"physical_properties/viscosity_models/#mixing-rules","title":"Mixing Rules","text":"<p>Most models use molar fraction-weighted mixing:</p> \\[\\eta_{mix} = \\exp\\left(\\sum_i x_i \\ln \\eta_i\\right)\\] <p>or the more rigorous:</p> \\[\\eta_{mix} = \\frac{\\sum_i x_i \\sqrt{M_i} \\eta_i}{\\sum_i x_i \\sqrt{M_i}}\\]"},{"location":"physical_properties/viscosity_models/#references","title":"References","text":"<ol> <li>Lohrenz, J., Bray, B.G., Clark, C.R. (1964). Calculating Viscosities of Reservoir Fluids from Their Compositions. JPT.</li> <li>Qui\u00f1ones-Cisneros, S.E., Firoozabadi, A. (2000). One Parameter Friction Theory. AIChE J.</li> <li>Pedersen, K.S., et al. (1987). Viscosity of Crude Oils. Chem. Eng. Sci.</li> <li>Chung, T.H., et al. (1988). Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties. I&amp;EC Res.</li> </ol>"},{"location":"process/","title":"Process Simulation Package","text":"<p>The <code>process</code> package provides process equipment, unit operations, controllers, and process system management for building complete flowsheets.</p>"},{"location":"process/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Documentation Structure</li> <li>Package Structure</li> <li>ProcessSystem</li> <li>Equipment Categories</li> <li>Controllers and Logic</li> <li>Safety Systems</li> <li>Usage Examples</li> </ul>"},{"location":"process/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process</code></p> <p>Purpose: - Model process equipment (separators, heat exchangers, compressors, etc.) - Build process flowsheets with <code>ProcessSystem</code> - Implement control logic and adjusters - Simulate dynamic and steady-state processes - Safety system modeling (PSV, ESD, blowdown)</p>"},{"location":"process/#documentation-structure","title":"Documentation Structure","text":"<p>This documentation is organized into the following sections:</p> Section Description equipment/ Equipment documentation (separators, compressors, etc.) processmodel/ ProcessSystem and flowsheet management safety/ Safety systems (PSV, ESD, blowdown) controllers.md Process controllers and logic"},{"location":"process/#equipment-categories","title":"Equipment Categories","text":"Category Documentation Classes Streams streams.md Stream, EnergyStream, VirtualStream Separators separators.md Separator, ThreePhaseSeparator, GasScrubber Heat Exchangers heat_exchangers.md Heater, Cooler, HeatExchanger Compressors compressors.md Compressor, CompressorChart Pumps pumps.md Pump, PumpChart Expanders expanders.md Expander, TurboExpanderCompressor Valves valves.md ThrottlingValve, SafetyValve, BlowdownValve Distillation distillation.md DistillationColumn, SimpleTray Absorbers absorbers.md SimpleAbsorber, SimpleTEGAbsorber Ejectors ejectors.md Ejector Membranes membranes.md MembraneSeparator Flares flares.md Flare, FlareStack Electrolyzers electrolyzers.md Electrolyzer, CO2Electrolyzer Filters filters.md Filter, CharCoalFilter Reactors reactors.md GibbsReactor Pipelines pipelines.md Pipeline, AdiabaticPipe Tanks tanks.md Tank, VesselDepressurization Wells wells.md Well equipment Mixers/Splitters mixers_splitters.md Mixer, Splitter Utility util/ Adjuster, Recycle, Calculator"},{"location":"process/#package-structure","title":"Package Structure","text":"<pre><code>process/\n\u251c\u2500\u2500 SimulationBaseClass.java         # Base class for simulations\n\u251c\u2500\u2500 SimulationInterface.java         # Simulation interface\n\u2502\n\u251c\u2500\u2500 equipment/                        # Process equipment\n\u2502   \u251c\u2500\u2500 ProcessEquipmentBaseClass.java\n\u2502   \u251c\u2500\u2500 ProcessEquipmentInterface.java\n\u2502   \u251c\u2500\u2500 TwoPortEquipment.java         # Equipment with inlet/outlet\n\u2502   \u251c\u2500\u2500 EquipmentFactory.java         # Factory for creating equipment\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 stream/                       # Streams\n\u2502   \u2502   \u251c\u2500\u2500 Stream.java\n\u2502   \u2502   \u251c\u2500\u2500 StreamInterface.java\n\u2502   \u2502   \u251c\u2500\u2500 EnergyStream.java\n\u2502   \u2502   \u2514\u2500\u2500 VirtualStream.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 separator/                    # Separators\n\u2502   \u2502   \u251c\u2500\u2500 Separator.java\n\u2502   \u2502   \u251c\u2500\u2500 ThreePhaseSeparator.java\n\u2502   \u2502   \u251c\u2500\u2500 GasScrubber.java\n\u2502   \u2502   \u2514\u2500\u2500 SeparatorInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 heatexchanger/               # Heat transfer\n\u2502   \u2502   \u251c\u2500\u2500 Heater.java\n\u2502   \u2502   \u251c\u2500\u2500 Cooler.java\n\u2502   \u2502   \u251c\u2500\u2500 HeatExchanger.java\n\u2502   \u2502   \u251c\u2500\u2500 NeqHeater.java\n\u2502   \u2502   \u2514\u2500\u2500 Condenser.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 compressor/                  # Compression\n\u2502   \u2502   \u251c\u2500\u2500 Compressor.java\n\u2502   \u2502   \u251c\u2500\u2500 CompressorInterface.java\n\u2502   \u2502   \u2514\u2500\u2500 CompressorChartInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 pump/                        # Pumps\n\u2502   \u2502   \u251c\u2500\u2500 Pump.java\n\u2502   \u2502   \u2514\u2500\u2500 PumpInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 expander/                    # Expanders\n\u2502   \u2502   \u251c\u2500\u2500 Expander.java\n\u2502   \u2502   \u2514\u2500\u2500 ExpanderInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 valve/                       # Valves\n\u2502   \u2502   \u251c\u2500\u2500 ThrottlingValve.java\n\u2502   \u2502   \u251c\u2500\u2500 ValveInterface.java\n\u2502   \u2502   \u2514\u2500\u2500 SafetyValve.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 mixer/                       # Mixers\n\u2502   \u2502   \u251c\u2500\u2500 Mixer.java\n\u2502   \u2502   \u251c\u2500\u2500 StaticMixer.java\n\u2502   \u2502   \u2514\u2500\u2500 MixerInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 splitter/                    # Splitters\n\u2502   \u2502   \u251c\u2500\u2500 Splitter.java\n\u2502   \u2502   \u2514\u2500\u2500 SplitterInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 distillation/                # Distillation\n\u2502   \u2502   \u251c\u2500\u2500 DistillationColumn.java\n\u2502   \u2502   \u251c\u2500\u2500 SimpleTray.java\n\u2502   \u2502   \u251c\u2500\u2500 Condenser.java\n\u2502   \u2502   \u2514\u2500\u2500 Reboiler.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 reactor/                     # Reactors\n\u2502   \u2502   \u251c\u2500\u2500 Reactor.java\n\u2502   \u2502   \u2514\u2500\u2500 PFReactor.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 absorber/                    # Absorption\n\u2502   \u2502   \u251c\u2500\u2500 Absorber.java\n\u2502   \u2502   \u2514\u2500\u2500 SimpleTEGAbsorber.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 pipeline/                    # Pipelines\n\u2502   \u2502   \u251c\u2500\u2500 Pipeline.java\n\u2502   \u2502   \u2514\u2500\u2500 PipelineInterface.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 well/                        # Wells\n\u2502   \u2502   \u251c\u2500\u2500 SimpleWell.java\n\u2502   \u2502   \u2514\u2500\u2500 WellFlow.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tank/                        # Tanks and vessels\n\u2502   \u2502   \u251c\u2500\u2500 Tank.java\n\u2502   \u2502   \u2514\u2500\u2500 ProcessVessel.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 filter/                      # Filters\n\u2502   \u2502   \u2514\u2500\u2500 Filter.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 membrane/                    # Membranes\n\u2502   \u2502   \u2514\u2500\u2500 Membrane.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 ejector/                     # Ejectors\n\u2502   \u2502   \u2514\u2500\u2500 Ejector.java\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 electrolyzer/                # Electrolyzers\n\u2502   \u2502   \u2514\u2500\u2500 PEM_Electrolyzer.java\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 util/                        # Utility equipment\n\u2502       \u251c\u2500\u2500 Adjuster.java\n\u2502       \u251c\u2500\u2500 Recycle.java\n\u2502       \u251c\u2500\u2500 Calculator.java\n\u2502       \u251c\u2500\u2500 Setter.java\n\u2502       \u2514\u2500\u2500 MoleFractionSetter.java\n\u2502\n\u251c\u2500\u2500 processmodel/                    # Process system\n\u2502   \u251c\u2500\u2500 ProcessSystem.java\n\u2502   \u251c\u2500\u2500 ProcessModule.java\n\u2502   \u2514\u2500\u2500 graph/                       # Graph-based execution\n\u2502       \u251c\u2500\u2500 ProcessGraph.java\n\u2502       \u2514\u2500\u2500 ProcessGraphBuilder.java\n\u2502\n\u251c\u2500\u2500 controllerdevice/                # Controllers\n\u2502   \u251c\u2500\u2500 ControllerDevice.java\n\u2502   \u2514\u2500\u2500 PIDController.java\n\u2502\n\u251c\u2500\u2500 measurementdevice/               # Measurements\n\u2502   \u251c\u2500\u2500 MeasurementDevice.java\n\u2502   \u251c\u2500\u2500 TemperatureMeasurement.java\n\u2502   \u251c\u2500\u2500 PressureMeasurement.java\n\u2502   \u2514\u2500\u2500 FlowMeasurement.java\n\u2502\n\u251c\u2500\u2500 logic/                           # Process logic\n\u2502   \u251c\u2500\u2500 ProcessLogicController.java\n\u2502   \u2514\u2500\u2500 ConditionalLogic.java\n\u2502\n\u251c\u2500\u2500 alarm/                           # Alarm system\n\u2502   \u2514\u2500\u2500 ProcessAlarmManager.java\n\u2502\n\u251c\u2500\u2500 safety/                          # Safety systems\n\u2502   \u251c\u2500\u2500 PSV/\n\u2502   \u251c\u2500\u2500 ESD/\n\u2502   \u2514\u2500\u2500 Blowdown/\n\u2502\n\u251c\u2500\u2500 calibration/                     # Equipment calibration\n\u251c\u2500\u2500 conditionmonitor/                # Condition monitoring\n\u251c\u2500\u2500 costestimation/                  # Cost estimation\n\u251c\u2500\u2500 mechanicaldesign/                # Mechanical design\n\u251c\u2500\u2500 mpc/                             # Model predictive control\n\u251c\u2500\u2500 ml/                              # Machine learning\n\u2514\u2500\u2500 streaming/                       # Data streaming\n</code></pre>"},{"location":"process/#processsystem","title":"ProcessSystem","text":"<p>The <code>ProcessSystem</code> class is the container for building and running process flowsheets.</p>"},{"location":"process/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.valve.ThrottlingValve;\n\n// Create process system\nProcessSystem process = new ProcessSystem(\"Gas Processing Plant\");\n\n// Create feed stream\nSystemInterface feed = new SystemSrkEos(300.0, 80.0);\nfeed.addComponent(\"methane\", 0.85);\nfeed.addComponent(\"ethane\", 0.08);\nfeed.addComponent(\"propane\", 0.05);\nfeed.addComponent(\"n-butane\", 0.02);\nfeed.setMixingRule(\"classic\");\n\nStream feedStream = new Stream(\"Feed\", feed);\nfeedStream.setFlowRate(1000.0, \"kg/hr\");\n\n// Add equipment to process\nprocess.add(feedStream);\n\n// Letdown valve\nThrottlingValve valve = new ThrottlingValve(\"Inlet Valve\", feedStream);\nvalve.setOutletPressure(40.0, \"bara\");\nprocess.add(valve);\n\n// Separator\nSeparator separator = new Separator(\"HP Separator\", valve.getOutletStream());\nprocess.add(separator);\n\n// Run process\nprocess.run();\n\n// Get results\nSystem.out.println(\"Separator gas rate: \" + \n    separator.getGasOutStream().getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"Separator liquid rate: \" + \n    separator.getLiquidOutStream().getFlowRate(\"kg/hr\") + \" kg/hr\");\n</code></pre>"},{"location":"process/#key-processsystem-methods","title":"Key ProcessSystem Methods","text":"Method Description <code>add(equipment)</code> Add equipment to process <code>run()</code> Run steady-state simulation <code>runTransient(time, dt)</code> Run transient simulation <code>getUnit(name)</code> Get equipment by name <code>copy()</code> Clone the process system <code>getReport()</code> Get process report <code>display()</code> Display process summary"},{"location":"process/#equipment-categories_1","title":"Equipment Categories","text":""},{"location":"process/#streams","title":"Streams","text":"<pre><code>// Material stream\nStream gas = new Stream(\"Natural Gas\", fluid);\ngas.setFlowRate(5000.0, \"Sm3/hr\");\ngas.setTemperature(25.0, \"C\");\ngas.setPressure(100.0, \"bara\");\ngas.run();\n\n// Energy stream\nEnergyStream heat = new EnergyStream(\"Heating Duty\");\nheat.setEnergyFlow(1000.0, \"kW\");\n</code></pre>"},{"location":"process/#separators","title":"Separators","text":"<pre><code>// Two-phase separator\nSeparator sep2p = new Separator(\"V-100\", inletStream);\nsep2p.run();\nStream gas = sep2p.getGasOutStream();\nStream liquid = sep2p.getLiquidOutStream();\n\n// Three-phase separator\nThreePhaseSeparator sep3p = new ThreePhaseSeparator(\"V-200\", inletStream);\nsep3p.run();\nStream gas = sep3p.getGasOutStream();\nStream oil = sep3p.getOilOutStream();\nStream water = sep3p.getWaterOutStream();\n</code></pre>"},{"location":"process/#heat-exchangers","title":"Heat Exchangers","text":"<pre><code>// Heater (duty specified)\nHeater heater = new Heater(\"E-100\", inletStream);\nheater.setOutTemperature(80.0, \"C\");\nheater.run();\nSystem.out.println(\"Duty: \" + heater.getDuty() + \" W\");\n\n// Cooler\nCooler cooler = new Cooler(\"E-200\", inletStream);\ncooler.setOutTemperature(30.0, \"C\");\ncooler.run();\n\n// Shell-tube heat exchanger\nHeatExchanger hx = new HeatExchanger(\"E-300\", hotStream, coldStream);\nhx.setUAvalue(5000.0);  // W/K\nhx.run();\n</code></pre>"},{"location":"process/#compressors","title":"Compressors","text":"<pre><code>// Compressor with polytropic efficiency\nCompressor comp = new Compressor(\"K-100\", inletStream);\ncomp.setOutletPressure(80.0, \"bara\");\ncomp.setPolytropicEfficiency(0.75);\ncomp.setUsePolytropicCalc(true);\ncomp.run();\n\nSystem.out.println(\"Power: \" + comp.getPower(\"kW\") + \" kW\");\nSystem.out.println(\"Outlet T: \" + comp.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\n</code></pre>"},{"location":"process/#valves","title":"Valves","text":"<pre><code>// Throttling valve (Joule-Thomson)\nThrottlingValve valve = new ThrottlingValve(\"FV-100\", inletStream);\nvalve.setOutletPressure(50.0, \"bara\");\nvalve.run();\n\n// Valve with Cv\nvalve.setCv(100.0, \"US\");\nvalve.setPercentValveOpening(50.0);\n</code></pre>"},{"location":"process/#distillation","title":"Distillation","text":"<pre><code>// Simple distillation column\nDistillationColumn column = new DistillationColumn(\"T-100\", 10, true, true);\ncolumn.addFeedStream(feedStream, 5);\ncolumn.setCondenserTemperature(40.0, \"C\");\ncolumn.setReboilerTemperature(120.0, \"C\");\ncolumn.run();\n\nStream overhead = column.getGasOutStream();\nStream bottoms = column.getLiquidOutStream();\n</code></pre>"},{"location":"process/#controllers-and-logic","title":"Controllers and Logic","text":""},{"location":"process/#adjusters","title":"Adjusters","text":"<p>Adjust a parameter to meet a specification.</p> <pre><code>// Adjust heater duty to achieve target temperature\nAdjuster tempAdjuster = new Adjuster(\"TC-100\");\ntempAdjuster.setAdjustedVariable(heater, \"duty\");\ntempAdjuster.setTargetVariable(heater.getOutletStream(), \"temperature\", 80.0, \"C\");\nprocess.add(tempAdjuster);\n</code></pre>"},{"location":"process/#recycles","title":"Recycles","text":"<p>Handle recycle loops in the process.</p> <pre><code>Recycle recycle = new Recycle(\"Recycle\");\nrecycle.addStream(recycleStream);\nrecycle.setOutletStream(recycleInletStream);\nrecycle.setTolerance(1e-6);\nprocess.add(recycle);\n</code></pre>"},{"location":"process/#calculators","title":"Calculators","text":"<p>Perform custom calculations.</p> <pre><code>Calculator calc = new Calculator(\"MW Calculator\");\ncalc.addInputVariable(stream);\ncalc.setOutputVariable(heater, \"duty\");\ncalc.setExpression(\"molarMass * 1000\");\nprocess.add(calc);\n</code></pre>"},{"location":"process/#safety-systems","title":"Safety Systems","text":""},{"location":"process/#pressure-safety-valves","title":"Pressure Safety Valves","text":"<pre><code>SafetyValve psv = new SafetyValve(\"PSV-100\", vessel);\npsv.setSetPressure(120.0, \"bara\");\npsv.setBlowdownPressure(0.1);  // 10% blowdown\nprocess.add(psv);\n</code></pre>"},{"location":"process/#blowdown-systems","title":"Blowdown Systems","text":"<p>See Safety Simulation Roadmap for detailed safety system documentation.</p>"},{"location":"process/#dynamic-simulation","title":"Dynamic Simulation","text":"<pre><code>// Run transient simulation\ndouble simulationTime = 3600.0;  // 1 hour\ndouble timeStep = 1.0;           // 1 second\n\nprocess.setTimeStep(timeStep);\nfor (double t = 0; t &lt; simulationTime; t += timeStep) {\n    process.runTransient();\n\n    // Log data\n    System.out.println(t + \", \" + \n        separator.getPressure() + \", \" +\n        separator.getGasOutStream().getFlowRate(\"kg/hr\"));\n}\n</code></pre>"},{"location":"process/#process-reports","title":"Process Reports","text":"<pre><code>// Get JSON report\nString jsonReport = process.getReport_json();\n\n// Get tabular report\nString[][] table = process.getUnitOperationsAsTable();\n\n// Display to console\nprocess.display();\n</code></pre>"},{"location":"process/#best-practices","title":"Best Practices","text":"<ol> <li>Use unique names for all equipment</li> <li>Set flow rate and conditions before running</li> <li>Add equipment in flow order for clarity</li> <li>Use Recycle for recycle loops</li> <li>Check mass balance after simulation</li> <li>Clone streams before branching to avoid shared state</li> </ol>"},{"location":"process/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Documentation - Detailed equipment guides</li> <li>Process Logic Framework - Logic controllers</li> <li>Safety Systems - Safety simulation</li> <li>Alarm System - Process alarms</li> </ul>"},{"location":"process/controllers/","title":"Process Controllers and Logic","text":"<p>Documentation for controllers, adjusters, recycles, and process logic in NeqSim.</p>"},{"location":"process/controllers/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Adjusters</li> <li>Recycles</li> <li>Setters</li> <li>Calculators</li> <li>PID Controllers</li> <li>Process Logic</li> </ul>"},{"location":"process/controllers/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.util</code>, <code>neqsim.process.controllerdevice</code>, <code>neqsim.process.logic</code></p> <p>Classes: - <code>Adjuster</code> - Adjust variable to meet specification - <code>Recycle</code> - Handle recycle streams - <code>Setter</code> - Set variable values - <code>Calculator</code> - Custom calculations - <code>PIDController</code> - PID control - <code>ProcessLogicController</code> - Conditional logic</p>"},{"location":"process/controllers/#adjusters","title":"Adjusters","text":"<p>Adjusters modify one variable to achieve a target specification.</p>"},{"location":"process/controllers/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Adjuster;\n\n// Adjust heater duty to achieve target outlet temperature\nAdjuster tempControl = new Adjuster(\"TC-100\");\ntempControl.setAdjustedVariable(heater, \"outTemperature\");\ntempControl.setTargetVariable(stream, \"temperature\", 80.0, \"C\");\nprocess.add(tempControl);\n</code></pre>"},{"location":"process/controllers/#adjustable-variables","title":"Adjustable Variables","text":"Equipment Variable Description Heater/Cooler <code>\"duty\"</code> Heat duty Heater/Cooler <code>\"outTemperature\"</code> Outlet temperature Compressor <code>\"outletPressure\"</code> Discharge pressure Valve <code>\"outletPressure\"</code> Outlet pressure Splitter <code>\"splitFactor\"</code> Split ratio Stream <code>\"flowRate\"</code> Flow rate"},{"location":"process/controllers/#target-variables","title":"Target Variables","text":"Equipment Variable Description Stream <code>\"temperature\"</code> Temperature Stream <code>\"pressure\"</code> Pressure Stream <code>\"flowRate\"</code> Flow rate Stream <code>\"moleFraction\"</code> Component mole fraction Separator <code>\"liquidLevel\"</code> Liquid level"},{"location":"process/controllers/#example-dew-point-control","title":"Example: Dew Point Control","text":"<pre><code>// Adjust cooler to achieve hydrocarbon dew point\nAdjuster dewPointControl = new Adjuster(\"Dew Point Controller\");\ndewPointControl.setAdjustedVariable(cooler, \"outTemperature\");\ndewPointControl.setTargetPhaseCondition(stream, \"dewpoint\", 50.0, \"bara\");\nprocess.add(dewPointControl);\n</code></pre>"},{"location":"process/controllers/#solver-settings","title":"Solver Settings","text":"<pre><code>adjuster.setMaximumIterations(50);\nadjuster.setTolerance(1e-6);\nadjuster.setMinimumValue(-1e6);  // Duty lower bound\nadjuster.setMaximumValue(1e6);   // Duty upper bound\n</code></pre>"},{"location":"process/controllers/#recycles","title":"Recycles","text":"<p>Handle recycle streams in process flowsheets.</p>"},{"location":"process/controllers/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Recycle;\n\n// Define recycle\nRecycle recycle = new Recycle(\"Solvent Recycle\");\nrecycle.addStream(recycleStream);\nrecycle.setOutletStream(inletMixer);\nrecycle.setTolerance(1e-6);\nprocess.add(recycle);\n</code></pre>"},{"location":"process/controllers/#recycle-placement","title":"Recycle Placement","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Feed\nprocess.add(feed);\n\n// Mixer (combines feed and recycle)\nMixer mixer = new Mixer(\"M-100\");\nmixer.addStream(feed);\nprocess.add(mixer);\n\n// Process equipment\nprocess.add(reactor);\nprocess.add(separator);\n\n// Splitter for recycle\nSplitter splitter = new Splitter(\"Splitter\", separator.getLiquidOutStream());\nsplitter.setSplitFactors(new double[]{0.9, 0.1});  // 10% recycle\nprocess.add(splitter);\n\n// Recycle stream\nRecycle recycle = new Recycle(\"Recycle\");\nrecycle.addStream(splitter.getSplitStream(1));\nrecycle.setOutletStream(mixer);\nprocess.add(recycle);\n\n// Connect mixer to recycle\nmixer.addStream(recycle.getOutletStream());\n\nprocess.run();\n</code></pre>"},{"location":"process/controllers/#convergence-settings","title":"Convergence Settings","text":"<pre><code>recycle.setTolerance(1e-6);\nrecycle.setMaximumIterations(100);\n\n// Acceleration methods\nrecycle.setAccelerationMethod(\"wegstein\");\n// Options: \"direct\", \"wegstein\", \"broyden\"\n</code></pre>"},{"location":"process/controllers/#setters","title":"Setters","text":"<p>Set variable values directly.</p>"},{"location":"process/controllers/#basic-usage_2","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Setter;\n\n// Set flow rate\nSetter flowSetter = new Setter(\"Flow Setter\", stream);\nflowSetter.setVariable(\"flowRate\", 1000.0, \"kg/hr\");\nprocess.add(flowSetter);\n</code></pre>"},{"location":"process/controllers/#mole-fraction-setter","title":"Mole Fraction Setter","text":"<pre><code>import neqsim.process.equipment.util.MoleFractionSetter;\n\n// Set component mole fraction\nMoleFractionSetter compSetter = new MoleFractionSetter(\"CO2 Setter\", stream);\ncompSetter.setMoleFraction(\"CO2\", 0.02);\nprocess.add(compSetter);\n</code></pre>"},{"location":"process/controllers/#calculators","title":"Calculators","text":"<p>Perform custom calculations.</p>"},{"location":"process/controllers/#basic-usage_3","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Calculator;\n\nCalculator calc = new Calculator(\"Energy Balance\");\ncalc.addInputVariable(stream1);\ncalc.addInputVariable(stream2);\ncalc.setOutputVariable(heater, \"duty\");\n\n// Custom calculation (override in subclass or use expression)\ncalc.setExpression(\"stream1.enthalpy - stream2.enthalpy\");\nprocess.add(calc);\n</code></pre>"},{"location":"process/controllers/#pid-controllers","title":"PID Controllers","text":"<p>For dynamic simulation with feedback control.</p>"},{"location":"process/controllers/#basic-usage_4","title":"Basic Usage","text":"<pre><code>import neqsim.process.controllerdevice.PIDController;\n\nPIDController levelControl = new PIDController(\"LC-100\");\nlevelControl.setMeasuredVariable(separator, \"liquidLevel\");\nlevelControl.setControlledVariable(valve, \"opening\");\nlevelControl.setSetPoint(0.5);  // 50% level\n\n// Tuning parameters\nlevelControl.setKp(2.0);    // Proportional gain\nlevelControl.setKi(0.1);    // Integral gain (1/s)\nlevelControl.setKd(0.0);    // Derivative gain (s)\n\nprocess.add(levelControl);\n</code></pre>"},{"location":"process/controllers/#tuning","title":"Tuning","text":"<pre><code>// Action\nlevelControl.setReverseAction(true);  // Increase output decreases PV\n\n// Output limits\nlevelControl.setOutputMin(0.0);\nlevelControl.setOutputMax(100.0);\n\n// Anti-windup\nlevelControl.setAntiWindup(true);\n</code></pre>"},{"location":"process/controllers/#dynamic-execution","title":"Dynamic Execution","text":"<pre><code>// Run transient with controllers\nfor (double t = 0; t &lt; 3600; t += 1.0) {\n    process.runTransient();\n\n    double pv = levelControl.getProcessVariable();\n    double sp = levelControl.getSetPoint();\n    double out = levelControl.getOutput();\n\n    System.out.printf(\"%.1f, %.3f, %.3f, %.1f%n\", t, pv, sp, out);\n}\n</code></pre>"},{"location":"process/controllers/#process-logic","title":"Process Logic","text":"<p>Conditional logic for process decisions.</p>"},{"location":"process/controllers/#basic-usage_5","title":"Basic Usage","text":"<pre><code>import neqsim.process.logic.ProcessLogicController;\n\nProcessLogicController logic = new ProcessLogicController(\"Emergency Logic\");\n\n// Define condition\nlogic.setCondition(pressure, \"&gt;\", 100.0, \"bara\");\n\n// Define action\nlogic.setAction(shutoffValve, \"close\");\n\nprocess.add(logic);\n</code></pre>"},{"location":"process/controllers/#complex-conditions","title":"Complex Conditions","text":"<pre><code>// AND condition\nlogic.addCondition(pressure, \"&gt;\", 100.0, \"bara\", \"AND\");\nlogic.addCondition(temperature, \"&gt;\", 150.0, \"C\", \"AND\");\n\n// OR condition\nlogic.addCondition(level, \"&lt;\", 0.1, \"ratio\", \"OR\");\nlogic.addCondition(level, \"&gt;\", 0.9, \"ratio\", \"OR\");\n</code></pre>"},{"location":"process/controllers/#alarm-integration","title":"Alarm Integration","text":"<pre><code>import neqsim.process.alarm.ProcessAlarmManager;\n\nProcessAlarmManager alarms = process.getAlarmManager();\n\n// High pressure alarm\nalarms.addAlarm(separator, \"pressure\", 95.0, \"high\", \"bara\");\nalarms.addAlarm(separator, \"pressure\", 100.0, \"highHigh\", \"bara\");\n\n// Low level alarm\nalarms.addAlarm(separator, \"liquidLevel\", 0.2, \"low\", \"ratio\");\n</code></pre>"},{"location":"process/controllers/#example-complete-control-system","title":"Example: Complete Control System","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Feed stream\nStream feed = new Stream(\"Feed\", feedFluid);\nfeed.setFlowRate(1000.0, \"kg/hr\");\nprocess.add(feed);\n\n// Heater with temperature control\nHeater heater = new Heater(\"E-100\", feed);\nprocess.add(heater);\n\nAdjuster tempControl = new Adjuster(\"TC-100\");\ntempControl.setAdjustedVariable(heater, \"duty\");\ntempControl.setTargetVariable(heater.getOutletStream(), \"temperature\", 80.0, \"C\");\nprocess.add(tempControl);\n\n// Separator with level control\nSeparator separator = new Separator(\"V-100\", heater.getOutletStream());\nprocess.add(separator);\n\nThrottlingValve liquidValve = new ThrottlingValve(\"LV-100\", separator.getLiquidOutStream());\nliquidValve.setOutletPressure(5.0, \"bara\");\nprocess.add(liquidValve);\n\n// Level controller (for dynamic)\nPIDController levelControl = new PIDController(\"LC-100\");\nlevelControl.setMeasuredVariable(separator, \"liquidLevel\");\nlevelControl.setControlledVariable(liquidValve, \"opening\");\nlevelControl.setSetPoint(0.5);\nlevelControl.setKp(5.0);\nlevelControl.setKi(0.5);\nprocess.add(levelControl);\n\n// Pressure control\nThrottlingValve gasValve = new ThrottlingValve(\"PV-100\", separator.getGasOutStream());\nprocess.add(gasValve);\n\nAdjuster pressControl = new Adjuster(\"PC-100\");\npressControl.setAdjustedVariable(gasValve, \"outletPressure\");\npressControl.setTargetVariable(separator, \"pressure\", 20.0, \"bara\");\nprocess.add(pressControl);\n\n// Run steady state\nprocess.run();\n\n// Run dynamic\nfor (double t = 0; t &lt; 3600; t += 1.0) {\n    // Disturbance at t=600\n    if (Math.abs(t - 600) &lt; 0.5) {\n        feed.setFlowRate(1200.0, \"kg/hr\");\n    }\n\n    process.runTransient();\n}\n</code></pre>"},{"location":"process/controllers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Equipment - Process equipment</li> <li>Alarm System - Alarms</li> <li>Process Logic Framework - Advanced logic</li> </ul>"},{"location":"process/equipment/","title":"Process Equipment Documentation","text":"<p>This folder contains detailed documentation for all process equipment in NeqSim.</p>"},{"location":"process/equipment/#equipment-categories","title":"Equipment Categories","text":""},{"location":"process/equipment/#flow-equipment","title":"Flow Equipment","text":"Equipment File Description Streams streams.md Material and energy streams Mixers &amp; Splitters mixers_splitters.md Stream mixing and splitting"},{"location":"process/equipment/#separation-equipment","title":"Separation Equipment","text":"Equipment File Description Separators separators.md 2-phase and 3-phase separators, scrubbers Distillation distillation.md Distillation columns Absorbers absorbers.md Absorption/stripping columns Membranes membranes.md Membrane separation units Filters filters.md Particulate and charcoal filters"},{"location":"process/equipment/#heat-transfer-equipment","title":"Heat Transfer Equipment","text":"Equipment File Description Heat Exchangers heat_exchangers.md Heaters, coolers, condensers, reboilers"},{"location":"process/equipment/#rotating-equipment","title":"Rotating Equipment","text":"Equipment File Description Compressors compressors.md Gas compression Pumps pumps.md Liquid pumping Expanders expanders.md Power recovery, turboexpanders"},{"location":"process/equipment/#flow-control","title":"Flow Control","text":"Equipment File Description Valves valves.md Throttling valves, chokes, safety valves"},{"location":"process/equipment/#reactors","title":"Reactors","text":"Equipment File Description Reactors reactors.md CSTR, PFR, equilibrium reactors Electrolyzers electrolyzers.md Water and CO\u2082 electrolysis"},{"location":"process/equipment/#ejectors","title":"Ejectors","text":"Equipment File Description Ejectors ejectors.md Steam and gas ejectors"},{"location":"process/equipment/#safety-equipment","title":"Safety Equipment","text":"Equipment File Description Flares flares.md Flare systems and combustion"},{"location":"process/equipment/#wellreservoir","title":"Well/Reservoir","text":"Equipment File Description Wells wells.md Production wells, chokes"},{"location":"process/equipment/#pipeline","title":"Pipeline","text":"Equipment File Description Pipelines pipelines.md Pipe flow, pressure drop"},{"location":"process/equipment/#storage","title":"Storage","text":"Equipment File Description Tanks tanks.md Storage tanks, LNG boil-off"},{"location":"process/equipment/#utility-equipment","title":"Utility Equipment","text":"Equipment File Description Adjusters util/adjusters.md Variable adjustment to meet specs Recycles util/recycles.md Recycle stream handling Calculators util/calculators.md Custom calculations and setters"},{"location":"process/equipment/#quick-reference","title":"Quick Reference","text":""},{"location":"process/equipment/#creating-equipment","title":"Creating Equipment","text":"<pre><code>// All equipment follows similar pattern\nEquipmentType equipment = new EquipmentType(\"Name\", inletStream);\nequipment.setParameter(value);\nequipment.run();\nStream outlet = equipment.getOutletStream();\n</code></pre>"},{"location":"process/equipment/#adding-to-processsystem","title":"Adding to ProcessSystem","text":"<pre><code>ProcessSystem process = new ProcessSystem();\nprocess.add(stream);\nprocess.add(equipment1);\nprocess.add(equipment2);\nprocess.run();\n</code></pre>"},{"location":"process/equipment/#getting-equipment-by-name","title":"Getting Equipment by Name","text":"<pre><code>Compressor comp = (Compressor) process.getUnit(\"K-100\");\n</code></pre>"},{"location":"process/equipment/#common-methods","title":"Common Methods","text":"<p>All equipment inherits from <code>ProcessEquipmentBaseClass</code>:</p> Method Description <code>run()</code> Execute calculation <code>runTransient()</code> Execute transient step <code>getName()</code> Get equipment name <code>getInletStream()</code> Get inlet stream <code>getOutletStream()</code> Get outlet stream <code>getPressure()</code> Get operating pressure <code>getTemperature()</code> Get operating temperature <code>getMechanicalDesign()</code> Get mechanical design object <code>needRecalculation()</code> Check if recalculation needed"},{"location":"process/equipment/#equipment-inheritance","title":"Equipment Inheritance","text":"<pre><code>ProcessEquipmentInterface\n    \u2502\n    \u2514\u2500\u2500 ProcessEquipmentBaseClass\n            \u2502\n            \u251c\u2500\u2500 TwoPortEquipment (inlet/outlet pattern)\n            \u2502       \u251c\u2500\u2500 Heater, Cooler\n            \u2502       \u251c\u2500\u2500 Compressor, Pump, Expander\n            \u2502       \u251c\u2500\u2500 ThrottlingValve\n            \u2502       \u2514\u2500\u2500 ...\n            \u2502\n            \u251c\u2500\u2500 Separator (multi-outlet)\n            \u2502       \u251c\u2500\u2500 ThreePhaseSeparator\n            \u2502       \u251c\u2500\u2500 GasScrubber\n            \u2502       \u2514\u2500\u2500 ...\n            \u2502\n            \u251c\u2500\u2500 Mixer (multi-inlet)\n            \u251c\u2500\u2500 Splitter (multi-outlet)\n            \u2502\n            \u2514\u2500\u2500 DistillationColumn\n</code></pre>"},{"location":"process/equipment/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>ProcessSystem - Process system guide</li> <li>ProcessModule - Modular process units</li> <li>Controllers - Control equipment</li> <li>Safety Systems - Safety equipment</li> </ul>"},{"location":"process/equipment/absorbers/","title":"Absorbers and Strippers","text":"<p>Documentation for mass transfer columns in NeqSim.</p>"},{"location":"process/equipment/absorbers/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Absorber</li> <li>Stripper</li> <li>Simple Absorber</li> <li>Examples</li> </ul>"},{"location":"process/equipment/absorbers/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.absorber</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Absorber</code> | General absorption column | | <code>SimpleAbsorber</code> | Simplified absorber model | | <code>WaterStripperColumn</code> | Water stripping column |</p> <p>Absorbers transfer components from gas to liquid phase, while strippers transfer from liquid to gas.</p>"},{"location":"process/equipment/absorbers/#absorber","title":"Absorber","text":""},{"location":"process/equipment/absorbers/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.absorber.Absorber;\n\nAbsorber absorber = new Absorber(\"Amine Absorber\");\nabsorber.addGasInStream(gasStream);\nabsorber.addSolventInStream(amineSolution);\nabsorber.setNumberOfTheoreticalStages(10);\nabsorber.run();\n\nStream sweetGas = absorber.getGasOutStream();\nStream richAmine = absorber.getLiquidOutStream();\n</code></pre>"},{"location":"process/equipment/absorbers/#absorption-efficiency","title":"Absorption Efficiency","text":"<pre><code>// Component removal efficiency\nabsorber.setRemovalEfficiency(\"CO2\", 0.95);  // 95% CO2 removal\nabsorber.setRemovalEfficiency(\"H2S\", 0.99);  // 99% H2S removal\n</code></pre>"},{"location":"process/equipment/absorbers/#stage-configuration","title":"Stage Configuration","text":"<pre><code>absorber.setNumberOfTheoreticalStages(20);\nabsorber.setStageEfficiency(0.7);  // Murphree efficiency\n</code></pre>"},{"location":"process/equipment/absorbers/#stripper","title":"Stripper","text":""},{"location":"process/equipment/absorbers/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.absorber.WaterStripperColumn;\n\nWaterStripperColumn stripper = new WaterStripperColumn(\"Regenerator\");\nstripper.setLiquidInStream(richAmine);\nstripper.setNumberOfStages(15);\nstripper.setReboilerTemperature(120.0, \"C\");\nstripper.run();\n\nStream leanAmine = stripper.getLiquidOutStream();\nStream acidGas = stripper.getGasOutStream();\n</code></pre>"},{"location":"process/equipment/absorbers/#simple-absorber","title":"Simple Absorber","text":"<p>Simplified mass transfer model.</p>"},{"location":"process/equipment/absorbers/#usage","title":"Usage","text":"<pre><code>import neqsim.process.equipment.absorber.SimpleAbsorber;\n\nSimpleAbsorber absorber = new SimpleAbsorber(\"CO2 Absorber\");\nabsorber.addGasInStream(feedGas);\nabsorber.addSolventInStream(solvent);\nabsorber.setAbsorptionEfficiency(0.90);\nabsorber.run();\n</code></pre>"},{"location":"process/equipment/absorbers/#examples","title":"Examples","text":""},{"location":"process/equipment/absorbers/#example-1-amine-gas-treating","title":"Example 1: Amine Gas Treating","text":"<pre><code>import neqsim.thermo.system.SystemSrkCPAstatoil;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.absorber.Absorber;\n\n// Sour gas\nSystemSrkCPAstatoil sourGas = new SystemSrkCPAstatoil(313.15, 70.0);\nsourGas.addComponent(\"methane\", 0.85);\nsourGas.addComponent(\"CO2\", 0.10);\nsourGas.addComponent(\"H2S\", 0.01);\nsourGas.addComponent(\"water\", 0.04);\nsourGas.setMixingRule(\"classic\");\n\nStream gasIn = new Stream(\"Sour Gas\", sourGas);\ngasIn.setFlowRate(100000.0, \"Sm3/hr\");\ngasIn.run();\n\n// Lean amine (MDEA solution)\nSystemSrkCPAstatoil amine = new SystemSrkCPAstatoil(313.15, 70.0);\namine.addComponent(\"water\", 0.50);\namine.addComponent(\"MDEA\", 0.50);\namine.setMixingRule(\"classic\");\n\nStream leanAmine = new Stream(\"Lean Amine\", amine);\nleanAmine.setFlowRate(50000.0, \"kg/hr\");\nleanAmine.run();\n\n// Absorber\nAbsorber absorber = new Absorber(\"Amine Contactor\");\nabsorber.addGasInStream(gasIn);\nabsorber.addSolventInStream(leanAmine);\nabsorber.setNumberOfTheoreticalStages(15);\nabsorber.run();\n\n// Results\nStream sweetGas = absorber.getGasOutStream();\ndouble co2Out = sweetGas.getFluid().getMoleFraction(\"CO2\") * 1e6;  // ppm\nSystem.out.println(\"Sweet gas CO2: \" + co2Out + \" ppm\");\n</code></pre>"},{"location":"process/equipment/absorbers/#example-2-teg-dehydration","title":"Example 2: TEG Dehydration","text":"<pre><code>// Wet natural gas\nSystemSrkEos wetGas = new SystemSrkEos(303.15, 70.0);\nwetGas.addComponent(\"methane\", 0.90);\nwetGas.addComponent(\"ethane\", 0.05);\nwetGas.addComponent(\"propane\", 0.03);\nwetGas.addComponent(\"water\", 0.02);\nwetGas.setMixingRule(\"classic\");\n\nStream gasIn = new Stream(\"Wet Gas\", wetGas);\ngasIn.setFlowRate(5000000.0, \"Sm3/day\");\ngasIn.run();\n\n// Lean TEG\nSystemSrkEos teg = new SystemSrkEos(313.15, 70.0);\nteg.addComponent(\"TEG\", 0.99);\nteg.addComponent(\"water\", 0.01);\nteg.setMixingRule(\"classic\");\n\nStream leanTEG = new Stream(\"Lean TEG\", teg);\nleanTEG.setFlowRate(1000.0, \"kg/hr\");\nleanTEG.run();\n\n// Contactor\nAbsorber contactor = new Absorber(\"TEG Contactor\");\ncontactor.addGasInStream(gasIn);\ncontactor.addSolventInStream(leanTEG);\ncontactor.setNumberOfTheoreticalStages(3);\ncontactor.run();\n\nStream dryGas = contactor.getGasOutStream();\ndouble waterContent = dryGas.getFluid().getMoleFraction(\"water\") * 1e6;\nSystem.out.println(\"Dry gas water content: \" + waterContent + \" ppm\");\n</code></pre>"},{"location":"process/equipment/absorbers/#example-3-water-wash-column","title":"Example 3: Water Wash Column","text":"<pre><code>// Gas with methanol\nSystemSrkEos gas = new SystemSrkEos(280.0, 50.0);\ngas.addComponent(\"methane\", 0.95);\ngas.addComponent(\"methanol\", 0.03);\ngas.addComponent(\"water\", 0.02);\ngas.setMixingRule(\"classic\");\n\nStream gasIn = new Stream(\"Gas\", gas);\ngasIn.setFlowRate(10000.0, \"kg/hr\");\ngasIn.run();\n\n// Wash water\nSystemSrkEos water = new SystemSrkEos(290.0, 50.0);\nwater.addComponent(\"water\", 1.0);\nwater.setMixingRule(\"classic\");\n\nStream washWater = new Stream(\"Wash Water\", water);\nwashWater.setFlowRate(500.0, \"kg/hr\");\nwashWater.run();\n\n// Absorber\nSimpleAbsorber waterWash = new SimpleAbsorber(\"Water Wash\");\nwaterWash.addGasInStream(gasIn);\nwaterWash.addSolventInStream(washWater);\nwaterWash.setAbsorptionEfficiency(0.85);\nwaterWash.run();\n\nStream cleanGas = waterWash.getGasOutStream();\ndouble meohRemaining = cleanGas.getFluid().getMoleFraction(\"methanol\") * 100;\nSystem.out.println(\"Methanol in clean gas: \" + meohRemaining + \" mol%\");\n</code></pre>"},{"location":"process/equipment/absorbers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Distillation - Distillation columns</li> <li>Separators - Phase separation</li> </ul>"},{"location":"process/equipment/compressors/","title":"Compressor Equipment","text":"<p>Documentation for compression equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/compressors/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Compressor Types</li> <li>Calculation Methods</li> <li>Performance Curves</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/compressors/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.compressor</code></p> <p>Classes: - <code>Compressor</code> - General compressor - <code>CompressorInterface</code> - Compressor interface - <code>CompressorChartInterface</code> - Performance map interface</p>"},{"location":"process/equipment/compressors/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.compressor.Compressor;\n\nCompressor compressor = new Compressor(\"K-100\", inletStream);\ncompressor.setOutletPressure(80.0, \"bara\");\ncompressor.setIsentropicEfficiency(0.75);\ncompressor.run();\n\n// Results\ndouble power = compressor.getPower(\"kW\");\ndouble outletT = compressor.getOutletStream().getTemperature(\"C\");\ndouble polytropicHead = compressor.getPolytropicHead(\"kJ/kg\");\n\nSystem.out.println(\"Power: \" + power + \" kW\");\nSystem.out.println(\"Outlet temperature: \" + outletT + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/compressors/#calculation-methods","title":"Calculation Methods","text":""},{"location":"process/equipment/compressors/#isentropic-compression","title":"Isentropic Compression","text":"<pre><code>compressor.setIsentropicEfficiency(0.75);  // 75%\ncompressor.setUsePolytropicCalc(false);\ncompressor.run();\n\ndouble isentropicHead = compressor.getIsentropicHead(\"kJ/kg\");\ndouble isentropicPower = compressor.getPower(\"kW\");\n</code></pre>"},{"location":"process/equipment/compressors/#polytropic-compression","title":"Polytropic Compression","text":"<p>More accurate for real gas behavior.</p> <pre><code>compressor.setPolytropicEfficiency(0.80);  // 80%\ncompressor.setUsePolytropicCalc(true);\ncompressor.run();\n\ndouble polytropicHead = compressor.getPolytropicHead(\"kJ/kg\");\ndouble polytropicExponent = compressor.getPolytropicExponent();\n</code></pre>"},{"location":"process/equipment/compressors/#power-specified","title":"Power Specified","text":"<pre><code>compressor.setPower(5000.0, \"kW\");  // Specify power\ncompressor.setIsentropicEfficiency(0.75);\ncompressor.run();\n\ndouble outletP = compressor.getOutletStream().getPressure(\"bara\");\n</code></pre>"},{"location":"process/equipment/compressors/#efficiency-relationships","title":"Efficiency Relationships","text":""},{"location":"process/equipment/compressors/#isentropic-efficiency","title":"Isentropic Efficiency","text":"\\[\\eta_{is} = \\frac{H_{is}}{H_{actual}} = \\frac{T_{2s} - T_1}{T_2 - T_1}\\]"},{"location":"process/equipment/compressors/#polytropic-efficiency","title":"Polytropic Efficiency","text":"\\[\\eta_p = \\frac{n-1}{n} \\cdot \\frac{k}{k-1}\\] <p>Where: - \\(n\\) = polytropic exponent - \\(k\\) = isentropic exponent (Cp/Cv)</p>"},{"location":"process/equipment/compressors/#performance-curves","title":"Performance Curves","text":""},{"location":"process/equipment/compressors/#setting-compressor-map","title":"Setting Compressor Map","text":"<pre><code>// Define speed curves\ndouble[] speeds = {8000, 9000, 10000, 11000};  // RPM\n\n// For each speed: arrays of flow, head, efficiency\ndouble[][] flows = { {flow1_curve1, flow2_curve1}, {flow1_curve2, flow2_curve2}, ... };\ndouble[][] heads = { {head1_curve1, head2_curve1}, {head1_curve2, head2_curve2}, ... };\ndouble[][] efficiencies = { {eff1_curve1, eff2_curve1}, {eff1_curve2, eff2_curve2}, ... };\n\nCompressorChartInterface chart = compressor.getCompressorChart();\nchart.setSpeedCurves(speeds, flows, heads, efficiencies);\ncompressor.setUseCompressorChart(true);\n</code></pre>"},{"location":"process/equipment/compressors/#operating-point","title":"Operating Point","text":"<pre><code>compressor.setSpeed(10000);  // RPM\ncompressor.run();\n\ndouble actualFlow = compressor.getActualFlow(\"m3/hr\");\ndouble head = compressor.getPolytropicHead(\"kJ/kg\");\ndouble efficiency = compressor.getPolytropicEfficiency();\n</code></pre>"},{"location":"process/equipment/compressors/#surge-and-choke","title":"Surge and Choke","text":"<pre><code>boolean isSurge = compressor.isSurge();\nboolean isChoke = compressor.isChoke();\ndouble surgeMargin = compressor.getSurgeMargin();\n\nif (isSurge) {\n    System.out.println(\"WARNING: Operating in surge!\");\n}\n</code></pre>"},{"location":"process/equipment/compressors/#compressor-staging","title":"Compressor Staging","text":""},{"location":"process/equipment/compressors/#multi-stage-with-intercooling","title":"Multi-Stage with Intercooling","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Stage 1: 20 -&gt; 50 bar\nCompressor stage1 = new Compressor(\"K-100A\", inletStream);\nstage1.setOutletPressure(50.0, \"bara\");\nstage1.setPolytropicEfficiency(0.78);\nprocess.add(stage1);\n\n// Intercooler\nCooler intercooler = new Cooler(\"E-100\", stage1.getOutletStream());\nintercooler.setOutTemperature(40.0, \"C\");\nprocess.add(intercooler);\n\n// Stage 2: 50 -&gt; 120 bar\nCompressor stage2 = new Compressor(\"K-100B\", intercooler.getOutletStream());\nstage2.setOutletPressure(120.0, \"bara\");\nstage2.setPolytropicEfficiency(0.78);\nprocess.add(stage2);\n\n// Aftercooler\nCooler aftercooler = new Cooler(\"E-101\", stage2.getOutletStream());\naftercooler.setOutTemperature(40.0, \"C\");\nprocess.add(aftercooler);\n\nprocess.run();\n\n// Total power\ndouble totalPower = stage1.getPower(\"kW\") + stage2.getPower(\"kW\");\nSystem.out.println(\"Total compression power: \" + totalPower + \" kW\");\n</code></pre>"},{"location":"process/equipment/compressors/#optimal-pressure-ratio","title":"Optimal Pressure Ratio","text":"<p>For minimum work with equal stage ratios:</p> \\[r_{stage} = \\left(\\frac{P_{out}}{P_{in}}\\right)^{1/n}\\] <pre><code>double overallRatio = 120.0 / 20.0;  // 6:1\nint numStages = 2;\ndouble stageRatio = Math.pow(overallRatio, 1.0 / numStages);  // \u221a6 \u2248 2.45\n</code></pre>"},{"location":"process/equipment/compressors/#antisurge-control","title":"Antisurge Control","text":"<pre><code>// Recycle valve for antisurge\nSplitter recycle = new Splitter(\"Antisurge Recycle\", stage2.getOutletStream());\nrecycle.setSplitFactors(new double[]{0.9, 0.1});  // 10% recycle\n\n// Mix with inlet\nMixer mixer = new Mixer(\"Inlet Mixer\");\nmixer.addStream(inletStream);\nmixer.addStream(recycle.getSplitStream(1));\n</code></pre>"},{"location":"process/equipment/compressors/#power-calculation-details","title":"Power Calculation Details","text":""},{"location":"process/equipment/compressors/#real-gas-effects","title":"Real Gas Effects","text":"<pre><code>// Account for compressibility\ndouble Z1 = compressor.getInletStream().getZ();\ndouble Z2 = compressor.getOutletStream().getZ();\ndouble Zavg = (Z1 + Z2) / 2;\n</code></pre>"},{"location":"process/equipment/compressors/#mechanical-efficiency","title":"Mechanical Efficiency","text":"<pre><code>// Include mechanical losses\ncompressor.setMechanicalEfficiency(0.98);\ndouble shaftPower = compressor.getShaftPower(\"kW\");\ndouble gasHorsepower = compressor.getGasHorsepower(\"hp\");\n</code></pre>"},{"location":"process/equipment/compressors/#example-export-gas-compression","title":"Example: Export Gas Compression","text":"<pre><code>// Export gas at 100 MSm\u00b3/day\nSystemInterface gas = new SystemSrkEos(288.15, 30.0);\ngas.addComponent(\"methane\", 0.92);\ngas.addComponent(\"ethane\", 0.04);\ngas.addComponent(\"propane\", 0.02);\ngas.addComponent(\"CO2\", 0.01);\ngas.addComponent(\"nitrogen\", 0.01);\ngas.setMixingRule(\"classic\");\n\nStream inlet = new Stream(\"Inlet Gas\", gas);\ninlet.setFlowRate(100.0, \"MSm3/day\");\ninlet.setTemperature(30.0, \"C\");\ninlet.setPressure(30.0, \"bara\");\n\nProcessSystem process = new ProcessSystem();\nprocess.add(inlet);\n\n// 3-stage compression to 200 bar\ndouble[] stagePressures = {55, 105, 200};\n\nStream currentStream = inlet;\nfor (int i = 0; i &lt; 3; i++) {\n    Compressor comp = new Compressor(\"K-10\" + (i+1), currentStream);\n    comp.setOutletPressure(stagePressures[i], \"bara\");\n    comp.setPolytropicEfficiency(0.78);\n    comp.setUsePolytropicCalc(true);\n    process.add(comp);\n\n    Cooler cooler = new Cooler(\"E-10\" + (i+1), comp.getOutletStream());\n    cooler.setOutTemperature(40.0, \"C\");\n    process.add(cooler);\n\n    currentStream = cooler.getOutletStream();\n}\n\nprocess.run();\n\n// Report\nSystem.out.println(\"\\n=== Compression Summary ===\");\ndouble totalPower = 0;\nfor (int i = 1; i &lt;= 3; i++) {\n    Compressor c = (Compressor) process.getUnit(\"K-10\" + i);\n    totalPower += c.getPower(\"MW\");\n    System.out.printf(\"Stage %d: %.2f bar -&gt; %.2f bar, %.2f MW%n\",\n        i, c.getInletStream().getPressure(\"bara\"),\n        c.getOutletStream().getPressure(\"bara\"),\n        c.getPower(\"MW\"));\n}\nSystem.out.println(\"Total power: \" + totalPower + \" MW\");\n</code></pre>"},{"location":"process/equipment/compressors/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Expanders - Expansion equipment</li> <li>Pumps - Liquid compression</li> </ul>"},{"location":"process/equipment/distillation/","title":"Distillation Equipment","text":"<p>Documentation for distillation column equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/distillation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Column Types</li> <li>Configuration</li> <li>Solver Options</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/distillation/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.distillation</code></p> <p>Classes: - <code>DistillationColumn</code> - Main distillation column - <code>SimpleTray</code> - Individual tray - <code>Condenser</code> - Column condenser - <code>Reboiler</code> - Column reboiler</p>"},{"location":"process/equipment/distillation/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.distillation.DistillationColumn;\n\n// Create column with 10 trays, condenser, and reboiler\nDistillationColumn column = new DistillationColumn(\"Deethanizer\", 10, true, true);\ncolumn.addFeedStream(feedStream, 5);  // Feed on tray 5\ncolumn.setCondenserTemperature(40.0, \"C\");\ncolumn.setReboilerTemperature(120.0, \"C\");\ncolumn.run();\n\n// Get products\nStream overhead = column.getGasOutStream();\nStream bottoms = column.getLiquidOutStream();\n</code></pre>"},{"location":"process/equipment/distillation/#column-configuration","title":"Column Configuration","text":""},{"location":"process/equipment/distillation/#number-of-trays","title":"Number of Trays","text":"<pre><code>// Constructor: (name, numTrays, hasCondenser, hasReboiler)\nDistillationColumn column = new DistillationColumn(\"T-100\", 20, true, true);\n</code></pre>"},{"location":"process/equipment/distillation/#feed-location","title":"Feed Location","text":"<pre><code>// Single feed\ncolumn.addFeedStream(feed, 10);  // Tray 10 from bottom\n\n// Multiple feeds\ncolumn.addFeedStream(feed1, 8);\ncolumn.addFeedStream(feed2, 12);\n</code></pre>"},{"location":"process/equipment/distillation/#condenser-type","title":"Condenser Type","text":"<pre><code>// Total condenser\ncolumn.setCondenserType(\"total\");\n\n// Partial condenser (vapor overhead)\ncolumn.setCondenserType(\"partial\");\n</code></pre>"},{"location":"process/equipment/distillation/#side-draws","title":"Side Draws","text":"<pre><code>// Liquid side draw\ncolumn.addSideDraw(7, \"liquid\", 100.0, \"kg/hr\");\n\n// Vapor side draw\ncolumn.addSideDraw(15, \"vapor\", 50.0, \"kg/hr\");\n</code></pre>"},{"location":"process/equipment/distillation/#operating-specifications","title":"Operating Specifications","text":""},{"location":"process/equipment/distillation/#temperature-specifications","title":"Temperature Specifications","text":"<pre><code>// Condenser temperature\ncolumn.setCondenserTemperature(40.0, \"C\");\n\n// Reboiler temperature\ncolumn.setReboilerTemperature(120.0, \"C\");\n</code></pre>"},{"location":"process/equipment/distillation/#pressure-profile","title":"Pressure Profile","text":"<pre><code>// Top pressure\ncolumn.setTopPressure(15.0, \"bara\");\n\n// Bottom pressure (or pressure drop)\ncolumn.setBottomPressure(16.0, \"bara\");\n\n// Or specify pressure drop per tray\ncolumn.setPressureDropPerTray(0.05, \"bar\");\n</code></pre>"},{"location":"process/equipment/distillation/#reflux-specifications","title":"Reflux Specifications","text":"<pre><code>// Reflux ratio\ncolumn.setRefluxRatio(3.0);\n\n// Condenser duty\ncolumn.setCondenserDuty(-5000000.0);  // W (negative = cooling)\n</code></pre>"},{"location":"process/equipment/distillation/#reboiler-specifications","title":"Reboiler Specifications","text":"<pre><code>// Reboiler duty\ncolumn.setReboilerDuty(6000000.0);  // W\n\n// Boilup ratio\ncolumn.setBoilupRatio(2.5);\n</code></pre>"},{"location":"process/equipment/distillation/#solver-options","title":"Solver Options","text":""},{"location":"process/equipment/distillation/#available-solvers","title":"Available Solvers","text":"<pre><code>// Standard sequential solver\ncolumn.setSolverType(DistillationColumn.SolverType.STANDARD);\n\n// Damped solver (more robust)\ncolumn.setSolverType(DistillationColumn.SolverType.DAMPED);\n\n// Inside-out solver (fastest for converged cases)\ncolumn.setSolverType(DistillationColumn.SolverType.INSIDE_OUT);\n</code></pre>"},{"location":"process/equipment/distillation/#convergence-settings","title":"Convergence Settings","text":"<pre><code>// Maximum iterations\ncolumn.setMaxIterations(100);\n\n// Tolerance\ncolumn.setTolerance(1e-6);\n\n// Damping factor\ncolumn.setDampingFactor(0.5);\n</code></pre>"},{"location":"process/equipment/distillation/#initialization","title":"Initialization","text":"<pre><code>// Linear temperature profile initialization\ncolumn.setInitialTemperatureProfile(\"linear\");\n\n// Custom initialization\ndouble[] initTemps = {120, 115, 110, 105, 100, 95, 90, 85, 80, 75, 70};\ncolumn.setInitialTemperatures(initTemps);\n</code></pre>"},{"location":"process/equipment/distillation/#column-results","title":"Column Results","text":""},{"location":"process/equipment/distillation/#tray-by-tray-profiles","title":"Tray-by-Tray Profiles","text":"<pre><code>column.run();\n\n// Temperature profile\nfor (int i = 0; i &lt; column.getNumberOfTrays(); i++) {\n    double T = column.getTray(i).getTemperature(\"C\");\n    System.out.println(\"Tray \" + i + \": \" + T + \" \u00b0C\");\n}\n\n// Composition profile\nfor (int i = 0; i &lt; column.getNumberOfTrays(); i++) {\n    double[] x = column.getTray(i).getLiquidComposition();\n    double[] y = column.getTray(i).getVaporComposition();\n}\n</code></pre>"},{"location":"process/equipment/distillation/#duties","title":"Duties","text":"<pre><code>double Qcond = column.getCondenserDuty();  // W\ndouble Qreb = column.getReboilerDuty();    // W\n\nSystem.out.println(\"Condenser duty: \" + (-Qcond/1e6) + \" MW\");\nSystem.out.println(\"Reboiler duty: \" + (Qreb/1e6) + \" MW\");\n</code></pre>"},{"location":"process/equipment/distillation/#separation-performance","title":"Separation Performance","text":"<pre><code>// Product purities\ndouble overheadPurity = overhead.getFluid().getComponent(\"ethane\").getx();\ndouble bottomsRecovery = 1.0 - (overhead.getFluid().getComponent(\"propane\").getNumberOfmable() /\n    feedStream.getFluid().getComponent(\"propane\").getNumberOfmable());\n</code></pre>"},{"location":"process/equipment/distillation/#example-ngl-fractionation","title":"Example: NGL Fractionation","text":""},{"location":"process/equipment/distillation/#deethanizer","title":"Deethanizer","text":"<pre><code>// Feed: NGL from gas plant\nSystemInterface ngl = new SystemSrkEos(273.15 + 30, 25.0);\nngl.addComponent(\"methane\", 0.02);\nngl.addComponent(\"ethane\", 0.25);\nngl.addComponent(\"propane\", 0.35);\nngl.addComponent(\"i-butane\", 0.10);\nngl.addComponent(\"n-butane\", 0.18);\nngl.addComponent(\"n-pentane\", 0.10);\nngl.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"NGL Feed\", ngl);\nfeed.setFlowRate(5000.0, \"kg/hr\");\n\nProcessSystem process = new ProcessSystem();\nprocess.add(feed);\n\n// Deethanizer column\nDistillationColumn deethanizer = new DistillationColumn(\"Deethanizer\", 25, true, true);\ndeethanizer.addFeedStream(feed, 12);\ndeethanizer.setTopPressure(25.0, \"bara\");\ndeethanizer.setCondenserTemperature(-10.0, \"C\");\ndeethanizer.setReboilerTemperature(100.0, \"C\");\ndeethanizer.setSolverType(DistillationColumn.SolverType.INSIDE_OUT);\nprocess.add(deethanizer);\n\nprocess.run();\n\n// Results\nStream ethaneProduct = deethanizer.getGasOutStream();\nStream c3plusProduct = deethanizer.getLiquidOutStream();\n\nSystem.out.println(\"Ethane product:\");\nSystem.out.println(\"  Flow: \" + ethaneProduct.getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"  C2 purity: \" + \n    ethaneProduct.getFluid().getComponent(\"ethane\").getx() * 100 + \" mol%\");\n\nSystem.out.println(\"C3+ product:\");\nSystem.out.println(\"  Flow: \" + c3plusProduct.getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"  C2 content: \" + \n    c3plusProduct.getFluid().getComponent(\"ethane\").getx() * 100 + \" mol%\");\n</code></pre>"},{"location":"process/equipment/distillation/#depropanizer","title":"Depropanizer","text":"<pre><code>// Feed from deethanizer bottoms\nDistillationColumn depropanizer = new DistillationColumn(\"Depropanizer\", 30, true, true);\ndepropanizer.addFeedStream(c3plusProduct, 15);\ndepropanizer.setTopPressure(18.0, \"bara\");\ndepropanizer.setCondenserTemperature(45.0, \"C\");\ndepropanizer.setReboilerTemperature(110.0, \"C\");\nprocess.add(depropanizer);\n\nprocess.run();\n\nStream propaneProduct = depropanizer.getGasOutStream();\nStream c4plusProduct = depropanizer.getLiquidOutStream();\n</code></pre>"},{"location":"process/equipment/distillation/#absorber-column","title":"Absorber Column","text":"<p>For absorption without reboiler:</p> <pre><code>DistillationColumn absorber = new DistillationColumn(\"Absorber\", 10, false, false);\nabsorber.addFeedStream(gasStream, 1);      // Gas at bottom\nabsorber.addFeedStream(leanSolvent, 10);   // Solvent at top\nabsorber.run();\n\nStream richSolvent = absorber.getLiquidOutStream();\nStream sweetGas = absorber.getGasOutStream();\n</code></pre>"},{"location":"process/equipment/distillation/#stripper-column","title":"Stripper Column","text":"<p>For stripping without condenser:</p> <pre><code>DistillationColumn stripper = new DistillationColumn(\"Stripper\", 8, false, true);\nstripper.addFeedStream(richSolvent, 1);\nstripper.setReboilerTemperature(120.0, \"C\");\nstripper.run();\n\nStream acidGas = stripper.getGasOutStream();\nStream leanSolvent = stripper.getLiquidOutStream();\n</code></pre>"},{"location":"process/equipment/distillation/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Heat Exchangers - Condensers and reboilers</li> <li>Absorbers - Absorption columns</li> </ul>"},{"location":"process/equipment/ejectors/","title":"Ejector Equipment","text":"<p>Documentation for ejector equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/ejectors/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Ejector Class</li> <li>Operating Principles</li> <li>Design Parameters</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/ejectors/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.ejector</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Ejector</code> | Steam/gas ejector for compression | | <code>EjectorDesignResult</code> | Design calculation results |</p> <p>Ejectors use the kinetic energy of a high-pressure motive stream to entrain and compress a low-pressure suction stream. Common applications include: - Vapor recovery systems - Vacuum generation - Flare gas recovery - LP gas compression without rotating equipment</p>"},{"location":"process/equipment/ejectors/#ejector-class","title":"Ejector Class","text":""},{"location":"process/equipment/ejectors/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.ejector.Ejector;\n\n// Create ejector with motive and suction streams\nEjector ejector = new Ejector(\"Ejector-100\", motiveStream, suctionStream);\nejector.setDischargePressure(5.0);  // bara\nejector.setEfficiencyIsentropic(0.75);  // Nozzle efficiency\nejector.setDiffuserEfficiency(0.80);    // Diffuser efficiency\nejector.run();\n\n// Get mixed stream\nStreamInterface mixedStream = ejector.getMixedStream();\ndouble dischargeT = mixedStream.getTemperature(\"C\");\ndouble dischargeP = mixedStream.getPressure(\"bara\");\n</code></pre>"},{"location":"process/equipment/ejectors/#stream-setup","title":"Stream Setup","text":"<pre><code>// High-pressure motive stream (e.g., HP steam or gas)\nSystemInterface motiveFluid = new SystemSrkEos(250.0, 10.0);\nmotiveFluid.addComponent(\"water\", 1.0);\nmotiveFluid.setMixingRule(\"classic\");\n\nStream motiveStream = new Stream(\"Motive Steam\", motiveFluid);\nmotiveStream.setFlowRate(1000.0, \"kg/hr\");\nmotiveStream.run();\n\n// Low-pressure suction stream\nSystemInterface suctionFluid = new SystemSrkEos(300.0, 1.5);\nsuctionFluid.addComponent(\"methane\", 0.95);\nsuctionFluid.addComponent(\"ethane\", 0.05);\nsuctionFluid.setMixingRule(\"classic\");\n\nStream suctionStream = new Stream(\"Suction Gas\", suctionFluid);\nsuctionStream.setFlowRate(500.0, \"kg/hr\");\nsuctionStream.run();\n</code></pre>"},{"location":"process/equipment/ejectors/#operating-principles","title":"Operating Principles","text":""},{"location":"process/equipment/ejectors/#ejector-sections","title":"Ejector Sections","text":"<p>An ejector consists of four main sections:</p> <ol> <li>Nozzle: Converts motive stream pressure to velocity</li> <li>Suction Chamber: Entrains low-pressure gas</li> <li>Mixing Chamber: Momentum exchange between streams</li> <li>Diffuser: Converts velocity back to pressure</li> </ol>"},{"location":"process/equipment/ejectors/#energy-balance","title":"Energy Balance","text":"<p>The ejector performs isentropic expansion and compression:</p> \\[\\eta_{nozzle} = \\frac{h_1 - h_2}{h_1 - h_{2s}}\\] \\[\\eta_{diffuser} = \\frac{h_{4s} - h_3}{h_4 - h_3}\\] <p>Where: - \\(h_1\\) = motive inlet enthalpy - \\(h_2\\) = nozzle outlet enthalpy (actual) - \\(h_{2s}\\) = nozzle outlet enthalpy (isentropic) - \\(h_3\\) = mixing section outlet enthalpy - \\(h_4\\) = diffuser outlet enthalpy (actual) - \\(h_{4s}\\) = diffuser outlet enthalpy (isentropic)</p>"},{"location":"process/equipment/ejectors/#entrainment-ratio","title":"Entrainment Ratio","text":"<p>The entrainment ratio (ER) is defined as:</p> \\[ER = \\frac{\\dot{m}_{suction}}{\\dot{m}_{motive}}\\]"},{"location":"process/equipment/ejectors/#design-parameters","title":"Design Parameters","text":""},{"location":"process/equipment/ejectors/#efficiency-settings","title":"Efficiency Settings","text":"<pre><code>// Nozzle isentropic efficiency (typically 0.7-0.9)\nejector.setEfficiencyIsentropic(0.75);\n\n// Diffuser efficiency (typically 0.7-0.85)\nejector.setDiffuserEfficiency(0.80);\n</code></pre>"},{"location":"process/equipment/ejectors/#discharge-pressure","title":"Discharge Pressure","text":"<pre><code>// Set target discharge pressure\nejector.setDischargePressure(5.0);  // bara\n</code></pre>"},{"location":"process/equipment/ejectors/#design-velocities","title":"Design Velocities","text":"<pre><code>// Optional: Override default suction and diffuser velocities\nejector.setDesignSuctionVelocity(30.0);  // m/s\nejector.setDesignDiffuserOutletVelocity(20.0);  // m/s\n</code></pre>"},{"location":"process/equipment/ejectors/#connection-lengths","title":"Connection Lengths","text":"<pre><code>// Optional: Set connection pipe lengths for pressure drop\nejector.setSuctionConnectionLength(2.0);  // m\nejector.setDischargeConnectionLength(3.0);  // m\n</code></pre>"},{"location":"process/equipment/ejectors/#mechanical-design","title":"Mechanical Design","text":"<pre><code>// Get mechanical design parameters\nEjectorMechanicalDesign mechDesign = ejector.getMechanicalDesign();\n\n// Calculate sizing\nmechDesign.calcDesign();\n\n// Get geometry\ndouble throatDiameter = mechDesign.getThroatDiameter();  // m\ndouble nozzleLength = mechDesign.getNozzleLength();  // m\ndouble mixingLength = mechDesign.getMixingLength();  // m\ndouble diffuserLength = mechDesign.getDiffuserLength();  // m\n</code></pre>"},{"location":"process/equipment/ejectors/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/ejectors/#flare-gas-recovery","title":"Flare Gas Recovery","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// High-pressure motive gas from compressor discharge\nStream motiveGas = new Stream(\"HP Gas\", hpGasFluid);\nmotiveGas.setFlowRate(2000.0, \"kg/hr\");\nmotiveGas.setTemperature(60.0, \"C\");\nmotiveGas.setPressure(40.0, \"bara\");\nprocess.add(motiveGas);\n\n// Low-pressure flare header gas\nStream flareGas = new Stream(\"Flare Gas\", flareGasFluid);\nflareGas.setFlowRate(500.0, \"kg/hr\");\nflareGas.setTemperature(40.0, \"C\");\nflareGas.setPressure(1.2, \"bara\");\nprocess.add(flareGas);\n\n// Ejector to recover flare gas\nEjector fgr = new Ejector(\"FGR Ejector\", motiveGas, flareGas);\nfgr.setDischargePressure(8.0);  // bara\nfgr.setEfficiencyIsentropic(0.75);\nfgr.setDiffuserEfficiency(0.80);\nprocess.add(fgr);\n\n// Run process\nprocess.run();\n\n// Results\ndouble entrainmentRatio = flareGas.getFlowRate(\"kg/hr\") / motiveGas.getFlowRate(\"kg/hr\");\nSystem.out.println(\"Entrainment ratio: \" + entrainmentRatio);\nSystem.out.println(\"Discharge pressure: \" + fgr.getMixedStream().getPressure(\"bara\") + \" bara\");\n</code></pre>"},{"location":"process/equipment/ejectors/#steam-ejector-vacuum-system","title":"Steam Ejector Vacuum System","text":"<pre><code>// HP steam as motive fluid\nStream hpSteam = new Stream(\"HP Steam\", steamFluid);\nhpSteam.setFlowRate(1500.0, \"kg/hr\");\nhpSteam.setTemperature(200.0, \"C\");\nhpSteam.setPressure(10.0, \"bara\");\n\n// Vacuum overhead vapor\nStream vacuumVapor = new Stream(\"Vacuum Vapor\", vaporFluid);\nvacuumVapor.setFlowRate(300.0, \"kg/hr\");\nvacuumVapor.setTemperature(50.0, \"C\");\nvacuumVapor.setPressure(0.1, \"bara\");\n\n// First stage ejector\nEjector ejector1 = new Ejector(\"1st Stage\", hpSteam, vacuumVapor);\nejector1.setDischargePressure(0.5);  // bara\nejector1.run();\n\n// Intercondenser\nCooler intercondenser = new Cooler(\"Intercondenser\", ejector1.getMixedStream());\nintercondenser.setOutTemperature(40.0, \"C\");\n\n// Second stage ejector\nEjector ejector2 = new Ejector(\"2nd Stage\", hpSteam2, intercondenser.getOutletStream());\nejector2.setDischargePressure(1.1);  // bara\nejector2.run();\n</code></pre>"},{"location":"process/equipment/ejectors/#performance-curves","title":"Performance Curves","text":""},{"location":"process/equipment/ejectors/#entrainment-vs-compression-ratio","title":"Entrainment vs Compression Ratio","text":"<p>For a given motive pressure and geometry, ejector performance follows characteristic curves:</p> <pre><code>// Calculate performance at different suction pressures\ndouble[] suctionPressures = {0.5, 1.0, 1.5, 2.0};  // bara\nfor (double Ps : suctionPressures) {\n    suctionStream.setPressure(Ps, \"bara\");\n    suctionStream.run();\n    ejector.run();\n\n    double compressionRatio = ejector.getMixedStream().getPressure(\"bara\") / Ps;\n    System.out.println(\"Suction P: \" + Ps + \" bara, CR: \" + compressionRatio);\n}\n</code></pre>"},{"location":"process/equipment/ejectors/#related-documentation","title":"Related Documentation","text":"<ul> <li>Compressors - Gas compression alternatives</li> <li>Streams - Stream handling</li> <li>Process Package - Package overview</li> </ul>"},{"location":"process/equipment/electrolyzers/","title":"Electrolyzer Equipment","text":"<p>Documentation for electrolyzer equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/electrolyzers/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Electrolyzer Classes</li> <li>PEM Electrolyzer</li> <li>CO\u2082 Electrolyzer</li> <li>Energy Calculations</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/electrolyzers/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.electrolyzer</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Electrolyzer</code> | Base electrolyzer class | | <code>CO2Electrolyzer</code> | CO\u2082 electrolysis unit |</p> <p>Electrolyzers convert electrical energy into chemical energy through electrochemical reactions. Key applications: - Green hydrogen production (water electrolysis) - CO\u2082 reduction to fuels/chemicals - Power-to-X systems - Energy storage</p>"},{"location":"process/equipment/electrolyzers/#electrolyzer-class","title":"Electrolyzer Class","text":""},{"location":"process/equipment/electrolyzers/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.electrolyzer.Electrolyzer;\n\n// Create electrolyzer with water feed\nElectrolyzer electrolyzer = new Electrolyzer(\"PEM Electrolyzer\", waterStream);\nelectrolyzer.setPower(1e6);  // 1 MW\nelectrolyzer.setEfficiency(0.70);  // 70% efficiency\nelectrolyzer.run();\n\n// Get hydrogen production\nStreamInterface h2Stream = electrolyzer.getHydrogenStream();\ndouble h2Rate = h2Stream.getFlowRate(\"kg/hr\");\nSystem.out.println(\"H2 production: \" + h2Rate + \" kg/hr\");\n</code></pre>"},{"location":"process/equipment/electrolyzers/#co2-electrolyzer","title":"CO\u2082 Electrolyzer","text":"<p>The CO2Electrolyzer converts CO\u2082 to valuable products through electrolysis.</p>"},{"location":"process/equipment/electrolyzers/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.electrolyzer.CO2Electrolyzer;\n\n// Create CO2 electrolyzer\nCO2Electrolyzer co2Elec = new CO2Electrolyzer(\"CO2 Electrolyzer\", co2Stream);\nco2Elec.setPower(500e3);  // 500 kW\nco2Elec.run();\n\n// Get products\nStreamInterface products = co2Elec.getOutletStream();\n</code></pre>"},{"location":"process/equipment/electrolyzers/#products","title":"Products","text":"<p>CO\u2082 electrolysis can produce various products depending on the catalyst: - Carbon monoxide (CO) - Formic acid (HCOOH) - Methanol (CH\u2083OH) - Ethylene (C\u2082H\u2084) - Syngas (CO + H\u2082)</p>"},{"location":"process/equipment/electrolyzers/#energy-calculations","title":"Energy Calculations","text":""},{"location":"process/equipment/electrolyzers/#power-consumption","title":"Power Consumption","text":"<p>The electrical power required for electrolysis:</p> \\[P = \\frac{\\Delta G}{\\eta_{elec}}\\] <p>Where: - \\(\\Delta G\\) = Gibbs free energy of reaction - \\(\\eta_{elec}\\) = electrolyzer efficiency</p>"},{"location":"process/equipment/electrolyzers/#efficiency","title":"Efficiency","text":"<pre><code>// Set efficiency (energy efficiency)\nelectrolyzer.setEfficiency(0.75);  // 75%\n\n// Get actual power consumption\ndouble power = electrolyzer.getPower();  // W\n</code></pre>"},{"location":"process/equipment/electrolyzers/#faradaic-efficiency","title":"Faradaic Efficiency","text":"<p>The fraction of electrical current that drives the desired reaction:</p> \\[\\eta_F = \\frac{n \\times F \\times \\dot{n}_{product}}{I}\\] <p>Where: - \\(n\\) = electrons per molecule - \\(F\\) = Faraday constant (96485 C/mol) - \\(\\dot{n}_{product}\\) = molar production rate - \\(I\\) = current</p>"},{"location":"process/equipment/electrolyzers/#water-electrolysis","title":"Water Electrolysis","text":""},{"location":"process/equipment/electrolyzers/#reaction","title":"Reaction","text":"\\[2H_2O \\rightarrow 2H_2 + O_2\\]"},{"location":"process/equipment/electrolyzers/#energy-requirement","title":"Energy Requirement","text":"<p>Theoretical minimum: 39.4 kWh/kg H\u2082 (based on HHV)</p> <p>Typical actual consumption: | Technology | Energy (kWh/kg H\u2082) | |------------|-------------------| | Alkaline | 50-55 | | PEM | 50-60 | | SOEC | 35-45 |</p>"},{"location":"process/equipment/electrolyzers/#example","title":"Example","text":"<pre><code>// Water feed\nSystemInterface waterFluid = new SystemSrkEos(298.15, 1.0);\nwaterFluid.addComponent(\"water\", 1.0);\nwaterFluid.setMixingRule(\"classic\");\n\nStream waterFeed = new Stream(\"Water Feed\", waterFluid);\nwaterFeed.setFlowRate(1000.0, \"kg/hr\");\nwaterFeed.run();\n\n// PEM Electrolyzer\nElectrolyzer pemElec = new Electrolyzer(\"PEM Stack\", waterFeed);\npemElec.setPower(10e6);  // 10 MW\npemElec.setEfficiency(0.70);  // 70%\npemElec.run();\n\n// Hydrogen output\ndouble h2Production = pemElec.getHydrogenStream().getFlowRate(\"kg/hr\");\ndouble specificEnergy = pemElec.getPower() / 1000 / h2Production;  // kWh/kg\n\nSystem.out.println(\"H2 production: \" + h2Production + \" kg/hr\");\nSystem.out.println(\"Specific energy: \" + specificEnergy + \" kWh/kg H2\");\n</code></pre>"},{"location":"process/equipment/electrolyzers/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/electrolyzers/#green-hydrogen-plant","title":"Green Hydrogen Plant","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Deionized water feed\nSystemInterface diWater = new SystemSrkEos(298.15, 1.0);\ndiWater.addComponent(\"water\", 1.0);\n\nStream waterFeed = new Stream(\"DI Water\", diWater);\nwaterFeed.setFlowRate(2000.0, \"kg/hr\");\nprocess.add(waterFeed);\n\n// Electrolyzer stack\nElectrolyzer electrolyzer = new Electrolyzer(\"H2 Electrolyzer\", waterFeed);\nelectrolyzer.setPower(20e6);  // 20 MW from renewable source\nelectrolyzer.setEfficiency(0.72);\nprocess.add(electrolyzer);\n\n// Hydrogen purification (PSA or membrane)\nMembraneSeparator h2Purifier = new MembraneSeparator(\"H2 Purifier\", \n    electrolyzer.getHydrogenStream());\nh2Purifier.setPermeateFraction(\"hydrogen\", 0.999);\nh2Purifier.setPermeateFraction(\"water\", 0.01);\nprocess.add(h2Purifier);\n\n// Compression for storage\nCompressor h2Comp = new Compressor(\"H2 Compressor\", h2Purifier.getPermeateStream());\nh2Comp.setOutletPressure(350.0, \"bara\");\nh2Comp.setPolytropicEfficiency(0.80);\nprocess.add(h2Comp);\n\n// Run process\nprocess.run();\n\n// Results\ndouble h2Output = h2Comp.getOutletStream().getFlowRate(\"kg/hr\");\ndouble h2Purity = h2Comp.getOutletStream().getFluid().getMoleFraction(\"hydrogen\") * 100;\nSystem.out.println(\"H2 output: \" + h2Output + \" kg/hr\");\nSystem.out.println(\"H2 purity: \" + h2Purity + \" %\");\n</code></pre>"},{"location":"process/equipment/electrolyzers/#power-to-methanol","title":"Power-to-Methanol","text":"<pre><code>// CO2 capture stream\nStream co2Stream = new Stream(\"Captured CO2\", co2Fluid);\nco2Stream.setFlowRate(1000.0, \"kg/hr\");\n\n// CO2 electrolyzer producing syngas\nCO2Electrolyzer co2Elec = new CO2Electrolyzer(\"CO2 Electrolyzer\", co2Stream);\nco2Elec.setPower(5e6);  // 5 MW\nco2Elec.run();\n\n// Additional hydrogen from water electrolysis\nElectrolyzer h2Elec = new Electrolyzer(\"H2 Electrolyzer\", waterStream);\nh2Elec.setPower(15e6);  // 15 MW\nh2Elec.run();\n\n// Mix syngas and H2 for methanol synthesis\nMixer syngasMixer = new Mixer(\"Syngas Mixer\");\nsyngasMixer.addStream(co2Elec.getOutletStream());\nsyngasMixer.addStream(h2Elec.getHydrogenStream());\n\n// Methanol reactor (downstream)\n// ...\n</code></pre>"},{"location":"process/equipment/electrolyzers/#energy-storage-application","title":"Energy Storage Application","text":"<pre><code>// Variable renewable power input\ndouble[] powerProfile = loadRenewablePowerProfile();  // hourly MW\n\n// Electrolyzer with variable power\nElectrolyzer electrolyzer = new Electrolyzer(\"Variable Electrolyzer\", waterFeed);\nelectrolyzer.setEfficiency(0.70);\n\ndouble totalH2 = 0.0;\nfor (int hour = 0; hour &lt; 24; hour++) {\n    double power = powerProfile[hour] * 1e6;  // Convert MW to W\n\n    if (power &gt; 0) {\n        electrolyzer.setPower(power);\n        electrolyzer.run();\n\n        double h2Rate = electrolyzer.getHydrogenStream().getFlowRate(\"kg/hr\");\n        totalH2 += h2Rate;\n\n        System.out.println(\"Hour \" + hour + \": Power=\" + power/1e6 + \n            \" MW, H2=\" + h2Rate + \" kg/hr\");\n    }\n}\n\nSystem.out.println(\"Total H2 production: \" + totalH2 + \" kg\");\n</code></pre>"},{"location":"process/equipment/electrolyzers/#operating-parameters","title":"Operating Parameters","text":""},{"location":"process/equipment/electrolyzers/#temperature-and-pressure","title":"Temperature and Pressure","text":"<pre><code>// Set operating conditions\nelectrolyzer.setTemperature(80.0, \"C\");  // PEM typical\nelectrolyzer.setPressure(30.0, \"bara\");  // Pressurized operation\n\n// High-temperature electrolysis (SOEC)\nelectrolyzer.setTemperature(800.0, \"C\");\nelectrolyzer.setPressure(1.0, \"bara\");\n</code></pre>"},{"location":"process/equipment/electrolyzers/#stack-configuration","title":"Stack Configuration","text":"<pre><code>// Set number of cells\nelectrolyzer.setNumberOfCells(100);\n\n// Set cell voltage\nelectrolyzer.setCellVoltage(1.8);  // V\n\n// Calculate current\ndouble current = electrolyzer.getCurrent();  // A\n</code></pre>"},{"location":"process/equipment/electrolyzers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Reactors - Chemical reactors</li> <li>Compressors - H2 compression</li> <li>Membrane Separators - Gas purification</li> <li>Process Package - Package overview</li> </ul>"},{"location":"process/equipment/expanders/","title":"Expanders and Turbines","text":"<p>Documentation for expansion equipment in NeqSim.</p>"},{"location":"process/equipment/expanders/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Expander Class</li> <li>Turboexpander</li> <li>Power Recovery</li> <li>Compander Systems</li> <li>Examples</li> </ul>"},{"location":"process/equipment/expanders/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.expander</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Expander</code> | General gas expander | | <code>TurboExpander</code> | Turboexpander with shaft coupling | | <code>ExpanderCompressorModule</code> | Compander unit |</p> <p>Gas expanders are used for: - Power recovery from high-pressure gas - Cryogenic cooling (JT effect + work extraction) - NGL recovery processes - LNG production</p>"},{"location":"process/equipment/expanders/#expander-class","title":"Expander Class","text":""},{"location":"process/equipment/expanders/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.expander.Expander;\n\n// Create expander\nExpander expander = new Expander(\"EX-100\", gasStream);\nexpander.setOutletPressure(10.0, \"bara\");\nexpander.setIsentropicEfficiency(0.85);\nexpander.run();\n\n// Results\ndouble power = expander.getPower(\"kW\");\ndouble outletTemp = expander.getOutletTemperature(\"C\");\n</code></pre>"},{"location":"process/equipment/expanders/#outlet-specification","title":"Outlet Specification","text":"<pre><code>// By outlet pressure\nexpander.setOutletPressure(10.0, \"bara\");\n\n// By pressure ratio\nexpander.setPressureRatio(5.0);\n\n// By outlet temperature\nexpander.setOutletTemperature(-50.0, \"C\");\n</code></pre>"},{"location":"process/equipment/expanders/#turboexpander","title":"Turboexpander","text":"<p>For direct shaft coupling to compressor.</p>"},{"location":"process/equipment/expanders/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.expander.TurboExpander;\n\nTurboExpander turboExpander = new TurboExpander(\"TEX-100\", gasStream);\nturboExpander.setOutletPressure(10.0, \"bara\");\nturboExpander.setIsentropicEfficiency(0.85);\nturboExpander.run();\n</code></pre>"},{"location":"process/equipment/expanders/#shaft-coupling","title":"Shaft Coupling","text":"<pre><code>// Couple expander to compressor\nturboExpander.setCoupledCompressor(compressor);\n\n// Power balance\nturboExpander.run();\ncompressor.run();\n\ndouble expanderPower = turboExpander.getPower(\"kW\");\ndouble compressorPower = compressor.getPower(\"kW\");\ndouble netPower = expanderPower - compressorPower;\n</code></pre>"},{"location":"process/equipment/expanders/#power-recovery","title":"Power Recovery","text":""},{"location":"process/equipment/expanders/#isentropic-power","title":"Isentropic Power","text":"\\[W_{isentropic} = \\dot{m} \\cdot (h_1 - h_{2s})\\] <p>Where: - \\(h_1\\) = inlet enthalpy - \\(h_{2s}\\) = isentropic outlet enthalpy</p>"},{"location":"process/equipment/expanders/#actual-power","title":"Actual Power","text":"\\[W_{actual} = \\eta_{isentropic} \\cdot W_{isentropic}\\]"},{"location":"process/equipment/expanders/#temperature-drop","title":"Temperature Drop","text":"<pre><code>// Get temperatures\ndouble T_in = expander.getInletTemperature(\"C\");\ndouble T_out = expander.getOutletTemperature(\"C\");\ndouble deltaT = T_in - T_out;\n\n// Compare to JT expansion (throttling)\nThrottlingValve valve = new ThrottlingValve(\"JT\", gasStream);\nvalve.setOutletPressure(10.0, \"bara\");\nvalve.run();\n\ndouble T_out_JT = valve.getOutletTemperature(\"C\");\ndouble deltaT_JT = T_in - T_out_JT;\n\nSystem.out.println(\"Expander cooling: \" + deltaT + \" C\");\nSystem.out.println(\"JT cooling: \" + deltaT_JT + \" C\");\n</code></pre>"},{"location":"process/equipment/expanders/#compander-systems","title":"Compander Systems","text":"<p>Combined expander-compressor on single shaft.</p>"},{"location":"process/equipment/expanders/#usage","title":"Usage","text":"<pre><code>import neqsim.process.equipment.expander.ExpanderCompressorModule;\n\nExpanderCompressorModule compander = new ExpanderCompressorModule(\"Compander\");\ncompander.setExpanderInletStream(hotGas);\ncompander.setCompressorInletStream(coldGas);\ncompander.setExpanderOutletPressure(10.0, \"bara\");\ncompander.setCompressorOutletPressure(40.0, \"bara\");\ncompander.setIsentropicEfficiency(0.85);\ncompander.run();\n\ndouble netPower = compander.getNetPower(\"kW\");  // Can be positive or negative\n</code></pre>"},{"location":"process/equipment/expanders/#examples","title":"Examples","text":""},{"location":"process/equipment/expanders/#example-1-simple-expander","title":"Example 1: Simple Expander","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.expander.Expander;\n\n// High pressure gas\nSystemSrkEos gas = new SystemSrkEos(320.0, 80.0);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.07);\ngas.addComponent(\"propane\", 0.03);\ngas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"HP Gas\", gas);\nfeed.setFlowRate(50000.0, \"kg/hr\");\nfeed.run();\n\n// Expander\nExpander expander = new Expander(\"EX-100\", feed);\nexpander.setOutletPressure(20.0, \"bara\");\nexpander.setIsentropicEfficiency(0.85);\nexpander.run();\n\nSystem.out.println(\"Inlet: \" + feed.getTemperature(\"C\") + \" C, \" + feed.getPressure(\"bara\") + \" bara\");\nSystem.out.println(\"Outlet: \" + expander.getOutletTemperature(\"C\") + \" C, \" + expander.getOutletPressure(\"bara\") + \" bara\");\nSystem.out.println(\"Power generated: \" + expander.getPower(\"kW\") + \" kW\");\n</code></pre>"},{"location":"process/equipment/expanders/#example-2-ngl-recovery-with-turboexpander","title":"Example 2: NGL Recovery with Turboexpander","text":"<pre><code>// Rich gas feed\nSystemSrkEos richGas = new SystemSrkEos(300.0, 70.0);\nrichGas.addComponent(\"nitrogen\", 0.02);\nrichGas.addComponent(\"methane\", 0.75);\nrichGas.addComponent(\"ethane\", 0.10);\nrichGas.addComponent(\"propane\", 0.08);\nrichGas.addComponent(\"n-butane\", 0.05);\nrichGas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"Rich Gas\", richGas);\nfeed.setFlowRate(100000.0, \"Sm3/day\");\nfeed.run();\n\n// Pre-cooling\nCooler precooler = new Cooler(\"Pre-cooler\", feed);\nprecooler.setOutletTemperature(280.0, \"K\");\nprecooler.run();\n\n// Turboexpander\nTurboExpander expander = new TurboExpander(\"TEX-100\", precooler.getOutletStream());\nexpander.setOutletPressure(25.0, \"bara\");\nexpander.setIsentropicEfficiency(0.82);\nexpander.run();\n\n// Cold separator\nSeparator coldSep = new Separator(\"Cold Sep\", expander.getOutletStream());\ncoldSep.run();\n\n// Results\nSystem.out.println(\"Expander outlet: \" + expander.getOutletTemperature(\"C\") + \" C\");\nSystem.out.println(\"Power: \" + expander.getPower(\"kW\") + \" kW\");\nSystem.out.println(\"NGL recovered: \" + coldSep.getLiquidOutStream().getFlowRate(\"m3/hr\") + \" m\u00b3/hr\");\n</code></pre>"},{"location":"process/equipment/expanders/#example-3-expander-vs-jt-valve-comparison","title":"Example 3: Expander vs JT Valve Comparison","text":"<pre><code>// Same inlet conditions\nSystemSrkEos gas = new SystemSrkEos(300.0, 60.0);\ngas.addComponent(\"methane\", 0.85);\ngas.addComponent(\"ethane\", 0.10);\ngas.addComponent(\"propane\", 0.05);\ngas.setMixingRule(\"classic\");\n\nStream feed1 = new Stream(\"Feed 1\", gas);\nfeed1.setFlowRate(10000.0, \"kg/hr\");\nfeed1.run();\n\nStream feed2 = new Stream(\"Feed 2\", gas.clone());\nfeed2.setFlowRate(10000.0, \"kg/hr\");\nfeed2.run();\n\n// JT valve\nThrottlingValve valve = new ThrottlingValve(\"JT Valve\", feed1);\nvalve.setOutletPressure(15.0, \"bara\");\nvalve.run();\n\n// Expander\nExpander expander = new Expander(\"Expander\", feed2);\nexpander.setOutletPressure(15.0, \"bara\");\nexpander.setIsentropicEfficiency(0.85);\nexpander.run();\n\nSystem.out.println(\"JT Valve outlet: \" + valve.getOutletTemperature(\"C\") + \" C\");\nSystem.out.println(\"Expander outlet: \" + expander.getOutletTemperature(\"C\") + \" C\");\nSystem.out.println(\"Extra cooling: \" + (valve.getOutletTemperature(\"C\") - expander.getOutletTemperature(\"C\")) + \" C\");\nSystem.out.println(\"Power recovered: \" + expander.getPower(\"kW\") + \" kW\");\n</code></pre>"},{"location":"process/equipment/expanders/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Compressors - Gas compression</li> <li>Valves - JT valves</li> <li>Heat Exchangers - Heat integration</li> </ul>"},{"location":"process/equipment/filters/","title":"Filter Equipment","text":"<p>Documentation for filter equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/filters/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Filter Classes</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/filters/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.filter</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Filter</code> | Generic filter unit | | <code>CharCoalFilter</code> | Activated charcoal filter |</p> <p>Filters are used to remove specific components or contaminants from process streams. Applications include: - Particulate removal - Activated carbon adsorption - Mercury removal - Sulfur compound removal</p>"},{"location":"process/equipment/filters/#filter-class","title":"Filter Class","text":""},{"location":"process/equipment/filters/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.filter.Filter;\n\n// Create filter on gas stream\nFilter filter = new Filter(\"Particulate Filter\", gasStream);\nfilter.run();\n\n// Get outlet stream\nStreamInterface cleanGas = filter.getOutletStream();\n</code></pre>"},{"location":"process/equipment/filters/#charcoalfilter-class","title":"CharCoalFilter Class","text":"<p>Activated charcoal filter for removing specific components.</p>"},{"location":"process/equipment/filters/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.filter.CharCoalFilter;\n\n// Create charcoal filter\nCharCoalFilter charFilter = new CharCoalFilter(\"Mercury Filter\", gasStream);\ncharFilter.setRemovalEfficiency(\"mercury\", 0.99);  // 99% removal\ncharFilter.run();\n\n// Get treated stream\nStreamInterface treatedGas = charFilter.getOutletStream();\n</code></pre>"},{"location":"process/equipment/filters/#removal-efficiency","title":"Removal Efficiency","text":"<pre><code>// Set removal efficiency for specific components\ncharFilter.setRemovalEfficiency(\"mercury\", 0.99);\ncharFilter.setRemovalEfficiency(\"H2S\", 0.95);\ncharFilter.setRemovalEfficiency(\"benzene\", 0.90);\n</code></pre>"},{"location":"process/equipment/filters/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/filters/#inlet-gas-conditioning","title":"Inlet Gas Conditioning","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Raw gas feed\nStream rawGas = new Stream(\"Raw Gas\", gasFluid);\nrawGas.setFlowRate(100000.0, \"Sm3/day\");\nprocess.add(rawGas);\n\n// Particulate filter\nFilter particleFilter = new Filter(\"Inlet Filter\", rawGas);\nprocess.add(particleFilter);\n\n// Mercury removal\nCharCoalFilter hgFilter = new CharCoalFilter(\"Hg Guard Bed\", \n    particleFilter.getOutletStream());\nhgFilter.setRemovalEfficiency(\"mercury\", 0.999);\nprocess.add(hgFilter);\n\n// Run\nprocess.run();\n</code></pre>"},{"location":"process/equipment/filters/#lng-mercury-removal","title":"LNG Mercury Removal","text":"<pre><code>// Upstream of cryogenic section\nCharCoalFilter mercuryRemoval = new CharCoalFilter(\"Mercury Removal\", feed);\nmercuryRemoval.setRemovalEfficiency(\"mercury\", 0.9999);  // Critical for aluminum equipment\nmercuryRemoval.run();\n\ndouble outletMercury = mercuryRemoval.getOutletStream()\n    .getFluid().getComponent(\"mercury\").getFlowRate(\"g/hr\");\nSystem.out.println(\"Outlet mercury: \" + outletMercury + \" g/hr\");\n</code></pre>"},{"location":"process/equipment/filters/#related-documentation","title":"Related Documentation","text":"<ul> <li>Separators - Phase separation</li> <li>Absorbers - Absorption processes</li> <li>Streams - Stream handling</li> </ul>"},{"location":"process/equipment/flares/","title":"Flare Systems","text":"<p>Documentation for flare equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/flares/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Flare Class</li> <li>Combustion Calculations</li> <li>Capacity Monitoring</li> <li>Dynamic Operation</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/flares/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.flare</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Flare</code> | Main flare combustion unit | | <code>FlareStack</code> | Flare stack with dispersion | | <code>FlareCapacityDTO</code> | Capacity check results | | <code>FlarePerformanceDTO</code> | Performance metrics |</p> <p>Flares are safety devices that combust hydrocarbon gases that cannot be recovered. They are used for: - Emergency depressuring - Process upsets - Maintenance activities - Start-up/shutdown operations</p>"},{"location":"process/equipment/flares/#flare-class","title":"Flare Class","text":""},{"location":"process/equipment/flares/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.flare.Flare;\n\n// Create flare with inlet stream\nFlare flare = new Flare(\"HP Flare\", inletStream);\nflare.run();\n\n// Get results\ndouble heatRelease = flare.getHeatDuty();  // W\ndouble co2Emission = flare.getCO2Emission();  // kg/s\n\nSystem.out.println(\"Heat release: \" + heatRelease/1e6 + \" MW\");\nSystem.out.println(\"CO2 emission: \" + co2Emission * 3600 + \" kg/hr\");\n</code></pre>"},{"location":"process/equipment/flares/#constructor-options","title":"Constructor Options","text":"<pre><code>// With name only\nFlare flare = new Flare(\"Flare\");\nflare.setInletStream(flareGas);\n\n// With name and inlet stream\nFlare flare = new Flare(\"Flare\", flareGas);\n</code></pre>"},{"location":"process/equipment/flares/#combustion-calculations","title":"Combustion Calculations","text":""},{"location":"process/equipment/flares/#heat-release","title":"Heat Release","text":"<p>The flare calculates heat release based on the Lower Calorific Value (LCV):</p> \\[Q = LCV \\times \\dot{V}_{Sm3}\\] <pre><code>// Get heat release rate\ndouble heatDuty = flare.getHeatDuty();  // W\n\n// Convert to MW\ndouble heatMW = heatDuty / 1e6;\nSystem.out.println(\"Heat release: \" + heatMW + \" MW\");\n</code></pre>"},{"location":"process/equipment/flares/#co2-emissions","title":"CO\u2082 Emissions","text":"<p>CO\u2082 emissions are calculated from the carbon content of the flared gas:</p> \\[\\dot{m}_{CO_2} = \\sum_i (x_i \\times \\dot{n}_{total} \\times n_{C,i} \\times M_{CO_2})\\] <p>Where: - \\(x_i\\) = mole fraction of component i - \\(\\dot{n}_{total}\\) = total molar flow - \\(n_{C,i}\\) = number of carbon atoms in component i - \\(M_{CO_2}\\) = molecular weight of CO\u2082 (44.01 g/mol)</p> <pre><code>// Get CO2 emission rate\ndouble co2Rate = flare.getCO2Emission();  // kg/s\n\n// Convert to tonnes per hour\ndouble co2TonHr = co2Rate * 3.6;\nSystem.out.println(\"CO2 emissions: \" + co2TonHr + \" t/hr\");\n</code></pre>"},{"location":"process/equipment/flares/#flare-design-parameters","title":"Flare Design Parameters","text":""},{"location":"process/equipment/flares/#radiation","title":"Radiation","text":"<pre><code>// Set radiant fraction (fraction of heat released as radiation)\nflare.setRadiantFraction(0.20);  // 20%\n\n// Set flame height for radiation calculations\nflare.setFlameHeight(40.0);  // m\n\n// Get radiation at ground level\ndouble radiation = flare.getRadiationAtDistance(100.0);  // W/m\u00b2 at 100m\n</code></pre>"},{"location":"process/equipment/flares/#tip-diameter","title":"Tip Diameter","text":"<pre><code>// Set tip diameter for velocity calculations\nflare.setTipDiameter(0.5);  // m\n\n// Get tip velocity\ndouble tipVelocity = flare.getTipVelocity();  // m/s\n</code></pre>"},{"location":"process/equipment/flares/#capacity-monitoring","title":"Capacity Monitoring","text":""},{"location":"process/equipment/flares/#design-capacity","title":"Design Capacity","text":"<pre><code>// Set design capacity limits\nflare.setDesignHeatDutyCapacity(100e6);  // 100 MW\nflare.setDesignMassFlowCapacity(50.0);   // 50 kg/s\nflare.setDesignMolarFlowCapacity(2000.0); // 2000 mol/s\n</code></pre>"},{"location":"process/equipment/flares/#capacity-check","title":"Capacity Check","text":"<pre><code>// Check if within capacity\nflare.run();\nCapacityCheckResult result = flare.getCapacityCheckResult();\n\nif (result.isOverCapacity()) {\n    System.out.println(\"WARNING: Flare over capacity!\");\n    System.out.println(\"Heat duty: \" + result.getHeatDutyPercent() + \"% of design\");\n    System.out.println(\"Mass flow: \" + result.getMassFlowPercent() + \"% of design\");\n}\n</code></pre>"},{"location":"process/equipment/flares/#dynamic-operation","title":"Dynamic Operation","text":""},{"location":"process/equipment/flares/#transient-simulation","title":"Transient Simulation","text":"<pre><code>// Track cumulative values during transient\ndouble timeStep = 1.0;  // seconds\ndouble totalTime = 900.0;  // 15 minutes\n\nfor (double t = 0; t &lt; totalTime; t += timeStep) {\n    // Update inlet conditions (e.g., from blowdown)\n    updateFlareInlet(t);\n\n    flare.run();\n    flare.updateCumulative(timeStep);\n}\n\n// Get cumulative values\ndouble totalHeatGJ = flare.getCumulativeHeatReleased();  // GJ\ndouble totalGasBurned = flare.getCumulativeGasBurned();  // kg\ndouble totalCO2 = flare.getCumulativeCO2Emission();  // kg\n\nSystem.out.println(\"Total heat released: \" + totalHeatGJ + \" GJ\");\nSystem.out.println(\"Total gas burned: \" + totalGasBurned + \" kg\");\nSystem.out.println(\"Total CO2 emitted: \" + totalCO2 + \" kg\");\n</code></pre>"},{"location":"process/equipment/flares/#reset-cumulative-counters","title":"Reset Cumulative Counters","text":"<pre><code>// Reset for new transient event\nflare.resetCumulative();\n</code></pre>"},{"location":"process/equipment/flares/#flarestack-class","title":"FlareStack Class","text":"<p>The FlareStack class includes additional features for dispersion modeling:</p> <pre><code>import neqsim.process.equipment.flare.FlareStack;\n\nFlareStack flareStack = new FlareStack(\"Main Flare Stack\", inletStream);\nflareStack.setStackHeight(100.0);  // m\nflareStack.setTipDiameter(0.6);    // m\nflareStack.run();\n\n// Get dispersion parameters\nFlareDispersionSurrogateDTO dispersion = flareStack.getDispersionSurrogate();\ndouble effectiveHeight = dispersion.getEffectiveStackHeight();\ndouble plumeMomentum = dispersion.getPlumeMomentum();\n</code></pre>"},{"location":"process/equipment/flares/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/flares/#emergency-blowdown-flare-load","title":"Emergency Blowdown Flare Load","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Vessel being depressured\nTank vessel = new Tank(\"HP Vessel\", vesselFluid);\nvessel.setVolume(100.0, \"m3\");\nvessel.setPressure(100.0, \"bara\");\nprocess.add(vessel);\n\n// Blowdown valve\nBlowdownValve bdv = new BlowdownValve(\"BDV-100\", vessel);\nbdv.setOrificeSize(100.0, \"mm\");\nbdv.setDownstreamPressure(1.5, \"barg\");\nprocess.add(bdv);\n\n// Flare receiving blowdown\nFlare flare = new Flare(\"HP Flare\", bdv.getOutletStream());\nflare.setDesignHeatDutyCapacity(200e6);  // 200 MW design\nprocess.add(flare);\n\n// Run transient blowdown\ndouble dt = 1.0;\nfor (double t = 0; t &lt; 900; t += dt) {\n    vessel.runTransient(dt);\n    bdv.run();\n    flare.run();\n    flare.updateCumulative(dt);\n\n    System.out.println(\"t=\" + t + \"s, P=\" + vessel.getPressure(\"barg\") + \n        \" barg, Q=\" + flare.getHeatDuty()/1e6 + \" MW\");\n}\n</code></pre>"},{"location":"process/equipment/flares/#flare-header-system","title":"Flare Header System","text":"<pre><code>// Multiple sources to common flare header\nMixer flareHeader = new Mixer(\"Flare Header\");\nflareHeader.addStream(lpFlareSource1);\nflareHeader.addStream(lpFlareSource2);\nflareHeader.addStream(lpFlareSource3);\nprocess.add(flareHeader);\n\n// Flare KO drum\nSeparator flareKODrum = new Separator(\"Flare KO Drum\", flareHeader.getOutletStream());\nprocess.add(flareKODrum);\n\n// Flare tip\nFlare flareTip = new Flare(\"LP Flare\", flareKODrum.getGasOutStream());\nflareTip.setDesignHeatDutyCapacity(50e6);\nprocess.add(flareTip);\n\nprocess.run();\n\n// Check overall flare load\ndouble totalLoad = flareTip.getHeatDuty();\ndouble percentCapacity = totalLoad / flareTip.getDesignHeatDutyCapacity() * 100;\nSystem.out.println(\"Flare load: \" + percentCapacity + \"% of design\");\n</code></pre>"},{"location":"process/equipment/flares/#relief-scenario-calculation","title":"Relief Scenario Calculation","text":"<pre><code>// Calculate flare load for blocked outlet scenario\ndouble reliefRate = calculateBlockedOutletRelief();  // kg/hr\n\n// Create relief stream\nSystemInterface reliefFluid = vesselFluid.clone();\nStream reliefStream = new Stream(\"Relief Flow\", reliefFluid);\nreliefStream.setFlowRate(reliefRate, \"kg/hr\");\nreliefStream.run();\n\n// Calculate flare load\nFlare flare = new Flare(\"Scenario Flare\", reliefStream);\nflare.run();\n\nSystem.out.println(\"Relief scenario:\");\nSystem.out.println(\"  Flow rate: \" + reliefRate + \" kg/hr\");\nSystem.out.println(\"  Heat release: \" + flare.getHeatDuty()/1e6 + \" MW\");\nSystem.out.println(\"  CO2 emission: \" + flare.getCO2Emission()*3600 + \" kg/hr\");\n</code></pre>"},{"location":"process/equipment/flares/#performance-reporting","title":"Performance Reporting","text":""},{"location":"process/equipment/flares/#get-performance-summary","title":"Get Performance Summary","text":"<pre><code>FlarePerformanceDTO performance = flare.getPerformance();\n\nSystem.out.println(\"=== Flare Performance ===\");\nSystem.out.println(\"Heat release: \" + performance.getHeatDutyMW() + \" MW\");\nSystem.out.println(\"Mass flow: \" + performance.getMassFlowKgS() + \" kg/s\");\nSystem.out.println(\"Tip velocity: \" + performance.getTipVelocity() + \" m/s\");\nSystem.out.println(\"CO2 emission: \" + performance.getCO2EmissionKgS() + \" kg/s\");\nSystem.out.println(\"Radiant heat: \" + performance.getRadiantHeatMW() + \" MW\");\n</code></pre>"},{"location":"process/equipment/flares/#environmental-calculations","title":"Environmental Calculations","text":""},{"location":"process/equipment/flares/#carbon-footprint","title":"Carbon Footprint","text":"<pre><code>// Calculate annual CO2 emissions from continuous flaring\ndouble avgFlowRate = 1000.0;  // Sm3/hr average\ndouble hoursPerYear = 8760.0;\n\nflare.getInletStream().setFlowRate(avgFlowRate, \"Sm3/hr\");\nflare.run();\n\ndouble annualCO2 = flare.getCO2Emission() * 3600 * hoursPerYear / 1000;  // tonnes/year\nSystem.out.println(\"Annual CO2 emissions: \" + annualCO2 + \" tonnes/year\");\n</code></pre>"},{"location":"process/equipment/flares/#related-documentation","title":"Related Documentation","text":"<ul> <li>Safety Systems - PSV and blowdown</li> <li>Valves - Blowdown valves</li> <li>Tanks - Vessel depressuring</li> </ul>"},{"location":"process/equipment/heat_exchangers/","title":"Heat Exchanger Equipment","text":"<p>Documentation for heat transfer equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/heat_exchangers/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Equipment Types</li> <li>Usage Examples</li> <li>Heat Exchanger Networks</li> </ul>"},{"location":"process/equipment/heat_exchangers/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.heatexchanger</code></p> <p>Classes: - <code>Heater</code> - Simple heater (duty or outlet T specified) - <code>Cooler</code> - Simple cooler (duty or outlet T specified) - <code>HeatExchanger</code> - Shell-tube heat exchanger - <code>NeqHeater</code> - Non-equilibrium heater - <code>Condenser</code> - Overhead condenser</p>"},{"location":"process/equipment/heat_exchangers/#equipment-types","title":"Equipment Types","text":""},{"location":"process/equipment/heat_exchangers/#heater","title":"Heater","text":"<pre><code>import neqsim.process.equipment.heatexchanger.Heater;\n\n// Specify outlet temperature\nHeater heater = new Heater(\"E-100\", inletStream);\nheater.setOutTemperature(80.0, \"C\");\nheater.run();\n\ndouble duty = heater.getDuty();  // W\nSystem.out.println(\"Heating duty: \" + duty/1000.0 + \" kW\");\n\n// Or specify duty\nHeater heater2 = new Heater(\"E-101\", inletStream);\nheater2.setEnergyInput(500000.0);  // 500 kW\nheater2.run();\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#cooler","title":"Cooler","text":"<pre><code>import neqsim.process.equipment.heatexchanger.Cooler;\n\nCooler cooler = new Cooler(\"E-200\", hotStream);\ncooler.setOutTemperature(30.0, \"C\");\ncooler.run();\n\ndouble duty = cooler.getDuty();  // Negative for cooling\nSystem.out.println(\"Cooling duty: \" + (-duty/1000.0) + \" kW\");\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#heat-exchanger","title":"Heat Exchanger","text":"<p>Two-stream heat exchanger with hot and cold sides.</p> <pre><code>import neqsim.process.equipment.heatexchanger.HeatExchanger;\n\nHeatExchanger hx = new HeatExchanger(\"E-300\", hotStream, coldStream);\n\n// Specify UA value\nhx.setUAvalue(10000.0);  // W/K\n\n// Or specify approach temperature\nhx.setApproachTemperature(10.0, \"C\");\n\nhx.run();\n\n// Results\ndouble hotOut = hx.getOutStream(0).getTemperature(\"C\");\ndouble coldOut = hx.getOutStream(1).getTemperature(\"C\");\ndouble duty = hx.getDuty();\ndouble LMTD = hx.getLMTD();\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#multi-stream-heat-exchanger","title":"Multi-Stream Heat Exchanger","text":"<pre><code>import neqsim.process.equipment.heatexchanger.MultiStreamHeatExchanger;\n\nMultiStreamHeatExchanger mshx = new MultiStreamHeatExchanger(\"LNG-100\");\nmshx.addStream(stream1, \"hot\");\nmshx.addStream(stream2, \"hot\");\nmshx.addStream(stream3, \"cold\");\n\nmshx.setUAvalue(50000.0);\nmshx.run();\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#operating-modes","title":"Operating Modes","text":""},{"location":"process/equipment/heat_exchangers/#temperature-specification","title":"Temperature Specification","text":"<pre><code>// Outlet temperature\nheater.setOutTemperature(100.0, \"C\");\n\n// Temperature change\nheater.setdT(50.0, \"C\");  // \u0394T = 50\u00b0C\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#duty-specification","title":"Duty Specification","text":"<pre><code>// Fixed duty\nheater.setEnergyInput(1000000.0);  // 1 MW\n\n// Duty from energy stream\nEnergyStream energyIn = new EnergyStream(\"Heat Source\");\nenergyIn.setEnergyFlow(500.0, \"kW\");\nheater.setEnergyStream(energyIn);\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#ua-specification","title":"UA Specification","text":"<pre><code>// For heat exchangers\nhx.setUAvalue(5000.0);  // W/K\n\n// Calculate UA from geometry\ndouble U = 500.0;  // Overall HTC, W/(m\u00b2\u00b7K)\ndouble A = 100.0;  // Area, m\u00b2\nhx.setUAvalue(U * A);\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#condenser","title":"Condenser","text":"<pre><code>import neqsim.process.equipment.heatexchanger.Condenser;\n\nCondenser condenser = new Condenser(\"Overhead Condenser\", vaporStream);\n\n// Total condensation\ncondenser.setOutTemperature(40.0, \"C\");\ncondenser.run();\n\n// Partial condensation\ncondenser.setDewPointTemperature(true);  // Operate at dew point\ncondenser.run();\n\n// Sub-cooling\ncondenser.setSubCooling(5.0, \"C\");  // 5\u00b0C subcooling\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#dynamic-simulation","title":"Dynamic Simulation","text":"<pre><code>heater.setCalculateSteadyState(false);\n\n// Set thermal mass\nheater.setThermalMass(10000.0);  // J/K\n\n// Transient response\nfor (double t = 0; t &lt; 3600; t += 1.0) {\n    heater.runTransient();\n    double Tout = heater.getOutletStream().getTemperature(\"C\");\n}\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#example-gas-cooling-train","title":"Example: Gas Cooling Train","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Hot gas inlet\nStream hotGas = new Stream(\"Hot Gas\", gasFluid);\nhotGas.setFlowRate(50000.0, \"kg/hr\");\nhotGas.setTemperature(150.0, \"C\");\nhotGas.setPressure(80.0, \"bara\");\nprocess.add(hotGas);\n\n// Air cooler\nCooler airCooler = new Cooler(\"Air Cooler\", hotGas);\nairCooler.setOutTemperature(60.0, \"C\");\nprocess.add(airCooler);\n\n// Trim cooler (seawater)\nCooler trimCooler = new Cooler(\"Trim Cooler\", airCooler.getOutletStream());\ntrimCooler.setOutTemperature(25.0, \"C\");\nprocess.add(trimCooler);\n\n// Separator for condensate\nSeparator separator = new Separator(\"Inlet Sep\", trimCooler.getOutletStream());\nprocess.add(separator);\n\nprocess.run();\n\n// Total cooling duty\ndouble airDuty = -airCooler.getDuty() / 1e6;  // MW\ndouble trimDuty = -trimCooler.getDuty() / 1e6;  // MW\nSystem.out.println(\"Air cooler duty: \" + airDuty + \" MW\");\nSystem.out.println(\"Trim cooler duty: \" + trimDuty + \" MW\");\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#heat-exchanger-design","title":"Heat Exchanger Design","text":""},{"location":"process/equipment/heat_exchangers/#lmtd-method","title":"LMTD Method","text":"<pre><code>HeatExchanger hx = new HeatExchanger(\"E-400\", hotIn, coldIn);\nhx.setUAvalue(ua);\nhx.run();\n\ndouble LMTD = hx.getLMTD();\ndouble duty = hx.getDuty();\ndouble UA = duty / LMTD;\ndouble area = UA / overallHTC;\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#effectiveness-ntu","title":"Effectiveness-NTU","text":"<pre><code>double NTU = hx.getNTU();\ndouble effectiveness = hx.getEffectiveness();\n</code></pre>"},{"location":"process/equipment/heat_exchangers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Compressors - Compression equipment</li> </ul>"},{"location":"process/equipment/membranes/","title":"Membrane Separation Equipment","text":"<p>Documentation for membrane separation equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/membranes/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>MembraneSeparator Class</li> <li>Permeation Models</li> <li>Configuration</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/membranes/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.membrane</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>MembraneSeparator</code> | Generic membrane separation unit |</p> <p>Membrane separators provide selective separation based on component permeabilities through a membrane material. Applications include: - CO\u2082 removal from natural gas - Hydrogen recovery - Nitrogen generation - Dehydration - Vapor/gas separation</p>"},{"location":"process/equipment/membranes/#membraneseparator-class","title":"MembraneSeparator Class","text":""},{"location":"process/equipment/membranes/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.membrane.MembraneSeparator;\n\n// Create membrane separator\nMembraneSeparator membrane = new MembraneSeparator(\"CO2 Membrane\", feedStream);\n\n// Set permeate fractions for each component\nmembrane.setPermeateFraction(\"CO2\", 0.95);     // 95% of CO2 permeates\nmembrane.setPermeateFraction(\"methane\", 0.05); // 5% of methane permeates\nmembrane.setPermeateFraction(\"ethane\", 0.03);  // 3% of ethane permeates\n\nmembrane.run();\n\n// Get output streams\nStreamInterface permeate = membrane.getPermeateStream();\nStreamInterface retentate = membrane.getRetentateStream();\n</code></pre>"},{"location":"process/equipment/membranes/#constructor-options","title":"Constructor Options","text":"<pre><code>// With name only\nMembraneSeparator membrane = new MembraneSeparator(\"MEM-100\");\nmembrane.setInletStream(feedStream);\n\n// With name and inlet stream\nMembraneSeparator membrane = new MembraneSeparator(\"MEM-100\", feedStream);\n</code></pre>"},{"location":"process/equipment/membranes/#permeation-models","title":"Permeation Models","text":""},{"location":"process/equipment/membranes/#permeate-fraction-method","title":"Permeate Fraction Method","text":"<p>The simplest approach specifies what fraction of each component permeates:</p> <pre><code>// Set permeate fraction (0.0 to 1.0)\nmembrane.setPermeateFraction(\"CO2\", 0.90);\nmembrane.setPermeateFraction(\"H2S\", 0.85);\nmembrane.setPermeateFraction(\"methane\", 0.02);\nmembrane.setPermeateFraction(\"ethane\", 0.01);\nmembrane.setPermeateFraction(\"propane\", 0.005);\n\n// Set default for unlisted components\nmembrane.setDefaultPermeateFraction(0.01);\n</code></pre>"},{"location":"process/equipment/membranes/#permeability-method","title":"Permeability Method","text":"<p>For more rigorous calculations using permeability coefficients:</p> <pre><code>// Set membrane area\nmembrane.setMembraneArea(100.0);  // m\u00b2\n\n// Set permeability for each component (mol/(m\u00b2\u00b7s\u00b7Pa))\nmembrane.setPermeability(\"CO2\", 1.0e-9);\nmembrane.setPermeability(\"methane\", 2.0e-11);\nmembrane.setPermeability(\"nitrogen\", 5.0e-12);\n</code></pre>"},{"location":"process/equipment/membranes/#selectivity","title":"Selectivity","text":"<p>The selectivity of component A over B is:</p> \\[\\alpha_{A/B} = \\frac{P_A}{P_B}\\] <p>Where \\(P_A\\) and \\(P_B\\) are the permeabilities of components A and B.</p> <p>Typical selectivities for polymeric membranes: | Separation | Selectivity | |------------|-------------| | CO\u2082/CH\u2084 | 15-50 | | H\u2082/CH\u2084 | 30-100 | | O\u2082/N\u2082 | 4-8 | | H\u2082O/CH\u2084 | &gt;100 |</p>"},{"location":"process/equipment/membranes/#configuration","title":"Configuration","text":""},{"location":"process/equipment/membranes/#operating-conditions","title":"Operating Conditions","text":"<pre><code>// Inlet stream conditions affect separation\nfeedStream.setPressure(50.0, \"bara\");  // High feed pressure\nfeedStream.setTemperature(40.0, \"C\");\n\n// Permeate side typically at lower pressure\n// (Pressure difference drives permeation)\n</code></pre>"},{"location":"process/equipment/membranes/#stage-cut","title":"Stage Cut","text":"<p>The stage cut (\u03b8) is the fraction of feed that permeates:</p> \\[\\theta = \\frac{\\dot{n}_{permeate}}{\\dot{n}_{feed}}\\] <pre><code>membrane.run();\n\ndouble feedFlow = feedStream.getFlowRate(\"kmol/hr\");\ndouble permeateFlow = membrane.getPermeateStream().getFlowRate(\"kmol/hr\");\ndouble stageCut = permeateFlow / feedFlow;\n\nSystem.out.println(\"Stage cut: \" + (stageCut * 100) + \" %\");\n</code></pre>"},{"location":"process/equipment/membranes/#output-streams","title":"Output Streams","text":""},{"location":"process/equipment/membranes/#permeate-stream","title":"Permeate Stream","text":"<p>The permeate contains components that pass through the membrane:</p> <pre><code>StreamInterface permeate = membrane.getPermeateStream();\n\n// Get permeate composition\ndouble co2InPermeate = permeate.getFluid().getMoleFraction(\"CO2\");\ndouble permeateFlow = permeate.getFlowRate(\"kmol/hr\");\n\nSystem.out.println(\"Permeate CO2: \" + (co2InPermeate * 100) + \" mol%\");\n</code></pre>"},{"location":"process/equipment/membranes/#retentate-stream","title":"Retentate Stream","text":"<p>The retentate contains components that do not permeate:</p> <pre><code>StreamInterface retentate = membrane.getRetentateStream();\n\n// Get retentate (product gas) composition\ndouble co2InRetentate = retentate.getFluid().getMoleFraction(\"CO2\");\ndouble ch4InRetentate = retentate.getFluid().getMoleFraction(\"methane\");\n\nSystem.out.println(\"Retentate CO2: \" + (co2InRetentate * 100) + \" mol%\");\nSystem.out.println(\"Retentate CH4: \" + (ch4InRetentate * 100) + \" mol%\");\n</code></pre>"},{"location":"process/equipment/membranes/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/membranes/#co2-removal-from-natural-gas","title":"CO\u2082 Removal from Natural Gas","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Feed gas with CO2\nSystemInterface feedFluid = new SystemSrkEos(310.0, 60.0);\nfeedFluid.addComponent(\"methane\", 0.85);\nfeedFluid.addComponent(\"ethane\", 0.05);\nfeedFluid.addComponent(\"propane\", 0.02);\nfeedFluid.addComponent(\"CO2\", 0.08);\nfeedFluid.setMixingRule(\"classic\");\n\nStream feedGas = new Stream(\"Feed Gas\", feedFluid);\nfeedGas.setFlowRate(100000.0, \"Sm3/day\");\nprocess.add(feedGas);\n\n// Membrane unit\nMembraneSeparator membrane = new MembraneSeparator(\"CO2 Membrane\", feedGas);\nmembrane.setPermeateFraction(\"CO2\", 0.90);\nmembrane.setPermeateFraction(\"methane\", 0.03);\nmembrane.setPermeateFraction(\"ethane\", 0.02);\nmembrane.setPermeateFraction(\"propane\", 0.01);\nprocess.add(membrane);\n\n// Run\nprocess.run();\n\n// Check CO2 spec\ndouble productCO2 = membrane.getRetentateStream().getFluid().getMoleFraction(\"CO2\");\nSystem.out.println(\"Product gas CO2: \" + (productCO2 * 100) + \" mol%\");\n\n// Methane recovery\ndouble feedCH4 = feedGas.getFlowRate(\"Sm3/day\") * 0.85;\ndouble productCH4 = membrane.getRetentateStream().getFlowRate(\"Sm3/day\") * \n    membrane.getRetentateStream().getFluid().getMoleFraction(\"methane\");\ndouble recovery = productCH4 / feedCH4 * 100;\nSystem.out.println(\"Methane recovery: \" + recovery + \" %\");\n</code></pre>"},{"location":"process/equipment/membranes/#multi-stage-membrane-system","title":"Multi-Stage Membrane System","text":"<p>For deep CO\u2082 removal, multiple stages may be required:</p> <pre><code>// First stage membrane\nMembraneSeparator stage1 = new MembraneSeparator(\"Stage 1\", feedGas);\nstage1.setPermeateFraction(\"CO2\", 0.80);\nstage1.setPermeateFraction(\"methane\", 0.05);\nprocess.add(stage1);\n\n// Second stage on retentate\nMembraneSeparator stage2 = new MembraneSeparator(\"Stage 2\", stage1.getRetentateStream());\nstage2.setPermeateFraction(\"CO2\", 0.80);\nstage2.setPermeateFraction(\"methane\", 0.05);\nprocess.add(stage2);\n\n// Recycle permeate from stage 2 to stage 1 feed\nMixer mixer = new Mixer(\"Feed Mixer\");\nmixer.addStream(feedGas);\nmixer.addStream(stage2.getPermeateStream());\nprocess.add(mixer);\n\n// Connect mixer to stage 1\nstage1.setInletStream(mixer.getOutletStream());\n\n// Add recycle\nRecycle recycle = new Recycle(\"Membrane Recycle\");\nrecycle.addStream(stage2.getPermeateStream());\nrecycle.setOutletStream(mixer);\nprocess.add(recycle);\n\nprocess.run();\n</code></pre>"},{"location":"process/equipment/membranes/#hydrogen-recovery","title":"Hydrogen Recovery","text":"<pre><code>// Refinery off-gas\nSystemInterface offgas = new SystemSrkEos(320.0, 30.0);\noffgas.addComponent(\"hydrogen\", 0.40);\noffgas.addComponent(\"methane\", 0.35);\noffgas.addComponent(\"ethane\", 0.15);\noffgas.addComponent(\"propane\", 0.10);\noffgas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"Off-gas\", offgas);\nfeed.setFlowRate(5000.0, \"Sm3/hr\");\n\n// H2 selective membrane\nMembraneSeparator h2Membrane = new MembraneSeparator(\"H2 Membrane\", feed);\nh2Membrane.setPermeateFraction(\"hydrogen\", 0.95);\nh2Membrane.setPermeateFraction(\"methane\", 0.08);\nh2Membrane.setPermeateFraction(\"ethane\", 0.02);\nh2Membrane.setPermeateFraction(\"propane\", 0.01);\nh2Membrane.run();\n\n// H2 purity in permeate\ndouble h2Purity = h2Membrane.getPermeateStream().getFluid().getMoleFraction(\"hydrogen\");\nSystem.out.println(\"H2 purity: \" + (h2Purity * 100) + \" mol%\");\n</code></pre>"},{"location":"process/equipment/membranes/#process-integration","title":"Process Integration","text":""},{"location":"process/equipment/membranes/#with-compression","title":"With Compression","text":"<pre><code>// Compress permeate for recycle or further processing\nCompressor permeateComp = new Compressor(\"Permeate Comp\", membrane.getPermeateStream());\npermeateComp.setOutletPressure(feedPressure, \"bara\");\npermeateComp.setIsentropicEfficiency(0.75);\n</code></pre>"},{"location":"process/equipment/membranes/#with-cooling","title":"With Cooling","text":"<pre><code>// Cool membrane feed to improve selectivity\nCooler feedCooler = new Cooler(\"Membrane Feed Cooler\", feedGas);\nfeedCooler.setOutTemperature(30.0, \"C\");\n\nmembrane.setInletStream(feedCooler.getOutletStream());\n</code></pre>"},{"location":"process/equipment/membranes/#design-considerations","title":"Design Considerations","text":""},{"location":"process/equipment/membranes/#operating-conditions_1","title":"Operating Conditions","text":"<ul> <li>Higher feed pressure \u2192 higher driving force \u2192 more permeation</li> <li>Lower temperature \u2192 higher selectivity (for most membranes)</li> <li>Higher stage cut \u2192 lower product purity</li> </ul>"},{"location":"process/equipment/membranes/#membrane-selection","title":"Membrane Selection","text":"Type Applications Selectivity Cellulose acetate CO\u2082/CH\u2084 15-25 Polyimide CO\u2082/CH\u2084, H\u2082 20-50 Polysulfone O\u2082/N\u2082 5-6 PDMS VOC removal varies"},{"location":"process/equipment/membranes/#related-documentation","title":"Related Documentation","text":"<ul> <li>Absorbers - Alternative for gas treating</li> <li>Separators - Phase separation</li> <li>Streams - Stream handling</li> </ul>"},{"location":"process/equipment/mixers_splitters/","title":"Mixers and Splitters","text":"<p>Documentation for stream mixing and splitting equipment in NeqSim.</p>"},{"location":"process/equipment/mixers_splitters/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Mixer</li> <li>Splitter</li> <li>Static Mixer</li> <li>Examples</li> </ul>"},{"location":"process/equipment/mixers_splitters/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.mixer</code>, <code>neqsim.process.equipment.splitter</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Mixer</code> | Combine multiple streams | | <code>MixerInterface</code> | Mixer interface | | <code>Splitter</code> | Split stream into fractions | | <code>SplitterInterface</code> | Splitter interface | | <code>StaticMixer</code> | Static mixing element |</p>"},{"location":"process/equipment/mixers_splitters/#mixer","title":"Mixer","text":"<p>Combine multiple streams into one outlet stream.</p>"},{"location":"process/equipment/mixers_splitters/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.mixer.Mixer;\n\nMixer mixer = new Mixer(\"M-100\");\nmixer.addStream(stream1);\nmixer.addStream(stream2);\nmixer.addStream(stream3);\nmixer.run();\n\nStream mixed = mixer.getOutletStream();\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#mixing-calculation","title":"Mixing Calculation","text":"<p>The mixer performs mass and energy balance:</p> \\[\\dot{m}_{out} = \\sum_i \\dot{m}_i\\] \\[\\dot{m}_{out} \\cdot h_{out} = \\sum_i \\dot{m}_i \\cdot h_i\\] \\[x_{j,out} = \\frac{\\sum_i \\dot{m}_i \\cdot x_{j,i}}{\\sum_i \\dot{m}_i}\\]"},{"location":"process/equipment/mixers_splitters/#pressure-handling","title":"Pressure Handling","text":"<pre><code>// Default: outlet pressure = minimum inlet pressure\nmixer.run();\n\n// Or specify outlet pressure\nmixer.setOutletPressure(20.0, \"bara\");\nmixer.run();\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#splitter","title":"Splitter","text":"<p>Split a stream into multiple fractions.</p>"},{"location":"process/equipment/mixers_splitters/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.splitter.Splitter;\n\n// Split into 2 streams\nSplitter splitter = new Splitter(\"SP-100\", inletStream, 2);\nsplitter.setSplitFactors(new double[]{0.7, 0.3});  // 70% and 30%\nsplitter.run();\n\nStream split1 = splitter.getSplitStream(0);  // 70%\nStream split2 = splitter.getSplitStream(1);  // 30%\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#split-factor-specification","title":"Split Factor Specification","text":"<pre><code>// By mass fractions (must sum to 1.0)\nsplitter.setSplitFactors(new double[]{0.5, 0.3, 0.2});\n\n// By flow rates\nsplitter.setFlowRates(new double[]{100.0, 60.0, 40.0}, \"kg/hr\");\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#properties","title":"Properties","text":"<p>All split streams have identical: - Temperature - Pressure - Composition (mole fractions)</p> <p>Only flow rate differs.</p>"},{"location":"process/equipment/mixers_splitters/#static-mixer","title":"Static Mixer","text":"<p>For inline mixing with pressure drop.</p>"},{"location":"process/equipment/mixers_splitters/#usage","title":"Usage","text":"<pre><code>import neqsim.process.equipment.mixer.StaticMixer;\n\nStaticMixer staticMixer = new StaticMixer(\"Static Mixer\");\nstaticMixer.addStream(stream1);\nstaticMixer.addStream(stream2);\nstaticMixer.setPressureDrop(0.5, \"bara\");\nstaticMixer.run();\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#examples","title":"Examples","text":""},{"location":"process/equipment/mixers_splitters/#example-1-simple-stream-mixing","title":"Example 1: Simple Stream Mixing","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.mixer.Mixer;\n\n// Stream 1: Rich gas\nSystemSrkEos gas1 = new SystemSrkEos(300.0, 50.0);\ngas1.addComponent(\"methane\", 0.80);\ngas1.addComponent(\"ethane\", 0.15);\ngas1.addComponent(\"propane\", 0.05);\ngas1.setMixingRule(\"classic\");\n\nStream stream1 = new Stream(\"Rich Gas\", gas1);\nstream1.setFlowRate(5000.0, \"kg/hr\");\nstream1.run();\n\n// Stream 2: Lean gas\nSystemSrkEos gas2 = new SystemSrkEos(310.0, 50.0);\ngas2.addComponent(\"methane\", 0.95);\ngas2.addComponent(\"ethane\", 0.04);\ngas2.addComponent(\"propane\", 0.01);\ngas2.setMixingRule(\"classic\");\n\nStream stream2 = new Stream(\"Lean Gas\", gas2);\nstream2.setFlowRate(3000.0, \"kg/hr\");\nstream2.run();\n\n// Mix streams\nMixer mixer = new Mixer(\"M-100\");\nmixer.addStream(stream1);\nmixer.addStream(stream2);\nmixer.run();\n\n// Results\nStream mixed = mixer.getOutletStream();\nSystem.out.println(\"Mixed flow: \" + mixed.getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"Mixed temp: \" + mixed.getTemperature(\"C\") + \" C\");\nSystem.out.println(\"Methane: \" + mixed.getFluid().getMoleFraction(\"methane\"));\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#example-2-recycle-split","title":"Example 2: Recycle Split","text":"<pre><code>// Main process stream\nStream processStream = new Stream(\"Process\", processFluid);\nprocessStream.setFlowRate(10000.0, \"kg/hr\");\nprocessStream.run();\n\n// Split: 90% product, 10% recycle\nSplitter splitter = new Splitter(\"Recycle Splitter\", processStream, 2);\nsplitter.setSplitFactors(new double[]{0.90, 0.10});\nsplitter.run();\n\nStream product = splitter.getSplitStream(0);\nStream recycle = splitter.getSplitStream(1);\n\nSystem.out.println(\"Product: \" + product.getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"Recycle: \" + recycle.getFlowRate(\"kg/hr\") + \" kg/hr\");\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#example-3-multiple-stream-manifold","title":"Example 3: Multiple Stream Manifold","text":"<pre><code>// Create manifold mixer for 4 wells\nMixer manifold = new Mixer(\"Production Manifold\");\n\nfor (int i = 1; i &lt;= 4; i++) {\n    SystemSrkEos wellFluid = new SystemSrkEos(350.0, 100.0 - i * 5);\n    wellFluid.addComponent(\"methane\", 0.85);\n    wellFluid.addComponent(\"ethane\", 0.08);\n    wellFluid.addComponent(\"propane\", 0.05);\n    wellFluid.addComponent(\"water\", 0.02);\n    wellFluid.setMixingRule(\"classic\");\n\n    Stream wellStream = new Stream(\"Well \" + i, wellFluid);\n    wellStream.setFlowRate(1000.0 + i * 200, \"Sm3/day\");\n    wellStream.run();\n\n    manifold.addStream(wellStream);\n}\n\nmanifold.run();\n\nSystem.out.println(\"Total production: \" + manifold.getOutletStream().getFlowRate(\"Sm3/day\") + \" Sm3/day\");\nSystem.out.println(\"Manifold pressure: \" + manifold.getOutletStream().getPressure(\"bara\") + \" bara\");\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#example-4-product-distribution","title":"Example 4: Product Distribution","text":"<pre><code>// Gas from separator\nStream gasProduct = separator.getGasOutStream();\n\n// Distribute to 3 customers\nSplitter distributor = new Splitter(\"Gas Distribution\", gasProduct, 3);\n\n// Set by flow rates\ndouble[] rates = {5000.0, 3000.0, 2000.0};  // Sm3/hr\ndistributor.setFlowRates(rates, \"Sm3/hr\");\ndistributor.run();\n\nfor (int i = 0; i &lt; 3; i++) {\n    Stream customerStream = distributor.getSplitStream(i);\n    System.out.println(\"Customer \" + (i+1) + \": \" + customerStream.getFlowRate(\"Sm3/hr\") + \" Sm3/hr\");\n}\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#example-5-bypass-configuration","title":"Example 5: Bypass Configuration","text":"<pre><code>// Main stream\nStream mainStream = new Stream(\"Main\", fluid);\nmainStream.setFlowRate(1000.0, \"kg/hr\");\nmainStream.run();\n\n// Split: 80% through heater, 20% bypass\nSplitter bypass = new Splitter(\"Bypass\", mainStream, 2);\nbypass.setSplitFactors(new double[]{0.80, 0.20});\nbypass.run();\n\n// Heat 80%\nHeater heater = new Heater(\"E-100\", bypass.getSplitStream(0));\nheater.setOutletTemperature(400.0, \"K\");\nheater.run();\n\n// Remix\nMixer remix = new Mixer(\"M-100\");\nremix.addStream(heater.getOutletStream());\nremix.addStream(bypass.getSplitStream(1));\nremix.run();\n\nSystem.out.println(\"Bypass temp control: \" + remix.getOutletStream().getTemperature(\"K\") + \" K\");\n</code></pre>"},{"location":"process/equipment/mixers_splitters/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Streams - Stream handling</li> <li>Controllers - Adjusters and recycles</li> </ul>"},{"location":"process/equipment/pipelines/","title":"Pipelines and Pipes","text":"<p>Documentation for pipeline equipment in NeqSim.</p>"},{"location":"process/equipment/pipelines/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Pipe Segment</li> <li>Pipeline</li> <li>Pressure Drop</li> <li>Heat Transfer</li> <li>Examples</li> </ul>"},{"location":"process/equipment/pipelines/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.pipeline</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>PipeBeggsAndBrills</code> | Beggs-Brill correlation | | <code>AdiabaticPipe</code> | Adiabatic pipe segment | | <code>OnePhasePipe</code> | Single-phase pipe | | <code>TwoPhasePipeLine</code> | Two-phase pipeline |</p> <p>For detailed pipe flow modeling, see also Fluid Mechanics.</p>"},{"location":"process/equipment/pipelines/#pipe-segment","title":"Pipe Segment","text":""},{"location":"process/equipment/pipelines/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.pipeline.PipeBeggsAndBrills;\n\nPipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"Pipe\", inletStream);\npipe.setLength(1000.0, \"m\");\npipe.setDiameter(0.3, \"m\");\npipe.setAngle(0.0);  // Horizontal\npipe.run();\n\ndouble pressureDrop = pipe.getPressureDrop(\"bara\");\nStream outlet = pipe.getOutletStream();\n</code></pre>"},{"location":"process/equipment/pipelines/#geometry","title":"Geometry","text":"<pre><code>// Length\npipe.setLength(5000.0, \"m\");\n\n// Inner diameter\npipe.setDiameter(0.254, \"m\");  // 10 inch\npipe.setInnerDiameter(0.254, \"m\");\n\n// Wall roughness\npipe.setRoughness(0.0001, \"m\");\n\n// Elevation change\npipe.setElevationChange(100.0, \"m\");  // 100m rise\npipe.setAngle(5.7);  // degrees from horizontal\n</code></pre>"},{"location":"process/equipment/pipelines/#pipeline","title":"Pipeline","text":"<p>For longer pipelines with multiple segments.</p>"},{"location":"process/equipment/pipelines/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.pipeline.TwoPhasePipeLine;\n\nTwoPhasePipeLine pipeline = new TwoPhasePipeLine(\"Export Pipeline\", inletStream);\npipeline.setLength(50000.0, \"m\");\npipeline.setDiameter(0.4, \"m\");\npipeline.setNumberOfNodes(100);\npipeline.run();\n\n// Get profile\ndouble[] pressure = pipeline.getPressureProfile();\ndouble[] temperature = pipeline.getTemperatureProfile();\ndouble[] holdup = pipeline.getLiquidHoldupProfile();\n</code></pre>"},{"location":"process/equipment/pipelines/#pressure-drop","title":"Pressure Drop","text":""},{"location":"process/equipment/pipelines/#friction-factor-correlations","title":"Friction Factor Correlations","text":"Method Application Beggs-Brill Two-phase flow Moody Single-phase turbulent Colebrook Single-phase implicit"},{"location":"process/equipment/pipelines/#beggs-brill-correlation","title":"Beggs-Brill Correlation","text":"<pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"Pipe\", stream);\npipe.setLength(1000.0, \"m\");\npipe.setDiameter(0.3, \"m\");\npipe.run();\n\n// Flow regime\nString regime = pipe.getFlowRegime();  // Segregated, Intermittent, Distributed\n\n// Liquid holdup\ndouble holdup = pipe.getLiquidHoldup();\n</code></pre>"},{"location":"process/equipment/pipelines/#pressure-drop-components","title":"Pressure Drop Components","text":"\\[\\Delta P_{total} = \\Delta P_{friction} + \\Delta P_{elevation} + \\Delta P_{acceleration}\\]"},{"location":"process/equipment/pipelines/#heat-transfer","title":"Heat Transfer","text":""},{"location":"process/equipment/pipelines/#adiabatic-pipe","title":"Adiabatic Pipe","text":"<pre><code>import neqsim.process.equipment.pipeline.AdiabaticPipe;\n\nAdiabaticPipe pipe = new AdiabaticPipe(\"Adiabatic Pipe\", stream);\npipe.setLength(500.0, \"m\");\npipe.setDiameter(0.2, \"m\");\npipe.run();\n\n// Temperature remains constant (no heat loss)\ndouble Tin = pipe.getInletStream().getTemperature(\"C\");\ndouble Tout = pipe.getOutletStream().getTemperature(\"C\");\n</code></pre>"},{"location":"process/equipment/pipelines/#pipe-with-heat-transfer","title":"Pipe with Heat Transfer","text":"<pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"Pipe\", stream);\npipe.setLength(1000.0, \"m\");\npipe.setDiameter(0.3, \"m\");\n\n// Heat transfer coefficient\npipe.setOverallHeatTransferCoefficient(25.0, \"W/m2K\");\n\n// Ambient temperature\npipe.setAmbientTemperature(5.0, \"C\");\n\npipe.run();\n\ndouble heatLoss = pipe.getHeatLoss(\"kW\");\n</code></pre>"},{"location":"process/equipment/pipelines/#examples","title":"Examples","text":""},{"location":"process/equipment/pipelines/#example-1-simple-pipe-segment","title":"Example 1: Simple Pipe Segment","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.pipeline.PipeBeggsAndBrills;\n\n// Natural gas\nSystemSrkEos gas = new SystemSrkEos(303.15, 80.0);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.07);\ngas.addComponent(\"propane\", 0.03);\ngas.setMixingRule(\"classic\");\n\nStream inlet = new Stream(\"Inlet\", gas);\ninlet.setFlowRate(1000000.0, \"Sm3/day\");\ninlet.run();\n\n// Pipe\nPipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"Pipe\", inlet);\npipe.setLength(5000.0, \"m\");\npipe.setDiameter(0.254, \"m\");  // 10 inch\npipe.setRoughness(0.00005, \"m\");\npipe.run();\n\nSystem.out.println(\"Inlet P: \" + inlet.getPressure(\"bara\") + \" bara\");\nSystem.out.println(\"Outlet P: \" + pipe.getOutletStream().getPressure(\"bara\") + \" bara\");\nSystem.out.println(\"\u0394P: \" + pipe.getPressureDrop(\"bara\") + \" bara\");\nSystem.out.println(\"Velocity: \" + pipe.getVelocity(\"m/s\") + \" m/s\");\n</code></pre>"},{"location":"process/equipment/pipelines/#example-2-two-phase-pipeline","title":"Example 2: Two-Phase Pipeline","text":"<pre><code>// Wellstream (gas + condensate)\nSystemSrkEos wellstream = new SystemSrkEos(350.0, 100.0);\nwellstream.addComponent(\"methane\", 0.70);\nwellstream.addComponent(\"ethane\", 0.10);\nwellstream.addComponent(\"propane\", 0.08);\nwellstream.addComponent(\"n-pentane\", 0.05);\nwellstream.addComponent(\"n-heptane\", 0.05);\nwellstream.addComponent(\"n-decane\", 0.02);\nwellstream.setMixingRule(\"classic\");\n\nStream inlet = new Stream(\"Wellstream\", wellstream);\ninlet.setFlowRate(50000.0, \"kg/hr\");\ninlet.run();\n\n// Two-phase pipeline\nTwoPhasePipeLine pipeline = new TwoPhasePipeLine(\"Flowline\", inlet);\npipeline.setLength(10000.0, \"m\");\npipeline.setDiameter(0.2, \"m\");\npipeline.setNumberOfNodes(50);\npipeline.run();\n\nSystem.out.println(\"Inlet: \" + inlet.getPressure(\"bara\") + \" bara, \" + \n                   inlet.getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"Outlet: \" + pipeline.getOutletStream().getPressure(\"bara\") + \" bara, \" +\n                   pipeline.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/pipelines/#example-3-subsea-pipeline-with-heat-loss","title":"Example 3: Subsea Pipeline with Heat Loss","text":"<pre><code>// Subsea conditions\nSystemSrkEos gas = new SystemSrkEos(350.0, 150.0);\ngas.addComponent(\"methane\", 0.92);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"CO2\", 0.02);\ngas.addComponent(\"water\", 0.01);\ngas.setMixingRule(\"classic\");\n\nStream inlet = new Stream(\"Wellhead\", gas);\ninlet.setFlowRate(5000000.0, \"Sm3/day\");\ninlet.run();\n\n// Subsea pipeline\nPipeBeggsAndBrills pipeline = new PipeBeggsAndBrills(\"Subsea\", inlet);\npipeline.setLength(50000.0, \"m\");\npipeline.setDiameter(0.4, \"m\");\npipeline.setOverallHeatTransferCoefficient(15.0, \"W/m2K\");\npipeline.setAmbientTemperature(4.0, \"C\");  // Seabed temperature\npipeline.run();\n\nSystem.out.println(\"Outlet temperature: \" + pipeline.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"Heat loss: \" + pipeline.getHeatLoss(\"MW\") + \" MW\");\n\n// Check hydrate temperature\ndouble hdtTemp = pipeline.getOutletStream().getFluid().getHydrateTemperature();\nSystem.out.println(\"Hydrate temperature: \" + (hdtTemp - 273.15) + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/pipelines/#example-4-riser-with-elevation","title":"Example 4: Riser with Elevation","text":"<pre><code>// Gas lift production\nStream production = new Stream(\"Production\", wellFluid);\nproduction.setFlowRate(10000.0, \"kg/hr\");\nproduction.run();\n\n// Riser (500m water depth)\nPipeBeggsAndBrills riser = new PipeBeggsAndBrills(\"Riser\", production);\nriser.setLength(550.0, \"m\");  // Account for catenary\nriser.setDiameter(0.2, \"m\");\nriser.setElevationChange(500.0, \"m\");  // Rise from seabed\nriser.run();\n\nSystem.out.println(\"Bottom P: \" + production.getPressure(\"bara\") + \" bara\");\nSystem.out.println(\"Top P: \" + riser.getOutletStream().getPressure(\"bara\") + \" bara\");\nSystem.out.println(\"Flow regime: \" + riser.getFlowRegime());\n</code></pre>"},{"location":"process/equipment/pipelines/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Fluid Mechanics - Detailed pipe flow</li> <li>Valves - Flow control</li> </ul>"},{"location":"process/equipment/pumps/","title":"Pumps","text":"<p>Documentation for liquid pumping equipment in NeqSim.</p>"},{"location":"process/equipment/pumps/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Pump Class</li> <li>Pump Performance</li> <li>Head and Efficiency Curves</li> <li>NPSH Calculations</li> <li>Examples</li> </ul>"},{"location":"process/equipment/pumps/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.pump</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Pump</code> | Centrifugal or positive displacement pump | | <code>PumpInterface</code> | Pump interface |</p>"},{"location":"process/equipment/pumps/#pump-class","title":"Pump Class","text":""},{"location":"process/equipment/pumps/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.pump.Pump;\n\n// Create pump on liquid stream\nPump pump = new Pump(\"P-100\", liquidStream);\npump.setOutletPressure(50.0, \"bara\");\npump.run();\n\n// Results\ndouble power = pump.getPower(\"kW\");\ndouble head = pump.getHead(\"m\");\ndouble efficiency = pump.getIsentropicEfficiency();\n</code></pre>"},{"location":"process/equipment/pumps/#outlet-specification","title":"Outlet Specification","text":"<pre><code>// By outlet pressure\npump.setOutletPressure(50.0, \"bara\");\n\n// By pressure rise\npump.setPressureRise(30.0, \"bara\");\n\n// By head\npump.setHead(300.0, \"m\");\n</code></pre>"},{"location":"process/equipment/pumps/#pump-performance","title":"Pump Performance","text":""},{"location":"process/equipment/pumps/#isentropic-efficiency","title":"Isentropic Efficiency","text":"<pre><code>// Set pump efficiency\npump.setIsentropicEfficiency(0.75);  // 75%\n\n// Calculate power\npump.run();\ndouble power = pump.getPower(\"kW\");\ndouble isentropicPower = pump.getIsentropicPower(\"kW\");\ndouble actualPower = pump.getActualPower(\"kW\");\n\n// Efficiency = Isentropic Power / Actual Power\n</code></pre>"},{"location":"process/equipment/pumps/#power-calculation","title":"Power Calculation","text":"<p>The pump power is calculated as:</p> \\[P = \\frac{\\dot{m} \\cdot \\Delta h_{isentropic}}{\\eta_{isentropic}}\\] <p>Where: - \\(\\dot{m}\\) = mass flow rate - \\(\\Delta h_{isentropic}\\) = isentropic enthalpy rise - \\(\\eta_{isentropic}\\) = isentropic efficiency</p>"},{"location":"process/equipment/pumps/#head-calculation","title":"Head Calculation","text":"\\[H = \\frac{\\Delta P}{\\rho \\cdot g}\\] <p>Where: - \\(\\Delta P\\) = pressure rise - \\(\\rho\\) = liquid density - \\(g\\) = gravitational acceleration</p>"},{"location":"process/equipment/pumps/#head-and-efficiency-curves","title":"Head and Efficiency Curves","text":""},{"location":"process/equipment/pumps/#define-pump-curves","title":"Define Pump Curves","text":"<pre><code>// Define head vs flow curve points\ndouble[] flowRates = {0, 50, 100, 150, 200};      // m\u00b3/hr\ndouble[] heads = {350, 340, 310, 260, 180};       // m\ndouble[] efficiencies = {0, 0.65, 0.80, 0.75, 0.60};\n\npump.setHeadCurve(flowRates, heads, \"m3/hr\", \"m\");\npump.setEfficiencyCurve(flowRates, efficiencies, \"m3/hr\");\n</code></pre>"},{"location":"process/equipment/pumps/#operating-point","title":"Operating Point","text":"<pre><code>pump.run();\n\n// Get operating point\ndouble flowRate = pump.getInletStream().getFlowRate(\"m3/hr\");\ndouble actualHead = pump.getHead(\"m\");\ndouble actualEff = pump.getIsentropicEfficiency();\n</code></pre>"},{"location":"process/equipment/pumps/#npsh-calculations","title":"NPSH Calculations","text":""},{"location":"process/equipment/pumps/#net-positive-suction-head","title":"Net Positive Suction Head","text":"<pre><code>// NPSH available from process conditions\ndouble npshAvailable = pump.getNPSHAvailable(\"m\");\n\n// NPSH required (from pump curve)\ndouble[] flows = {50, 100, 150, 200};\ndouble[] npshReq = {1.5, 2.0, 3.0, 5.0};\npump.setNPSHRequiredCurve(flows, npshReq, \"m3/hr\", \"m\");\n\ndouble npshRequired = pump.getNPSHRequired(\"m\");\n\n// Check cavitation margin\ndouble margin = npshAvailable - npshRequired;\nif (margin &lt; 1.0) {\n    System.out.println(\"Warning: Low NPSH margin\");\n}\n</code></pre>"},{"location":"process/equipment/pumps/#npsh-available-calculation","title":"NPSH Available Calculation","text":"\\[NPSH_A = \\frac{P_{suction}}{\\rho g} + \\frac{v^2}{2g} - \\frac{P_{vapor}}{\\rho g}\\]"},{"location":"process/equipment/pumps/#examples","title":"Examples","text":""},{"location":"process/equipment/pumps/#example-1-simple-pump","title":"Example 1: Simple Pump","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.pump.Pump;\n\n// Create liquid stream\nSystemSrkEos fluid = new SystemSrkEos(298.15, 5.0);\nfluid.addComponent(\"n-heptane\", 1.0);\nfluid.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"Feed\", fluid);\nfeed.setFlowRate(100.0, \"m3/hr\");\nfeed.run();\n\n// Pump\nPump pump = new Pump(\"P-100\", feed);\npump.setOutletPressure(30.0, \"bara\");\npump.setIsentropicEfficiency(0.75);\npump.run();\n\n// Results\nSystem.out.println(\"Flow rate: \" + pump.getInletStream().getFlowRate(\"m3/hr\") + \" m\u00b3/hr\");\nSystem.out.println(\"Head: \" + pump.getHead(\"m\") + \" m\");\nSystem.out.println(\"Power: \" + pump.getPower(\"kW\") + \" kW\");\nSystem.out.println(\"Efficiency: \" + pump.getIsentropicEfficiency() * 100 + \" %\");\n</code></pre>"},{"location":"process/equipment/pumps/#example-2-pump-with-curves","title":"Example 2: Pump with Curves","text":"<pre><code>// Define pump curves\ndouble[] flows = {0, 25, 50, 75, 100, 125, 150};\ndouble[] heads = {400, 395, 380, 355, 320, 270, 200};\ndouble[] effs = {0, 0.55, 0.70, 0.78, 0.80, 0.75, 0.65};\n\nPump pump = new Pump(\"P-100\", liquidStream);\npump.setHeadCurve(flows, heads, \"m3/hr\", \"m\");\npump.setEfficiencyCurve(flows, effs, \"m3/hr\");\npump.run();\n\n// Operating point found on curves\nSystem.out.println(\"Operating flow: \" + pump.getInletStream().getFlowRate(\"m3/hr\"));\nSystem.out.println(\"Operating head: \" + pump.getHead(\"m\"));\nSystem.out.println(\"Operating efficiency: \" + pump.getIsentropicEfficiency());\n</code></pre>"},{"location":"process/equipment/pumps/#example-3-booster-pump-system","title":"Example 3: Booster Pump System","text":"<pre><code>// Inlet conditions\nSystemSrkEos crude = new SystemSrkEos(340.0, 3.0);\ncrude.addComponent(\"methane\", 0.01);\ncrude.addComponent(\"n-pentane\", 0.20);\ncrude.addComponent(\"n-heptane\", 0.50);\ncrude.addComponent(\"n-decane\", 0.29);\ncrude.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"Crude Feed\", crude);\nfeed.setFlowRate(500.0, \"m3/hr\");\nfeed.run();\n\n// First stage pump\nPump pump1 = new Pump(\"P-100A\", feed);\npump1.setOutletPressure(20.0, \"bara\");\npump1.setIsentropicEfficiency(0.78);\npump1.run();\n\n// Second stage pump\nPump pump2 = new Pump(\"P-100B\", pump1.getOutletStream());\npump2.setOutletPressure(50.0, \"bara\");\npump2.setIsentropicEfficiency(0.75);\npump2.run();\n\n// Total power\ndouble totalPower = pump1.getPower(\"kW\") + pump2.getPower(\"kW\");\nSystem.out.println(\"Total pump power: \" + totalPower + \" kW\");\n</code></pre>"},{"location":"process/equipment/pumps/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Compressors - Gas compression</li> <li>Separators - Phase separation</li> </ul>"},{"location":"process/equipment/reactors/","title":"Reactors","text":"<p>Documentation for chemical reactor equipment in NeqSim.</p>"},{"location":"process/equipment/reactors/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Reactor Types</li> <li>CSTR</li> <li>PFR</li> <li>Equilibrium Reactor</li> <li>Gibbs Reactor</li> <li>Examples</li> </ul>"},{"location":"process/equipment/reactors/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.reactor</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Reactor</code> | Base reactor class | | <code>CSTRReactor</code> | Continuous stirred tank reactor | | <code>PFRReactor</code> | Plug flow reactor | | <code>EquilibriumReactor</code> | Chemical equilibrium reactor | | <code>GibbsReactor</code> | Gibbs energy minimization reactor |</p>"},{"location":"process/equipment/reactors/#reactor-types","title":"Reactor Types","text":""},{"location":"process/equipment/reactors/#selection-guide","title":"Selection Guide","text":"Reactor When to Use CSTR Liquid-phase reactions, good mixing PFR Gas-phase reactions, no back-mixing Equilibrium Fast reactions at equilibrium Gibbs Complex equilibrium without specifying reactions"},{"location":"process/equipment/reactors/#cstr","title":"CSTR","text":"<p>Continuous Stirred Tank Reactor with perfect mixing.</p>"},{"location":"process/equipment/reactors/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.reactor.CSTRReactor;\n\nCSTRReactor cstr = new CSTRReactor(\"R-100\", feedStream);\ncstr.setVolume(10.0, \"m3\");\ncstr.setTemperature(400.0, \"K\");\ncstr.run();\n</code></pre>"},{"location":"process/equipment/reactors/#with-reaction","title":"With Reaction","text":"<pre><code>// Define reaction: A + B \u2192 C\ncstr.addReaction(\"component_A\", -1);  // reactant\ncstr.addReaction(\"component_B\", -1);  // reactant\ncstr.addReaction(\"component_C\", 1);   // product\n\n// Reaction rate constant\ncstr.setRateConstant(0.1, \"1/s\");\n\ncstr.run();\n</code></pre>"},{"location":"process/equipment/reactors/#residence-time","title":"Residence Time","text":"\\[\\tau = \\frac{V}{\\dot{Q}}\\] <p>Where: - \\(\\tau\\) = residence time - \\(V\\) = reactor volume - \\(\\dot{Q}\\) = volumetric flow rate</p>"},{"location":"process/equipment/reactors/#pfr","title":"PFR","text":"<p>Plug Flow Reactor with no back-mixing.</p>"},{"location":"process/equipment/reactors/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.reactor.PFRReactor;\n\nPFRReactor pfr = new PFRReactor(\"R-100\", feedStream);\npfr.setLength(10.0, \"m\");\npfr.setDiameter(0.5, \"m\");\npfr.run();\n</code></pre>"},{"location":"process/equipment/reactors/#with-kinetics","title":"With Kinetics","text":"<pre><code>// Set reaction kinetics\npfr.setReaction(reaction);\npfr.setNumberOfReactorSegments(100);\npfr.run();\n</code></pre>"},{"location":"process/equipment/reactors/#equilibrium-reactor","title":"Equilibrium Reactor","text":"<p>For reactions at chemical equilibrium.</p>"},{"location":"process/equipment/reactors/#basic-usage_2","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.reactor.EquilibriumReactor;\n\nEquilibriumReactor eqReactor = new EquilibriumReactor(\"R-100\", feedStream);\neqReactor.setTemperature(500.0, \"K\");\neqReactor.setPressure(10.0, \"bara\");\neqReactor.run();\n</code></pre>"},{"location":"process/equipment/reactors/#reaction-definition","title":"Reaction Definition","text":"<pre><code>// Water-gas shift: CO + H2O \u21cc CO2 + H2\neqReactor.addReaction(\"CO\", -1);\neqReactor.addReaction(\"H2O\", -1);\neqReactor.addReaction(\"CO2\", 1);\neqReactor.addReaction(\"H2\", 1);\n\n// Equilibrium constant\neqReactor.setEquilibriumConstant(Keq);\n</code></pre>"},{"location":"process/equipment/reactors/#gibbs-reactor","title":"Gibbs Reactor","text":"<p>Minimize Gibbs free energy to find equilibrium composition.</p>"},{"location":"process/equipment/reactors/#basic-usage_3","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.reactor.GibbsReactor;\n\nGibbsReactor gibbs = new GibbsReactor(\"R-100\", feedStream);\ngibbs.setTemperature(1000.0, \"K\");\ngibbs.setPressure(10.0, \"bara\");\ngibbs.run();\n\n// Get equilibrium composition\nStream outlet = gibbs.getOutletStream();\n</code></pre>"},{"location":"process/equipment/reactors/#constrained-minimization","title":"Constrained Minimization","text":"<pre><code>// Specify which elements to balance\ngibbs.setElementBalanceCheck(true);\n\n// Specify inert components\ngibbs.setInertComponent(\"N2\", true);\n</code></pre>"},{"location":"process/equipment/reactors/#examples","title":"Examples","text":""},{"location":"process/equipment/reactors/#example-1-simple-cstr","title":"Example 1: Simple CSTR","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.reactor.CSTRReactor;\n\n// Feed with reactants\nSystemSrkEos feed = new SystemSrkEos(350.0, 5.0);\nfeed.addComponent(\"methanol\", 0.5);\nfeed.addComponent(\"water\", 0.5);\nfeed.setMixingRule(\"classic\");\n\nStream feedStream = new Stream(\"Feed\", feed);\nfeedStream.setFlowRate(1000.0, \"kg/hr\");\nfeedStream.run();\n\n// Reactor\nCSTRReactor reactor = new CSTRReactor(\"R-100\", feedStream);\nreactor.setVolume(5.0, \"m3\");\nreactor.run();\n\ndouble residenceTime = reactor.getResidenceTime(\"min\");\nSystem.out.println(\"Residence time: \" + residenceTime + \" min\");\n</code></pre>"},{"location":"process/equipment/reactors/#example-2-steam-methane-reforming-gibbs","title":"Example 2: Steam Methane Reforming (Gibbs)","text":"<pre><code>// SMR: CH4 + H2O \u21cc CO + 3H2\nSystemSrkEos feed = new SystemSrkEos(700.0, 20.0);\nfeed.addComponent(\"methane\", 1.0);\nfeed.addComponent(\"water\", 3.0);  // Steam to carbon ratio = 3\nfeed.setMixingRule(\"classic\");\n\n// Add possible products\nfeed.addComponent(\"CO\", 0.0);\nfeed.addComponent(\"CO2\", 0.0);\nfeed.addComponent(\"hydrogen\", 0.0);\n\nStream feedStream = new Stream(\"SMR Feed\", feed);\nfeedStream.setFlowRate(100.0, \"kmol/hr\");\nfeedStream.run();\n\n// Gibbs reactor for equilibrium\nGibbsReactor smr = new GibbsReactor(\"SMR Reactor\", feedStream);\nsmr.setTemperature(1100.0, \"K\");\nsmr.setPressure(20.0, \"bara\");\nsmr.run();\n\n// Results\nStream product = smr.getOutletStream();\nSystem.out.println(\"H2 mole fraction: \" + product.getFluid().getMoleFraction(\"hydrogen\"));\nSystem.out.println(\"CO mole fraction: \" + product.getFluid().getMoleFraction(\"CO\"));\nSystem.out.println(\"CH4 conversion: \" + \n    (1 - product.getFluid().getMoleFraction(\"methane\") / \n     feedStream.getFluid().getMoleFraction(\"methane\")) * 100 + \" %\");\n</code></pre>"},{"location":"process/equipment/reactors/#example-3-ammonia-synthesis","title":"Example 3: Ammonia Synthesis","text":"<pre><code>// N2 + 3H2 \u21cc 2NH3\nSystemSrkEos synthGas = new SystemSrkEos(700.0, 200.0);\nsynthGas.addComponent(\"nitrogen\", 1.0);\nsynthGas.addComponent(\"hydrogen\", 3.0);\nsynthGas.addComponent(\"ammonia\", 0.0);\nsynthGas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"Syngas\", synthGas);\nfeed.setFlowRate(1000.0, \"kmol/hr\");\nfeed.run();\n\nEquilibriumReactor ammoniaReactor = new EquilibriumReactor(\"Ammonia Reactor\", feed);\nammoniaReactor.setTemperature(700.0, \"K\");\nammoniaReactor.setPressure(200.0, \"bara\");\nammoniaReactor.run();\n\ndouble nh3Prod = ammoniaReactor.getOutletStream().getFluid().getMoleFraction(\"ammonia\");\nSystem.out.println(\"Ammonia mole fraction: \" + nh3Prod);\n</code></pre>"},{"location":"process/equipment/reactors/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Chemical Reactions - Reaction modeling</li> <li>Heat Exchangers - Reactor heat exchange</li> </ul>"},{"location":"process/equipment/separators/","title":"Separator Equipment","text":"<p>Documentation for separator equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/separators/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Separator Types</li> <li>Usage Examples</li> <li>Design Calculations</li> </ul>"},{"location":"process/equipment/separators/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.separator</code></p> <p>Classes: - <code>Separator</code> - Two-phase gas-liquid separator - <code>ThreePhaseSeparator</code> - Three-phase gas-oil-water separator - <code>GasScrubber</code> - Gas scrubbing separator - <code>GasScrubberSimple</code> - Simplified gas scrubber</p>"},{"location":"process/equipment/separators/#separator-types","title":"Separator Types","text":""},{"location":"process/equipment/separators/#two-phase-separator","title":"Two-Phase Separator","text":"<pre><code>import neqsim.process.equipment.separator.Separator;\n\nSeparator separator = new Separator(\"V-100\", inletStream);\nseparator.run();\n\n// Get outlet streams\nStream gasOut = separator.getGasOutStream();\nStream liquidOut = separator.getLiquidOutStream();\n\n// Properties\ndouble gasRate = gasOut.getFlowRate(\"kg/hr\");\ndouble liquidRate = liquidOut.getFlowRate(\"kg/hr\");\ndouble liquidLevel = separator.getLiquidLevel();\n</code></pre>"},{"location":"process/equipment/separators/#three-phase-separator","title":"Three-Phase Separator","text":"<pre><code>import neqsim.process.equipment.separator.ThreePhaseSeparator;\n\nThreePhaseSeparator separator = new ThreePhaseSeparator(\"V-200\", inletStream);\nseparator.run();\n\n// Get outlet streams\nStream gasOut = separator.getGasOutStream();\nStream oilOut = separator.getOilOutStream();\nStream waterOut = separator.getWaterOutStream();\n\n// Water cut\ndouble waterCut = separator.getWaterCut();\n</code></pre>"},{"location":"process/equipment/separators/#gas-scrubber","title":"Gas Scrubber","text":"<pre><code>import neqsim.process.equipment.separator.GasScrubber;\n\nGasScrubber scrubber = new GasScrubber(\"Inlet Scrubber\", gasStream);\nscrubber.run();\n\n// Dry gas output\nStream dryGas = scrubber.getGasOutStream();\n\n// Condensate removal\nStream condensate = scrubber.getLiquidOutStream();\n</code></pre>"},{"location":"process/equipment/separators/#separator-sizing","title":"Separator Sizing","text":""},{"location":"process/equipment/separators/#vertical-separator","title":"Vertical Separator","text":"<pre><code>// Set dimensions\nseparator.setInternalDiameter(2.0, \"m\");\nseparator.setLiquidVolume(10.0, \"m3\");\n\n// Or specify residence time\nseparator.setLiquidResidenceTime(120.0, \"sec\");\n</code></pre>"},{"location":"process/equipment/separators/#horizontal-separator","title":"Horizontal Separator","text":"<pre><code>separator.setSeparatorType(\"horizontal\");\nseparator.setLength(10.0, \"m\");\nseparator.setInternalDiameter(2.5, \"m\");\n</code></pre>"},{"location":"process/equipment/separators/#dynamic-simulation","title":"Dynamic Simulation","text":"<pre><code>// Enable dynamic mode\nseparator.setCalculateSteadyState(false);\n\n// Set initial conditions\nseparator.setLiquidLevel(0.5);  // 50% level\n\n// Run transient\nfor (int i = 0; i &lt; 100; i++) {\n    separator.runTransient();\n\n    double level = separator.getLiquidLevel();\n    double pressure = separator.getPressure();\n}\n</code></pre>"},{"location":"process/equipment/separators/#separation-efficiency","title":"Separation Efficiency","text":"<pre><code>// Set droplet removal efficiency\nseparator.setGasCarryUnderFraction(0.001);  // 0.1% liquid in gas\nseparator.setLiquidCarryOverFraction(0.0001); // 0.01% gas in liquid\n</code></pre>"},{"location":"process/equipment/separators/#example-hplp-separation-train","title":"Example: HP/LP Separation Train","text":"<pre><code>// HP Separator at 50 bar\nSeparator hpSep = new Separator(\"HP Sep\", feedStream);\nprocess.add(hpSep);\n\n// Letdown valve\nThrottlingValve lpValve = new ThrottlingValve(\"LP Valve\", hpSep.getLiquidOutStream());\nlpValve.setOutletPressure(5.0, \"bara\");\nprocess.add(lpValve);\n\n// LP Separator at 5 bar\nSeparator lpSep = new Separator(\"LP Sep\", lpValve.getOutletStream());\nprocess.add(lpSep);\n\n// Run process\nprocess.run();\n\n// Total gas production\ndouble hpGas = hpSep.getGasOutStream().getFlowRate(\"MSm3/day\");\ndouble lpGas = lpSep.getGasOutStream().getFlowRate(\"MSm3/day\");\ndouble totalGas = hpGas + lpGas;\n</code></pre>"},{"location":"process/equipment/separators/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Streams - Stream handling</li> </ul>"},{"location":"process/equipment/streams/","title":"Streams","text":"<p>Comprehensive documentation for process streams in NeqSim.</p>"},{"location":"process/equipment/streams/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Stream Architecture</li> <li>Stream Class</li> <li>Stream Specifications</li> <li>Stream Properties</li> <li>Phase Handling</li> <li>Gas Quality Properties</li> <li>Virtual Streams</li> <li>NeqStream</li> <li>Energy Streams</li> <li>Cloning and State Management</li> <li>Transient Operations</li> <li>Examples</li> <li>Advanced Topics</li> </ul>"},{"location":"process/equipment/streams/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.stream</code></p> <p>Streams are the fundamental connections between process equipment in NeqSim, carrying material and energy through process flowsheets. They encapsulate thermodynamic fluid systems with flow conditions and provide methods for flash calculations, property retrieval, and gas quality analysis.</p>"},{"location":"process/equipment/streams/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>ProcessEquipmentBaseClass\n    \u2514\u2500\u2500 Stream (implements StreamInterface)\n            \u2514\u2500\u2500 NeqStream\n\nProcessEquipmentBaseClass\n    \u2514\u2500\u2500 VirtualStream\n\njava.io.Serializable\n    \u2514\u2500\u2500 EnergyStream\n</code></pre>"},{"location":"process/equipment/streams/#available-classes","title":"Available Classes","text":"Class Description Use Case <code>Stream</code> Standard process stream with full thermodynamic calculations General material flows <code>StreamInterface</code> Interface defining stream contract Type declarations and polymorphism <code>NeqStream</code> Stream without flash (uses existing phase split) When phase equilibrium is known <code>VirtualStream</code> Reference stream with property overrides Branch flows, what-if scenarios <code>EnergyStream</code> Heat/work duty carrier Heat exchanger duties, compressor work"},{"location":"process/equipment/streams/#stream-architecture","title":"Stream Architecture","text":""},{"location":"process/equipment/streams/#internal-structure","title":"Internal Structure","text":"<p>A Stream contains: - thermoSystem: The underlying <code>SystemInterface</code> fluid object - stream: Optional reference to source stream (for linked streams) - specification: Flash type specification (TP, PH, dewP, etc.) - lastState: Cached results for recalculation optimization</p>"},{"location":"process/equipment/streams/#object-ownership","title":"Object Ownership","text":"<pre><code>// IMPORTANT: Stream uses the fluid object directly (not cloned)\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 1.0);\n\n// The stream references the same fluid object\nStream stream = new Stream(\"Feed\", fluid);\n\n// To create independent streams, clone explicitly\nStream independent = new Stream(\"Independent\", fluid.clone());\n</code></pre>"},{"location":"process/equipment/streams/#linked-streams","title":"Linked Streams","text":"<p>Streams can reference other streams:</p> <pre><code>// Source stream\nStream source = new Stream(\"Source\", fluid);\nsource.run();\n\n// Linked stream (shares fluid with source)\nStream linked = new Stream(\"Linked\", source);\n\n// When source changes, linked sees the changes after run()\nsource.setTemperature(350.0, \"K\");\nsource.run();\nlinked.run();  // Uses updated source properties\n</code></pre>"},{"location":"process/equipment/streams/#stream-class","title":"Stream Class","text":""},{"location":"process/equipment/streams/#constructors","title":"Constructors","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\n\n// 1. Create with name only (fluid set later)\nStream emptyStream = new Stream(\"Empty\");\n\n// 2. Create from fluid system (uses fluid directly, not cloned)\nSystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.90);\nfluid.addComponent(\"ethane\", 0.07);\nfluid.addComponent(\"propane\", 0.03);\nfluid.setMixingRule(\"classic\");\nStream feedStream = new Stream(\"Feed\", fluid);\n\n// 3. Create from another stream (linked reference)\nStream linkedStream = new Stream(\"Linked\", feedStream);\n</code></pre>"},{"location":"process/equipment/streams/#setting-process-conditions","title":"Setting Process Conditions","text":"<pre><code>// Temperature (various units)\nfeed.setTemperature(300.0, \"K\");        // Kelvin\nfeed.setTemperature(25.0, \"C\");         // Celsius\nfeed.setTemperature(77.0, \"F\");         // Fahrenheit\n\n// Pressure (various units)\nfeed.setPressure(50.0, \"bara\");         // Bar absolute\nfeed.setPressure(725.0, \"psia\");        // PSI absolute\nfeed.setPressure(5.0, \"MPa\");           // Megapascal\n\n// Flow rate (various units)\nfeed.setFlowRate(10000.0, \"kg/hr\");     // Mass flow\nfeed.setFlowRate(500.0, \"kmol/hr\");     // Molar flow\nfeed.setFlowRate(1000000.0, \"Sm3/day\"); // Standard volume (gas)\nfeed.setFlowRate(100.0, \"m3/hr\");       // Actual volume\n\n// IMPORTANT: Always run() after setting conditions\nfeed.run();\n</code></pre>"},{"location":"process/equipment/streams/#setting-fluidcomposition","title":"Setting Fluid/Composition","text":"<pre><code>// Replace entire fluid\nfeed.setFluid(newFluidSystem);\nfeed.setThermoSystem(newFluidSystem);\n\n// Set from specific phase of another system\nfeed.setThermoSystemFromPhase(otherSystem, \"gas\");      // Gas phase only\nfeed.setThermoSystemFromPhase(otherSystem, \"oil\");      // Oil phase only\nfeed.setThermoSystemFromPhase(otherSystem, \"aqueous\");  // Water phase only\nfeed.setThermoSystemFromPhase(otherSystem, \"liquid\");   // All liquid phases\n\n// Create empty stream from template\nfeed.setEmptyThermoSystem(templateSystem);\n</code></pre>"},{"location":"process/equipment/streams/#stream-specifications","title":"Stream Specifications","text":"<p>The stream specification controls how flash calculations are performed.</p>"},{"location":"process/equipment/streams/#available-specifications","title":"Available Specifications","text":"Specification Description When to Use <code>\"TP\"</code> Temperature-Pressure flash (default) Standard conditions <code>\"PH\"</code> Pressure-Enthalpy flash After isenthalpic processes <code>\"dewP\"</code> Dew point temperature at given P Condensation studies <code>\"dewT\"</code> Dew point pressure at given T Dew point analysis <code>\"bubP\"</code> Bubble point temperature at given P Evaporation studies <code>\"bubT\"</code> Bubble point pressure at given T Bubble point analysis <code>\"gas quality\"</code> Constant phase fraction flash Fixed vapor fraction"},{"location":"process/equipment/streams/#using-specifications","title":"Using Specifications","text":"<pre><code>// Default TP flash\nStream stream = new Stream(\"Process\", fluid);\nstream.run();  // Performs TP flash\n\n// Dew point calculation\nstream.setSpecification(\"dewP\");\nstream.run();  // Calculates dew point temperature at current pressure\n\n// Bubble point calculation\nstream.setSpecification(\"bubP\");\nstream.run();  // Calculates bubble point temperature at current pressure\n\n// Gas quality specification\nstream.setSpecification(\"gas quality\");\nstream.setGasQuality(0.5);  // 50% vapor fraction\nstream.run();  // Calculates temperature for specified vapor fraction\n</code></pre>"},{"location":"process/equipment/streams/#stream-properties","title":"Stream Properties","text":""},{"location":"process/equipment/streams/#thermodynamic-properties","title":"Thermodynamic Properties","text":"<pre><code>stream.run();  // Ensure stream is calculated\n\n// Temperature\ndouble tempK = stream.getTemperature();          // Kelvin (default)\ndouble tempC = stream.getTemperature(\"C\");       // Celsius\ndouble tempF = stream.getTemperature(\"F\");       // Fahrenheit\n\n// Pressure\ndouble pressPa = stream.getPressure();           // Pascal (default)\ndouble pressBara = stream.getPressure(\"bara\");   // Bar absolute\ndouble pressPsia = stream.getPressure(\"psia\");   // PSI absolute\n\n// Flow rates\ndouble massFlow = stream.getFlowRate(\"kg/hr\");\ndouble molarFlow = stream.getFlowRate(\"kmol/hr\");\ndouble molarRate = stream.getMolarRate();        // Total moles\ndouble volFlow = stream.getFlowRate(\"m3/hr\");\ndouble stdVolFlow = stream.getFlowRate(\"Sm3/day\");\n</code></pre>"},{"location":"process/equipment/streams/#flow-rate-unit-reference","title":"Flow Rate Unit Reference","text":"Unit Description Basis <code>\"kg/sec\"</code> Kilograms per second Mass <code>\"kg/min\"</code> Kilograms per minute Mass <code>\"kg/hr\"</code> Kilograms per hour Mass <code>\"kg/day\"</code> Kilograms per day Mass <code>\"kmol/hr\"</code> Kilomoles per hour Molar <code>\"mole/sec\"</code> Moles per second Molar <code>\"mole/min\"</code> Moles per minute Molar <code>\"mole/hr\"</code> Moles per hour Molar <code>\"m3/sec\"</code> Actual m\u00b3/second Volume <code>\"m3/min\"</code> Actual m\u00b3/minute Volume <code>\"m3/hr\"</code> Actual m\u00b3/hour Volume <code>\"Sm3/sec\"</code> Standard m\u00b3/second Std Volume <code>\"Sm3/hr\"</code> Standard m\u00b3/hour Std Volume <code>\"Sm3/day\"</code> Standard m\u00b3/day Std Volume <code>\"MSm3/day\"</code> Million Sm\u00b3/day Std Volume <code>\"barrel/day\"</code> Oil barrels/day Volume"},{"location":"process/equipment/streams/#accessing-the-fluid-system","title":"Accessing the Fluid System","text":"<pre><code>// Get fluid object for detailed properties\nSystemInterface fluid = stream.getFluid();\n// or equivalently:\nSystemInterface fluid = stream.getThermoSystem();\n\n// Molecular weight\ndouble mw = fluid.getMolarMass(\"kg/kmol\");\n\n// Enthalpy\ndouble enthalpy = fluid.getEnthalpy(\"kJ/kg\");\n\n// Entropy\ndouble entropy = fluid.getEntropy(\"kJ/kgK\");\n\n// Density\ndouble density = fluid.getDensity(\"kg/m3\");\n\n// Composition\ndouble[] moleFractions = fluid.getMolarComposition();\ndouble methaneFrac = fluid.getComponent(\"methane\").getz();\n</code></pre>"},{"location":"process/equipment/streams/#phase-handling","title":"Phase Handling","text":""},{"location":"process/equipment/streams/#checking-phase-presence","title":"Checking Phase Presence","text":"<pre><code>SystemInterface fluid = stream.getFluid();\n\n// Check for specific phases\nboolean hasGas = fluid.hasPhaseType(\"gas\");\nboolean hasOil = fluid.hasPhaseType(\"oil\");\nboolean hasAqueous = fluid.hasPhaseType(\"aqueous\");\n\n// Number of phases\nint numPhases = fluid.getNumberOfPhases();\n\n// Phase mole fractions (beta)\ndouble gasFraction = fluid.getPhase(\"gas\").getBeta();  // Mole basis\n</code></pre>"},{"location":"process/equipment/streams/#accessing-phase-properties","title":"Accessing Phase Properties","text":"<pre><code>if (fluid.hasPhaseType(\"gas\")) {\n    PhaseInterface gasPhase = fluid.getPhase(\"gas\");\n\n    // Phase properties\n    double gasDensity = gasPhase.getDensity(\"kg/m3\");\n    double gasViscosity = gasPhase.getViscosity(\"cP\");\n    double gasMW = gasPhase.getMolarMass(\"kg/kmol\");\n    double gasZ = gasPhase.getZ();  // Compressibility factor\n\n    // Component in phase\n    double methaneInGas = gasPhase.getComponent(\"methane\").getx();\n}\n\nif (fluid.hasPhaseType(\"oil\")) {\n    PhaseInterface oilPhase = fluid.getPhase(\"oil\");\n    double oilDensity = oilPhase.getDensity(\"kg/m3\");\n    double oilViscosity = oilPhase.getViscosity(\"cP\");\n}\n</code></pre>"},{"location":"process/equipment/streams/#creating-streams-from-phases","title":"Creating Streams from Phases","text":"<pre><code>// From separator outlet\nSeparator separator = new Separator(\"Sep\", feed);\nseparator.run();\n\n// Gas outlet\nStream gasOut = new Stream(\"Gas Out\");\ngasOut.setThermoSystemFromPhase(separator.getFluid(), \"gas\");\ngasOut.run();\n\n// Oil outlet\nStream oilOut = new Stream(\"Oil Out\");\noilOut.setThermoSystemFromPhase(separator.getFluid(), \"oil\");\noilOut.run();\n\n// All liquids combined\nStream liquidOut = new Stream(\"Liquid Out\");\nliquidOut.setThermoSystemFromPhase(separator.getFluid(), \"liquid\");\nliquidOut.run();\n</code></pre>"},{"location":"process/equipment/streams/#gas-quality-properties","title":"Gas Quality Properties","text":"<p>NeqSim provides comprehensive gas quality calculations per ISO 6976 and other standards.</p>"},{"location":"process/equipment/streams/#calorific-values","title":"Calorific Values","text":"<pre><code>// Gross Calorific Value (Higher Heating Value)\ndouble gcv = stream.GCV();  // kJ/Sm\u00b3 at 0\u00b0C, 15.55\u00b0C combustion\n\n// GCV with specified reference conditions\ndouble gcvCustom = stream.getGCV(\"volume\", 15.0, 15.0);  // refT=15\u00b0C, combT=15\u00b0C\n\n// Net Calorific Value (Lower Heating Value)\ndouble lcv = stream.LCV();  // kJ/Sm\u00b3\n</code></pre>"},{"location":"process/equipment/streams/#wobbe-index","title":"Wobbe Index","text":"<pre><code>// Wobbe Index (gas interchangeability measure)\ndouble wi = stream.getWI(\"volume\", 15.0, 15.0);  // kJ/Sm\u00b3\n</code></pre>"},{"location":"process/equipment/streams/#iso-6976-standard-calculations","title":"ISO 6976 Standard Calculations","text":"<pre><code>// Get full ISO 6976 results\nStandard_ISO6976 iso = stream.getISO6976(\"volume\", 15.0, 15.0);\niso.calculate();\n\ndouble gcv = iso.getValue(\"SuperiorCalorificValue\");\ndouble lcv = iso.getValue(\"InferiorCalorificValue\");\ndouble wobbe = iso.getValue(\"SuperiorWobbeIndex\");\ndouble relDensity = iso.getValue(\"RelativeDensity\");\ndouble compressibility = iso.getValue(\"CompressionFactor\");\n</code></pre>"},{"location":"process/equipment/streams/#dew-points","title":"Dew Points","text":"<pre><code>// Hydrocarbon dew point at specified pressure\ndouble hcDewPoint = stream.getHydrocarbonDewPoint(\"C\", 70.0, \"bara\");\n\n// Hydrate equilibrium temperature\ndouble hydrateTemp = stream.getHydrateEquilibriumTemperature();  // K\n\n// Solid formation temperature\ndouble freezeTemp = stream.getSolidFormationTemperature(\"wax\");\n</code></pre>"},{"location":"process/equipment/streams/#phase-envelope-points","title":"Phase Envelope Points","text":"<pre><code>// Cricondentherm (maximum temperature for two-phase)\ndouble cctTemp = stream.CCT(\"C\");      // Temperature\ndouble cctPres = stream.CCT(\"bara\");   // Pressure at CCT\n\n// Cricondenbar (maximum pressure for two-phase)\ndouble ccbTemp = stream.CCB(\"C\");      // Temperature at CCB\ndouble ccbPres = stream.CCB(\"bara\");   // Pressure\n\n// Phase envelope visualization\nstream.phaseEnvelope();  // Opens plot window\n</code></pre>"},{"location":"process/equipment/streams/#vapor-pressure","title":"Vapor Pressure","text":"<pre><code>// True Vapor Pressure at reference temperature\ndouble tvp = stream.TVP(37.8, \"C\");  // bara at 100\u00b0F\ndouble tvpPsia = stream.getTVP(37.8, \"C\", \"psia\");\n\n// Reid Vapor Pressure (ASTM D6377)\ndouble rvp = stream.getRVP(37.8, \"C\", \"psia\");\ndouble rvpMethod = stream.getRVP(37.8, \"C\", \"psia\", \"VPCR4\");\n</code></pre>"},{"location":"process/equipment/streams/#virtual-streams","title":"Virtual Streams","text":"<p>VirtualStream creates a modified copy of a reference stream with overridden properties.</p>"},{"location":"process/equipment/streams/#purpose","title":"Purpose","text":"<ul> <li>Create branch streams with different flow rates</li> <li>Model \"what-if\" scenarios</li> <li>Avoid direct fluid manipulation</li> </ul>"},{"location":"process/equipment/streams/#usage","title":"Usage","text":"<pre><code>import neqsim.process.equipment.stream.VirtualStream;\n\n// Reference stream\nStream mainFlow = new Stream(\"Main\", fluid);\nmainFlow.setFlowRate(10000.0, \"kg/hr\");\nmainFlow.run();\n\n// Virtual stream with modified flow\nVirtualStream branch = new VirtualStream(\"Branch\", mainFlow);\nbranch.setFlowRate(2000.0, \"kg/hr\");  // Override flow\nbranch.run();\n\n// Virtual stream with modified conditions\nVirtualStream heated = new VirtualStream(\"Heated\", mainFlow);\nheated.setTemperature(350.0, \"K\");    // Override temperature\nheated.setFlowRate(3000.0, \"kg/hr\");  // Override flow\nheated.run();\n\n// Virtual stream with modified composition\nVirtualStream altered = new VirtualStream(\"Altered\", mainFlow);\ndouble[] newComp = {0.95, 0.03, 0.02};  // New mole fractions\naltered.setComposition(newComp, \"mole\");\naltered.run();\n\n// Get output stream from virtual\nStreamInterface outputStream = altered.getOutletStream();\n</code></pre>"},{"location":"process/equipment/streams/#key-methods","title":"Key Methods","text":"Method Description <code>setReferenceStream(stream)</code> Set the source stream <code>setFlowRate(value, unit)</code> Override flow rate <code>setTemperature(value, unit)</code> Override temperature <code>setPressure(value, unit)</code> Override pressure <code>setComposition(array, unit)</code> Override composition <code>getOutletStream()</code> Get the modified stream"},{"location":"process/equipment/streams/#neqstream","title":"NeqStream","text":"<p>NeqStream is a specialized stream that skips flash calculations, using the existing phase distribution.</p>"},{"location":"process/equipment/streams/#when-to-use","title":"When to Use","text":"<ul> <li>Phase equilibrium is already calculated</li> <li>Performance optimization (skip redundant flashes)</li> <li>Maintaining exact phase splits from previous calculations</li> </ul>"},{"location":"process/equipment/streams/#behavior-difference","title":"Behavior Difference","text":"<pre><code>// Standard Stream: performs TP flash\nStream standard = new Stream(\"Standard\", fluid);\nstandard.run();  // Calculates new phase equilibrium\n\n// NeqStream: uses existing phases, just initializes properties\nNeqStream neq = new NeqStream(\"NeqStream\", fluid);\nneq.run();  // Skips flash, uses existing x, y, beta\n</code></pre>"},{"location":"process/equipment/streams/#usage-example","title":"Usage Example","text":"<pre><code>import neqsim.process.equipment.stream.NeqStream;\n\n// After separator has calculated phases\nSeparator sep = new Separator(\"Sep\", feed);\nsep.run();\n\n// Use NeqStream to preserve exact phase split\nNeqStream gasStream = new NeqStream(\"Gas\", sep.getGasOutStream());\ngasStream.run();  // No reflash, preserves separator results\n</code></pre>"},{"location":"process/equipment/streams/#energy-streams","title":"Energy Streams","text":"<p>EnergyStream carries heat or work duty between equipment.</p>"},{"location":"process/equipment/streams/#creating-energy-streams","title":"Creating Energy Streams","text":"<pre><code>import neqsim.process.equipment.stream.EnergyStream;\n\n// Create energy stream\nEnergyStream heatDuty = new EnergyStream(\"Heater Duty\");\nheatDuty.setDuty(1000000.0);  // Watts\n\n// Get duty\ndouble duty = heatDuty.getDuty();  // Watts\n</code></pre>"},{"location":"process/equipment/streams/#connecting-to-equipment","title":"Connecting to Equipment","text":"<pre><code>// Heater with energy stream\nHeater heater = new Heater(\"Heater\", feed);\nheater.setOutletTemperature(350.0, \"K\");\nheater.run();\n\n// Energy stream gets duty from heater\nEnergyStream heaterPower = new EnergyStream(\"Heater Power\");\nheaterPower.setDuty(heater.getDuty());\n\n// Connect to heat source\nHeatExchanger hx = new HeatExchanger(\"HX\");\nhx.setEnergyStream(heaterPower);\n</code></pre>"},{"location":"process/equipment/streams/#cloning-and-state-management","title":"Cloning and State Management","text":""},{"location":"process/equipment/streams/#cloning-streams","title":"Cloning Streams","text":"<pre><code>// Clone with same name (returns copy)\nStream original = new Stream(\"Feed\", fluid);\noriginal.run();\n\nStream copy = original.clone();\n\n// Clone with new name\nStream namedCopy = original.clone(\"Feed Copy\");\n\n// Clones are independent\ncopy.setFlowRate(500.0, \"kg/hr\");\ncopy.run();\n// Original unchanged\n</code></pre>"},{"location":"process/equipment/streams/#state-caching","title":"State Caching","text":"<p>Streams cache their last calculated state for optimization:</p> <pre><code>// Check if recalculation is needed\nif (stream.needRecalculation()) {\n    stream.run();  // Conditions changed, recalculate\n}\n\n// Cached values used internally:\n// - lastTemperature\n// - lastPressure\n// - lastFlowRate\n// - lastComposition\n</code></pre>"},{"location":"process/equipment/streams/#transient-operations","title":"Transient Operations","text":"<p>Streams support dynamic simulation with controller integration.</p>"},{"location":"process/equipment/streams/#running-transient","title":"Running Transient","text":"<pre><code>// Time step in seconds\ndouble dt = 1.0;\nUUID calcId = UUID.randomUUID();\n\n// Run transient step\nstream.runTransient(dt, calcId);\n\n// Increase simulation time\nstream.increaseTime(dt);\n</code></pre>"},{"location":"process/equipment/streams/#with-flow-controller","title":"With Flow Controller","text":"<pre><code>// Attach controller\nControllerDeviceInterface controller = new PIDController();\ncontroller.setControllerSetPoint(1000.0);  // kg/hr target\nstream.setController(controller);\n\n// Transient run adjusts flow via controller\nfor (int i = 0; i &lt; 100; i++) {\n    stream.runTransient(1.0, UUID.randomUUID());\n}\n</code></pre>"},{"location":"process/equipment/streams/#minimum-flow-handling","title":"Minimum Flow Handling","text":"<pre><code>// Streams below minimum flow are deactivated\nif (stream.getFlowRate(\"kg/hr\") &lt; stream.getMinimumFlow()) {\n    // Stream runs but marks as inactive\n    stream.isActive();  // Returns false\n}\n</code></pre>"},{"location":"process/equipment/streams/#examples","title":"Examples","text":""},{"location":"process/equipment/streams/#example-1-complete-natural-gas-feed-setup","title":"Example 1: Complete Natural Gas Feed Setup","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\n\n// Natural gas composition\nSystemSrkEos gas = new SystemSrkEos(298.15, 70.0);\ngas.addComponent(\"nitrogen\", 0.02);\ngas.addComponent(\"CO2\", 0.01);\ngas.addComponent(\"methane\", 0.85);\ngas.addComponent(\"ethane\", 0.06);\ngas.addComponent(\"propane\", 0.03);\ngas.addComponent(\"i-butane\", 0.01);\ngas.addComponent(\"n-butane\", 0.015);\ngas.addComponent(\"i-pentane\", 0.005);\ngas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"Natural Gas Feed\", gas);\nfeed.setFlowRate(10.0, \"MSm3/day\");  // 10 million Sm\u00b3/day\nfeed.run();\n\n// Report properties\nSystem.out.println(\"=== Feed Stream Properties ===\");\nSystem.out.println(\"Temperature: \" + feed.getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"Pressure: \" + feed.getPressure(\"bara\") + \" bara\");\nSystem.out.println(\"Mass flow: \" + feed.getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"Molar flow: \" + feed.getFlowRate(\"kmol/hr\") + \" kmol/hr\");\nSystem.out.println(\"Density: \" + feed.getFluid().getDensity(\"kg/m3\") + \" kg/m\u00b3\");\nSystem.out.println(\"MW: \" + feed.getFluid().getMolarMass(\"kg/kmol\") + \" kg/kmol\");\n\n// Gas quality\nSystem.out.println(\"\\n=== Gas Quality ===\");\nSystem.out.println(\"GCV: \" + feed.GCV() / 1000.0 + \" MJ/Sm\u00b3\");\nSystem.out.println(\"LCV: \" + feed.LCV() / 1000.0 + \" MJ/Sm\u00b3\");\nSystem.out.println(\"Wobbe Index: \" + feed.getWI(\"volume\", 15.0, 15.0) / 1000.0 + \" MJ/Sm\u00b3\");\nSystem.out.println(\"HC Dew Point: \" + feed.getHydrocarbonDewPoint(\"C\", 70.0, \"bara\") + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/streams/#example-2-two-phase-stream-analysis","title":"Example 2: Two-Phase Stream Analysis","text":"<pre><code>// Wellhead mixture\nSystemSrkEos wellfluid = new SystemSrkEos(350.0, 150.0);\nwellfluid.addComponent(\"methane\", 0.60);\nwellfluid.addComponent(\"ethane\", 0.08);\nwellfluid.addComponent(\"propane\", 0.05);\nwellfluid.addComponent(\"n-hexane\", 0.12);\nwellfluid.addComponent(\"n-decane\", 0.10);\nwellfluid.addComponent(\"water\", 0.05);\nwellfluid.setMixingRule(\"classic\");\n\nStream wellStream = new Stream(\"Well Stream\", wellfluid);\nwellStream.setFlowRate(50000.0, \"kg/hr\");\nwellStream.run();\n\n// Phase analysis\nSystemInterface fluid = wellStream.getFluid();\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\n\nif (fluid.hasPhaseType(\"gas\")) {\n    double gasRate = fluid.getPhase(\"gas\").getBeta() \n                   * wellStream.getFlowRate(\"kg/hr\");\n    System.out.println(\"Gas rate: \" + gasRate + \" kg/hr\");\n    System.out.println(\"Gas density: \" + fluid.getPhase(\"gas\").getDensity(\"kg/m3\") + \" kg/m\u00b3\");\n}\n\nif (fluid.hasPhaseType(\"oil\")) {\n    double oilRate = fluid.getPhase(\"oil\").getBeta() \n                   * wellStream.getFlowRate(\"kg/hr\");\n    System.out.println(\"Oil rate: \" + oilRate + \" kg/hr\");\n    System.out.println(\"Oil API: \" + fluid.getPhase(\"oil\").getPhysicalProperties()\n                       .getValue(\"API_gravity\"));\n}\n\nif (fluid.hasPhaseType(\"aqueous\")) {\n    double waterRate = fluid.getPhase(\"aqueous\").getBeta() \n                     * wellStream.getFlowRate(\"kg/hr\");\n    System.out.println(\"Water rate: \" + waterRate + \" kg/hr\");\n}\n</code></pre>"},{"location":"process/equipment/streams/#example-3-branch-flows-with-virtualstream","title":"Example 3: Branch Flows with VirtualStream","text":"<pre><code>// Main pipeline flow\nStream pipeline = new Stream(\"Pipeline\", gas);\npipeline.setFlowRate(100000.0, \"kg/hr\");\npipeline.run();\n\n// Customer branches (each takes portion of main flow)\nVirtualStream customer1 = new VirtualStream(\"Customer 1\", pipeline);\ncustomer1.setFlowRate(30000.0, \"kg/hr\");\ncustomer1.run();\n\nVirtualStream customer2 = new VirtualStream(\"Customer 2\", pipeline);\ncustomer2.setFlowRate(25000.0, \"kg/hr\");\ncustomer2.setTemperature(280.0, \"K\");  // Heated for customer 2\ncustomer2.run();\n\nVirtualStream customer3 = new VirtualStream(\"Customer 3\", pipeline);\ncustomer3.setFlowRate(45000.0, \"kg/hr\");\ncustomer3.setPressure(40.0, \"bara\");  // Reduced pressure\ncustomer3.run();\n\n// Verify mass balance\ndouble totalOut = customer1.getOutletStream().getFlowRate(\"kg/hr\")\n                + customer2.getOutletStream().getFlowRate(\"kg/hr\")\n                + customer3.getOutletStream().getFlowRate(\"kg/hr\");\nSystem.out.println(\"Pipeline in: \" + pipeline.getFlowRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"Total out: \" + totalOut + \" kg/hr\");\n</code></pre>"},{"location":"process/equipment/streams/#example-4-dew-point-specification","title":"Example 4: Dew Point Specification","text":"<pre><code>// Gas stream\nStream gasStream = new Stream(\"Export Gas\", gas);\ngasStream.setPressure(70.0, \"bara\");\ngasStream.setFlowRate(5000.0, \"kmol/hr\");\n\n// Calculate dew point temperature\ngasStream.setSpecification(\"dewP\");\ngasStream.run();\nSystem.out.println(\"Dew point at 70 bara: \" + gasStream.getTemperature(\"C\") + \" \u00b0C\");\n\n// Calculate bubble point\ngasStream.setSpecification(\"bubP\");\ngasStream.run();\nSystem.out.println(\"Bubble point at 70 bara: \" + gasStream.getTemperature(\"C\") + \" \u00b0C\");\n\n// Return to normal operation\ngasStream.setSpecification(\"TP\");\ngasStream.setTemperature(25.0, \"C\");\ngasStream.run();\n</code></pre>"},{"location":"process/equipment/streams/#example-5-stream-cloning-for-parallel-paths","title":"Example 5: Stream Cloning for Parallel Paths","text":"<pre><code>// Feed stream\nStream feed = new Stream(\"Feed\", fluid);\nfeed.setFlowRate(10000.0, \"kg/hr\");\nfeed.run();\n\n// Clone for train A (50%)\nStream trainA = feed.clone(\"Train A Feed\");\ntrainA.setFlowRate(5000.0, \"kg/hr\");\ntrainA.run();\n\n// Clone for train B (50%)\nStream trainB = feed.clone(\"Train B Feed\");\ntrainB.setFlowRate(5000.0, \"kg/hr\");\ntrainB.run();\n\n// Process independently\nHeater heaterA = new Heater(\"Heater A\", trainA);\nheaterA.setOutletTemperature(400.0, \"K\");\nheaterA.run();\n\nHeater heaterB = new Heater(\"Heater B\", trainB);\nheaterB.setOutletTemperature(380.0, \"K\");  // Different setpoint\nheaterB.run();\n\nSystem.out.println(\"Train A outlet T: \" + heaterA.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"Train B outlet T: \" + heaterB.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/streams/#example-6-stream-reporting","title":"Example 6: Stream Reporting","text":"<pre><code>// Get formatted report\nArrayList&lt;String[]&gt; report = stream.getReport();\nfor (String[] row : report) {\n    System.out.println(String.join(\" | \", row));\n}\n\n// JSON output\nString json = stream.toJson();\nSystem.out.println(json);\n\n// Result table\nString[][] results = stream.getResultTable();\nfor (String[] row : results) {\n    System.out.println(String.join(\"\\t\", row));\n}\n\n// Display in NeqSim GUI\nstream.displayResult();\n</code></pre>"},{"location":"process/equipment/streams/#advanced-topics","title":"Advanced Topics","text":""},{"location":"process/equipment/streams/#flash-type-auto-selection","title":"Flash Type Auto-Selection","text":"<p>For single-component systems from other streams, the stream automatically switches to PH flash to handle phase changes correctly:</p> <pre><code>// Single component from separator\nif (stream != null &amp;&amp; thermoSystem.getNumberOfComponents() == 1 \n    &amp;&amp; getSpecification().equals(\"TP\")) {\n    setSpecification(\"PH\");  // Auto-switch for stability\n}\n</code></pre>"},{"location":"process/equipment/streams/#recalculation-optimization","title":"Recalculation Optimization","text":"<p>Streams track their last state to avoid unnecessary calculations:</p> <pre><code>// Implementation checks cached values\nif (temperature == lastTemperature \n    &amp;&amp; pressure == lastPressure\n    &amp;&amp; flowRate == lastFlowRate\n    &amp;&amp; composition == lastComposition) {\n    return false;  // No recalculation needed\n}\n</code></pre>"},{"location":"process/equipment/streams/#serialization","title":"Serialization","text":"<p>Streams are fully serializable for persistence:</p> <pre><code>// Save process state\nObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"process.dat\"));\nout.writeObject(stream);\nout.close();\n\n// Restore process state\nObjectInputStream in = new ObjectInputStream(new FileInputStream(\"process.dat\"));\nStream restored = (Stream) in.readObject();\nin.close();\n</code></pre>"},{"location":"process/equipment/streams/#integration-with-processsystem","title":"Integration with ProcessSystem","text":"<pre><code>// Add streams to process system\nProcessSystem process = new ProcessSystem();\n\nStream feed = new Stream(\"Feed\", fluid);\nfeed.setFlowRate(1000.0, \"kg/hr\");\n\nHeater heater = new Heater(\"Heater\", feed);\nheater.setOutletTemperature(350.0, \"K\");\n\nSeparator sep = new Separator(\"Separator\", heater.getOutletStream());\n\nprocess.add(feed);\nprocess.add(heater);\nprocess.add(sep);\n\n// Run entire process\nprocess.run();\n\n// Access any stream\nStreamInterface processedFeed = process.getMeasurementDevice(\"Feed\");\n</code></pre>"},{"location":"process/equipment/streams/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All process equipment</li> <li>Mixers and Splitters - Combining and dividing streams</li> <li>Separators - Phase separation equipment</li> <li>Heat Exchangers - Thermal processing</li> <li>Process System - Flowsheet management</li> <li>Utility Equipment - Adjusters, recycles, calculators</li> </ul>"},{"location":"process/equipment/tanks/","title":"Storage Tanks","text":"<p>Documentation for liquid storage tanks in NeqSim.</p>"},{"location":"process/equipment/tanks/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Tank Class</li> <li>Dynamic Operation</li> <li>Boil-off Gas</li> <li>Examples</li> </ul>"},{"location":"process/equipment/tanks/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.tank</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Tank</code> | Basic storage tank | | <code>LNGTank</code> | LNG storage tank with boil-off |</p>"},{"location":"process/equipment/tanks/#tank-class","title":"Tank Class","text":""},{"location":"process/equipment/tanks/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.tank.Tank;\n\nTank tank = new Tank(\"T-100\", liquidStream);\ntank.setVolume(1000.0, \"m3\");\ntank.setLiquidLevel(0.5);  // 50% full\ntank.run();\n</code></pre>"},{"location":"process/equipment/tanks/#operating-pressure","title":"Operating Pressure","text":"<pre><code>// Atmospheric tank\ntank.setPressure(1.013, \"bara\");\n\n// Pressurized storage\ntank.setPressure(5.0, \"bara\");\n</code></pre>"},{"location":"process/equipment/tanks/#dynamic-operation","title":"Dynamic Operation","text":""},{"location":"process/equipment/tanks/#fill-and-drain","title":"Fill and Drain","text":"<pre><code>// Initial conditions\ntank.setLiquidLevel(0.3);  // 30% full\ntank.run();\n\n// Simulate filling\nfor (double t = 0; t &lt; 3600; t += 60) {\n    tank.setInletStream(inletStream);\n    tank.runTransient();\n\n    double level = tank.getLiquidLevel();\n    System.out.println(\"Time: \" + t + \" s, Level: \" + level * 100 + \" %\");\n}\n</code></pre>"},{"location":"process/equipment/tanks/#level-calculation","title":"Level Calculation","text":"\\[\\frac{dV_{liq}}{dt} = \\dot{Q}_{in} - \\dot{Q}_{out}\\] \\[L = \\frac{V_{liq}}{V_{tank}}\\]"},{"location":"process/equipment/tanks/#boil-off-gas","title":"Boil-off Gas","text":"<p>For cryogenic storage (LNG, LPG).</p>"},{"location":"process/equipment/tanks/#lng-tank","title":"LNG Tank","text":"<pre><code>import neqsim.process.equipment.tank.LNGTank;\n\nLNGTank lngTank = new LNGTank(\"LNG Storage\", lngStream);\nlngTank.setVolume(160000.0, \"m3\");\nlngTank.setHeatInput(500.0, \"kW\");  // Heat leak\nlngTank.run();\n\n// Boil-off rate\ndouble bogRate = lngTank.getBoilOffGasRate(\"kg/hr\");\nStream bog = lngTank.getBoilOffGasStream();\n</code></pre>"},{"location":"process/equipment/tanks/#boil-off-calculation","title":"Boil-off Calculation","text":"\\[\\dot{m}_{BOG} = \\frac{\\dot{Q}_{heat}}{\\Delta H_{vap}}\\] <p>Where: - \\(\\dot{Q}_{heat}\\) = heat leak rate - \\(\\Delta H_{vap}\\) = latent heat of vaporization</p>"},{"location":"process/equipment/tanks/#examples","title":"Examples","text":""},{"location":"process/equipment/tanks/#example-1-simple-storage-tank","title":"Example 1: Simple Storage Tank","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.tank.Tank;\n\n// Crude oil\nSystemSrkEos oil = new SystemSrkEos(298.15, 1.013);\noil.addComponent(\"n-heptane\", 0.50);\noil.addComponent(\"n-decane\", 0.50);\noil.setMixingRule(\"classic\");\n\nStream oilStream = new Stream(\"Crude\", oil);\noilStream.setFlowRate(100.0, \"m3/hr\");\noilStream.run();\n\n// Storage tank\nTank storage = new Tank(\"Crude Storage\", oilStream);\nstorage.setVolume(10000.0, \"m3\");\nstorage.setLiquidLevel(0.6);\nstorage.run();\n\ndouble inventory = storage.getLiquidVolume(\"m3\");\nSystem.out.println(\"Inventory: \" + inventory + \" m\u00b3\");\n</code></pre>"},{"location":"process/equipment/tanks/#example-2-lng-storage-with-boil-off","title":"Example 2: LNG Storage with Boil-off","text":"<pre><code>// LNG composition\nSystemSrkEos lng = new SystemSrkEos(112.0, 1.013);  // -161\u00b0C\nlng.addComponent(\"nitrogen\", 0.01);\nlng.addComponent(\"methane\", 0.92);\nlng.addComponent(\"ethane\", 0.05);\nlng.addComponent(\"propane\", 0.02);\nlng.setMixingRule(\"classic\");\n\nStream lngIn = new Stream(\"LNG In\", lng);\nlngIn.setFlowRate(1000.0, \"m3/hr\");\nlngIn.run();\n\n// LNG tank\nLNGTank tank = new LNGTank(\"LNG Tank\", lngIn);\ntank.setVolume(160000.0, \"m3\");  // 160,000 m\u00b3 tank\ntank.setHeatInput(300.0, \"kW\");  // Heat leak\ntank.run();\n\n// Results\nSystem.out.println(\"BOG rate: \" + tank.getBoilOffGasRate(\"kg/hr\") + \" kg/hr\");\nSystem.out.println(\"BOG temp: \" + tank.getBoilOffGasStream().getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"BOG rate %: \" + tank.getBoilOffRate() * 100 + \" %/day\");\n</code></pre>"},{"location":"process/equipment/tanks/#example-3-tank-with-level-control","title":"Example 3: Tank with Level Control","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Feed stream\nStream feed = new Stream(\"Feed\", oilFluid);\nfeed.setFlowRate(100.0, \"m3/hr\");\nprocess.add(feed);\n\n// Storage tank\nTank tank = new Tank(\"T-100\", feed);\ntank.setVolume(5000.0, \"m3\");\ntank.setLiquidLevel(0.5);\nprocess.add(tank);\n\n// Outlet with level control\nThrottlingValve outlet = new ThrottlingValve(\"LV-100\", tank.getOutletStream());\noutlet.setOutletPressure(1.0, \"bara\");\nprocess.add(outlet);\n\n// Level controller\nPIDController lc = new PIDController(\"LC-100\");\nlc.setMeasuredVariable(tank, \"liquidLevel\");\nlc.setControlledVariable(outlet, \"opening\");\nlc.setSetPoint(0.5);\nlc.setKp(5.0);\nlc.setKi(0.1);\nprocess.add(lc);\n\n// Run transient\nfor (double t = 0; t &lt; 7200; t += 60) {\n    // Disturb inlet at t=1800\n    if (Math.abs(t - 1800) &lt; 30) {\n        feed.setFlowRate(150.0, \"m3/hr\");\n    }\n\n    process.runTransient();\n    System.out.printf(\"%.0f, %.3f, %.1f%n\", \n        t, tank.getLiquidLevel(), outlet.getOpening() * 100);\n}\n</code></pre>"},{"location":"process/equipment/tanks/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Index - All equipment</li> <li>Separators - Phase separation</li> <li>Controllers - Level control</li> </ul>"},{"location":"process/equipment/valves/","title":"Valve Equipment","text":"<p>Documentation for valve equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/valves/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Valve Types</li> <li>Sizing and Cv</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/valves/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.valve</code></p> <p>Classes: - <code>ThrottlingValve</code> - Joule-Thomson throttling valve - <code>ValveInterface</code> - Valve interface - <code>SafetyValve</code> - Pressure relief valve</p>"},{"location":"process/equipment/valves/#throttling-valve","title":"Throttling Valve","text":""},{"location":"process/equipment/valves/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.valve.ThrottlingValve;\n\nThrottlingValve valve = new ThrottlingValve(\"FV-100\", inletStream);\nvalve.setOutletPressure(30.0, \"bara\");\nvalve.run();\n\n// Joule-Thomson cooling\ndouble Tin = inletStream.getTemperature(\"C\");\ndouble Tout = valve.getOutletStream().getTemperature(\"C\");\ndouble deltaT = Tout - Tin;\n\nSystem.out.println(\"Temperature change: \" + deltaT + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/valves/#isenthalpic-expansion","title":"Isenthalpic Expansion","text":"<p>Throttling is isenthalpic (constant enthalpy):</p> <pre><code>double H_in = inletStream.getEnthalpy(\"J/mol\");\ndouble H_out = valve.getOutletStream().getEnthalpy(\"J/mol\");\n// H_in \u2248 H_out (within numerical precision)\n</code></pre>"},{"location":"process/equipment/valves/#valve-sizing","title":"Valve Sizing","text":""},{"location":"process/equipment/valves/#flow-coefficient-cv","title":"Flow Coefficient (Cv)","text":"<pre><code>// Set Cv\nvalve.setCv(150.0, \"US\");  // US gallons/min at 1 psi \u0394P\n// Or\nvalve.setCv(150.0, \"SI\");  // m\u00b3/hr at 1 bar \u0394P\n\n// Get Cv at current conditions\ndouble Cv = valve.getCv(\"US\");\n</code></pre>"},{"location":"process/equipment/valves/#valve-opening","title":"Valve Opening","text":"<pre><code>// Set valve position\nvalve.setPercentValveOpening(50.0);  // 50% open\n\n// Cv varies with opening (inherent characteristic)\nvalve.setValveCharacteristic(\"linear\");\n// or\nvalve.setValveCharacteristic(\"equal_percentage\");\n// or\nvalve.setValveCharacteristic(\"quick_opening\");\n</code></pre>"},{"location":"process/equipment/valves/#calculate-pressure-drop","title":"Calculate Pressure Drop","text":"<pre><code>// Given Cv and flow, calculate \u0394P\nvalve.setCv(100.0, \"US\");\nvalve.setPercentValveOpening(75.0);\nvalve.run();\n\ndouble Pin = inletStream.getPressure(\"bara\");\ndouble Pout = valve.getOutletStream().getPressure(\"bara\");\ndouble deltaP = Pin - Pout;\n</code></pre>"},{"location":"process/equipment/valves/#critical-flow","title":"Critical Flow","text":"<p>For high pressure drops, flow becomes critical (choked).</p> <pre><code>// Check if flow is critical\nboolean isCritical = valve.isCriticalFlow();\n\n// Critical flow factor\ndouble Cf = valve.getCriticalFlowFactor();\n</code></pre>"},{"location":"process/equipment/valves/#safety-valve-psv","title":"Safety Valve (PSV)","text":""},{"location":"process/equipment/valves/#basic-setup","title":"Basic Setup","text":"<pre><code>import neqsim.process.equipment.valve.SafetyValve;\n\nSafetyValve psv = new SafetyValve(\"PSV-100\", vessel);\npsv.setSetPressure(100.0, \"barg\");  // Set pressure\npsv.setBlowdownPressure(10.0, \"%\"); // 10% blowdown\npsv.run();\n\n// Check if valve is open\nboolean isOpen = psv.isOpen();\ndouble relievingFlow = psv.getRelievingFlow(\"kg/hr\");\n</code></pre>"},{"location":"process/equipment/valves/#sizing","title":"Sizing","text":"<pre><code>// Required relieving capacity\npsv.setRequiredCapacity(10000.0, \"kg/hr\");\n\n// Get required orifice area\ndouble area = psv.getRequiredOrificeArea(\"cm2\");\n\n// Select API orifice\nString orifice = psv.selectAPIorifice();  // e.g., \"J\", \"K\", \"L\"\n</code></pre>"},{"location":"process/equipment/valves/#choke-valve","title":"Choke Valve","text":"<p>For wellhead and production applications:</p> <pre><code>import neqsim.process.equipment.valve.ChokeValve;\n\nChokeValve choke = new ChokeValve(\"Wellhead Choke\", wellStream);\nchoke.setOutletPressure(50.0, \"bara\");\nchoke.run();\n\n// Or specify bean size\nchoke.setBeanSize(32, \"64ths\");  // 32/64\" = 0.5\"\nchoke.run();\n\ndouble Pout = choke.getOutletStream().getPressure(\"bara\");\n</code></pre>"},{"location":"process/equipment/valves/#dynamic-simulation","title":"Dynamic Simulation","text":"<pre><code>// Valve dynamics\nvalve.setCalculateSteadyState(false);\n\n// Valve stroke time\nvalve.setStrokeTime(10.0);  // seconds for 0-100%\n\n// Step change\nvalve.setPercentValveOpening(80.0);\n\nfor (double t = 0; t &lt; 30; t += 0.1) {\n    valve.runTransient();\n    double opening = valve.getActualOpening();  // Lags setpoint\n}\n</code></pre>"},{"location":"process/equipment/valves/#example-pressure-letdown-station","title":"Example: Pressure Letdown Station","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// HP gas inlet\nStream hpGas = new Stream(\"HP Gas\", gasFluid);\nhpGas.setFlowRate(50000.0, \"kg/hr\");\nhpGas.setTemperature(50.0, \"C\");\nhpGas.setPressure(100.0, \"bara\");\nprocess.add(hpGas);\n\n// Stage 1: 100 -&gt; 50 bar\nThrottlingValve pv1 = new ThrottlingValve(\"PV-100\", hpGas);\npv1.setOutletPressure(50.0, \"bara\");\npv1.setCv(200.0, \"US\");\nprocess.add(pv1);\n\n// Heater (compensate JT cooling)\nHeater heater = new Heater(\"E-100\", pv1.getOutletStream());\nheater.setOutTemperature(40.0, \"C\");\nprocess.add(heater);\n\n// Stage 2: 50 -&gt; 10 bar\nThrottlingValve pv2 = new ThrottlingValve(\"PV-101\", heater.getOutletStream());\npv2.setOutletPressure(10.0, \"bara\");\npv2.setCv(300.0, \"US\");\nprocess.add(pv2);\n\nprocess.run();\n\n// JT effects\nSystem.out.println(\"After PV-100: \" + pv1.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"After E-100: \" + heater.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"After PV-101: \" + pv2.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\n</code></pre>"},{"location":"process/equipment/valves/#joule-thomson-coefficient","title":"Joule-Thomson Coefficient","text":"<p>For ideal gases, \\(\\mu_{JT} = 0\\). For real gases:</p> \\[\\mu_{JT} = \\left(\\frac{\\partial T}{\\partial P}\\right)_H = \\frac{1}{C_p}\\left[T\\left(\\frac{\\partial V}{\\partial T}\\right)_P - V\\right]\\] <pre><code>// Get JT coefficient\ndouble muJT = inletStream.getJouleThomsonCoefficient();  // K/bar\n</code></pre>"},{"location":"process/equipment/valves/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Separators - Separation equipment</li> <li>Safety Systems - Safety valve sizing</li> </ul>"},{"location":"process/equipment/wells/","title":"Well and Reservoir Equipment","text":"<p>Documentation for well and reservoir equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/wells/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Well Types</li> <li>IPR Curves</li> <li>Choke Modeling</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/wells/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.well</code></p> <p>Classes: - <code>SimpleWell</code> - Simple well model - <code>WellFlow</code> - Well flow calculations - <code>ChokeValve</code> - Wellhead choke</p> <p>Related: <code>neqsim.process.equipment.reservoir</code></p>"},{"location":"process/equipment/wells/#simplewell","title":"SimpleWell","text":""},{"location":"process/equipment/wells/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.well.SimpleWell;\n\n// Create reservoir fluid\nSystemInterface reservoirFluid = new SystemPrEos(373.15, 250.0);\nreservoirFluid.addComponent(\"methane\", 0.70);\nreservoirFluid.addComponent(\"ethane\", 0.10);\nreservoirFluid.addComponent(\"propane\", 0.05);\nreservoirFluid.addComponent(\"n-heptane\", 0.10);\nreservoirFluid.addComponent(\"water\", 0.05);\nreservoirFluid.setMixingRule(\"classic\");\n\n// Create well\nSimpleWell well = new SimpleWell(\"Producer 1\", reservoirFluid);\nwell.setWellheadPressure(50.0, \"bara\");\nwell.setFlowRate(10000.0, \"Sm3/day\");\nwell.run();\n\nStream wellheadStream = well.getOutletStream();\n</code></pre>"},{"location":"process/equipment/wells/#ipr-curves","title":"IPR Curves","text":""},{"location":"process/equipment/wells/#vogel-ipr-oil-wells","title":"Vogel IPR (Oil Wells)","text":"\\[q = q_{max} \\left[1 - 0.2\\frac{P_{wf}}{P_r} - 0.8\\left(\\frac{P_{wf}}{P_r}\\right)^2\\right]\\] <pre><code>well.setIPRModel(\"vogel\");\nwell.setReservoirPressure(300.0, \"bara\");\nwell.setMaxFlowRate(50000.0, \"Sm3/day\");\nwell.setWellheadPressure(50.0, \"bara\");\nwell.run();\n\ndouble flowRate = well.getFlowRate(\"Sm3/day\");\n</code></pre>"},{"location":"process/equipment/wells/#darcy-ipr-gas-wells","title":"Darcy IPR (Gas Wells)","text":"\\[q = \\frac{k \\cdot h \\cdot (P_r^2 - P_{wf}^2)}{1422 \\cdot T \\cdot \\mu \\cdot Z \\cdot \\ln(r_e/r_w)}\\] <pre><code>well.setIPRModel(\"darcy\");\nwell.setPermeability(100.0, \"mD\");\nwell.setPayThickness(50.0, \"m\");\nwell.setDrainageRadius(500.0, \"m\");\nwell.setWellboreRadius(0.1, \"m\");\n</code></pre>"},{"location":"process/equipment/wells/#backpressure-equation","title":"Backpressure Equation","text":"\\[q = C (P_r^2 - P_{wf}^2)^n\\] <pre><code>well.setIPRModel(\"backpressure\");\nwell.setBackpressureCoefficient(0.001);\nwell.setBackpressureExponent(0.85);\n</code></pre>"},{"location":"process/equipment/wells/#wellbore-hydraulics","title":"Wellbore Hydraulics","text":""},{"location":"process/equipment/wells/#vertical-lift-performance","title":"Vertical Lift Performance","text":"<pre><code>well.setWellDepth(3000.0, \"m\");\nwell.setTubingDiameter(0.1, \"m\");\nwell.setWallRoughness(0.00005, \"m\");\n\n// Correlation selection\nwell.setPressureDropCorrelation(\"beggs-brill\");\n// Options: \"beggs-brill\", \"hagedorn-brown\", \"duns-ros\", \"gray\"\n\nwell.run();\n\ndouble bottomholePressure = well.getBottomholePressure(\"bara\");\ndouble pressureDrop = well.getTubingPressureDrop(\"bar\");\n</code></pre>"},{"location":"process/equipment/wells/#temperature-profile","title":"Temperature Profile","text":"<pre><code>well.setReservoirTemperature(120.0, \"C\");\nwell.setSurfaceTemperature(30.0, \"C\");\nwell.setGeothermalGradient(0.03, \"C/m\");\n\nwell.run();\n\ndouble wellheadT = well.getWellheadTemperature(\"C\");\n</code></pre>"},{"location":"process/equipment/wells/#choke-modeling","title":"Choke Modeling","text":""},{"location":"process/equipment/wells/#wellhead-choke","title":"Wellhead Choke","text":"<pre><code>import neqsim.process.equipment.valve.ChokeValve;\n\nChokeValve choke = new ChokeValve(\"Wellhead Choke\", well.getOutletStream());\nchoke.setOutletPressure(30.0, \"bara\");\nchoke.run();\n\n// Or specify bean size\nchoke.setBeanSize(24, \"64ths\");  // 24/64\" choke\nchoke.run();\n\ndouble chokeDP = choke.getPressureDrop(\"bar\");\n</code></pre>"},{"location":"process/equipment/wells/#critical-flow","title":"Critical Flow","text":"<pre><code>boolean isCritical = choke.isCriticalFlow();\ndouble criticalRatio = choke.getCriticalPressureRatio();\n</code></pre>"},{"location":"process/equipment/wells/#nodal-analysis","title":"Nodal Analysis","text":"<p>Find operating point by intersecting IPR and VLP curves.</p> <pre><code>// IPR curve (reservoir deliverability)\ndouble[] Pwf_ipr = new double[20];\ndouble[] q_ipr = new double[20];\n\ndouble Pr = 300.0;  // Reservoir pressure, bar\ndouble qmax = 50000.0;  // Max rate, Sm3/day\n\nfor (int i = 0; i &lt; 20; i++) {\n    Pwf_ipr[i] = Pr * i / 20.0;\n    // Vogel equation\n    q_ipr[i] = qmax * (1 - 0.2 * (Pwf_ipr[i]/Pr) - 0.8 * Math.pow(Pwf_ipr[i]/Pr, 2));\n}\n\n// VLP curve (tubing performance)\ndouble[] Pwf_vlp = new double[20];\ndouble[] q_vlp = new double[20];\n\nfor (int i = 0; i &lt; 20; i++) {\n    q_vlp[i] = i * 3000.0;  // Flow rate\n    well.setFlowRate(q_vlp[i], \"Sm3/day\");\n    well.run();\n    Pwf_vlp[i] = well.getBottomholePressure(\"bara\");\n}\n\n// Find intersection (operating point)\n</code></pre>"},{"location":"process/equipment/wells/#gas-lift","title":"Gas Lift","text":"<pre><code>import neqsim.process.equipment.well.GasLiftWell;\n\nGasLiftWell glWell = new GasLiftWell(\"GL Producer\", reservoirFluid);\nglWell.setGasLiftRate(1.0, \"MMSm3/day\");\nglWell.setGasLiftDepth(2500.0, \"m\");\nglWell.run();\n\ndouble liftedRate = glWell.getOilRate(\"Sm3/day\");\n</code></pre>"},{"location":"process/equipment/wells/#esp-electrical-submersible-pump","title":"ESP (Electrical Submersible Pump)","text":"<pre><code>import neqsim.process.equipment.well.ESPWell;\n\nESPWell espWell = new ESPWell(\"ESP Producer\", reservoirFluid);\nespWell.setPumpDepth(2800.0, \"m\");\nespWell.setPumpDifferentialPressure(100.0, \"bar\");\nespWell.setPumpEfficiency(0.6);\nespWell.run();\n\ndouble pumpPower = espWell.getPumpPower(\"kW\");\ndouble liftedRate = espWell.getOilRate(\"Sm3/day\");\n</code></pre>"},{"location":"process/equipment/wells/#example-production-system","title":"Example: Production System","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Reservoir fluid\nSystemInterface oil = new SystemPrEos(380.0, 280.0);\noil.addComponent(\"methane\", 0.40);\noil.addComponent(\"ethane\", 0.08);\noil.addComponent(\"propane\", 0.06);\noil.addComponent(\"n-butane\", 0.04);\noil.addComponent(\"n-pentane\", 0.03);\noil.addComponent(\"n-heptane\", 0.15);\noil.addTBPfraction(\"C10+\", 0.20, 200.0/1000.0, 0.85);\noil.addComponent(\"water\", 0.04);\noil.setMixingRule(\"classic\");\n\n// Well 1\nSimpleWell well1 = new SimpleWell(\"P-1\", oil.clone());\nwell1.setReservoirPressure(280.0, \"bara\");\nwell1.setWellheadPressure(50.0, \"bara\");\nwell1.setFlowRate(3000.0, \"Sm3/day\");\nprocess.add(well1);\n\n// Choke 1\nChokeValve choke1 = new ChokeValve(\"XV-1\", well1.getOutletStream());\nchoke1.setOutletPressure(30.0, \"bara\");\nprocess.add(choke1);\n\n// Well 2\nSimpleWell well2 = new SimpleWell(\"P-2\", oil.clone());\nwell2.setReservoirPressure(260.0, \"bara\");\nwell2.setWellheadPressure(45.0, \"bara\");\nwell2.setFlowRate(2500.0, \"Sm3/day\");\nprocess.add(well2);\n\n// Choke 2\nChokeValve choke2 = new ChokeValve(\"XV-2\", well2.getOutletStream());\nchoke2.setOutletPressure(30.0, \"bara\");\nprocess.add(choke2);\n\n// Manifold\nMixer manifold = new Mixer(\"Production Manifold\");\nmanifold.addStream(choke1.getOutletStream());\nmanifold.addStream(choke2.getOutletStream());\nprocess.add(manifold);\n\n// First stage separator\nThreePhaseSeparator hpSep = new ThreePhaseSeparator(\"HP Separator\", \n    manifold.getOutletStream());\nprocess.add(hpSep);\n\nprocess.run();\n\n// Results\nSystem.out.println(\"Total oil rate: \" + hpSep.getOilOutStream().getFlowRate(\"Sm3/day\") + \" Sm3/day\");\nSystem.out.println(\"Total gas rate: \" + hpSep.getGasOutStream().getFlowRate(\"MSm3/day\") + \" MSm3/day\");\nSystem.out.println(\"Total water rate: \" + hpSep.getWaterOutStream().getFlowRate(\"m3/day\") + \" m3/day\");\n</code></pre>"},{"location":"process/equipment/wells/#gor-and-water-cut","title":"GOR and Water Cut","text":"<pre><code>// Gas-oil ratio\ndouble GOR = hpSep.getGasOutStream().getFlowRate(\"Sm3/day\") / \n    hpSep.getOilOutStream().getFlowRate(\"Sm3/day\");\n\n// Water cut\ndouble waterCut = hpSep.getWaterOutStream().getFlowRate(\"m3/day\") / \n    (hpSep.getOilOutStream().getFlowRate(\"m3/day\") + \n     hpSep.getWaterOutStream().getFlowRate(\"m3/day\"));\n\nSystem.out.println(\"GOR: \" + GOR + \" Sm3/Sm3\");\nSystem.out.println(\"Water cut: \" + (waterCut * 100) + \" %\");\n</code></pre>"},{"location":"process/equipment/wells/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Package overview</li> <li>Valves - Choke valve details</li> <li>Separators - Production separators</li> <li>Well Simulation Guide - Detailed well modeling</li> </ul>"},{"location":"process/equipment/util/","title":"Utility Equipment","text":"<p>This folder contains documentation for utility and control equipment in NeqSim.</p>"},{"location":"process/equipment/util/#equipment-categories","title":"Equipment Categories","text":""},{"location":"process/equipment/util/#process-control","title":"Process Control","text":"Equipment File Description Adjusters adjusters.md Parameter adjustment to meet specifications Recycles recycles.md Recycle stream handling Setters setters.md Variable setters Calculators calculators.md Custom calculations"},{"location":"process/equipment/util/#flow-control","title":"Flow Control","text":"Equipment File Description Set Points setpoints.md Process set points Flow Rate Adjusters flow_adjusters.md Flow rate control"},{"location":"process/equipment/util/#quick-reference","title":"Quick Reference","text":""},{"location":"process/equipment/util/#adjuster-pattern","title":"Adjuster Pattern","text":"<pre><code>Adjuster adjuster = new Adjuster(\"Controller\");\nadjuster.setAdjustedVariable(equipment, \"parameter\");\nadjuster.setTargetVariable(stream, \"property\", targetValue, unit);\nprocess.add(adjuster);\n</code></pre>"},{"location":"process/equipment/util/#recycle-pattern","title":"Recycle Pattern","text":"<pre><code>Recycle recycle = new Recycle(\"RecycleName\");\nrecycle.addStream(recycleStream);\nrecycle.setOutletStream(targetMixer);\nrecycle.setTolerance(1e-6);\nprocess.add(recycle);\n</code></pre>"},{"location":"process/equipment/util/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Controllers - Controller documentation</li> <li>Equipment Overview - All equipment</li> </ul>"},{"location":"process/equipment/util/adjusters/","title":"Adjusters","text":"<p>Documentation for adjuster equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/util/adjusters/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Adjuster Class</li> <li>Configuration</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/util/adjusters/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.util</code></p> <p>Class: <code>Adjuster</code></p> <p>Adjusters are iterative solvers that modify one process variable to achieve a target specification. They are essential for solving design problems where: - An output specification is known - The input parameter to achieve it must be found</p>"},{"location":"process/equipment/util/adjusters/#adjuster-class","title":"Adjuster Class","text":""},{"location":"process/equipment/util/adjusters/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Adjuster;\n\n// Create adjuster\nAdjuster adjuster = new Adjuster(\"Temperature Controller\");\n\n// Set the variable to adjust\nadjuster.setAdjustedVariable(heater, \"outTemperature\");\n\n// Set the target specification\nadjuster.setTargetVariable(stream, \"temperature\", 80.0, \"C\");\n\n// Add to process\nprocess.add(adjuster);\nprocess.run();\n\n// Get the adjusted value\ndouble adjustedTemp = heater.getOutTemperature(\"C\");\n</code></pre>"},{"location":"process/equipment/util/adjusters/#configuration","title":"Configuration","text":""},{"location":"process/equipment/util/adjusters/#adjusted-variables","title":"Adjusted Variables","text":"<p>The variable that the adjuster will modify:</p> Equipment Variable Description <code>Heater/Cooler</code> <code>\"duty\"</code> Heat duty (W) <code>Heater/Cooler</code> <code>\"outTemperature\"</code> Outlet temperature <code>Compressor</code> <code>\"outletPressure\"</code> Discharge pressure <code>Valve</code> <code>\"outletPressure\"</code> Outlet pressure <code>Valve</code> <code>\"percentValveOpening\"</code> Valve position <code>Splitter</code> <code>\"splitFactor\"</code> Split ratio <code>Stream</code> <code>\"flowRate\"</code> Flow rate <pre><code>// Examples\nadjuster.setAdjustedVariable(heater, \"duty\");\nadjuster.setAdjustedVariable(compressor, \"outletPressure\");\nadjuster.setAdjustedVariable(valve, \"percentValveOpening\");\nadjuster.setAdjustedVariable(splitter, \"splitFactor\", 0);  // First split\n</code></pre>"},{"location":"process/equipment/util/adjusters/#target-variables","title":"Target Variables","text":"<p>The specification to be achieved:</p> Equipment Variable Description <code>Stream</code> <code>\"temperature\"</code> Stream temperature <code>Stream</code> <code>\"pressure\"</code> Stream pressure <code>Stream</code> <code>\"flowRate\"</code> Stream flow rate <code>Stream</code> <code>\"moleFraction\"</code> Component mole fraction <code>Separator</code> <code>\"liquidLevel\"</code> Liquid level fraction Any Custom User-defined property <pre><code>// Examples\nadjuster.setTargetVariable(stream, \"temperature\", 80.0, \"C\");\nadjuster.setTargetVariable(separator, \"liquidLevel\", 0.5);\nadjuster.setTargetVariable(stream, \"moleFraction\", 0.02, \"CO2\");\n</code></pre>"},{"location":"process/equipment/util/adjusters/#solver-settings","title":"Solver Settings","text":"<pre><code>// Maximum iterations\nadjuster.setMaximumIterations(100);\n\n// Convergence tolerance\nadjuster.setTolerance(1e-6);\n\n// Bounds on adjusted variable\nadjuster.setMinimumValue(-1e7);  // Lower bound\nadjuster.setMaximumValue(1e7);   // Upper bound\n\n// Step size for numerical derivatives\nadjuster.setStepSize(0.001);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/util/adjusters/#temperature-control","title":"Temperature Control","text":"<pre><code>// Adjust heater duty to achieve target outlet temperature\nAdjuster tempControl = new Adjuster(\"TC-100\");\ntempControl.setAdjustedVariable(heater, \"duty\");\ntempControl.setTargetVariable(heater.getOutletStream(), \"temperature\", 100.0, \"C\");\nprocess.add(tempControl);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#dew-point-control","title":"Dew Point Control","text":"<pre><code>// Adjust cooler to achieve hydrocarbon dew point\nAdjuster dewPointControl = new Adjuster(\"HCDP Controller\");\ndewPointControl.setAdjustedVariable(cooler, \"outTemperature\");\ndewPointControl.setTargetPhaseCondition(stream, \"cricondenbar\", 50.0, \"bara\");\nprocess.add(dewPointControl);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#product-purity","title":"Product Purity","text":"<pre><code>// Adjust column reflux to achieve product purity\nAdjuster purityControl = new Adjuster(\"Purity Controller\");\npurityControl.setAdjustedVariable(column, \"refluxRatio\");\npurityControl.setTargetVariable(overhead, \"moleFraction\", 0.99, \"methane\");\nprocess.add(purityControl);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#separator-level-control","title":"Separator Level Control","text":"<pre><code>// Adjust outlet valve to maintain liquid level\nAdjuster levelControl = new Adjuster(\"LC-100\");\nlevelControl.setAdjustedVariable(outletValve, \"percentValveOpening\");\nlevelControl.setTargetVariable(separator, \"liquidLevel\", 0.5);\nprocess.add(levelControl);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#flow-split-optimization","title":"Flow Split Optimization","text":"<pre><code>// Adjust split ratio to achieve target flow in branch\nAdjuster flowControl = new Adjuster(\"FC-100\");\nflowControl.setAdjustedVariable(splitter, \"splitFactor\", 0);\nflowControl.setTargetVariable(branchStream, \"flowRate\", 5000.0, \"kg/hr\");\nprocess.add(flowControl);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#multiple-adjusters","title":"Multiple Adjusters","text":"<p>When using multiple adjusters, add them in order of priority:</p> <pre><code>// First adjuster (higher priority)\nAdjuster adj1 = new Adjuster(\"Primary\");\nadj1.setAdjustedVariable(heater, \"duty\");\nadj1.setTargetVariable(stream1, \"temperature\", 80.0, \"C\");\nprocess.add(adj1);\n\n// Second adjuster (solved after first converges)\nAdjuster adj2 = new Adjuster(\"Secondary\");\nadj2.setAdjustedVariable(cooler, \"duty\");\nadj2.setTargetVariable(stream2, \"temperature\", 30.0, \"C\");\nprocess.add(adj2);\n</code></pre>"},{"location":"process/equipment/util/adjusters/#troubleshooting","title":"Troubleshooting","text":""},{"location":"process/equipment/util/adjusters/#convergence-issues","title":"Convergence Issues","text":"<pre><code>// Increase iterations\nadjuster.setMaximumIterations(200);\n\n// Widen bounds\nadjuster.setMinimumValue(-1e8);\nadjuster.setMaximumValue(1e8);\n\n// Check if converged\nif (!adjuster.isConverged()) {\n    System.out.println(\"Adjuster did not converge\");\n    System.out.println(\"Current error: \" + adjuster.getError());\n}\n</code></pre>"},{"location":"process/equipment/util/adjusters/#infeasible-specifications","title":"Infeasible Specifications","text":"<p>Some specifications may be physically impossible: - Heating to above decomposition temperature - Cooling below freezing with liquid product - Pressure above equipment limits</p> <p>Check that specifications are achievable before troubleshooting solver settings.</p>"},{"location":"process/equipment/util/adjusters/#related-documentation","title":"Related Documentation","text":"<ul> <li>Recycles - Recycle handling</li> <li>Calculators - Custom calculations</li> <li>Process Controllers - PID and logic control</li> </ul>"},{"location":"process/equipment/util/calculators/","title":"Calculators and Setters","text":"<p>Documentation for calculator and setter equipment in NeqSim process simulation.</p>"},{"location":"process/equipment/util/calculators/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Calculator Class</li> <li>Setter Class</li> <li>Flow Setter</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/util/calculators/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.util</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Calculator</code> | Custom calculation unit | | <code>CalculatorLibrary</code> | Pre-built calculation functions | | <code>Setter</code> | Variable setter | | <code>FlowSetter</code> | Flow rate setter | | <code>MoleFractionControllerUtil</code> | Composition control |</p>"},{"location":"process/equipment/util/calculators/#calculator-class","title":"Calculator Class","text":"<p>Performs custom calculations based on process variables.</p>"},{"location":"process/equipment/util/calculators/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Calculator;\n\n// Create calculator\nCalculator calc = new Calculator(\"Duty Calculator\");\n\n// Add input variables\ncalc.addInputVariable(stream1);\ncalc.addInputVariable(stream2);\n\n// Set output variable\ncalc.setOutputVariable(heater, \"duty\");\n\n// Set calculation expression\ncalc.setExpression(\"(flow1 * cp1 + flow2 * cp2) * deltaT\");\n\n// Add to process\nprocess.add(calc);\n</code></pre>"},{"location":"process/equipment/util/calculators/#input-variables","title":"Input Variables","text":"<pre><code>// Add streams as inputs\ncalc.addInputVariable(stream, \"stream1\");\n\n// Add equipment properties\ncalc.addInputVariable(separator, \"pressure\", \"sepP\");\ncalc.addInputVariable(compressor, \"power\", \"compPower\");\n</code></pre>"},{"location":"process/equipment/util/calculators/#expressions","title":"Expressions","text":"<pre><code>// Mathematical expressions\ncalc.setExpression(\"flow * 1.1\");  // 10% margin\ncalc.setExpression(\"max(value1, value2)\");\ncalc.setExpression(\"sqrt(a^2 + b^2)\");\n\n// Conditional expressions\ncalc.setExpression(\"if(temp &gt; 100, duty1, duty2)\");\n</code></pre>"},{"location":"process/equipment/util/calculators/#calculator-library","title":"Calculator Library","text":"<p>Pre-built calculations for common tasks:</p> <pre><code>import neqsim.process.equipment.util.CalculatorLibrary;\n\n// Heat duty calculation\ndouble duty = CalculatorLibrary.calculateHeatDuty(stream, deltaT);\n\n// Compressor power\ndouble power = CalculatorLibrary.calculateCompressorPower(\n    flow, pressureRatio, efficiency);\n\n// Pressure drop\ndouble dp = CalculatorLibrary.calculatePressureDrop(\n    flow, diameter, length, roughness);\n</code></pre>"},{"location":"process/equipment/util/calculators/#setter-class","title":"Setter Class","text":"<p>Sets process variables to specific values.</p>"},{"location":"process/equipment/util/calculators/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Setter;\n\n// Create setter\nSetter setter = new Setter(\"Temperature Setter\");\n\n// Set target equipment and property\nsetter.setEquipment(heater);\nsetter.setProperty(\"outTemperature\");\nsetter.setValue(80.0);\nsetter.setUnit(\"C\");\n\n// Add to process\nprocess.add(setter);\n</code></pre>"},{"location":"process/equipment/util/calculators/#use-cases","title":"Use Cases","text":"<pre><code>// Set valve position\nSetter valveSetter = new Setter(\"Valve Opener\");\nvalveSetter.setEquipment(valve);\nvalveSetter.setProperty(\"percentValveOpening\");\nvalveSetter.setValue(75.0);\n\n// Set compressor speed\nSetter speedSetter = new Setter(\"Speed Setter\");\nspeedSetter.setEquipment(compressor);\nspeedSetter.setProperty(\"speed\");\nspeedSetter.setValue(5000.0);\n</code></pre>"},{"location":"process/equipment/util/calculators/#flow-setter","title":"Flow Setter","text":"<p>Specifically for setting flow rates.</p>"},{"location":"process/equipment/util/calculators/#basic-usage_2","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.FlowSetter;\n\n// Create flow setter\nFlowSetter flowSetter = new FlowSetter(\"Production Rate\", stream);\nflowSetter.setFlowRate(10000.0, \"kg/hr\");\n\n// Add to process\nprocess.add(flowSetter);\n</code></pre>"},{"location":"process/equipment/util/calculators/#with-ramping","title":"With Ramping","text":"<pre><code>// Ramp flow rate over time\nflowSetter.setRampRate(1000.0, \"kg/hr/min\");\nflowSetter.setTargetFlowRate(20000.0, \"kg/hr\");\n</code></pre>"},{"location":"process/equipment/util/calculators/#mole-fraction-controller","title":"Mole Fraction Controller","text":"<p>Control stream composition.</p>"},{"location":"process/equipment/util/calculators/#basic-usage_3","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.MoleFractionControllerUtil;\n\n// Control CO2 content\nMoleFractionControllerUtil co2Control = \n    new MoleFractionControllerUtil(\"CO2 Spec\", stream);\nco2Control.setTargetMoleFraction(\"CO2\", 0.02);  // 2 mol%\n\n// Add to process\nprocess.add(co2Control);\n</code></pre>"},{"location":"process/equipment/util/calculators/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/util/calculators/#production-optimizer","title":"Production Optimizer","text":"<pre><code>// Calculator to maximize production\nCalculator optimizer = new Calculator(\"Production Optimizer\");\noptimizer.addInputVariable(separator, \"pressure\");\noptimizer.addInputVariable(feedStream, \"flowRate\");\noptimizer.setOutputVariable(exportValve, \"percentValveOpening\");\noptimizer.setExpression(\"calculateOptimalOpening(pressure, flowRate)\");\nprocess.add(optimizer);\n</code></pre>"},{"location":"process/equipment/util/calculators/#cascade-control","title":"Cascade Control","text":"<pre><code>// Primary controller output sets secondary setpoint\nCalculator cascade = new Calculator(\"Cascade\");\ncascade.addInputVariable(temperatureController, \"output\");\ncascade.setOutputVariable(flowController, \"setpoint\");\ncascade.setExpression(\"output * flowGain + flowBias\");\nprocess.add(cascade);\n</code></pre>"},{"location":"process/equipment/util/calculators/#ratio-control","title":"Ratio Control","text":"<pre><code>// Maintain fuel/air ratio\nCalculator ratioCalc = new Calculator(\"F/A Ratio\");\nratioCalc.addInputVariable(fuelStream, \"flowRate\");\nratioCalc.setOutputVariable(airDamper, \"position\");\nratioCalc.setExpression(\"fuelFlow * stoichRatio * excessAir\");\nprocess.add(ratioCalc);\n</code></pre>"},{"location":"process/equipment/util/calculators/#duty-calculation","title":"Duty Calculation","text":"<pre><code>// Calculate required cooling duty\nCalculator dutyCalc = new Calculator(\"Cooling Duty\");\ndutyCalc.addInputVariable(inletStream, \"temperature\");\ndutyCalc.addInputVariable(inletStream, \"flowRate\");\ndutyCalc.addInputVariable(inletStream, \"heatCapacity\");\ndutyCalc.setOutputVariable(cooler, \"duty\");\ndutyCalc.setExpression(\"-flowRate * heatCapacity * (targetTemp - inletTemp)\");\nprocess.add(dutyCalc);\n</code></pre>"},{"location":"process/equipment/util/calculators/#set-point-class","title":"Set Point Class","text":"<p>Stores and manages process set points.</p> <pre><code>import neqsim.process.equipment.util.SetPoint;\n\n// Create set point\nSetPoint tempSP = new SetPoint(\"Temperature SP\");\ntempSP.setValue(80.0);\ntempSP.setUnit(\"C\");\ntempSP.setHighLimit(120.0);\ntempSP.setLowLimit(40.0);\n\n// Use in adjuster\nadjuster.setTargetValue(tempSP);\n</code></pre>"},{"location":"process/equipment/util/calculators/#stream-transition","title":"Stream Transition","text":"<p>Smooth transition between operating states.</p> <pre><code>import neqsim.process.equipment.util.StreamTransition;\n\n// Create transition\nStreamTransition transition = new StreamTransition(\"Startup Ramp\");\ntransition.setStream(feedStream);\ntransition.setInitialFlowRate(0.0, \"kg/hr\");\ntransition.setFinalFlowRate(10000.0, \"kg/hr\");\ntransition.setTransitionTime(3600.0);  // 1 hour ramp\n\n// Run transition\nfor (double t = 0; t &lt; 3600; t += 60) {\n    transition.setTime(t);\n    process.run();\n}\n</code></pre>"},{"location":"process/equipment/util/calculators/#related-documentation","title":"Related Documentation","text":"<ul> <li>Adjusters - Iterative adjustment</li> <li>Recycles - Recycle handling</li> <li>Process Controllers - Control systems</li> </ul>"},{"location":"process/equipment/util/recycles/","title":"Recycles","text":"<p>Documentation for recycle handling in NeqSim process simulation.</p>"},{"location":"process/equipment/util/recycles/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Recycle Class</li> <li>Convergence</li> <li>Acceleration Methods</li> <li>Usage Examples</li> </ul>"},{"location":"process/equipment/util/recycles/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.util</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>Recycle</code> | Main recycle handler | | <code>RecycleController</code> | Advanced recycle control | | <code>AccelerationMethod</code> | Convergence acceleration | | <code>BroydenAccelerator</code> | Broyden's method acceleration |</p> <p>Recycles handle iterative loops in process flowsheets where a downstream stream feeds back into an upstream unit. Common examples: - Solvent recycle in absorption - Reactor recycle for conversion - Distillation reflux - Heat integration loops</p>"},{"location":"process/equipment/util/recycles/#recycle-class","title":"Recycle Class","text":""},{"location":"process/equipment/util/recycles/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.util.Recycle;\n\n// Create recycle\nRecycle recycle = new Recycle(\"Solvent Recycle\");\n\n// Add the stream coming from downstream\nrecycle.addStream(returnStream);\n\n// Set where the recycle feeds into\nrecycle.setOutletStream(feedMixer);\n\n// Add to process\nprocess.add(recycle);\nprocess.run();\n</code></pre>"},{"location":"process/equipment/util/recycles/#how-recycles-work","title":"How Recycles Work","text":"<ol> <li>Initial Estimate: Process runs with assumed recycle composition</li> <li>Calculate Downstream: Equipment processes the estimate</li> <li>Update Recycle: New recycle stream values are calculated</li> <li>Iterate: Repeat until convergence</li> </ol>"},{"location":"process/equipment/util/recycles/#configuration","title":"Configuration","text":""},{"location":"process/equipment/util/recycles/#tolerance","title":"Tolerance","text":"<pre><code>// Set convergence tolerance\nrecycle.setTolerance(1e-6);\n\n// Separate tolerances for flow and composition\nrecycle.setFlowTolerance(1e-4);\nrecycle.setCompositionTolerance(1e-6);\nrecycle.setTemperatureTolerance(0.1);  // K\nrecycle.setPressureTolerance(0.01);    // bar\n</code></pre>"},{"location":"process/equipment/util/recycles/#maximum-iterations","title":"Maximum Iterations","text":"<pre><code>// Limit iterations\nrecycle.setMaximumIterations(50);\n</code></pre>"},{"location":"process/equipment/util/recycles/#damping","title":"Damping","text":"<p>Damping helps prevent oscillation:</p> <pre><code>// Set damping factor (0-1, lower = more damping)\nrecycle.setDampingFactor(0.5);  // 50% of new value, 50% of old\n</code></pre>"},{"location":"process/equipment/util/recycles/#acceleration-methods","title":"Acceleration Methods","text":"<p>For faster convergence, acceleration methods can be used:</p>"},{"location":"process/equipment/util/recycles/#wegstein-acceleration","title":"Wegstein Acceleration","text":"<pre><code>recycle.setAccelerationMethod(\"wegstein\");\n</code></pre>"},{"location":"process/equipment/util/recycles/#broyden-acceleration","title":"Broyden Acceleration","text":"<pre><code>import neqsim.process.equipment.util.BroydenAccelerator;\n\nBroydenAccelerator accelerator = new BroydenAccelerator();\nrecycle.setAccelerationMethod(accelerator);\n</code></pre>"},{"location":"process/equipment/util/recycles/#direct-substitution","title":"Direct Substitution","text":"<p>Simple successive substitution (default):</p> <pre><code>recycle.setAccelerationMethod(\"direct\");\n</code></pre>"},{"location":"process/equipment/util/recycles/#usage-examples","title":"Usage Examples","text":""},{"location":"process/equipment/util/recycles/#simple-solvent-recycle","title":"Simple Solvent Recycle","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Feed stream\nStream feed = new Stream(\"Feed\", feedFluid);\nprocess.add(feed);\n\n// Mixer for feed and recycle\nMixer mixer = new Mixer(\"Feed Mixer\");\nmixer.addStream(feed);\nprocess.add(mixer);\n\n// Process unit (e.g., absorber)\nAbsorber absorber = new Absorber(\"TEG Contactor\", mixer.getOutletStream());\nprocess.add(absorber);\n\n// Regeneration\nHeater regenerator = new Heater(\"TEG Regenerator\", absorber.getLiquidOutStream());\nregenerator.setOutTemperature(200.0, \"C\");\nprocess.add(regenerator);\n\n// Cooler\nCooler cooler = new Cooler(\"TEG Cooler\", regenerator.getOutletStream());\ncooler.setOutTemperature(40.0, \"C\");\nprocess.add(cooler);\n\n// Recycle lean solvent back to mixer\nRecycle solventRecycle = new Recycle(\"TEG Recycle\");\nsolventRecycle.addStream(cooler.getOutletStream());\nsolventRecycle.setOutletStream(mixer);\nsolventRecycle.setTolerance(1e-5);\nprocess.add(solventRecycle);\n\n// Connect mixer to absorber with recycle\nmixer.addStream(solventRecycle.getOutletStream());\n\n// Run\nprocess.run();\n\n// Check convergence\nif (solventRecycle.isConverged()) {\n    System.out.println(\"Recycle converged in \" + \n        solventRecycle.getIterations() + \" iterations\");\n}\n</code></pre>"},{"location":"process/equipment/util/recycles/#reactor-recycle","title":"Reactor Recycle","text":"<pre><code>// Fresh feed\nStream freshFeed = new Stream(\"Fresh Feed\", freshFeedFluid);\nprocess.add(freshFeed);\n\n// Mix fresh feed with recycle\nMixer reactorFeed = new Mixer(\"Reactor Feed\");\nreactorFeed.addStream(freshFeed);\nprocess.add(reactorFeed);\n\n// Reactor\nGibbsReactor reactor = new GibbsReactor(\"Synthesis Reactor\");\nreactor.setInletStream(reactorFeed.getOutletStream());\nprocess.add(reactor);\n\n// Separator\nSeparator productSep = new Separator(\"Product Separator\", reactor.getOutletStream());\nprocess.add(productSep);\n\n// Recycle unreacted gas\nRecycle gasRecycle = new Recycle(\"Unreacted Gas Recycle\");\ngasRecycle.addStream(productSep.getGasOutStream());\ngasRecycle.setOutletStream(reactorFeed);\ngasRecycle.setTolerance(1e-5);\ngasRecycle.setDampingFactor(0.7);\nprocess.add(gasRecycle);\n\nreactorFeed.addStream(gasRecycle.getOutletStream());\n\nprocess.run();\n</code></pre>"},{"location":"process/equipment/util/recycles/#nested-recycles","title":"Nested Recycles","text":"<p>For processes with multiple recycle loops:</p> <pre><code>// Outer recycle (converges first)\nRecycle outerRecycle = new Recycle(\"Outer Recycle\");\nouterRecycle.addStream(outerStream);\nouterRecycle.setOutletStream(outerMixer);\nouterRecycle.setPriority(1);  // Lower priority converges first\nprocess.add(outerRecycle);\n\n// Inner recycle (converges second)\nRecycle innerRecycle = new Recycle(\"Inner Recycle\");\ninnerRecycle.addStream(innerStream);\ninnerRecycle.setOutletStream(innerMixer);\ninnerRecycle.setPriority(2);  // Higher priority\nprocess.add(innerRecycle);\n</code></pre>"},{"location":"process/equipment/util/recycles/#convergence-monitoring","title":"Convergence Monitoring","text":""},{"location":"process/equipment/util/recycles/#check-status","title":"Check Status","text":"<pre><code>// Check if converged\nboolean converged = recycle.isConverged();\n\n// Get number of iterations\nint iterations = recycle.getIterations();\n\n// Get current error\ndouble error = recycle.getError();\n\nSystem.out.println(\"Recycle status:\");\nSystem.out.println(\"  Converged: \" + converged);\nSystem.out.println(\"  Iterations: \" + iterations);\nSystem.out.println(\"  Error: \" + error);\n</code></pre>"},{"location":"process/equipment/util/recycles/#convergence-history","title":"Convergence History","text":"<pre><code>// Get convergence history for debugging\ndouble[] errorHistory = recycle.getErrorHistory();\nfor (int i = 0; i &lt; errorHistory.length; i++) {\n    System.out.println(\"Iteration \" + i + \": error = \" + errorHistory[i]);\n}\n</code></pre>"},{"location":"process/equipment/util/recycles/#troubleshooting","title":"Troubleshooting","text":""},{"location":"process/equipment/util/recycles/#slow-convergence","title":"Slow Convergence","text":"<ol> <li>Reduce damping factor</li> <li>Use acceleration method</li> <li>Check for conflicting specifications</li> <li>Improve initial estimate</li> </ol> <pre><code>// Try Wegstein acceleration\nrecycle.setAccelerationMethod(\"wegstein\");\nrecycle.setDampingFactor(0.8);\n</code></pre>"},{"location":"process/equipment/util/recycles/#oscillation","title":"Oscillation","text":"<ol> <li>Increase damping</li> <li>Reduce step size</li> <li>Check for multiple solutions</li> </ol> <pre><code>// Heavy damping for oscillating systems\nrecycle.setDampingFactor(0.3);\nrecycle.setMaximumIterations(100);\n</code></pre>"},{"location":"process/equipment/util/recycles/#non-convergence","title":"Non-Convergence","text":"<ol> <li>Check physical feasibility</li> <li>Verify mass balance closure</li> <li>Start with simpler configuration</li> <li>Check stream specifications</li> </ol> <pre><code>// Debug mode\nrecycle.setVerbose(true);\nprocess.run();\n</code></pre>"},{"location":"process/equipment/util/recycles/#best-practices","title":"Best Practices","text":"<ol> <li>Tear Stream Selection: Choose streams with least impact on downstream</li> <li>Good Initial Estimate: Provide reasonable starting values</li> <li>Appropriate Tolerance: Balance accuracy vs. computation time</li> <li>Monitor Convergence: Check iteration count and error trends</li> <li>Sequential Solution: For nested loops, converge inner loops first</li> </ol>"},{"location":"process/equipment/util/recycles/#related-documentation","title":"Related Documentation","text":"<ul> <li>Adjusters - Variable adjustment</li> <li>Calculators - Custom calculations</li> <li>Process System - Process execution</li> </ul>"},{"location":"process/processmodel/","title":"Process System and Flowsheet Management","text":"<p>This folder contains documentation for process system and flowsheet management in NeqSim.</p>"},{"location":"process/processmodel/#contents","title":"Contents","text":"Document Description ProcessSystem Main process system class ProcessModule Modular process units Graph-Based Simulation Graph-based execution"},{"location":"process/processmodel/#overview","title":"Overview","text":"<p>The <code>processmodel</code> package provides the framework for building and executing process simulations:</p> <ul> <li>ProcessSystem: Container for process equipment and execution engine</li> <li>ProcessModule: Encapsulated process modules for reuse</li> <li>ProcessGraph: Graph-based execution for complex flowsheets</li> </ul>"},{"location":"process/processmodel/#quick-start","title":"Quick Start","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.separator.Separator;\n\n// Create process system\nProcessSystem process = new ProcessSystem();\n\n// Add equipment\nprocess.add(feedStream);\nprocess.add(separator);\nprocess.add(compressor);\n\n// Run simulation\nprocess.run();\n\n// Get results\nprocess.display();\n</code></pre>"},{"location":"process/processmodel/#related-documentation","title":"Related Documentation","text":"<ul> <li>Equipment Overview - Process equipment</li> <li>Controllers - Control systems</li> <li>Safety Systems - Safety equipment</li> </ul>"},{"location":"process/processmodel/graph_simulation/","title":"Graph-Based Process Simulation","text":"<p>Documentation for graph-based execution in NeqSim.</p>"},{"location":"process/processmodel/graph_simulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>ProcessGraph Class</li> <li>Graph Construction</li> <li>Execution Strategies</li> <li>Usage Examples</li> </ul>"},{"location":"process/processmodel/graph_simulation/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.processmodel.graph</code></p> <p>Classes: | Class | Description | |-------|-------------| | <code>ProcessGraph</code> | Graph representation of process | | <code>ProcessGraphBuilder</code> | Builder for constructing graphs |</p> <p>Graph-based simulation represents the process as a directed graph where: - Nodes represent equipment - Edges represent stream connections - Execution follows topological order</p> <p>Benefits: - Automatic dependency resolution - Parallel execution of independent units - Better handling of complex flowsheets - Visual representation of process structure</p>"},{"location":"process/processmodel/graph_simulation/#processgraph-class","title":"ProcessGraph Class","text":""},{"location":"process/processmodel/graph_simulation/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.processmodel.graph.ProcessGraph;\nimport neqsim.process.processmodel.graph.ProcessGraphBuilder;\n\n// Build graph from process\nProcessGraphBuilder builder = new ProcessGraphBuilder();\nProcessGraph graph = builder.build(processSystem);\n\n// Execute in topological order\ngraph.execute();\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#graph-properties","title":"Graph Properties","text":"<pre><code>// Get number of nodes (equipment)\nint nodeCount = graph.getNodeCount();\n\n// Get number of edges (connections)\nint edgeCount = graph.getEdgeCount();\n\n// Check for cycles (recycles)\nboolean hasCycles = graph.hasCycles();\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#graph-construction","title":"Graph Construction","text":""},{"location":"process/processmodel/graph_simulation/#automatic-construction","title":"Automatic Construction","text":"<pre><code>// Build from existing process\nProcessGraphBuilder builder = new ProcessGraphBuilder();\nProcessGraph graph = builder.build(process);\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#manual-construction","title":"Manual Construction","text":"<pre><code>ProcessGraph graph = new ProcessGraph();\n\n// Add nodes\ngraph.addNode(feed);\ngraph.addNode(heater);\ngraph.addNode(separator);\n\n// Add edges (connections)\ngraph.addEdge(feed, heater);\ngraph.addEdge(heater, separator);\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#with-metadata","title":"With Metadata","text":"<pre><code>// Add node with properties\ngraph.addNode(compressor, Map.of(\n    \"criticality\", \"high\",\n    \"maintainPriority\", 1\n));\n\n// Add edge with properties\ngraph.addEdge(stream1, mixer, Map.of(\n    \"streamType\", \"recycle\",\n    \"flowDirection\", \"forward\"\n));\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#execution-strategies","title":"Execution Strategies","text":""},{"location":"process/processmodel/graph_simulation/#sequential-execution","title":"Sequential Execution","text":"<p>Default topological ordering:</p> <pre><code>graph.setExecutionStrategy(ExecutionStrategy.SEQUENTIAL);\ngraph.execute();\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#parallel-execution","title":"Parallel Execution","text":"<p>Execute independent nodes in parallel:</p> <pre><code>graph.setExecutionStrategy(ExecutionStrategy.PARALLEL);\ngraph.setNumberOfThreads(4);\ngraph.execute();\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#level-based-execution","title":"Level-Based Execution","text":"<p>Execute by levels (all nodes at same depth together):</p> <pre><code>graph.setExecutionStrategy(ExecutionStrategy.LEVEL_BASED);\ngraph.execute();\n\n// Get execution levels\nList&lt;List&lt;ProcessEquipmentInterface&gt;&gt; levels = graph.getExecutionLevels();\nfor (int i = 0; i &lt; levels.size(); i++) {\n    System.out.println(\"Level \" + i + \": \" + \n        levels.get(i).stream().map(e -&gt; e.getName()).collect(Collectors.toList()));\n}\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#graph-analysis","title":"Graph Analysis","text":""},{"location":"process/processmodel/graph_simulation/#topological-sort","title":"Topological Sort","text":"<pre><code>// Get execution order\nList&lt;ProcessEquipmentInterface&gt; order = graph.topologicalSort();\n\nfor (int i = 0; i &lt; order.size(); i++) {\n    System.out.println((i+1) + \". \" + order.get(i).getName());\n}\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#find-cycles","title":"Find Cycles","text":"<pre><code>// Identify recycle loops\nList&lt;List&lt;ProcessEquipmentInterface&gt;&gt; cycles = graph.findCycles();\n\nfor (List&lt;ProcessEquipmentInterface&gt; cycle : cycles) {\n    System.out.println(\"Cycle found:\");\n    for (ProcessEquipmentInterface node : cycle) {\n        System.out.println(\"  - \" + node.getName());\n    }\n}\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#critical-path","title":"Critical Path","text":"<pre><code>// Find longest path (critical path)\nList&lt;ProcessEquipmentInterface&gt; criticalPath = graph.findCriticalPath();\n\nSystem.out.println(\"Critical path:\");\nfor (ProcessEquipmentInterface node : criticalPath) {\n    System.out.println(\"  \" + node.getName());\n}\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#visualization","title":"Visualization","text":""},{"location":"process/processmodel/graph_simulation/#export-to-dot-format","title":"Export to DOT Format","text":"<pre><code>// Export for Graphviz visualization\nString dot = graph.toDOT();\nFiles.writeString(Path.of(\"process_graph.dot\"), dot);\n\n// Generate image with Graphviz:\n// dot -Tpng process_graph.dot -o process_graph.png\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#export-to-json","title":"Export to JSON","text":"<pre><code>// Export graph structure to JSON\nString json = graph.toJSON();\nFiles.writeString(Path.of(\"process_graph.json\"), json);\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#usage-examples","title":"Usage Examples","text":""},{"location":"process/processmodel/graph_simulation/#parallel-compression-train","title":"Parallel Compression Train","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Feed splitter\nSplitter splitter = new Splitter(\"Feed Splitter\", feedStream);\nsplitter.setSplitRatios(new double[]{0.5, 0.5});\nprocess.add(splitter);\n\n// Parallel compressor trains (can execute simultaneously)\nCompressor comp1 = new Compressor(\"K-101\", splitter.getOutletStream(0));\ncomp1.setOutletPressure(80.0, \"bara\");\nprocess.add(comp1);\n\nCompressor comp2 = new Compressor(\"K-102\", splitter.getOutletStream(1));\ncomp2.setOutletPressure(80.0, \"bara\");\nprocess.add(comp2);\n\n// Merger\nMixer mixer = new Mixer(\"Discharge Mixer\");\nmixer.addStream(comp1.getOutletStream());\nmixer.addStream(comp2.getOutletStream());\nprocess.add(mixer);\n\n// Build graph\nProcessGraph graph = new ProcessGraphBuilder().build(process);\n\n// Parallel execution - K-101 and K-102 run simultaneously\ngraph.setExecutionStrategy(ExecutionStrategy.PARALLEL);\ngraph.execute();\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#complex-flowsheet-analysis","title":"Complex Flowsheet Analysis","text":"<pre><code>// Build graph from complex process\nProcessGraph graph = new ProcessGraphBuilder().build(process);\n\n// Analyze structure\nSystem.out.println(\"Process structure:\");\nSystem.out.println(\"  Equipment count: \" + graph.getNodeCount());\nSystem.out.println(\"  Connections: \" + graph.getEdgeCount());\nSystem.out.println(\"  Has recycles: \" + graph.hasCycles());\n\n// Identify independent sections\nList&lt;Set&lt;ProcessEquipmentInterface&gt;&gt; sections = graph.findConnectedComponents();\nSystem.out.println(\"  Independent sections: \" + sections.size());\n\n// Find potential bottlenecks (high in-degree)\nfor (ProcessEquipmentInterface node : graph.getNodes()) {\n    int inDegree = graph.getInDegree(node);\n    if (inDegree &gt; 2) {\n        System.out.println(\"  Potential bottleneck: \" + node.getName() + \n            \" (\" + inDegree + \" inputs)\");\n    }\n}\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#recycle-identification","title":"Recycle Identification","text":"<pre><code>ProcessGraph graph = new ProcessGraphBuilder().build(process);\n\n// Find all recycle streams\nList&lt;List&lt;ProcessEquipmentInterface&gt;&gt; cycles = graph.findCycles();\n\nSystem.out.println(\"Recycle loops identified:\");\nfor (int i = 0; i &lt; cycles.size(); i++) {\n    System.out.println(\"Recycle \" + (i+1) + \":\");\n    List&lt;ProcessEquipmentInterface&gt; cycle = cycles.get(i);\n    for (ProcessEquipmentInterface node : cycle) {\n        System.out.println(\"  -&gt; \" + node.getName());\n    }\n\n    // Suggest tear stream (node with lowest \"impact\")\n    ProcessEquipmentInterface tearStream = graph.suggestTearStream(cycle);\n    System.out.println(\"  Suggested tear stream: \" + tearStream.getName());\n}\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#performance-optimization","title":"Performance Optimization","text":""},{"location":"process/processmodel/graph_simulation/#identify-parallel-opportunities","title":"Identify Parallel Opportunities","text":"<pre><code>// Get execution levels\nList&lt;List&lt;ProcessEquipmentInterface&gt;&gt; levels = graph.getExecutionLevels();\n\n// Count parallel opportunities\nint parallelOps = 0;\nfor (List&lt;ProcessEquipmentInterface&gt; level : levels) {\n    if (level.size() &gt; 1) {\n        parallelOps += level.size() - 1;\n    }\n}\n\nSystem.out.println(\"Parallel execution opportunities: \" + parallelOps);\nSystem.out.println(\"Potential speedup: \" + \n    (double)graph.getNodeCount() / levels.size() + \"x\");\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#subgraph-extraction","title":"Subgraph Extraction","text":"<pre><code>// Extract subgraph for specific section\nSet&lt;ProcessEquipmentInterface&gt; compressionUnits = process.getUnitsOfType(\n    CompressorInterface.class).stream().collect(Collectors.toSet());\n\nProcessGraph compressionGraph = graph.extractSubgraph(compressionUnits);\n\n// Analyze compression section separately\ncompressionGraph.execute();\n</code></pre>"},{"location":"process/processmodel/graph_simulation/#related-documentation","title":"Related Documentation","text":"<ul> <li>ProcessSystem - Process system management</li> <li>ProcessModule - Modular process units</li> <li>Parallel Simulation - Parallel execution guide</li> </ul>"},{"location":"process/processmodel/process_module/","title":"ProcessModule Class","text":"<p>Documentation for modular process units in NeqSim.</p>"},{"location":"process/processmodel/process_module/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Creating Modules</li> <li>Module Interface</li> <li>Built-in Modules</li> <li>Custom Modules</li> <li>Usage Examples</li> </ul>"},{"location":"process/processmodel/process_module/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.processmodel.ProcessModule</code></p> <p>Process modules encapsulate complex process subsystems into reusable units. Benefits include: - Reusability across different simulations - Simplified flowsheet construction - Better organization of large processes - Easier maintenance and testing</p>"},{"location":"process/processmodel/process_module/#creating-modules","title":"Creating Modules","text":""},{"location":"process/processmodel/process_module/#basic-module","title":"Basic Module","text":"<pre><code>import neqsim.process.processmodel.ProcessModule;\n\n// Create module\nProcessModule module = new ProcessModule(\"Compression Train\");\n\n// Add equipment to module\nmodule.add(scrubber);\nmodule.add(compressor);\nmodule.add(cooler);\n\n// Set inlet/outlet\nmodule.setInletStream(gasIn);\nmodule.setOutletStream(cooler.getOutletStream());\n</code></pre>"},{"location":"process/processmodel/process_module/#adding-to-process","title":"Adding to Process","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Add module to process\nprocess.addModule(module);\n\n// Connect to other equipment\nmodule.setInletStream(feedStream);\nStream compressed = module.getOutletStream();\nprocess.add(downstream equipment);\n</code></pre>"},{"location":"process/processmodel/process_module/#module-interface","title":"Module Interface","text":""},{"location":"process/processmodel/process_module/#moduleinterface-methods","title":"ModuleInterface Methods","text":"<pre><code>public interface ModuleInterface {\n    // Identification\n    String getName();\n    void setName(String name);\n\n    // Streams\n    void setInletStream(StreamInterface stream);\n    StreamInterface getInletStream();\n    StreamInterface getOutletStream();\n\n    // Execution\n    void run();\n    void runTransient(double dt);\n\n    // Initialization\n    void initializeModule();\n\n    // Equipment access\n    ProcessEquipmentInterface getUnit(String name);\n    List&lt;ProcessEquipmentInterface&gt; getUnits();\n}\n</code></pre>"},{"location":"process/processmodel/process_module/#built-in-modules","title":"Built-in Modules","text":""},{"location":"process/processmodel/process_module/#compressor-train-module","title":"Compressor Train Module","text":"<pre><code>// Multi-stage compression with intercooling\nCompressorTrainModule compTrain = new CompressorTrainModule(\"HP Compression\");\ncompTrain.setNumberOfStages(3);\ncompTrain.setOutletPressure(150.0, \"bara\");\ncompTrain.setIntercoolerTemperature(40.0, \"C\");\ncompTrain.setIsentropicEfficiency(0.78);\n\ncompTrain.setInletStream(feedGas);\nprocess.addModule(compTrain);\n</code></pre>"},{"location":"process/processmodel/process_module/#separation-train-module","title":"Separation Train Module","text":"<pre><code>// Multi-stage separation\nSeparationTrainModule sepTrain = new SeparationTrainModule(\"Separation\");\nsepTrain.addStage(50.0, \"bara\");  // HP stage\nsepTrain.addStage(15.0, \"bara\");  // MP stage\nsepTrain.addStage(3.0, \"bara\");   // LP stage\n\nsepTrain.setInletStream(wellFluid);\nprocess.addModule(sepTrain);\n\n// Get products\nStream exportGas = sepTrain.getGasOutStream();\nStream exportOil = sepTrain.getOilOutStream();\nStream prodWater = sepTrain.getWaterOutStream();\n</code></pre>"},{"location":"process/processmodel/process_module/#dehydration-module","title":"Dehydration Module","text":"<pre><code>// TEG dehydration unit\nDehydrationModule dehy = new DehydrationModule(\"Gas Dehy\");\ndehy.setWaterDewPoint(-20.0, \"C\");\ndehy.setSolventType(\"TEG\");\n\ndehy.setInletStream(wetGas);\nprocess.addModule(dehy);\n\nStream dryGas = dehy.getOutletStream();\n</code></pre>"},{"location":"process/processmodel/process_module/#custom-modules","title":"Custom Modules","text":""},{"location":"process/processmodel/process_module/#creating-custom-module","title":"Creating Custom Module","text":"<pre><code>public class MyCustomModule extends ProcessModule {\n\n    private Separator inlet Scrubber;\n    private HeatExchanger heatEx;\n    private Compressor compressor;\n\n    public MyCustomModule(String name) {\n        super(name);\n        initializeEquipment();\n    }\n\n    private void initializeEquipment() {\n        inletScrubber = new Separator(\"Inlet Scrubber\");\n        add(inletScrubber);\n\n        heatEx = new HeatExchanger(\"Feed/Effluent HX\");\n        add(heatEx);\n\n        compressor = new Compressor(\"Main Compressor\");\n        add(compressor);\n    }\n\n    @Override\n    public void setInletStream(StreamInterface stream) {\n        super.setInletStream(stream);\n        inletScrubber.setInletStream(stream);\n    }\n\n    @Override\n    public StreamInterface getOutletStream() {\n        return compressor.getOutletStream();\n    }\n\n    public void setOutletPressure(double pressure, String unit) {\n        compressor.setOutletPressure(pressure, unit);\n    }\n}\n</code></pre>"},{"location":"process/processmodel/process_module/#using-custom-module","title":"Using Custom Module","text":"<pre><code>MyCustomModule customModule = new MyCustomModule(\"My Unit\");\ncustomModule.setInletStream(feed);\ncustomModule.setOutletPressure(80.0, \"bara\");\n\nprocess.addModule(customModule);\nprocess.run();\n</code></pre>"},{"location":"process/processmodel/process_module/#module-communication","title":"Module Communication","text":""},{"location":"process/processmodel/process_module/#multiple-inlets","title":"Multiple Inlets","text":"<pre><code>public class TwoInletModule extends ProcessModule {\n    private Mixer inletMixer;\n\n    public void setInletStream1(StreamInterface stream) {\n        inletMixer.addStream(stream);\n    }\n\n    public void setInletStream2(StreamInterface stream) {\n        inletMixer.addStream(stream);\n    }\n}\n</code></pre>"},{"location":"process/processmodel/process_module/#multiple-outlets","title":"Multiple Outlets","text":"<pre><code>public class TwoOutletModule extends ProcessModule {\n    private Splitter outletSplitter;\n\n    public StreamInterface getOutletStream1() {\n        return outletSplitter.getOutletStream(0);\n    }\n\n    public StreamInterface getOutletStream2() {\n        return outletSplitter.getOutletStream(1);\n    }\n}\n</code></pre>"},{"location":"process/processmodel/process_module/#usage-examples","title":"Usage Examples","text":""},{"location":"process/processmodel/process_module/#lng-train-module","title":"LNG Train Module","text":"<pre><code>public class LNGTrainModule extends ProcessModule {\n\n    private Cooler precooler;\n    private HeatExchanger mainCryoExchanger;\n    private Expander jt Expander;\n    private Separator lngSeparator;\n\n    public LNGTrainModule(String name) {\n        super(name);\n\n        precooler = new Cooler(\"Precooler\");\n        add(precooler);\n\n        mainCryoExchanger = new HeatExchanger(\"MCHE\");\n        add(mainCryoExchanger);\n\n        jtExpander = new Expander(\"JT Expander\");\n        add(jtExpander);\n\n        lngSeparator = new Separator(\"LNG Separator\");\n        add(lngSeparator);\n    }\n\n    @Override\n    public void setInletStream(StreamInterface stream) {\n        super.setInletStream(stream);\n        precooler.setInletStream(stream);\n    }\n\n    public void setLNGTemperature(double temp, String unit) {\n        // Configure for target LNG temperature\n    }\n\n    public StreamInterface getLNGStream() {\n        return lngSeparator.getLiquidOutStream();\n    }\n\n    public StreamInterface getBoilOffGas() {\n        return lngSeparator.getGasOutStream();\n    }\n}\n\n// Usage\nLNGTrainModule lngTrain = new LNGTrainModule(\"LNG Production\");\nlngTrain.setInletStream(treatedGas);\nlngTrain.setLNGTemperature(-162.0, \"C\");\n\nprocess.addModule(lngTrain);\nprocess.run();\n\nStream lng = lngTrain.getLNGStream();\nSystem.out.println(\"LNG production: \" + lng.getFlowRate(\"tonne/day\") + \" t/d\");\n</code></pre>"},{"location":"process/processmodel/process_module/#fpso-topsides-module","title":"FPSO Topsides Module","text":"<pre><code>// Complete FPSO processing\nProcessSystem fpso = new ProcessSystem(\"FPSO Topsides\");\n\n// Separation module\nSeparationTrainModule separation = new SeparationTrainModule(\"Separation\");\nseparation.setInletStream(wellFluid);\nfpso.addModule(separation);\n\n// Gas compression\nCompressorTrainModule gasComp = new CompressorTrainModule(\"Gas Compression\");\ngasComp.setInletStream(separation.getGasOutStream());\ngasComp.setOutletPressure(200.0, \"bara\");\nfpso.addModule(gasComp);\n\n// Gas dehydration\nDehydrationModule dehy = new DehydrationModule(\"Dehydration\");\ndehy.setInletStream(gasComp.getOutletStream());\nfpso.addModule(dehy);\n\n// Water treatment\nWaterTreatmentModule waterTreat = new WaterTreatmentModule(\"Water Treatment\");\nwaterTreat.setInletStream(separation.getWaterOutStream());\nfpso.addModule(waterTreat);\n\nfpso.run();\n</code></pre>"},{"location":"process/processmodel/process_module/#best-practices","title":"Best Practices","text":"<ol> <li>Self-Contained: Modules should be self-contained with clear interfaces</li> <li>Documented Interfaces: Document inlet/outlet requirements</li> <li>Reasonable Defaults: Provide sensible default values</li> <li>Error Handling: Validate inputs and provide clear error messages</li> <li>Testing: Create unit tests for each module</li> </ol>"},{"location":"process/processmodel/process_module/#related-documentation","title":"Related Documentation","text":"<ul> <li>ProcessSystem - Process system management</li> <li>Graph Simulation - Graph-based execution</li> <li>Equipment Overview - Process equipment</li> </ul>"},{"location":"process/processmodel/process_system/","title":"ProcessSystem Class","text":"<p>Documentation for the ProcessSystem class in NeqSim.</p>"},{"location":"process/processmodel/process_system/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Creating a Process</li> <li>Adding Equipment</li> <li>Running Simulations</li> <li>Results and Reporting</li> <li>Advanced Features</li> <li>Examples</li> </ul>"},{"location":"process/processmodel/process_system/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.processmodel.ProcessSystem</code></p> <p>The <code>ProcessSystem</code> class is the main container for building and running process flowsheets. It: - Manages equipment registration - Enforces unique naming - Handles execution order - Coordinates recycles and adjusters - Provides reporting capabilities</p>"},{"location":"process/processmodel/process_system/#creating-a-process","title":"Creating a Process","text":""},{"location":"process/processmodel/process_system/#basic-constructor","title":"Basic Constructor","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\n\n// Create empty process system\nProcessSystem process = new ProcessSystem();\n\n// Create with name\nProcessSystem process = new ProcessSystem(\"Gas Processing Plant\");\n</code></pre>"},{"location":"process/processmodel/process_system/#adding-equipment","title":"Adding Equipment","text":""},{"location":"process/processmodel/process_system/#basic-addition","title":"Basic Addition","text":"<pre><code>// Add equipment in sequence\nprocess.add(feedStream);\nprocess.add(heater);\nprocess.add(separator);\nprocess.add(compressor);\n</code></pre>"},{"location":"process/processmodel/process_system/#equipment-order","title":"Equipment Order","text":"<p>Equipment is typically added in flow order, but the ProcessSystem handles dependencies automatically:</p> <pre><code>// ProcessSystem resolves dependencies\nprocess.add(stream);        // First\nprocess.add(heater);        // Uses stream as input\nprocess.add(separator);     // Uses heater output\nprocess.add(compressor);    // Uses separator gas output\n</code></pre>"},{"location":"process/processmodel/process_system/#unique-names","title":"Unique Names","text":"<p>All equipment must have unique names:</p> <pre><code>Stream stream1 = new Stream(\"Feed\", fluid1);\nStream stream2 = new Stream(\"Feed\", fluid2);  // ERROR: Duplicate name!\n\n// Use unique names\nStream stream1 = new Stream(\"Feed-1\", fluid1);\nStream stream2 = new Stream(\"Feed-2\", fluid2);\n</code></pre>"},{"location":"process/processmodel/process_system/#running-simulations","title":"Running Simulations","text":""},{"location":"process/processmodel/process_system/#steady-state-simulation","title":"Steady-State Simulation","text":"<pre><code>// Run until converged\nprocess.run();\n\n// Run with calculation ID for tracking\nUUID calcId = UUID.randomUUID();\nprocess.run(calcId);\n</code></pre>"},{"location":"process/processmodel/process_system/#transient-simulation","title":"Transient Simulation","text":"<pre><code>// Set time step\ndouble dt = 1.0;  // seconds\n\n// Run single transient step\nprocess.runTransient(dt);\n\n// Run for specified duration\ndouble totalTime = 3600.0;  // 1 hour\nfor (double t = 0; t &lt; totalTime; t += dt) {\n    process.runTransient(dt);\n    logResults(t);\n}\n</code></pre>"},{"location":"process/processmodel/process_system/#transient-with-events","title":"Transient with Events","text":"<pre><code>// Run transient with event handling\nprocess.runTransient(dt, (time) -&gt; {\n    if (time &gt; 600.0) {\n        // Open blowdown valve after 10 minutes\n        bdv.setOpen(true);\n    }\n});\n</code></pre>"},{"location":"process/processmodel/process_system/#retrieving-equipment","title":"Retrieving Equipment","text":""},{"location":"process/processmodel/process_system/#by-name","title":"By Name","text":"<pre><code>// Get specific equipment\nCompressor comp = (Compressor) process.getUnit(\"K-100\");\nSeparator sep = (Separator) process.getUnit(\"HP Separator\");\nStream stream = (Stream) process.getUnit(\"Feed\");\n</code></pre>"},{"location":"process/processmodel/process_system/#by-type","title":"By Type","text":"<pre><code>// Get all compressors\nList&lt;CompressorInterface&gt; compressors = process.getUnitsOfType(CompressorInterface.class);\n\n// Get all separators\nList&lt;SeparatorInterface&gt; separators = process.getUnitsOfType(SeparatorInterface.class);\n</code></pre>"},{"location":"process/processmodel/process_system/#all-equipment","title":"All Equipment","text":"<pre><code>// Get all equipment\nList&lt;ProcessEquipmentInterface&gt; allUnits = process.getUnitOperations();\n\nfor (ProcessEquipmentInterface unit : allUnits) {\n    System.out.println(unit.getName() + \": \" + unit.getClass().getSimpleName());\n}\n</code></pre>"},{"location":"process/processmodel/process_system/#results-and-reporting","title":"Results and Reporting","text":""},{"location":"process/processmodel/process_system/#console-display","title":"Console Display","text":"<pre><code>// Display summary to console\nprocess.display();\n</code></pre>"},{"location":"process/processmodel/process_system/#json-report","title":"JSON Report","text":"<pre><code>// Get JSON report\nString jsonReport = process.getReport_json();\n\n// Save to file\nFiles.writeString(Path.of(\"process_report.json\"), jsonReport);\n</code></pre>"},{"location":"process/processmodel/process_system/#tabular-report","title":"Tabular Report","text":"<pre><code>// Get as table\nString[][] table = process.getUnitOperationsAsTable();\n\n// Print table\nfor (String[] row : table) {\n    System.out.println(String.join(\"\\t\", row));\n}\n</code></pre>"},{"location":"process/processmodel/process_system/#mass-balance","title":"Mass Balance","text":"<pre><code>// Check overall mass balance\ndouble totalIn = 0.0;\ndouble totalOut = 0.0;\n\nfor (ProcessEquipmentInterface unit : process.getUnitOperations()) {\n    if (unit instanceof StreamInterface) {\n        StreamInterface stream = (StreamInterface) unit;\n        if (isInletStream(stream)) {\n            totalIn += stream.getFlowRate(\"kg/hr\");\n        } else if (isOutletStream(stream)) {\n            totalOut += stream.getFlowRate(\"kg/hr\");\n        }\n    }\n}\n\ndouble balance = (totalIn - totalOut) / totalIn * 100;\nSystem.out.println(\"Mass balance closure: \" + balance + \"%\");\n</code></pre>"},{"location":"process/processmodel/process_system/#process-copying","title":"Process Copying","text":""},{"location":"process/processmodel/process_system/#clone-process","title":"Clone Process","text":"<pre><code>// Create copy of process\nProcessSystem processCopy = process.copy();\n\n// Modify copy without affecting original\nHeater heater = (Heater) processCopy.getUnit(\"Heater\");\nheater.setOutTemperature(100.0, \"C\");\nprocessCopy.run();\n</code></pre>"},{"location":"process/processmodel/process_system/#deep-copy","title":"Deep Copy","text":"<p>All equipment and streams are deep-copied:</p> <pre><code>// Original\nprocess.run();\ndouble originalT = ((Stream) process.getUnit(\"Feed\")).getTemperature(\"C\");\n\n// Copy and modify\nProcessSystem copy = process.copy();\n((Stream) copy.getUnit(\"Feed\")).setTemperature(50.0, \"C\");\ncopy.run();\n\n// Original unchanged\nassert originalT == ((Stream) process.getUnit(\"Feed\")).getTemperature(\"C\");\n</code></pre>"},{"location":"process/processmodel/process_system/#advanced-features","title":"Advanced Features","text":""},{"location":"process/processmodel/process_system/#execution-order-control","title":"Execution Order Control","text":"<pre><code>// Force specific execution order\nprocess.setExecutionOrder(Arrays.asList(\n    \"Feed\",\n    \"Heater\",\n    \"Separator\",\n    \"Gas Compressor\",\n    \"Liquid Pump\"\n));\n</code></pre>"},{"location":"process/processmodel/process_system/#parallel-execution","title":"Parallel Execution","text":"<pre><code>// Enable parallel execution for independent units\nprocess.setParallelExecution(true);\nprocess.setNumberOfThreads(4);\n</code></pre>"},{"location":"process/processmodel/process_system/#convergence-settings","title":"Convergence Settings","text":"<pre><code>// Set global convergence tolerance\nprocess.setGlobalTolerance(1e-6);\n\n// Set maximum iterations for recycles\nprocess.setMaxRecycleIterations(50);\n</code></pre>"},{"location":"process/processmodel/process_system/#process-modules","title":"Process Modules","text":"<pre><code>// Add pre-built module\nProcessModule compressorTrain = new CompressorTrainModule(\"HP Compression\");\nprocess.addModule(compressorTrain);\n\n// Connect to process\ncompressorTrain.setInletStream(feedGas);\nStream compressed = compressorTrain.getOutletStream();\n</code></pre>"},{"location":"process/processmodel/process_system/#examples","title":"Examples","text":""},{"location":"process/processmodel/process_system/#simple-separation-process","title":"Simple Separation Process","text":"<pre><code>ProcessSystem process = new ProcessSystem(\"Separator System\");\n\n// Create fluid\nSystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.08);\nfluid.addComponent(\"propane\", 0.04);\nfluid.addComponent(\"n-butane\", 0.03);\nfluid.setMixingRule(\"classic\");\n\n// Feed stream\nStream feed = new Stream(\"Feed\", fluid);\nfeed.setFlowRate(100000.0, \"kg/hr\");\nprocess.add(feed);\n\n// Inlet valve\nThrottlingValve inletValve = new ThrottlingValve(\"Inlet Valve\", feed);\ninletValve.setOutletPressure(30.0, \"bara\");\nprocess.add(inletValve);\n\n// HP Separator\nSeparator hpSep = new Separator(\"HP Separator\", inletValve.getOutletStream());\nprocess.add(hpSep);\n\n// LP Valve\nThrottlingValve lpValve = new ThrottlingValve(\"LP Valve\", hpSep.getLiquidOutStream());\nlpValve.setOutletPressure(5.0, \"bara\");\nprocess.add(lpValve);\n\n// LP Separator\nSeparator lpSep = new Separator(\"LP Separator\", lpValve.getOutletStream());\nprocess.add(lpSep);\n\n// Run\nprocess.run();\n\n// Results\nSystem.out.println(\"HP Gas: \" + hpSep.getGasOutStream().getFlowRate(\"MSm3/day\") + \" MSm3/day\");\nSystem.out.println(\"LP Gas: \" + lpSep.getGasOutStream().getFlowRate(\"MSm3/day\") + \" MSm3/day\");\nSystem.out.println(\"Liquid: \" + lpSep.getLiquidOutStream().getFlowRate(\"m3/hr\") + \" m3/hr\");\n</code></pre>"},{"location":"process/processmodel/process_system/#compression-system","title":"Compression System","text":"<pre><code>ProcessSystem process = new ProcessSystem(\"Compression System\");\n\n// Gas feed\nStream gas = new Stream(\"Gas Feed\", gasFluid);\ngas.setFlowRate(50000.0, \"Sm3/hr\");\ngas.setTemperature(40.0, \"C\");\ngas.setPressure(5.0, \"bara\");\nprocess.add(gas);\n\n// First stage compressor\nCompressor comp1 = new Compressor(\"K-101\", gas);\ncomp1.setOutletPressure(15.0, \"bara\");\ncomp1.setPolytropicEfficiency(0.78);\nprocess.add(comp1);\n\n// Intercooler\nCooler cooler1 = new Cooler(\"E-101\", comp1.getOutletStream());\ncooler1.setOutTemperature(40.0, \"C\");\nprocess.add(cooler1);\n\n// Second stage compressor\nCompressor comp2 = new Compressor(\"K-102\", cooler1.getOutletStream());\ncomp2.setOutletPressure(45.0, \"bara\");\ncomp2.setPolytropicEfficiency(0.78);\nprocess.add(comp2);\n\n// Aftercooler\nCooler cooler2 = new Cooler(\"E-102\", comp2.getOutletStream());\ncooler2.setOutTemperature(40.0, \"C\");\nprocess.add(cooler2);\n\n// Run\nprocess.run();\n\n// Total power\ndouble totalPower = comp1.getPower(\"kW\") + comp2.getPower(\"kW\");\nSystem.out.println(\"Total compression power: \" + totalPower + \" kW\");\n</code></pre>"},{"location":"process/processmodel/process_system/#process-with-recycle","title":"Process with Recycle","text":"<pre><code>ProcessSystem process = new ProcessSystem(\"Recycle Process\");\n\n// Fresh feed\nStream freshFeed = new Stream(\"Fresh Feed\", freshFluid);\nfreshFeed.setFlowRate(1000.0, \"kg/hr\");\nprocess.add(freshFeed);\n\n// Mixer for fresh feed and recycle\nMixer feedMixer = new Mixer(\"Feed Mixer\");\nfeedMixer.addStream(freshFeed);\nprocess.add(feedMixer);\n\n// Reactor\nGibbsReactor reactor = new GibbsReactor(\"Reactor\");\nreactor.setInletStream(feedMixer.getOutletStream());\nprocess.add(reactor);\n\n// Product separator\nSeparator productSep = new Separator(\"Product Sep\", reactor.getOutletStream());\nprocess.add(productSep);\n\n// Product stream\nStream product = productSep.getLiquidOutStream();\n\n// Recycle unreacted gas\nRecycle recycle = new Recycle(\"Gas Recycle\");\nrecycle.addStream(productSep.getGasOutStream());\nrecycle.setOutletStream(feedMixer);\nrecycle.setTolerance(1e-5);\nprocess.add(recycle);\n\n// Complete the connection\nfeedMixer.addStream(recycle.getOutletStream());\n\n// Run (will iterate until recycle converges)\nprocess.run();\n\nSystem.out.println(\"Recycle converged: \" + recycle.isConverged());\nSystem.out.println(\"Product rate: \" + product.getFlowRate(\"kg/hr\") + \" kg/hr\");\n</code></pre>"},{"location":"process/processmodel/process_system/#related-documentation","title":"Related Documentation","text":"<ul> <li>ProcessModule - Modular process units</li> <li>Graph Simulation - Graph-based execution</li> <li>Equipment Overview - Process equipment</li> </ul>"},{"location":"process/safety/","title":"Safety Systems Package","text":"<p>Documentation for safety systems modeling in NeqSim.</p>"},{"location":"process/safety/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Safety Equipment</li> <li>Emergency Shutdown (ESD)</li> <li>Blowdown Systems</li> <li>Pressure Safety Valves</li> <li>HIPPS</li> </ul>"},{"location":"process/safety/#overview","title":"Overview","text":"<p>Location: <code>neqsim.process.equipment.safety</code>, <code>neqsim.process.safety</code></p> <p>NeqSim provides equipment and logic for modeling process safety systems: - Pressure Safety Valves (PSV) - Relief valves - Emergency Shutdown (ESD) systems - Blowdown and depressuring systems - High Integrity Pressure Protection Systems (HIPPS)</p>"},{"location":"process/safety/#safety-equipment","title":"Safety Equipment","text":""},{"location":"process/safety/#pressure-safety-valve-psv","title":"Pressure Safety Valve (PSV)","text":"<pre><code>import neqsim.process.equipment.valve.SafetyValve;\n\nSafetyValve psv = new SafetyValve(\"PSV-100\", vessel);\npsv.setOpeningPressure(95.0, \"barg\");  // Set pressure\npsv.setFullOpenPressure(100.0, \"barg\"); // Overpressure\npsv.setBlowdownPressure(85.0, \"barg\");  // Reseating pressure\n</code></pre>"},{"location":"process/safety/#rupture-disk","title":"Rupture Disk","text":"<pre><code>import neqsim.process.equipment.valve.RuptureDisk;\n\nRuptureDisk disk = new RuptureDisk(\"RD-100\", vessel);\ndisk.setBurstPressure(110.0, \"barg\");\ndisk.setDiameter(150.0, \"mm\");\n</code></pre>"},{"location":"process/safety/#emergency-shutdown-esd","title":"Emergency Shutdown (ESD)","text":""},{"location":"process/safety/#esd-logic","title":"ESD Logic","text":"<pre><code>import neqsim.process.safety.ESDController;\n\nESDController esd = new ESDController(\"ESD-1\");\n\n// Add trip conditions\nesd.addHighPressureTrip(separator, 100.0, \"barg\");\nesd.addLowPressureTrip(separator, 5.0, \"barg\");\nesd.addHighLevelTrip(separator, 0.9);\nesd.addLowLevelTrip(separator, 0.1);\n\n// Add shutdown actions\nesd.addShutdownValve(inletValve);\nesd.addShutdownValve(outletValve);\n</code></pre>"},{"location":"process/safety/#esd-levels","title":"ESD Levels","text":"Level Description Actions ESD-0 Total shutdown Full plant shutdown ESD-1 Process shutdown Process area isolation ESD-2 Unit shutdown Single unit isolation ESD-3 Equipment shutdown Single equipment stop"},{"location":"process/safety/#blowdown-systems","title":"Blowdown Systems","text":""},{"location":"process/safety/#depressuring-calculation","title":"Depressuring Calculation","text":"<pre><code>import neqsim.process.equipment.valve.BlowdownValve;\n\nBlowdownValve blowdown = new BlowdownValve(\"BDV-100\", vessel);\nblowdown.setDownstreamPressure(1.0, \"barg\");  // Flare pressure\nblowdown.setOrificeSize(100.0, \"mm\");\n\n// Run depressuring transient\nfor (double t = 0; t &lt; 900; t += 1.0) {\n    blowdown.runTransient();\n\n    double P = vessel.getPressure(\"barg\");\n    double T = vessel.getTemperature(\"C\");\n\n    if (P &lt; 7.0) {  // 15 minute rule target\n        System.out.println(\"Reached target at \" + t + \" seconds\");\n        break;\n    }\n}\n</code></pre>"},{"location":"process/safety/#fire-case-calculation","title":"Fire Case Calculation","text":"<pre><code>// Calculate heat input from fire\ndouble wettedArea = 50.0;  // m\u00b2\ndouble Q = 43200 * Math.pow(wettedArea, 0.82);  // API 521 formula\n\nvessel.setHeatInput(Q, \"W\");\n</code></pre>"},{"location":"process/safety/#pressure-safety-valves","title":"Pressure Safety Valves","text":""},{"location":"process/safety/#psv-sizing","title":"PSV Sizing","text":"<pre><code>// Calculate required relief rate\ndouble reliefRate = psv.getReliefRate(\"kg/hr\");\n\n// API 520 sizing\ndouble area = psv.getRequiredOrificeArea(\"mm2\");\nString orifice = psv.getAPIOrificeLetter();\n\nSystem.out.println(\"Required area: \" + area + \" mm\u00b2\");\nSystem.out.println(\"API orifice: \" + orifice);\n</code></pre>"},{"location":"process/safety/#multiple-relief-scenarios","title":"Multiple Relief Scenarios","text":"Scenario Description Blocked outlet Outlet valve closed Fire case External fire exposure Tube rupture Heat exchanger tube failure Power failure Loss of cooling/control Thermal relief Liquid expansion"},{"location":"process/safety/#hipps","title":"HIPPS","text":"<p>High Integrity Pressure Protection System.</p> <pre><code>import neqsim.process.safety.HIPPS;\n\nHIPPS hipps = new HIPPS(\"HIPPS-1\");\n\n// Add sensors (2oo3 voting)\nhipps.addPressureSensor(pt1);\nhipps.addPressureSensor(pt2);\nhipps.addPressureSensor(pt3);\n\n// Set trip point\nhipps.setTripPressure(95.0, \"barg\");\n\n// Add final elements\nhipps.addIsolationValve(sdv1);\nhipps.addIsolationValve(sdv2);\n\n// Set voting logic\nhipps.setVotingLogic(\"2oo3\");  // 2 out of 3\n</code></pre>"},{"location":"process/safety/#example-complete-safety-system","title":"Example: Complete Safety System","text":"<pre><code>ProcessSystem process = new ProcessSystem();\n\n// Process equipment\nStream feed = new Stream(\"Feed\", feedFluid);\nprocess.add(feed);\n\nSeparator separator = new Separator(\"V-100\", feed);\nseparator.setVolume(10.0, \"m3\");\nprocess.add(separator);\n\n// PSV on separator\nSafetyValve psv = new SafetyValve(\"PSV-100\", separator);\npsv.setOpeningPressure(100.0, \"barg\");\npsv.setDischargeStream(flareStream);\nprocess.add(psv);\n\n// Blowdown valve\nBlowdownValve bdv = new BlowdownValve(\"BDV-100\", separator);\nbdv.setDownstreamPressure(1.0, \"barg\");\nprocess.add(bdv);\n\n// ESD controller\nESDController esd = new ESDController(\"ESD\");\nesd.addHighPressureTrip(separator, 95.0, \"barg\");\nesd.addShutdownAction(() -&gt; {\n    inletValve.close();\n    bdv.open();\n});\nprocess.add(esd);\n\n// Run simulation\nprocess.run();\n\n// Simulate fire scenario\nseparator.setHeatInput(500.0, \"kW\");\n\nfor (double t = 0; t &lt; 3600; t += 1.0) {\n    process.runTransient();\n\n    // Check ESD status\n    if (esd.isTripped()) {\n        System.out.println(\"ESD activated at \" + t + \" s\");\n    }\n}\n</code></pre>"},{"location":"process/safety/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Process simulation overview</li> <li>ESD Blowdown System - Detailed ESD guide</li> <li>HIPPS Summary - HIPPS overview</li> <li>PSV Dynamic Sizing - PSV sizing example</li> </ul>"},{"location":"pvtsimulation/","title":"PVT Simulation Package","text":"<p>The <code>pvtsimulation</code> package provides tools for simulating standard PVT laboratory experiments used in reservoir fluid characterization.</p>"},{"location":"pvtsimulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>PVT Experiments</li> <li>Usage Examples</li> <li>Integration with Characterization</li> </ul>"},{"location":"pvtsimulation/#overview","title":"Overview","text":"<p>Location: <code>neqsim.pvtsimulation</code></p> <p>Purpose: - Simulate standard PVT laboratory experiments - Support fluid characterization workflows - Model tuning and regression against lab data - Generate PVT reports</p>"},{"location":"pvtsimulation/#package-structure","title":"Package Structure","text":"<pre><code>pvtsimulation/\n\u251c\u2500\u2500 simulation/                      # PVT experiment simulations\n\u2502   \u251c\u2500\u2500 BasePVTsimulation.java       # Base class\n\u2502   \u251c\u2500\u2500 SimulationInterface.java     # Interface\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 SaturationPressure.java      # Bubble/dew point\n\u2502   \u251c\u2500\u2500 SaturationTemperature.java   # Saturation temperature\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 ConstantMassExpansion.java   # CME experiment\n\u2502   \u251c\u2500\u2500 ConstantVolumeDepletion.java # CVD experiment\n\u2502   \u251c\u2500\u2500 DifferentialLiberation.java  # DL experiment\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 SeparatorTest.java           # Single separator\n\u2502   \u251c\u2500\u2500 MultiStageSeparatorTest.java # Multi-stage separation\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 SwellingTest.java            # Gas injection swelling\n\u2502   \u251c\u2500\u2500 SlimTubeSim.java             # Slim tube MMP\n\u2502   \u251c\u2500\u2500 MMPCalculator.java           # Minimum miscibility pressure\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 ViscositySim.java            # Viscosity vs pressure\n\u2502   \u251c\u2500\u2500 ViscosityWaxOilSim.java      # Wax oil viscosity\n\u2502   \u251c\u2500\u2500 DensitySim.java              # Density vs pressure\n\u2502   \u251c\u2500\u2500 WaxFractionSim.java          # Wax precipitation\n\u2502   \u2514\u2500\u2500 GOR.java                     # Gas-oil ratio\n\u2502\n\u251c\u2500\u2500 regression/                      # Parameter fitting\n\u2502   \u2514\u2500\u2500 PVTRegression.java\n\u2502\n\u251c\u2500\u2500 modeltuning/                     # Model tuning\n\u2502   \u2514\u2500\u2500 ModelTuning.java\n\u2502\n\u251c\u2500\u2500 reservoirproperties/             # Reservoir calculations\n\u2502   \u2514\u2500\u2500 ReservoirProperties.java\n\u2502\n\u2514\u2500\u2500 util/                            # Utilities\n    \u2514\u2500\u2500 PVTUtil.java\n</code></pre>"},{"location":"pvtsimulation/#pvt-experiments","title":"PVT Experiments","text":""},{"location":"pvtsimulation/#saturation-pressure","title":"Saturation Pressure","text":"<p>Calculate bubble point or dew point pressure.</p> <pre><code>import neqsim.pvtsimulation.simulation.SaturationPressure;\n\nSystemInterface oil = new SystemSrkEos(373.15, 200.0);\noil.addComponent(\"nitrogen\", 0.5);\noil.addComponent(\"CO2\", 2.0);\noil.addComponent(\"methane\", 40.0);\noil.addComponent(\"ethane\", 8.0);\noil.addComponent(\"propane\", 5.0);\noil.addComponent(\"n-pentane\", 3.0);\noil.addComponent(\"n-heptane\", 20.0);\noil.addComponent(\"n-C10\", 21.5);\noil.setMixingRule(\"classic\");\n\nSaturationPressure satPres = new SaturationPressure(oil);\nsatPres.setTemperature(373.15, \"K\");\nsatPres.run();\n\nSystem.out.println(\"Saturation pressure: \" + satPres.getSaturationPressure() + \" bar\");\n</code></pre>"},{"location":"pvtsimulation/#constant-mass-expansion-cme","title":"Constant Mass Expansion (CME)","text":"<p>Simulates isothermal expansion of reservoir fluid, measuring relative volume.</p> <pre><code>import neqsim.pvtsimulation.simulation.ConstantMassExpansion;\n\nConstantMassExpansion cme = new ConstantMassExpansion(oil);\ncme.setTemperature(373.15, \"K\");\n\n// Set pressure steps\ndouble[] pressures = {300, 250, 200, 180, 160, 140, 120, 100, 80, 60, 40};\ncme.setPressures(pressures, \"bara\");\n\ncme.run();\n\n// Get results\ndouble[] relativeVolumes = cme.getRelativeVolume();\ndouble[] liquidVolumes = cme.getLiquidRelativeVolume();\ndouble[] Yvalues = cme.getYfactor();\ndouble[] densities = cme.getDensity();\ndouble[] Zfactors = cme.getZfactor();\n\n// Print results\nSystem.out.println(\"P (bar)\\tVrel\\tVliq\\tY\\tDensity\\tZ\");\nfor (int i = 0; i &lt; pressures.length; i++) {\n    System.out.printf(\"%.1f\\t%.4f\\t%.4f\\t%.4f\\t%.2f\\t%.4f%n\",\n        pressures[i], relativeVolumes[i], liquidVolumes[i],\n        Yvalues[i], densities[i], Zfactors[i]);\n}\n</code></pre> <p>CME Output Properties: - Relative volume (V/Vsat) - Liquid relative volume - Y-factor - Density - Compressibility factor (Z)</p>"},{"location":"pvtsimulation/#constant-volume-depletion-cvd","title":"Constant Volume Depletion (CVD)","text":"<p>Simulates gas condensate depletion at constant volume.</p> <pre><code>import neqsim.pvtsimulation.simulation.ConstantVolumeDepletion;\n\nSystemInterface condensate = new SystemPrEos(373.15, 400.0);\n// Add components...\n\nConstantVolumeDepletion cvd = new ConstantVolumeDepletion(condensate);\ncvd.setTemperature(373.15, \"K\");\n\ndouble[] pressures = {400, 350, 300, 250, 200, 150, 100, 50};\ncvd.setPressures(pressures, \"bara\");\n\ncvd.run();\n\n// Results\ndouble[] liquidDropout = cvd.getLiquidVolumeFraction();\ndouble[] cumulativeGasProduced = cvd.getCumulativeGasProduced();\ndouble[] Zfactors = cvd.getZfactor();\ndouble[] Bg = cvd.getBg();\n</code></pre> <p>CVD Output Properties: - Liquid dropout (volume fraction) - Cumulative gas produced - Two-phase Z-factor - Gas formation volume factor (Bg) - Produced gas composition (each step)</p>"},{"location":"pvtsimulation/#differential-liberation-dl","title":"Differential Liberation (DL)","text":"<p>Black oil experiment - gas released at each pressure step.</p> <pre><code>import neqsim.pvtsimulation.simulation.DifferentialLiberation;\n\nDifferentialLiberation dl = new DifferentialLiberation(oil);\ndl.setTemperature(373.15, \"K\");\n\ndouble[] pressures = {300, 250, 200, 150, 100, 50, 1.01325};\ndl.setPressures(pressures, \"bara\");\n\ndl.run();\n\n// Results\ndouble[] Rs = dl.getRs();           // Solution GOR\ndouble[] Bo = dl.getBo();           // Oil FVF\ndouble[] oilDensity = dl.getOilDensity();\ndouble[] oilViscosity = dl.getOilViscosity();\ndouble[] gasDensity = dl.getGasDensity();\ndouble[] gasGravity = dl.getGasGravity();\ndouble[] Bg = dl.getBg();\n\nSystem.out.println(\"P (bar)\\tRs (Sm3/Sm3)\\tBo\\t\u03c1_oil (kg/m3)\");\nfor (int i = 0; i &lt; pressures.length; i++) {\n    System.out.printf(\"%.1f\\t%.2f\\t\\t%.4f\\t%.2f%n\",\n        pressures[i], Rs[i], Bo[i], oilDensity[i]);\n}\n</code></pre> <p>DL Output Properties: - Solution GOR (Rs) - Oil formation volume factor (Bo) - Oil density - Oil viscosity - Gas gravity - Gas formation volume factor (Bg)</p>"},{"location":"pvtsimulation/#separator-test","title":"Separator Test","text":"<p>Model surface separation conditions.</p> <pre><code>import neqsim.pvtsimulation.simulation.SeparatorTest;\n\nSeparatorTest sepTest = new SeparatorTest(oil);\n\n// Define separator stages\ndouble[] temperatures = {323.15, 288.15};  // K\ndouble[] pressures = {50.0, 1.01325};       // bar\n\nsepTest.setSeparatorConditions(temperatures, pressures);\nsepTest.run();\n\n// Results\ndouble GOR = sepTest.getGOR();\ndouble Bo = sepTest.getBo();\ndouble oilDensity = sepTest.getOilDensity();\ndouble oilMW = sepTest.getOilMolarMass();\n\nSystem.out.println(\"GOR: \" + GOR + \" Sm3/Sm3\");\nSystem.out.println(\"Bo: \" + Bo);\nSystem.out.println(\"Stock tank oil density: \" + oilDensity + \" kg/m3\");\n</code></pre>"},{"location":"pvtsimulation/#multi-stage-separator-test","title":"Multi-Stage Separator Test","text":"<pre><code>import neqsim.pvtsimulation.simulation.MultiStageSeparatorTest;\n\nMultiStageSeparatorTest mst = new MultiStageSeparatorTest(oil);\n\n// Configure stages\nmst.addSeparator(50.0, 323.15);   // HP separator\nmst.addSeparator(10.0, 308.15);   // LP separator  \nmst.addSeparator(1.01325, 288.15); // Stock tank\n\nmst.run();\n\ndouble[] stageGORs = mst.getStageGOR();\ndouble totalGOR = mst.getTotalGOR();\n</code></pre>"},{"location":"pvtsimulation/#swelling-test","title":"Swelling Test","text":"<p>Gas injection swelling experiment.</p> <pre><code>import neqsim.pvtsimulation.simulation.SwellingTest;\n\nSystemInterface injectionGas = new SystemSrkEos(373.15, 200.0);\ninjectionGas.addComponent(\"CO2\", 1.0);\ninjectionGas.setMixingRule(\"classic\");\n\nSwellingTest swelling = new SwellingTest(oil);\nswelling.setInjectionGas(injectionGas);\nswelling.setTemperature(373.15, \"K\");\n\n// Injection amounts (moles per mole original oil)\ndouble[] injectionAmounts = {0.0, 0.1, 0.2, 0.3, 0.4, 0.5};\nswelling.setInjectionAmounts(injectionAmounts);\n\nswelling.run();\n\ndouble[] saturationPressures = swelling.getSaturationPressures();\ndouble[] swellingFactors = swelling.getSwellingFactors();\ndouble[] oilDensities = swelling.getOilDensities();\n</code></pre>"},{"location":"pvtsimulation/#mmp-calculation","title":"MMP Calculation","text":"<p>Minimum miscibility pressure via slim tube simulation.</p> <pre><code>import neqsim.pvtsimulation.simulation.MMPCalculator;\n\nMMPCalculator mmp = new MMPCalculator(oil, injectionGas);\nmmp.setTemperature(373.15, \"K\");\nmmp.run();\n\ndouble minimumMiscibilityPressure = mmp.getMMP();\nSystem.out.println(\"MMP: \" + minimumMiscibilityPressure + \" bar\");\n</code></pre>"},{"location":"pvtsimulation/#viscosity-simulation","title":"Viscosity Simulation","text":"<pre><code>import neqsim.pvtsimulation.simulation.ViscositySim;\n\nViscositySim viscSim = new ViscositySim(oil);\nviscSim.setTemperature(373.15, \"K\");\n\ndouble[] pressures = {400, 300, 200, 150, 100, 50};\nviscSim.setPressures(pressures, \"bara\");\n\nviscSim.run();\n\ndouble[] oilViscosities = viscSim.getOilViscosity();\ndouble[] gasViscosities = viscSim.getGasViscosity();\n</code></pre>"},{"location":"pvtsimulation/#integration-with-characterization","title":"Integration with Characterization","text":""},{"location":"pvtsimulation/#tuning-to-lab-data","title":"Tuning to Lab Data","text":"<pre><code>import neqsim.pvtsimulation.regression.PVTRegression;\n\n// Set up experiment with measured data\nConstantMassExpansion cme = new ConstantMassExpansion(oil);\ncme.setExperimentalData(measuredPressures, measuredRelativeVolumes);\n\n// Create regression\nPVTRegression regression = new PVTRegression(oil);\nregression.addExperiment(cme);\n\n// Select parameters to tune\nregression.tuneParameter(\"C7+\", \"Tc\", 0.95, 1.05);  // \u00b15%\nregression.tuneParameter(\"C7+\", \"Pc\", 0.95, 1.05);\nregression.tuneParameter(\"C7+\", \"acf\", 0.90, 1.10);\n\n// Run regression\nregression.run();\n\n// Get tuned fluid\nSystemInterface tunedOil = regression.getTunedSystem();\n</code></pre>"},{"location":"pvtsimulation/#complete-pvt-study-example","title":"Complete PVT Study Example","text":"<pre><code>// Create reservoir oil\nSystemInterface oil = new SystemSrkEos(373.15, 300.0);\noil.addComponent(\"nitrogen\", 0.5);\noil.addComponent(\"CO2\", 2.1);\noil.addComponent(\"methane\", 35.2);\noil.addComponent(\"ethane\", 7.8);\noil.addComponent(\"propane\", 5.4);\noil.addComponent(\"i-butane\", 1.2);\noil.addComponent(\"n-butane\", 3.1);\noil.addComponent(\"i-pentane\", 1.5);\noil.addComponent(\"n-pentane\", 2.1);\noil.addComponent(\"n-hexane\", 3.5);\noil.addTBPfraction(\"C7\", 8.2, 96.0 / 1000.0, 0.738);\noil.addTBPfraction(\"C10\", 12.4, 134.0 / 1000.0, 0.785);\noil.addTBPfraction(\"C15\", 8.5, 206.0 / 1000.0, 0.835);\noil.addTBPfraction(\"C20+\", 8.5, 450.0 / 1000.0, 0.920);\noil.setMixingRule(\"classic\");\noil.useVolumeCorrection(true);\n\ndouble reservoirTemp = 373.15;  // K\n\n// 1. Saturation Pressure\nSaturationPressure sat = new SaturationPressure(oil);\nsat.setTemperature(reservoirTemp, \"K\");\nsat.run();\ndouble Psat = sat.getSaturationPressure();\nSystem.out.println(\"Bubble point: \" + Psat + \" bar\");\n\n// 2. CME\nConstantMassExpansion cme = new ConstantMassExpansion(oil.clone());\ncme.setTemperature(reservoirTemp, \"K\");\ndouble[] cmePressures = generatePressureRange(Psat + 50, 50, 15);\ncme.setPressures(cmePressures, \"bara\");\ncme.run();\n\n// 3. Differential Liberation\nDifferentialLiberation dl = new DifferentialLiberation(oil.clone());\ndl.setTemperature(reservoirTemp, \"K\");\ndouble[] dlPressures = generatePressureRange(Psat, 1.01325, 10);\ndl.setPressures(dlPressures, \"bara\");\ndl.run();\n\n// 4. Separator Test\nSeparatorTest sep = new SeparatorTest(oil.clone());\nsep.setSeparatorConditions(\n    new double[]{323.15, 288.15},  // Temperatures\n    new double[]{30.0, 1.01325}    // Pressures\n);\nsep.run();\n\n// Print summary\nSystem.out.println(\"\\n=== PVT Summary ===\");\nSystem.out.println(\"Bubble point: \" + Psat + \" bar\");\nSystem.out.println(\"GOR: \" + sep.getGOR() + \" Sm3/Sm3\");\nSystem.out.println(\"Bo at Psat: \" + dl.getBo()[0]);\nSystem.out.println(\"Oil density at STC: \" + sep.getOilDensity() + \" kg/m3\");\n</code></pre>"},{"location":"pvtsimulation/#best-practices","title":"Best Practices","text":"<ol> <li>Clone fluids before running multiple experiments</li> <li>Use appropriate EoS for fluid type (CPA for polar, PR for heavy oils)</li> <li>Match temperature units carefully (K vs \u00b0C)</li> <li>Validate against lab data before using for field predictions</li> <li>Document characterization for reproducibility</li> </ol>"},{"location":"pvtsimulation/#related-documentation","title":"Related Documentation","text":"<ul> <li>PVT Workflow - End-to-end PVT workflow</li> <li>Fluid Characterization - Heavy end characterization</li> <li>Black Oil Package - Black oil model export</li> </ul>"},{"location":"pvtsimulation/CO2ElectrolyzerExample/","title":"CO\u2082 Electrolyzer usage example","text":"<p>The snippet below illustrates how to couple the new <code>CO2Electrolyzer</code> with a CO\u2082-rich feed, a power supply, and a downstream separator in a <code>ProcessSystem</code>.</p> <pre><code>import neqsim.process.equipment.electrolyzer.CO2Electrolyzer;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.stream.StreamInterface;\nimport neqsim.process.equipment.battery.BatteryStorage;\nimport neqsim.process.processmodel.ProcessSystem;\nimport neqsim.thermo.Fluid;\nimport neqsim.thermo.system.SystemInterface;\n\nSystemInterface feedFluid = new Fluid().create2(\n    new String[] {\"CO2\", \"water\"},\n    new double[] {0.95, 0.05},\n    \"mole/sec\");\nfeedFluid.setTemperature(298.15);\nfeedFluid.setPressure(20.0);\nStream feedStream = new Stream(\"CO2 feed\", feedFluid);\n\nCO2Electrolyzer electrolyzer = new CO2Electrolyzer(\"CO2 electrolyzer\", feedStream);\nelectrolyzer.setCO2Conversion(0.55);\nelectrolyzer.setGasProductSelectivity(\"CO\", 0.7);\nelectrolyzer.setGasProductSelectivity(\"H2\", 0.3);\nelectrolyzer.setProductFaradaicEfficiency(\"CO\", 0.9);\nelectrolyzer.setElectronsPerMoleProduct(\"H2\", 2.0);\n\n// Downstream separation polishing the gas product\nSeparator syngasPolisher = new Separator(\"syngas polisher\");\nsyngasPolisher.setInletStream((StreamInterface) electrolyzer.getGasProductStream());\n\nProcessSystem process = new ProcessSystem(\"CO2 to fuels\");\nprocess.add(feedStream);\nprocess.add(electrolyzer);\nprocess.add(syngasPolisher);\nprocess.run();\n\ndouble powerDraw = electrolyzer.getEnergyStream().getDuty();\nBatteryStorage battery = new BatteryStorage(\"renewable battery\", 5.0e8);\nbattery.discharge(powerDraw, 1.0 / 3600.0);\nSystem.out.println(\"Electrolyzer power demand: \" + powerDraw + \" W\");\n</code></pre> <p>The gas product stream carries the vapor-phase synthesis gas, the liquid product stream (accessible through <code>getLiquidProductStream()</code>) contains soluble products such as formate or methanol, and the <code>EnergyStream</code> keeps track of the instantaneous electrical duty demanded from the battery.</p>"},{"location":"pvtsimulation/blackoil_pvt_export/","title":"Black Oil PVT and Reservoir Simulator Export","text":"<p>This document describes NeqSim's black oil implementation and the ability to export PVT data to reservoir simulators like Eclipse and CMG.</p>"},{"location":"pvtsimulation/blackoil_pvt_export/#overview","title":"Overview","text":"<p>NeqSim provides a complete workflow for converting compositional EOS (Equation of State) fluid models to black oil PVT tables suitable for reservoir simulation. The <code>neqsim.blackoil</code> package includes:</p> <ul> <li>BlackOilConverter - Converts compositional fluids to black oil properties</li> <li>BlackOilPVTTable - Stores black oil PVT data (Bo, Rs, Bg, \u03bco, \u03bcg, etc.)</li> <li>EclipseEOSExporter - Exports to Schlumberger Eclipse format</li> <li>CMGEOSExporter - Exports to CMG IMEX/GEM/STARS formats</li> </ul>"},{"location":"pvtsimulation/blackoil_pvt_export/#black-oil-conversion","title":"Black Oil Conversion","text":"<p>The <code>BlackOilConverter</code> class performs flash calculations at multiple pressures to generate black oil properties:</p> <pre><code>import neqsim.blackoil.BlackOilConverter;\nimport neqsim.blackoil.BlackOilPVTTable;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create a compositional fluid\nSystemInterface fluid = new SystemSrkEos(373.15, 200.0); // 100\u00b0C, 200 bar\nfluid.addComponent(\"nitrogen\", 0.01);\nfluid.addComponent(\"CO2\", 0.02);\nfluid.addComponent(\"methane\", 0.50);\nfluid.addComponent(\"ethane\", 0.08);\nfluid.addComponent(\"propane\", 0.05);\nfluid.addComponent(\"n-butane\", 0.03);\nfluid.addComponent(\"n-pentane\", 0.02);\nfluid.addComponent(\"n-hexane\", 0.02);\nfluid.addComponent(\"n-heptane\", 0.07);\nfluid.addComponent(\"water\", 0.20);\nfluid.setMixingRule(\"classic\");\n\n// Define pressure grid for PVT table\ndouble[] pressures = {20, 50, 100, 150, 200, 250, 300, 350, 400}; // bar\n\n// Convert to black oil\ndouble Tref = 373.15;  // Reference temperature (K)\ndouble Pstd = 1.01325; // Standard pressure (bar)\ndouble Tstd = 288.15;  // Standard temperature (K)\n\nBlackOilPVTTable pvtTable = BlackOilConverter.convert(fluid, Tref, pressures, Pstd, Tstd);\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#black-oil-properties","title":"Black Oil Properties","text":"<p>The <code>BlackOilPVTTable</code> contains records with the following properties:</p> Property Symbol Unit Description Pressure p bar Reservoir pressure Solution GOR Rs Sm\u00b3/Sm\u00b3 Gas dissolved in oil at standard conditions Oil FVF Bo Rm\u00b3/Sm\u00b3 Oil formation volume factor Oil viscosity \u03bco Pa\u00b7s Oil dynamic viscosity Gas FVF Bg Rm\u00b3/Sm\u00b3 Gas formation volume factor Gas viscosity \u03bcg Pa\u00b7s Gas dynamic viscosity Vaporized OGR Rv Sm\u00b3/Sm\u00b3 Oil vaporized in gas (for volatile oil/gas condensate) Water FVF Bw Rm\u00b3/Sm\u00b3 Water formation volume factor Water viscosity \u03bcw Pa\u00b7s Water dynamic viscosity"},{"location":"pvtsimulation/blackoil_pvt_export/#eclipse-export","title":"Eclipse Export","text":"<p>The <code>EclipseEOSExporter</code> generates PVT include files compatible with Schlumberger Eclipse reservoir simulator.</p>"},{"location":"pvtsimulation/blackoil_pvt_export/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.blackoil.io.EclipseEOSExporter;\nimport java.nio.file.Path;\n\n// Export with default settings (METRIC units)\nEclipseEOSExporter.toFile(fluid, Path.of(\"PVT.INC\"));\n\n// Or get as string\nString eclipseOutput = EclipseEOSExporter.toString(fluid);\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#configuration-options","title":"Configuration Options","text":"<pre><code>import neqsim.blackoil.io.EclipseEOSExporter;\nimport neqsim.blackoil.io.EclipseEOSExporter.ExportConfig;\nimport neqsim.blackoil.io.EclipseEOSExporter.Units;\n\nExportConfig config = new ExportConfig()\n    .setUnits(Units.FIELD)                              // METRIC or FIELD\n    .setIncludeHeader(true)                             // Include header comments\n    .setComment(\"Generated for Field X, Well A-1\")      // Custom comment\n    .setPressureGrid(new double[]{50, 100, 150, 200, 250, 300, 350, 400})\n    .setIncludePVTO(true)                               // Include live oil table\n    .setIncludePVTG(true)                               // Include wet gas table\n    .setIncludePVTW(true)                               // Include water properties\n    .setIncludeDensity(true);                           // Include DENSITY keyword\n\nString output = EclipseEOSExporter.toString(fluid, config);\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#export-from-pre-computed-pvt-table","title":"Export from Pre-computed PVT Table","text":"<pre><code>// If you already have a BlackOilPVTTable\ndouble rhoOilSc = 820.0;   // Oil density at standard conditions (kg/m\u00b3)\ndouble rhoGasSc = 1.2;     // Gas density at standard conditions (kg/m\u00b3)\ndouble rhoWaterSc = 1000.0; // Water density at standard conditions (kg/m\u00b3)\n\nEclipseEOSExporter.toFile(pvtTable, rhoOilSc, rhoGasSc, rhoWaterSc, Path.of(\"PVT.INC\"));\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#eclipse-output-format","title":"Eclipse Output Format","text":"<p>The exporter generates the following Eclipse keywords:</p>"},{"location":"pvtsimulation/blackoil_pvt_export/#density","title":"DENSITY","text":"<pre><code>DENSITY\n-- Oil      Gas       Water\n   820.0    1.200000  1000.0 /\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#pvto-live-oil","title":"PVTO (Live Oil)","text":"<pre><code>PVTO\n-- Rs       P         Bo        mu_o\n   50.0     100.0     1.250     0.00080\n            150.0     1.220     0.00085\n            200.0     1.200     0.00090 /\n   80.0     150.0     1.350     0.00070\n            200.0     1.320     0.00075 /\n/\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#pvtg-wet-gas","title":"PVTG (Wet Gas)","text":"<pre><code>PVTG\n-- Pg       Rv        Bg        mu_g\n   100.0    0.0       0.0120    1.50E-05\n            0.0001    0.0122    1.52E-05 /\n   150.0    0.0       0.0080    1.80E-05 /\n/\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#pvtw-water","title":"PVTW (Water)","text":"<pre><code>PVTW\n-- Pref     Bw        Cw        mu_w    Cv\n   200.0    1.020     4.5E-05   0.00050 0.0 /\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#unit-systems","title":"Unit Systems","text":"Property METRIC FIELD Pressure bar (BARSA) psia (PSIA) Density kg/m\u00b3 lb/ft\u00b3 FVF rm\u00b3/sm\u00b3 rb/stb GOR sm\u00b3/sm\u00b3 scf/stb Viscosity cP cP"},{"location":"pvtsimulation/blackoil_pvt_export/#cmg-export","title":"CMG Export","text":"<p>The <code>CMGEOSExporter</code> generates PVT data files compatible with CMG reservoir simulators (IMEX, GEM, STARS).</p>"},{"location":"pvtsimulation/blackoil_pvt_export/#basic-usage_1","title":"Basic Usage","text":"<pre><code>import neqsim.blackoil.io.CMGEOSExporter;\nimport java.nio.file.Path;\n\n// Export with default settings (IMEX, SI units)\nCMGEOSExporter.toFile(fluid, Path.of(\"PVT.DAT\"));\n\n// Or get as string\nString cmgOutput = CMGEOSExporter.toString(fluid);\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#configuration-options_1","title":"Configuration Options","text":"<pre><code>import neqsim.blackoil.io.CMGEOSExporter;\nimport neqsim.blackoil.io.CMGEOSExporter.ExportConfig;\nimport neqsim.blackoil.io.CMGEOSExporter.Simulator;\nimport neqsim.blackoil.io.CMGEOSExporter.Units;\n\nExportConfig config = new ExportConfig()\n    .setSimulator(Simulator.IMEX)                       // IMEX, GEM, or STARS\n    .setUnits(Units.FIELD)                              // SI or FIELD\n    .setModelName(\"RESERVOIR_FLUID_MODEL\")              // Model identifier\n    .setComment(\"PVT model for Field X\")                // Custom comment\n    .setPressureGrid(new double[]{50, 100, 150, 200, 250, 300});\n\nCMGEOSExporter.toFile(fluid, Path.of(\"PVT.DAT\"), config);\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#cmg-simulators","title":"CMG Simulators","text":"Simulator Type Description IMEX Black Oil Implicit-Explicit black oil simulator GEM Compositional Generalized equation-of-state model STARS Thermal Steam, thermal, and advanced processes"},{"location":"pvtsimulation/blackoil_pvt_export/#imex-output-format","title":"IMEX Output Format","text":"<pre><code>** ============================================================\n** Generated by NeqSim - Black Oil PVT Export\n** Simulator: IMEX\n** Units: SI\n** ============================================================\n\n*MODEL *BLACKOIL\n\n*DENSITY *OIL 820.0\n*DENSITY *GAS 1.2\n*DENSITY *WATER 1000.0\n\n*BOTOIL\n** P(kPa)    Rs(m3/m3)    Bo(m3/m3)    mu_o(cP)\n   10000.0   50.0         1.250        0.80\n   15000.0   80.0         1.350        0.70\n   20000.0   100.0        1.420        0.65\n\n*BOTGAS\n** P(kPa)    Bg(m3/m3)    mu_g(cP)\n   10000.0   0.0120       0.015\n   15000.0   0.0080       0.018\n   20000.0   0.0060       0.021\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#unit-systems_1","title":"Unit Systems","text":"Property SI FIELD Pressure kPa psia Density kg/m\u00b3 lb/ft\u00b3 FVF m\u00b3/m\u00b3 bbl/bbl GOR m\u00b3/m\u00b3 scf/bbl Viscosity cP cP"},{"location":"pvtsimulation/blackoil_pvt_export/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>import neqsim.blackoil.BlackOilConverter;\nimport neqsim.blackoil.BlackOilPVTTable;\nimport neqsim.blackoil.io.EclipseEOSExporter;\nimport neqsim.blackoil.io.CMGEOSExporter;\nimport neqsim.thermo.system.SystemSrkEos;\nimport java.nio.file.Path;\n\npublic class PVTExportExample {\n    public static void main(String[] args) {\n        // 1. Create compositional fluid model\n        var fluid = new SystemSrkEos(373.15, 250.0);\n        fluid.addComponent(\"methane\", 0.60);\n        fluid.addComponent(\"ethane\", 0.08);\n        fluid.addComponent(\"propane\", 0.05);\n        fluid.addComponent(\"n-butane\", 0.03);\n        fluid.addComponent(\"n-pentane\", 0.02);\n        fluid.addComponent(\"n-heptane\", 0.12);\n        fluid.addComponent(\"water\", 0.10);\n        fluid.setMixingRule(\"classic\");\n\n        // 2. Export to Eclipse (METRIC units)\n        var eclipseConfig = new EclipseEOSExporter.ExportConfig()\n            .setUnits(EclipseEOSExporter.Units.METRIC)\n            .setComment(\"Light oil reservoir - Block A\");\n        EclipseEOSExporter.toFile(fluid, Path.of(\"eclipse_pvt.inc\"), eclipseConfig);\n\n        // 3. Export to CMG IMEX (FIELD units)\n        var cmgConfig = new CMGEOSExporter.ExportConfig()\n            .setSimulator(CMGEOSExporter.Simulator.IMEX)\n            .setUnits(CMGEOSExporter.Units.FIELD)\n            .setModelName(\"BLOCK_A_FLUID\");\n        CMGEOSExporter.toFile(fluid, Path.of(\"cmg_pvt.dat\"), cmgConfig);\n\n        System.out.println(\"PVT files exported successfully!\");\n    }\n}\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#integration-with-whitson-pvt-workflows","title":"Integration with Whitson PVT Workflows","text":"<p>The export functionality enables seamless integration with PVT software like whitsonPVT:</p> <ol> <li>EOS Tuning - Tune EOS parameters using experimental PVT data in NeqSim</li> <li>C7+ Characterization - Use Whitson's Gamma model for plus-fraction splitting</li> <li>Export - Generate simulator-ready PVT files for reservoir engineering</li> </ol> <pre><code>// After EOS tuning and characterization\nSystemInterface tunedFluid = /* ... tuned fluid model ... */;\n\n// Export for reservoir simulation workflow\nEclipseEOSExporter.toFile(tunedFluid, Path.of(\"TUNED_PVT.INC\"));\n</code></pre>"},{"location":"pvtsimulation/blackoil_pvt_export/#api-reference","title":"API Reference","text":""},{"location":"pvtsimulation/blackoil_pvt_export/#eclipseeosexporter","title":"EclipseEOSExporter","text":"Method Description <code>toString(SystemInterface)</code> Export fluid to Eclipse format string <code>toString(SystemInterface, ExportConfig)</code> Export with configuration <code>toString(BlackOilPVTTable, rhoO, rhoG, rhoW)</code> Export PVT table <code>toFile(SystemInterface, Path)</code> Write to file <code>toFile(SystemInterface, Path, ExportConfig)</code> Write with configuration"},{"location":"pvtsimulation/blackoil_pvt_export/#cmgeosexporter","title":"CMGEOSExporter","text":"Method Description <code>toString(SystemInterface)</code> Export fluid to CMG format string <code>toString(SystemInterface, ExportConfig)</code> Export with configuration <code>toString(BlackOilPVTTable, rhoO, rhoG, rhoW)</code> Export PVT table <code>toFile(SystemInterface, Path)</code> Write to file <code>toFile(SystemInterface, Path, ExportConfig)</code> Write with configuration"},{"location":"pvtsimulation/blackoil_pvt_export/#see-also","title":"See Also","text":"<ul> <li>PVT Experiments - CCE, CVD, DLE simulations</li> <li>C7+ Characterization - Plus-fraction modeling</li> <li>Thermodynamic Models - EOS and mixing rules</li> </ul>"},{"location":"pvtsimulation/fluid_characterization_mathematics/","title":"Fluid Characterization in NeqSim: Mathematical Foundations","text":"<p>This document provides detailed mathematical documentation of the fluid characterization methods implemented in NeqSim, with emphasis on plus fraction (C7+) modeling, TBP fraction property correlations, and pseudo-component generation.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Plus Fraction Distribution Models</li> <li>Whitson Gamma Distribution Model</li> <li>Pedersen Exponential Model</li> <li>Critical Property Correlations</li> <li>Pedersen Correlations</li> <li>Riazi-Daubert Correlations</li> <li>Kesler-Lee Correlations</li> <li>Density Correlations</li> <li>Watson K-Factor Method (UOP)</li> <li>S\u00f8reide Correlation</li> <li>Boiling Point Correlations</li> <li>Lumping Methods</li> <li>Usage Examples</li> <li>Common Fluid Characterization</li> <li>PseudoComponentCombiner Utility</li> <li>CharacterizationOptions</li> <li>BIP Transfer</li> <li>Validation Reports</li> </ol>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#overview","title":"Overview","text":"<p>Petroleum fluids contain thousands of hydrocarbon compounds. For practical thermodynamic calculations, heavy fractions (typically C7+) must be characterized using continuous distribution functions or discrete pseudo-components. NeqSim implements industry-standard characterization methods from Whitson (1983), Pedersen et al. (1984), and others.</p> <p>The characterization workflow consists of three main steps:</p> <ol> <li>Plus Fraction Splitting: Distribute the C7+ fraction into discrete Single Carbon Number (SCN) groups</li> <li>Property Estimation: Calculate critical properties (Tc, Pc, \u03c9) for each pseudo-component</li> <li>Lumping: Combine pseudo-components into computationally efficient groups</li> </ol>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#plus-fraction-distribution-models","title":"Plus Fraction Distribution Models","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#whitson-gamma-distribution-model","title":"Whitson Gamma Distribution Model","text":"<p>The Whitson gamma distribution (SPE 12233, 1983) is the most widely used continuous distribution for petroleum C7+ fractions.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#probability-density-function","title":"Probability Density Function","text":"<p>The molar distribution of the plus fraction is described by a three-parameter gamma distribution:</p> \\[p(M) = \\frac{(M - \\eta)^{\\alpha - 1}}{\\beta^\\alpha \\cdot \\Gamma(\\alpha)} \\exp\\left(-\\frac{M - \\eta}{\\beta}\\right)\\] <p>where: - \\(M\\) = molecular weight (g/mol) - \\(\\alpha\\) = shape parameter (dimensionless) - \\(\\eta\\) = minimum molecular weight (g/mol), typically 84-90 for C7+ - \\(\\beta\\) = scale parameter (g/mol) - \\(\\Gamma(\\alpha)\\) = gamma function</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#gamma-function-approximation","title":"Gamma Function Approximation","text":"<p>NeqSim uses a polynomial approximation for the gamma function:</p> \\[\\Gamma(\\alpha) \\approx \\alpha \\cdot \\left(1 + \\sum_{i=1}^{8} b_i \\cdot (\\alpha - 1)^i\\right)\\] <p>with coefficients: | \\(i\\) | \\(b_i\\) | |-----|-------| | 1 | -0.577191652 | | 2 | 0.988205891 | | 3 | -0.897056937 | | 4 | 0.918206857 | | 5 | -0.756704078 | | 6 | 0.482199394 | | 7 | -0.193527818 | | 8 | 0.035868343 |</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#parameter-relationships","title":"Parameter Relationships","text":"<p>The mean of the gamma distribution equals the plus fraction average molecular weight:</p> \\[\\bar{M}_{C7+} = \\eta + \\alpha \\cdot \\beta\\] <p>Therefore, the scale parameter is calculated as:</p> \\[\\beta = \\frac{\\bar{M}_{C7+} - \\eta}{\\alpha}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#cumulative-distribution-functions","title":"Cumulative Distribution Functions","text":"<p>For splitting the plus fraction into SCN groups, NeqSim computes:</p> \\[P_0(M_b) = \\int_\\eta^{M_b} p(M) \\, dM = Q(M_b) \\cdot S(M_b)\\] <p>where:</p> \\[Q = \\frac{\\exp(-Y) \\cdot Y^\\alpha}{\\Gamma(\\alpha)}, \\quad Y = \\frac{M_b - \\eta}{\\beta}\\] \\[S = \\sum_{j=0}^{\\infty} \\frac{Y^j}{\\prod_{k=0}^{j}(\\alpha + k)} = \\frac{1}{\\alpha} + \\frac{Y}{\\alpha(\\alpha+1)} + \\frac{Y^2}{\\alpha(\\alpha+1)(\\alpha+2)} + \\cdots\\] <p>The first moment \\(P_1\\) is used for average molecular weight calculation:</p> \\[P_1(M_b) = Q(M_b) \\cdot \\left(S(M_b) - \\frac{1}{\\alpha}\\right)\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#mole-fraction-of-scn-group","title":"Mole Fraction of SCN Group","text":"<p>For an SCN group bounded by molecular weights \\(M_L\\) (lower) and \\(M_U\\) (upper):</p> \\[z_i = z_{C7+} \\cdot \\left[P_0(M_U) - P_0(M_L)\\right]\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#average-molecular-weight-of-scn-group","title":"Average Molecular Weight of SCN Group","text":"\\[\\bar{M}_i = \\eta + \\alpha \\cdot \\beta \\cdot \\frac{P_1(M_U) - P_1(M_L)}{P_0(M_U) - P_0(M_L)}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#shape-parameter-guidelines","title":"Shape Parameter Guidelines","text":"<p>The shape parameter \\(\\alpha\\) characterizes the fluid type:</p> Fluid Type Typical \\(\\alpha\\) Range Watson \\(K_w\\) Gas condensates 0.5 - 1.0 &gt; 12.5 Black oils 1.0 - 2.0 11.5 - 12.5 Heavy/naphthenic oils 2.0 - 4.0 &lt; 11.5"},{"location":"pvtsimulation/fluid_characterization_mathematics/#automatic-alpha-estimation","title":"Automatic Alpha Estimation","text":"<p>NeqSim can automatically estimate \\(\\alpha\\) using the Watson characterization factor:</p> \\[K_w = 4.5579 \\cdot M_{C7+}^{0.15178} \\cdot \\rho_{C7+}^{-1.18241}\\] <p>where \\(\\rho\\) is specific gravity (g/cm\u00b3). The estimated alpha is:</p> \\[\\alpha = \\begin{cases} 0.5 + 0.1(K_w - 12.5) &amp; K_w \\geq 12.5 \\text{ (paraffinic)} \\\\ 1.0 + 0.5(K_w - 11.5) &amp; 11.5 \\leq K_w &lt; 12.5 \\text{ (mixed)} \\\\ 1.5 + 0.5(K_w - 10.5) &amp; 10.5 \\leq K_w &lt; 11.5 \\text{ (naphthenic)} \\\\ 2.0 + 0.5(10.5 - K_w) &amp; K_w &lt; 10.5 \\text{ (aromatic)} \\end{cases}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#pedersen-exponential-model","title":"Pedersen Exponential Model","text":"<p>The Pedersen model (Pedersen et al., 1984) uses an exponential distribution:</p> \\[\\ln(z_n) = A + B \\cdot n\\] <p>where: - \\(z_n\\) = mole fraction of carbon number \\(n\\) - \\(A, B\\) = regression coefficients</p> <p>The coefficients are determined by matching: 1. The plus fraction mole fraction \\(z_{C7+}\\) 2. The plus fraction molecular weight \\(M_{C7+}\\) 3. The plus fraction density \\(\\rho_{C7+}\\)</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#density-correlation-pedersen","title":"Density Correlation (Pedersen)","text":"\\[\\rho_n = C_1 + C_2 \\cdot \\ln(n)\\] <p>where \\(C_1\\) and \\(C_2\\) are fitted to match the measured plus fraction density.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-property-correlations","title":"Critical Property Correlations","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#pedersen-correlations","title":"Pedersen Correlations","text":"<p>For SRK equation of state, critical properties are calculated using Pedersen et al. correlations:</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-temperature-k","title":"Critical Temperature (K)","text":"\\[T_c = a_0 \\cdot \\rho + a_1 \\cdot \\ln(M) + a_2 \\cdot M + \\frac{a_3}{M}\\] Coefficient Light Oil (M &lt; 1120 g/mol) Heavy Oil \\(a_0\\) 163.12 830.63 \\(a_1\\) 86.052 17.5228 \\(a_2\\) 0.43475 0.0455911 \\(a_3\\) -1877.4 -11348.4"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-pressure-bar","title":"Critical Pressure (bar)","text":"\\[P_c = \\exp\\left(0.01325 + b_0 + b_1 \\cdot \\rho^{b_4} + \\frac{b_2}{M} + \\frac{b_3}{M^2}\\right)\\] Coefficient Light Oil Heavy Oil \\(b_0\\) -0.13408 0.802988 \\(b_1\\) 2.5019 1.78396 \\(b_2\\) 208.46 156.740 \\(b_3\\) -3987.2 -6965.59 \\(b_4\\) 1.0 0.25"},{"location":"pvtsimulation/fluid_characterization_mathematics/#acentric-factor-srk-m-parameter","title":"Acentric Factor (SRK m-parameter)","text":"\\[m = c_0 + c_1 \\cdot M + c_2 \\cdot \\rho + c_3 \\cdot M^2\\] <p>For Peng-Robinson, different coefficients are used.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#riazi-daubert-correlations","title":"Riazi-Daubert Correlations","text":"<p>Alternative correlations based on molecular weight and specific gravity:</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-temperature-k_1","title":"Critical Temperature (K)","text":"\\[T_c = \\frac{5}{9} \\cdot 554.4 \\cdot \\exp(-1.3478 \\times 10^{-4} M - 0.61641 \\cdot \\rho) \\cdot M^{0.2998} \\cdot \\rho^{1.0555}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-pressure-bar_1","title":"Critical Pressure (bar)","text":"\\[P_c = 0.068947 \\cdot 4.5203 \\times 10^4 \\cdot \\exp(-1.8078 \\times 10^{-3} M - 0.3084 \\cdot \\rho) \\cdot M^{-0.8063} \\cdot \\rho^{1.6015}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#kesler-lee-correlations","title":"Kesler-Lee Correlations","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#acentric-factor","title":"Acentric Factor","text":"<p>For \\(T_{br} = T_b/T_c &lt; 0.8\\):</p> \\[\\omega = \\frac{\\ln(P_{br}) - 5.92714 + \\frac{6.09649}{T_{br}} + 1.28862 \\ln(T_{br}) - 0.169347 T_{br}^6}{15.2518 - \\frac{15.6875}{T_{br}} - 13.4721 \\ln(T_{br}) + 0.43577 T_{br}^6}\\] <p>For \\(T_{br} \\geq 0.8\\):</p> \\[\\omega = -7.904 + 0.1352 K_w - 0.007465 K_w^2 + 8.359 T_{br} + \\frac{1.408 - 0.01063 K_w}{T_{br}}\\] <p>where \\(P_{br} = 1.01325 / P_c\\) and \\(K_w = T_b^{1/3} / \\rho\\) is the Watson K-factor.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#density-correlations","title":"Density Correlations","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#watson-k-factor-method-uop","title":"Watson K-Factor Method (UOP)","text":"<p>The Universal Oil Products (UOP) characterization assumes constant Watson K for all SCN groups:</p> \\[K_w = 4.5579 \\cdot M_{C7+}^{0.15178} \\cdot \\rho_{C7+}^{-1.18241}\\] <p>Individual SCN densities:</p> \\[\\rho_i = 6.0108 \\cdot M_i^{0.17947} \\cdot K_w^{-1.18241}\\] <p>Limitation: Less accurate for heavy fractions (C20+).</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#sreide-correlation","title":"S\u00f8reide Correlation","text":"<p>S\u00f8reide (1989) developed a more accurate correlation for heavy fractions:</p> \\[SG = 0.2855 + C_f \\cdot (M - 66)^{0.13}\\] <p>where \\(SG\\) is specific gravity (same as \\(\\rho\\) in g/cm\u00b3) and \\(C_f\\) is calculated from the plus fraction:</p> \\[C_f = \\frac{SG_{C7+} - 0.2855}{(M_{C7+} - 66)^{0.13}}\\] <p>Individual SCN densities:</p> \\[\\rho_i = 0.2855 + C_f \\cdot (M_i - 66)^{0.13}\\] <p>Constrained to physical limits: \\(0.6 \\leq \\rho_i \\leq 1.2\\) g/cm\u00b3.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#boiling-point-correlations","title":"Boiling Point Correlations","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#sreide-correlation_1","title":"S\u00f8reide Correlation","text":"\\[T_b = \\frac{1}{1.8}\\left(1928.3 - 1.695 \\times 10^5 \\cdot M^{-0.03522} \\cdot \\rho^{3.266} \\cdot \\exp\\left(-4.922 \\times 10^{-3} M - 4.7685 \\rho + 3.462 \\times 10^{-3} M \\cdot \\rho\\right)\\right)\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#riazi-daubert-correlation","title":"Riazi-Daubert Correlation","text":"\\[T_b = \\left(\\frac{M}{5.805 \\times 10^{-5} \\cdot \\rho^{0.9371}}\\right)^{1/2.3776}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#polynomial-correlation-light-components","title":"Polynomial Correlation (Light Components)","text":"<p>For \\(M &lt; 540\\) g/mol:</p> \\[T_b = 2 \\times 10^{-6} M^3 - 0.0035 M^2 + 2.4003 M + 171.74\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#lumping-methods","title":"Lumping Methods","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#standard-weight-based-lumping","title":"Standard Weight-Based Lumping","text":"<p>SCN pseudo-components are grouped into \\(N\\) lumps with approximately equal weight fractions:</p> \\[w_{target} = \\frac{\\sum_i z_i \\cdot M_i}{N}\\] <p>For each lump \\(k\\), the properties are averaged:</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#mole-fraction","title":"Mole Fraction","text":"\\[z_k = \\sum_{i \\in k} z_i\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#molecular-weight","title":"Molecular Weight","text":"\\[M_k = \\frac{\\sum_{i \\in k} z_i \\cdot M_i}{z_k}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#density-volume-weighted","title":"Density (Volume-Weighted)","text":"\\[\\rho_k = \\frac{\\sum_{i \\in k} z_i \\cdot M_i}{\\sum_{i \\in k} \\frac{z_i \\cdot M_i}{\\rho_i}}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-properties","title":"Critical Properties","text":"<p>Mixing rules (typically mole-fraction weighted):</p> \\[T_{c,k} = \\sum_{i \\in k} \\frac{z_i}{z_k} \\cdot T_{c,i}\\] \\[P_{c,k} = \\sum_{i \\in k} \\frac{z_i}{z_k} \\cdot P_{c,i}\\] \\[\\omega_k = \\sum_{i \\in k} \\frac{z_i}{z_k} \\cdot \\omega_i\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#usage-examples","title":"Usage Examples","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#basic-whitson-gamma-characterization","title":"Basic Whitson Gamma Characterization","text":"<pre><code>import neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create fluid with plus fraction\nSystemInterface fluid = new SystemSrkEos(350.0, 150.0);\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.addPlusFraction(\"C7+\", 0.15, 150.0 / 1000.0, 0.82);  // MW in kg/mol, density in g/cm\u00b3\nfluid.setMixingRule(2);\n\n// Configure Whitson Gamma Model\nfluid.getCharacterization()\n    .setPlusFractionModel(\"Whitson Gamma Model\")\n    .setGammaShapeParameter(1.5)      // alpha for black oil\n    .setGammaMinMW(84.0)              // eta for C7+\n    .setGammaDensityModel(\"Soreide\"); // Use S\u00f8reide density correlation\n\n// Run characterization\nfluid.getCharacterization().characterisePlusFraction();\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#automatic-alpha-estimation_1","title":"Automatic Alpha Estimation","text":"<pre><code>// Let NeqSim estimate alpha based on Watson K-factor\nfluid.getCharacterization()\n    .setPlusFractionModel(\"Whitson Gamma Model\")\n    .setAutoEstimateGammaAlpha(true)\n    .setGammaDensityModel(\"Soreide\");\n\nfluid.getCharacterization().characterisePlusFraction();\n\n// Check the estimated alpha\ndouble alpha = ((PlusFractionModel.WhitsonGammaModel) \n    fluid.getCharacterization().getPlusFractionModel()).getAlpha();\ndouble watsonK = ((PlusFractionModel.WhitsonGammaModel) \n    fluid.getCharacterization().getPlusFractionModel()).getWatsonKFactor();\n\nSystem.out.println(\"Estimated alpha: \" + alpha);\nSystem.out.println(\"Watson K-factor: \" + watsonK);\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#pedersen-model-with-lumping","title":"Pedersen Model with Lumping","text":"<pre><code>fluid.getCharacterization()\n    .setPlusFractionModel(\"Pedersen\")\n    .setLumpingModel(\"Standard\");\n\nfluid.getCharacterization().getLumpingModel().setNumberOfPseudoComponents(6);\nfluid.getCharacterization().characterisePlusFraction();\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#accessing-characterized-data","title":"Accessing Characterized Data","text":"<pre><code>PlusFractionModelInterface model = fluid.getCharacterization().getPlusFractionModel();\n\ndouble[] moleFractions = model.getZ();\ndouble[] molecularWeights = model.getM();\ndouble[] densities = model.getDens();\n\nfor (int i = model.getFirstPlusFractionNumber(); i &lt; model.getLastPlusFractionNumber(); i++) {\n    if (moleFractions[i] &gt; 1e-10) {\n        System.out.printf(\"SCN %d: z=%.6f, M=%.1f g/mol, rho=%.4f g/cm\u00b3%n\",\n            i, moleFractions[i], molecularWeights[i] * 1000, densities[i]);\n    }\n}\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#pvt-regression-framework","title":"PVT Regression Framework","text":"<p>This section documents the PVT regression framework for automatic EOS model tuning based on experimental PVT report data. The framework is implemented in the <code>neqsim.pvtsimulation.regression</code> package.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#package-overview","title":"Package Overview","text":"Class Description <code>PVTRegression</code> Main regression framework class <code>RegressionParameter</code> Enum defining tunable parameters (BIPs, volume shifts, critical properties) <code>ExperimentType</code> Enum for experiment types (CCE, CVD, DLE, SEPARATOR, etc.) <code>CCEDataPoint</code>, <code>CVDDataPoint</code>, <code>DLEDataPoint</code>, <code>SeparatorDataPoint</code> Data point classes for each experiment type <code>RegressionParameterConfig</code> Configuration for each regression parameter with bounds <code>PVTRegressionFunction</code> Objective function extending LevenbergMarquardtFunction <code>RegressionResult</code> Result container with tuned fluid and uncertainty analysis <code>UncertaintyAnalysis</code> Statistical uncertainty quantification"},{"location":"pvtsimulation/fluid_characterization_mathematics/#overview_1","title":"Overview","text":"<p>PVT regression involves adjusting equation of state parameters to minimize the deviation between calculated and experimental properties. The framework handles multiple experiment types simultaneously while maintaining physical consistency.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#multi-objective-regression","title":"Multi-Objective Regression","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#objective-function","title":"Objective Function","text":"<p>The total objective function combines weighted contributions from different PVT experiments:</p> \\[F_{obj} = \\sum_{k} w_k \\cdot F_k\\] <p>where \\(w_k\\) are user-defined weights and \\(F_k\\) are individual experiment objective functions.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#constant-composition-expansion-cce","title":"Constant Composition Expansion (CCE)","text":"\\[F_{CCE} = \\sum_{i=1}^{N_{CCE}} \\left[ \\left(\\frac{V_{rel,i}^{calc} - V_{rel,i}^{exp}}{V_{rel,i}^{exp}}\\right)^2 + \\lambda_Y \\left(\\frac{Y_i^{calc} - Y_i^{exp}}{Y_i^{exp}}\\right)^2 \\right]\\] <p>where: - \\(V_{rel}\\) = relative volume - \\(Y\\) = gas compressibility factor (above saturation) - \\(\\lambda_Y\\) = weight factor for Y-function</p> <p>Key match points: - Saturation pressure \\(P_{sat}\\) - Relative volume curve - Oil/gas compressibility</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#constant-volume-depletion-cvd","title":"Constant Volume Depletion (CVD)","text":"\\[F_{CVD} = \\sum_{i=1}^{N_{CVD}} \\left[ \\left(\\frac{L_i^{calc} - L_i^{exp}}{L_i^{exp}}\\right)^2 + \\left(\\frac{Z_i^{calc} - Z_i^{exp}}{Z_i^{exp}}\\right)^2 + \\sum_{j} \\left(\\frac{y_{j,i}^{calc} - y_{j,i}^{exp}}{y_{j,i}^{exp}}\\right)^2 \\right]\\] <p>where: - \\(L\\) = liquid dropout (volume %) - \\(Z\\) = gas compressibility factor - \\(y_j\\) = produced gas composition</p> <p>Key match points: - Liquid dropout curve (retrograde condensation) - Two-phase Z-factor - Produced gas compositions at each stage</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#differential-liberation-expansion-dle","title":"Differential Liberation Expansion (DLE)","text":"\\[F_{DLE} = \\sum_{i=1}^{N_{DLE}} \\left[ \\left(\\frac{R_{s,i}^{calc} - R_{s,i}^{exp}}{R_{s,i}^{exp}}\\right)^2 + \\left(\\frac{B_{o,i}^{calc} - B_{o,i}^{exp}}{B_{o,i}^{exp}}\\right)^2 + \\left(\\frac{\\rho_{o,i}^{calc} - \\rho_{o,i}^{exp}}{\\rho_{o,i}^{exp}}\\right)^2 \\right]\\] <p>where: - \\(R_s\\) = solution gas-oil ratio - \\(B_o\\) = oil formation volume factor - \\(\\rho_o\\) = oil density</p> <p>Key match points: - Solution GOR curve - Oil FVF curve - Oil density/shrinkage - Gas gravity</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#separator-test","title":"Separator Test","text":"\\[F_{SEP} = \\left(\\frac{GOR^{calc} - GOR^{exp}}{GOR^{exp}}\\right)^2 + \\left(\\frac{B_o^{calc} - B_o^{exp}}{B_o^{exp}}\\right)^2 + \\left(\\frac{API^{calc} - API^{exp}}{API^{exp}}\\right)^2\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#viscosity-optional","title":"Viscosity (Optional)","text":"\\[F_{\\mu} = \\sum_{i} \\left(\\frac{\\mu_i^{calc} - \\mu_i^{exp}}{\\mu_i^{exp}}\\right)^2\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#automatic-binary-interaction-parameter-bip-optimization","title":"Automatic Binary Interaction Parameter (BIP) Optimization","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#bip-matrix-structure","title":"BIP Matrix Structure","text":"<p>For a system with \\(N_c\\) components, the symmetric BIP matrix has \\(N_c(N_c-1)/2\\) independent parameters. To reduce dimensionality, group-based BIPs are used:</p> Group Pairs Typical Starting \\(k_{ij}\\) Regression Range CH\u2084 - C\u2082-C\u2086 0.00 - 0.02 Fixed or narrow CH\u2084 - C7+ 0.02 - 0.05 Primary target CO\u2082 - HC 0.10 - 0.15 If CO\u2082 present N\u2082 - HC 0.04 - 0.08 If N\u2082 present H\u2082S - HC 0.05 - 0.10 If H\u2082S present C7+ - C7+ 0.00 Usually fixed"},{"location":"pvtsimulation/fluid_characterization_mathematics/#bip-correlation-carbon-number-based","title":"BIP Correlation (Carbon Number Based)","text":"<p>For C7+ pseudo-components, BIPs can be correlated:</p> \\[k_{ij} = k_{CH_4-C7+} \\cdot \\left(1 - \\left(\\frac{2\\sqrt{T_{c,i} \\cdot T_{c,j}}}{T_{c,i} + T_{c,j}}\\right)^n\\right)\\] <p>where \\(n\\) is a tunable exponent (typically 0.5-2.0).</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#optimization-strategy","title":"Optimization Strategy","text":"<ol> <li>Level 1: Tune \\(k_{CH_4-C7+}\\) to match saturation pressure</li> <li>Level 2: Tune \\(k_{C_2-C_6, C7+}\\) to improve phase envelope shape</li> <li>Level 3: Tune correlation exponent \\(n\\) for density matching</li> </ol>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#volume-translation-parameter-tuning","title":"Volume Translation Parameter Tuning","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#peneloux-volume-shift","title":"Peneloux Volume Shift","text":"<p>The Peneloux (1982) volume translation corrects liquid density without affecting VLE:</p> \\[V_{corrected} = V_{EOS} - \\sum_i x_i \\cdot c_i\\] <p>where \\(c_i\\) is the component volume shift parameter.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#regression-approach","title":"Regression Approach","text":"<p>For pseudo-components, express volume shift as:</p> \\[c_i = c_0 + c_1 \\cdot M_i + c_2 \\cdot M_i^2\\] <p>Objective: Minimize density deviation in single-phase liquid region:</p> \\[F_c = \\sum_{i} \\left(\\frac{\\rho_i^{calc} - \\rho_i^{exp}}{\\rho_i^{exp}}\\right)^2\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#rackett-equation-alternative","title":"Rackett Equation Alternative","text":"\\[Z_{RA,i} = Z_{RA}^{ref} + a \\cdot (M_i - M_{ref})\\] <p>where \\(Z_{RA}\\) is the Rackett compressibility factor and \\(a\\) is a tunable coefficient.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#critical-property-regression-for-pseudo-components","title":"Critical Property Regression for Pseudo-Components","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#parameterization","title":"Parameterization","text":"<p>Instead of regressing individual \\(T_c\\), \\(P_c\\), \\(\\omega\\) values, tune the correlation coefficients:</p> <p>Critical Temperature: $\\(T_c = (a_0 + \\Delta a_0) \\cdot \\rho + (a_1 + \\Delta a_1) \\cdot \\ln(M) + a_2 \\cdot M + \\frac{a_3}{M}\\)$</p> <p>Critical Pressure: $\\(\\ln(P_c) = (b_0 + \\Delta b_0) + b_1 \\cdot \\rho^{b_4} + \\frac{b_2}{M} + \\frac{b_3}{M^2}\\)$</p> <p>Acentric Factor: $\\(\\omega = (\\omega_{base} + \\Delta\\omega) \\cdot f(M, \\rho)\\)$</p> <p>where \\(\\Delta a_0\\), \\(\\Delta a_1\\), \\(\\Delta b_0\\), \\(\\Delta\\omega\\) are regression parameters.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#constraints","title":"Constraints","text":"<p>Physical bounds must be enforced:</p> \\[T_c &gt; T_b &gt; 0$$ $$P_c &gt; 0$$ $$0 &lt; \\omega &lt; 2$$ $$\\frac{\\partial T_c}{\\partial M} &gt; 0 \\text{ (monotonic increase)}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#uncertainty-quantification","title":"Uncertainty Quantification","text":""},{"location":"pvtsimulation/fluid_characterization_mathematics/#parameter-sensitivity-analysis","title":"Parameter Sensitivity Analysis","text":"<p>Compute the Jacobian matrix at the optimum:</p> \\[J_{ij} = \\frac{\\partial F_i}{\\partial \\theta_j}\\] <p>where \\(F_i\\) are individual residuals and \\(\\theta_j\\) are parameters.</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#covariance-matrix","title":"Covariance Matrix","text":"\\[\\text{Cov}(\\theta) = s^2 \\cdot (J^T J)^{-1}\\] <p>where \\(s^2\\) is the residual variance:</p> \\[s^2 = \\frac{F_{obj}}{N_{data} - N_{params}}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#confidence-intervals","title":"Confidence Intervals","text":"<p>95% confidence interval for parameter \\(\\theta_j\\):</p> \\[\\theta_j \\pm t_{0.975, N-p} \\cdot \\sqrt{\\text{Cov}(\\theta)_{jj}}\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#monte-carlo-uncertainty-propagation","title":"Monte Carlo Uncertainty Propagation","text":"<ol> <li>Sample parameters from multivariate normal: \\(\\theta \\sim N(\\hat{\\theta}, \\text{Cov}(\\theta))\\)</li> <li>Run flash calculations for each sample</li> <li>Compute prediction intervals for properties:</li> </ol> \\[P_{95\\%} = \\left[\\mu - 1.96\\sigma, \\mu + 1.96\\sigma\\right]\\]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#api-usage-example","title":"API Usage Example","text":"<pre><code>import neqsim.pvtsimulation.regression.*;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create base fluid\nSystemInterface fluid = new SystemSrkEos(373.15, 200.0);\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.addComponent(\"n-pentane\", 0.05);\nfluid.addPlusFraction(\"C7+\", 0.10, 0.150, 0.82);\nfluid.setMixingRule(2);\n\n// Create PVT regression framework\nPVTRegression regression = new PVTRegression(fluid);\n\n// Add experimental CCE data\ndouble[] pressures = {300.0, 250.0, 200.0, 150.0, 100.0};\ndouble[] relativeVolumes = {0.98, 1.00, 1.08, 1.25, 1.55};\nregression.addCCEData(pressures, relativeVolumes, 373.15);\n\n// Add DLE data\ndouble[] dlePressures = {250.0, 200.0, 150.0, 100.0};\ndouble[] rs = {150.0, 120.0, 85.0, 50.0};\ndouble[] bo = {1.45, 1.38, 1.30, 1.20};\ndouble[] oilDensity = {720.0, 740.0, 760.0, 780.0};\nregression.addDLEData(dlePressures, rs, bo, oilDensity, 373.15);\n\n// Configure regression parameters (with custom bounds or use defaults)\nregression.addRegressionParameter(RegressionParameter.BIP_METHANE_C7PLUS, 0.0, 0.10, 0.03);\nregression.addRegressionParameter(RegressionParameter.VOLUME_SHIFT_C7PLUS);  // Uses defaults\n\n// Set weights for multi-objective optimization\nregression.setExperimentWeight(ExperimentType.CCE, 1.0);\nregression.setExperimentWeight(ExperimentType.DLE, 1.5);  // Prioritize DLE matching\n\n// Configure optimization\nregression.setMaxIterations(100);\nregression.setVerbose(true);\n\n// Run regression\nRegressionResult result = regression.runRegression();\n\n// Get tuned fluid\nSystemInterface tunedFluid = result.getTunedFluid();\n\n// Get optimized parameter values\ndouble optimizedBIP = result.getOptimizedValue(RegressionParameter.BIP_METHANE_C7PLUS);\nSystem.out.println(\"Optimized BIP (CH4-C7+): \" + optimizedBIP);\n\n// Uncertainty analysis\nUncertaintyAnalysis uncertainty = result.getUncertainty();\ndouble[] ci = uncertainty.getConfidenceIntervalBounds(0);\nSystem.out.println(\"95% CI for BIP: [\" + ci[0] + \", \" + ci[1] + \"]\");\n\n// Generate summary report\nString summary = result.generateSummary();\nSystem.out.println(summary);\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#available-regression-parameters","title":"Available Regression Parameters","text":"Parameter Description Default Bounds <code>BIP_METHANE_C7PLUS</code> BIP between methane and C7+ fractions [0.0, 0.10, 0.03] <code>BIP_C2C6_C7PLUS</code> BIP between C2-C6 and C7+ fractions [0.0, 0.05, 0.01] <code>BIP_CO2_HC</code> BIP between CO\u2082 and hydrocarbons [0.08, 0.18, 0.12] <code>BIP_N2_HC</code> BIP between N\u2082 and hydrocarbons [0.02, 0.12, 0.05] <code>VOLUME_SHIFT_C7PLUS</code> Volume shift multiplier for C7+ [0.8, 1.2, 1.0] <code>TC_MULTIPLIER_C7PLUS</code> Critical temperature multiplier [0.95, 1.05, 1.0] <code>PC_MULTIPLIER_C7PLUS</code> Critical pressure multiplier [0.95, 1.05, 1.0] <code>OMEGA_MULTIPLIER_C7PLUS</code> Acentric factor multiplier [0.90, 1.10, 1.0] <code>PLUS_MOLAR_MASS_MULTIPLIER</code> Plus fraction MW multiplier [0.90, 1.10, 1.0] <code>GAMMA_ALPHA</code> Gamma distribution shape parameter [0.5, 4.0, 1.0] <code>GAMMA_ETA</code> Gamma distribution minimum MW [75.0, 95.0, 84.0]"},{"location":"pvtsimulation/fluid_characterization_mathematics/#data-input-format-csv","title":"Data Input Format (CSV)","text":"<p>CCE Data: <pre><code>Pressure(bara),RelativeVolume,YFactor\n350.0,0.9850,\n300.0,0.9912,\n250.0,1.0000,  # Saturation point\n200.0,1.0523,1.0234\n150.0,1.1876,1.0456\n</code></pre></p> <p>DLE Data: <pre><code>Pressure(bara),Rs(Sm3/Sm3),Bo(m3/Sm3),OilDensity(kg/m3),GasGravity\n250.0,150.5,1.425,725.3,0.85\n200.0,120.2,1.380,742.1,0.82\n150.0,85.6,1.312,761.5,0.79\n</code></pre></p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#implementation-status","title":"Implementation Status","text":"Phase Feature Status 1 CCE/DLE simulation with objective function \u2705 Implemented 2 BIP regression for saturation pressure \u2705 Implemented 3 Volume translation optimization \u2705 Implemented 4 CVD simulation and regression \u2705 Implemented 5 Critical property correlation tuning \u2705 Implemented 6 Multi-objective optimization framework \u2705 Implemented 7 Uncertainty quantification \u2705 Implemented 8 GUI/Report generation \ud83d\udd32 Future work"},{"location":"pvtsimulation/fluid_characterization_mathematics/#common-fluid-characterization-matching-pseudo-components","title":"Common Fluid Characterization (Matching Pseudo-Components)","text":"<p>When working with multiple reservoir fluids in a simulation model (e.g., compositional reservoir simulation, commingled production), all fluids must share the same pseudo-component (PC) structure. NeqSim provides utilities for this workflow based on Pedersen et al. (Chapter 5.5-5.6).</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#pseudocomponentcombiner-utility","title":"PseudoComponentCombiner Utility","text":"<p>The <code>PseudoComponentCombiner</code> class provides methods for matching fluid characterizations:</p> <pre><code>import neqsim.thermo.characterization.PseudoComponentCombiner;\n\n// Match source fluid to reference's PC structure\nSystemInterface matched = PseudoComponentCombiner.characterizeToReference(\n    sourceFluid, referenceFluid);\n\n// Combine multiple fluids with automatic common PC structure\nSystemInterface combined = PseudoComponentCombiner.combineReservoirFluids(\n    Arrays.asList(fluid1, fluid2, fluid3),\n    Arrays.asList(0.5, 0.3, 0.2));  // volume fractions\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#characterizationoptions","title":"CharacterizationOptions","text":"<p>For advanced control, use the <code>CharacterizationOptions</code> builder:</p> <pre><code>import neqsim.thermo.characterization.CharacterizationOptions;\nimport neqsim.thermo.characterization.CharacterizationOptions.NamingScheme;\n\nCharacterizationOptions options = CharacterizationOptions.builder()\n    .transferBinaryInteractionParameters(true)  // Copy BIPs from reference\n    .normalizeComposition(true)                 // Ensure mole fractions sum to 1.0\n    .namingScheme(NamingScheme.REFERENCE)       // Use reference component names\n    .generateValidationReport(true)             // Create before/after comparison\n    .build();\n\nSystemInterface matched = PseudoComponentCombiner.characterizeToReference(\n    sourceFluid, referenceFluid, options);\n</code></pre> Option Description Default <code>transferBinaryInteractionParameters</code> Copy BIPs from reference fluid <code>false</code> <code>normalizeComposition</code> Normalize mole fractions to sum to 1.0 <code>true</code> <code>namingScheme</code> Use SOURCE, REFERENCE, or MERGED names <code>REFERENCE</code> <code>generateValidationReport</code> Generate validation report <code>false</code>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#bip-transfer","title":"BIP Transfer","text":"<p>Binary Interaction Parameters (BIPs) can be transferred between fluids:</p> <pre><code>// Transfer BIPs during characterization\nPseudoComponentCombiner.transferBinaryInteractionParameters(\n    sourceFluid, referenceFluid);\n\n// Fluent API on Characterise class\nSystemInterface fluid = new SystemSrkEos(298, 50);\nfluid.addComponent(\"methane\", 0.7);\nfluid.addPlusFraction(\"C7+\", 0.3, 0.200, 0.85);\nfluid.getCharacterization()\n    .setTBPModel(\"PedersenSRK\")\n    .characterize()\n    .transferBipsFrom(tunedReferenceFluid);\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#validation-reports","title":"Validation Reports","text":"<p>The <code>CharacterizationValidationReport</code> provides before/after comparison:</p> <pre><code>CharacterizationValidationReport report = \n    PseudoComponentCombiner.generateValidationReport(sourceFluid, matchedFluid);\n\nSystem.out.println(\"Mass conserved: \" + report.isMassConserved());\nSystem.out.println(\"Moles conserved: \" + report.isMolesConserved());\nSystem.out.println(\"PC count before: \" + report.getSourcePseudoComponentCount());\nSystem.out.println(\"PC count after: \" + report.getResultPseudoComponentCount());\nSystem.out.println(report.toReportString());\n</code></pre>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#mathematical-background","title":"Mathematical Background","text":"<p>When matching a source fluid to a reference PC structure:</p> <ol> <li>Component Mapping: Discrete components (C1, C2, CO\u2082, etc.) are mapped directly</li> <li>PC Redistribution: Plus fraction moles are redistributed proportionally across reference PCs:</li> </ol> \\[z_i^{matched} = z_{C7+}^{source} \\cdot \\frac{z_i^{ref}}{\\sum_{j \\in PC} z_j^{ref}}\\] <ol> <li>Mass Conservation: Total mass is preserved through the redistribution</li> <li>BIP Transfer: For EOS phases, BIPs are copied element-by-element from reference</li> </ol>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#references","title":"References","text":"<ol> <li> <p>Whitson, C.H. (1983). \"Characterizing Hydrocarbon Plus Fractions.\" SPE Journal, 23(4), 683-694. SPE-12233-PA.</p> </li> <li> <p>Pedersen, K.S., Thomassen, P., and Fredenslund, A. (1984). \"Thermodynamics of Petroleum Mixtures Containing Heavy Hydrocarbons. 1. Phase Envelope Calculations by Use of the Soave-Redlich-Kwong Equation of State.\" Industrial &amp; Engineering Chemistry Process Design and Development, 23(1), 163-170.</p> </li> <li> <p>S\u00f8reide, I. (1989). \"Improved Phase Behavior Predictions of Petroleum Reservoir Fluids from a Cubic Equation of State.\" Dr.Ing. Thesis, Norwegian Institute of Technology (NTH), Trondheim.</p> </li> <li> <p>Riazi, M.R. and Daubert, T.E. (1980). \"Simplify Property Predictions.\" Hydrocarbon Processing, 59(3), 115-116.</p> </li> <li> <p>Kesler, M.G. and Lee, B.I. (1976). \"Improve Prediction of Enthalpy of Fractions.\" Hydrocarbon Processing, 55(3), 153-158.</p> </li> <li> <p>Whitson, C.H. and Brul\u00e9, M.R. (2000). \"Phase Behavior.\" SPE Monograph Series, Vol. 20. Society of Petroleum Engineers.</p> </li> </ol>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#appendix-a-unit-conventions-in-neqsim","title":"Appendix A: Unit Conventions in NeqSim","text":"Property Internal Unit Common Input Unit Molecular weight kg/mol g/mol (\u00f71000) Density g/cm\u00b3 g/cm\u00b3 or kg/m\u00b3 (\u00f71000) Temperature K \u00b0C (+273.15) Pressure bar bara Critical temperature K K Critical pressure bar bar <p>Note: When using <code>addPlusFraction()</code>, molecular weight should be in kg/mol and density in g/cm\u00b3 (specific gravity).</p>"},{"location":"pvtsimulation/fluid_characterization_mathematics/#appendix-b-mathematical-notation-summary","title":"Appendix B: Mathematical Notation Summary","text":"Symbol Description Typical Range \\(\\alpha\\) Gamma shape parameter 0.5 - 4.0 \\(\\beta\\) Gamma scale parameter Calculated \\(\\eta\\) Minimum molecular weight 84 - 90 g/mol \\(M\\) Molecular weight g/mol \\(\\rho\\) Density (specific gravity) 0.6 - 1.0 g/cm\u00b3 \\(K_w\\) Watson characterization factor 10 - 13 \\(T_c\\) Critical temperature K \\(P_c\\) Critical pressure bar \\(\\omega\\) Acentric factor 0.2 - 1.5 \\(T_b\\) Normal boiling point K \\(z\\) Mole fraction 0 - 1"},{"location":"pvtsimulation/pvt_workflow/","title":"PVT Workflow: From Lab Data to Tuned Fluid Model","text":"<p>This document describes the complete workflow for generating and tuning fluid models from laboratory PVT data in NeqSim.</p>"},{"location":"pvtsimulation/pvt_workflow/#typical-laboratory-pvt-report-data","title":"Typical Laboratory PVT Report Data","text":"<p>A standard PVT laboratory report contains the following sections. Below are example data tables showing the format typically received from labs like Core Lab, Schlumberger, or Intertek.</p>"},{"location":"pvtsimulation/pvt_workflow/#sample-information","title":"Sample Information","text":"<pre><code>Well Name:           A-1\nSample Type:         Bottom Hole Sample (BHS)\nSampling Depth:      2850 m TVD\nSampling Date:       2024-06-15\nReservoir Pressure:  285 bara\nReservoir Temp:      98 \u00b0C (371.15 K)\nSaturation Pressure: 248 bara (Bubble Point)\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#compositional-analysis-mole","title":"Compositional Analysis (Mole %)","text":"Component Mol % MW (g/mol) Density (g/cm\u00b3) N\u2082 0.34 28.01 - CO\u2082 3.53 44.01 - H\u2082S 0.00 34.08 - C\u2081 70.78 16.04 - C\u2082 8.94 30.07 - C\u2083 5.05 44.10 - i-C\u2084 0.85 58.12 - n-C\u2084 1.68 58.12 - i-C\u2085 0.62 72.15 - n-C\u2085 0.79 72.15 - C\u2086 0.83 86.18 0.664 C\u2087 1.06 92.2 0.7324 C\u2088 1.06 104.6 0.7602 C\u2089 0.79 119.1 0.7677 C\u2081\u2080 0.57 133.0 0.790 C\u2081\u2081 0.38 147.0 0.795 C\u2081\u2082+ 2.73 263.0 0.854 Total 100.00"},{"location":"pvtsimulation/pvt_workflow/#constant-composition-expansion-cce-at-98c","title":"Constant Composition Expansion (CCE) at 98\u00b0C","text":"Pressure (bara) Relative Volume Y-Factor Oil Density (kg/m\u00b3) Oil Viscosity (cP) 350 0.9521 - 612.3 0.285 300 0.9712 - 625.1 0.312 280 0.9845 - 632.8 0.328 248 (Psat) 1.0000 - 645.2 0.352 220 1.0523 2.145 658.4 0.385 200 1.1124 2.287 670.1 0.412 180 1.1892 2.456 682.5 0.445 150 1.3245 2.712 698.2 0.498 120 1.5421 3.024 715.8 0.562 100 1.7856 3.312 728.4 0.615"},{"location":"pvtsimulation/pvt_workflow/#differential-liberation-dle-at-98c","title":"Differential Liberation (DLE) at 98\u00b0C","text":"Pressure (bara) Rs (Sm\u00b3/Sm\u00b3) Bo (m\u00b3/Sm\u00b3) Oil Density (kg/m\u00b3) Oil Viscosity (cP) Gas Z-factor Gas Gravity 248 (Psat) 152.3 1.4521 645.2 0.352 - - 220 138.5 1.4012 658.4 0.385 0.862 0.745 200 125.2 1.3654 670.1 0.412 0.851 0.768 180 112.8 1.3285 682.5 0.445 0.838 0.792 150 94.5 1.2756 698.2 0.498 0.815 0.825 120 75.2 1.2198 715.8 0.562 0.792 0.861 100 61.8 1.1812 728.4 0.615 0.775 0.892 80 48.2 1.1425 742.1 0.685 0.758 0.928 50 28.5 1.0912 762.5 0.812 0.732 0.975 20 8.5 1.0385 785.2 1.025 0.712 1.045 1.01 (STO) 0.0 1.0000 825.4 2.850 - -"},{"location":"pvtsimulation/pvt_workflow/#constant-volume-depletion-cvd-at-98c-for-gas-condensates","title":"Constant Volume Depletion (CVD) at 98\u00b0C (for Gas Condensates)","text":"Pressure (bara) Liquid Dropout (%) Z-factor Cumulative Gas Produced (%) Liquid Density (kg/m\u00b3) 285 (Pdew) 0.0 0.892 0.0 - 260 4.2 0.875 8.5 612.5 230 8.5 0.856 18.2 628.4 200 12.8 0.838 28.5 645.2 170 15.2 0.821 39.8 658.7 140 14.5 0.805 51.2 672.1 110 12.1 0.792 62.8 685.4 80 8.8 0.781 74.5 698.2 50 5.2 0.772 86.2 712.5"},{"location":"pvtsimulation/pvt_workflow/#multi-stage-separator-test","title":"Multi-Stage Separator Test","text":"<p>Test Conditions:</p> Stage Pressure (bara) Temperature (\u00b0C) 1 (HP Sep) 45.0 45.0 2 (LP Sep) 8.0 35.0 3 (Stock Tank) 1.01 15.0 <p>Results:</p> Property Stage 1 Stage 2 Stage 3 Total GOR (Sm\u00b3/Sm\u00b3) 95.2 18.5 8.2 121.9 Gas Gravity 0.752 0.985 1.245 0.812 Oil Density (kg/m\u00b3) 712.5 758.2 825.4 - Oil Viscosity (cP) 0.52 0.85 2.45 - <p>Stock Tank Oil Properties: - API Gravity: 39.8 \u00b0API - Density: 825.4 kg/m\u00b3 - Formation Volume Factor (Bo): 1.385 rm\u00b3/Sm\u00b3 - Solution GOR (Rs): 121.9 Sm\u00b3/Sm\u00b3</p>"},{"location":"pvtsimulation/pvt_workflow/#viscosity-data-separate-measurements","title":"Viscosity Data (Separate Measurements)","text":"Pressure (bara) Temperature (\u00b0C) Oil Viscosity (cP) Gas Viscosity (cP) 285 98 0.285 0.0185 248 98 0.352 0.0178 200 98 0.412 0.0165 150 98 0.498 0.0148 100 98 0.615 0.0132 248 80 0.425 0.0168 248 60 0.585 0.0155"},{"location":"pvtsimulation/pvt_workflow/#swelling-test-co2-injection","title":"Swelling Test (CO\u2082 Injection)","text":"Cumulative CO\u2082 Injected (mol%) Saturation Pressure (bara) Relative Swelling Factor Oil Density (kg/m\u00b3) 0.0 248.0 1.000 645.2 5.0 268.5 1.025 638.4 10.0 292.1 1.052 630.1 15.0 318.4 1.082 620.5 20.0 348.2 1.115 608.2 25.0 382.5 1.152 594.8 30.0 421.8 1.195 578.5"},{"location":"pvtsimulation/pvt_workflow/#overview","title":"Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Lab PVT Data  \u2502\u2500\u2500\u2500\u25b6\u2502  Initial Fluid  \u2502\u2500\u2500\u2500\u25b6\u2502  EOS Regression \u2502\u2500\u2500\u2500\u25b6\u2502  Export Model   \u2502\n\u2502   (CCE,DLE,CVD) \u2502    \u2502  Characterization\u2502    \u2502  (Parameter Fit)\u2502    \u2502  (E300, CSV)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#step-1-create-initial-fluid-from-composition","title":"Step 1: Create Initial Fluid from Composition","text":"<p>Start with laboratory-reported composition and characterize heavy fractions:</p> <pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermo.system.SystemInterface;\n\n// Create fluid at reservoir conditions\nSystemInterface fluid = new SystemSrkEos(373.15, 250.0);  // T(K), P(bar)\n\n// Add defined components (from lab composition)\nfluid.addComponent(\"nitrogen\", 0.34);\nfluid.addComponent(\"CO2\", 3.53);\nfluid.addComponent(\"methane\", 70.78);\nfluid.addComponent(\"ethane\", 8.94);\nfluid.addComponent(\"propane\", 5.05);\nfluid.addComponent(\"i-butane\", 0.85);\nfluid.addComponent(\"n-butane\", 1.68);\nfluid.addComponent(\"i-pentane\", 0.62);\nfluid.addComponent(\"n-pentane\", 0.79);\nfluid.addComponent(\"n-hexane\", 0.83);\n\n// Add C7+ fractions (TBP cuts from lab)\nfluid.addTBPfraction(\"C7\", 1.06, 92.2/1000.0, 0.7324);   // name, mole%, MW(kg/mol), SG\nfluid.addTBPfraction(\"C8\", 1.06, 104.6/1000.0, 0.7602);\nfluid.addTBPfraction(\"C9\", 0.79, 119.1/1000.0, 0.7677);\nfluid.addTBPfraction(\"C10\", 0.57, 133.0/1000.0, 0.79);\n\n// Add plus fraction\nfluid.addPlusFraction(\"C20+\", 2.11, 381.0/1000.0, 0.88);\n\n// Characterize plus fraction into pseudo-components\nfluid.getCharacterization().characterisePlusFraction();\n\n// Initialize database and set mixing rule\nfluid.createDatabase(true);\nfluid.setMixingRule(2);  // Classic mixing rule\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#step-2-add-laboratory-pvt-data","title":"Step 2: Add Laboratory PVT Data","text":"<p>Import experimental data from CCE, DLE, CVD, and separator tests:</p> <pre><code>import neqsim.pvtsimulation.regression.PVTRegression;\nimport neqsim.pvtsimulation.regression.RegressionParameter;\n\nPVTRegression regression = new PVTRegression(fluid);\n\n// CCE (Constant Composition Expansion) data\ndouble[] ccePressures = {400, 350, 300, 280, 260, 240, 220, 200, 180};  // bara\ndouble[] cceRelVol = {0.95, 0.97, 0.99, 1.00, 1.02, 1.05, 1.10, 1.18, 1.30};\ndouble cceTemperature = 373.15;  // K\nregression.addCCEData(ccePressures, cceRelVol, cceTemperature);\n\n// DLE (Differential Liberation) data\ndouble[] dlePressures = {280, 240, 200, 160, 120, 80, 40, 1.01325};  // bara\ndouble[] dleRs = {150, 130, 110, 85, 60, 35, 15, 0};  // Sm\u00b3/Sm\u00b3\ndouble[] dleBo = {1.45, 1.40, 1.35, 1.28, 1.20, 1.12, 1.06, 1.02};  // m\u00b3/Sm\u00b3\ndouble[] dleOilDensity = {650, 680, 710, 740, 770, 800, 830, 850};  // kg/m\u00b3\ndouble dleTemperature = 373.15;  // K\nregression.addDLEData(dlePressures, dleRs, dleBo, dleOilDensity, dleTemperature);\n\n// CVD (Constant Volume Depletion) data - for gas condensates\ndouble[] cvdPressures = {350, 300, 250, 200, 150, 100};  // bara\ndouble[] cvdLiquidDropout = {0, 5, 12, 18, 15, 10};  // volume %\ndouble[] cvdZFactor = {0.85, 0.82, 0.80, 0.78, 0.77, 0.76};\ndouble cvdTemperature = 373.15;  // K\nregression.addCVDData(cvdPressures, cvdLiquidDropout, cvdZFactor, cvdTemperature);\n\n// Separator test data\nregression.addSeparatorData(\n    125.0,    // GOR (Sm\u00b3/Sm\u00b3)\n    1.35,     // Bo\n    35.0,     // API gravity\n    50.0,     // separator pressure (bar)\n    313.15,   // separator temperature (K)\n    373.15    // reservoir temperature (K)\n);\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#step-3-configure-regression-parameters","title":"Step 3: Configure Regression Parameters","text":"<p>Select which EOS parameters to tune:</p> <pre><code>// Binary Interaction Parameters (BIPs)\nregression.addRegressionParameter(RegressionParameter.BIP_METHANE_C7PLUS);\nregression.addRegressionParameter(RegressionParameter.BIP_C2C6_C7PLUS);\nregression.addRegressionParameter(RegressionParameter.BIP_CO2_HC);\n\n// Critical property multipliers for C7+ pseudo-components\nregression.addRegressionParameter(RegressionParameter.TC_MULTIPLIER_C7PLUS);\nregression.addRegressionParameter(RegressionParameter.PC_MULTIPLIER_C7PLUS);\nregression.addRegressionParameter(RegressionParameter.OMEGA_MULTIPLIER_C7PLUS);\n\n// Volume shift for density matching\nregression.addRegressionParameter(RegressionParameter.VOLUME_SHIFT_C7PLUS);\n\n// Viscosity parameters (if tuning viscosity)\nregression.addRegressionParameter(RegressionParameter.VISCOSITY_LBC_MULTIPLIER);\nregression.addRegressionParameter(RegressionParameter.VISCOSITY_PEDERSEN_ALPHA);\n\n// Custom bounds (optional)\nregression.addRegressionParameter(\n    RegressionParameter.BIP_METHANE_C7PLUS, \n    0.0,    // lower bound\n    0.15,   // upper bound\n    0.05    // initial guess\n);\n\n// Set experiment weights (optional)\nregression.setExperimentWeight(ExperimentType.CCE, 1.0);\nregression.setExperimentWeight(ExperimentType.DLE, 1.5);  // Higher weight for DLE\nregression.setExperimentWeight(ExperimentType.SEPARATOR, 1.0);\n\n// Optimization settings\nregression.setMaxIterations(200);\nregression.setTolerance(1e-8);\nregression.setVerbose(true);\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#step-4-run-regression","title":"Step 4: Run Regression","text":"<p>Execute the optimization:</p> <pre><code>import neqsim.pvtsimulation.regression.RegressionResult;\n\nRegressionResult result = regression.runRegression();\n\n// Get the tuned fluid\nSystemInterface tunedFluid = result.getTunedFluid();\n\n// Check results\nSystem.out.println(\"Final chi-square: \" + result.getChiSquare());\nSystem.out.println(\"Optimized parameters:\");\ndouble[] params = result.getOptimizedParameters();\nfor (int i = 0; i &lt; params.length; i++) {\n    System.out.println(\"  Parameter \" + i + \": \" + params[i]);\n}\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#step-5-validate-and-compare-with-lab-data","title":"Step 5: Validate and Compare with Lab Data","text":"<p>Generate comparison reports:</p> <pre><code>import neqsim.pvtsimulation.util.PVTReportGenerator;\nimport neqsim.pvtsimulation.simulation.*;\n\n// Run PVT simulations with tuned fluid\nConstantMassExpansion cce = new ConstantMassExpansion(tunedFluid);\ncce.setTemperature(373.15);\ncce.setPressures(ccePressures);\ncce.runCalc();\n\nDifferentialLiberation dle = new DifferentialLiberation(tunedFluid);\ndle.setTemperature(373.15);\ndle.setPressures(dlePressures);\ndle.runCalc();\n\n// Create report generator\nPVTReportGenerator report = new PVTReportGenerator(tunedFluid);\nreport.setProjectInfo(\"Field X Development\", \"Well A-1 Sample\");\nreport.setReservoirConditions(250.0, 100.0);  // P(bar), T(\u00b0C)\n\n// Add simulation results\nreport.addCCE(cce);\nreport.addDLE(dle);\n\n// Add lab data for comparison\nfor (int i = 0; i &lt; ccePressures.length; i++) {\n    report.addLabCCEData(ccePressures[i], \"RelVol\", cceRelVol[i], \"\");\n}\nfor (int i = 0; i &lt; dlePressures.length; i++) {\n    report.addLabDLEData(dlePressures[i], \"Bo\", dleBo[i], \"m\u00b3/Sm\u00b3\");\n    report.addLabDLEData(dlePressures[i], \"Rs\", dleRs[i], \"Sm\u00b3/Sm\u00b3\");\n}\n\n// Generate comparison with statistics\nString comparison = report.generateLabComparison();\nSystem.out.println(comparison);\n// Output includes AAD (Average Absolute Deviation) and ARE (Average Relative Error)\n\n// Generate full Markdown report\nString fullReport = report.generateMarkdownReport();\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#step-6-export-to-reservoir-simulator","title":"Step 6: Export to Reservoir Simulator","text":"<p>Export the tuned fluid model to Eclipse E300 format:</p> <pre><code>import neqsim.blackoil.io.EclipseEOSExporter;\nimport java.nio.file.Path;\n\n// Simple export with default settings\nEclipseEOSExporter.toFile(tunedFluid, Path.of(\"PVT_TUNED.INC\"));\n\n// Export with custom configuration\nEclipseEOSExporter.ExportConfig config = new EclipseEOSExporter.ExportConfig()\n    .setUnits(EclipseEOSExporter.Units.FIELD)      // METRIC or FIELD\n    .setReferenceTemperature(373.15)               // Reservoir temp (K)\n    .setIncludePVTO(true)                          // Live oil table\n    .setIncludePVTG(true)                          // Wet gas table\n    .setIncludePVTW(true)                          // Water properties\n    .setIncludeDensity(true)                       // Stock tank densities\n    .setComment(\"Tuned to Well A-1 PVT data\");\n\nEclipseEOSExporter.toFile(tunedFluid, Path.of(\"PVT_FIELD.INC\"), config);\n\n// Or get as string for inspection\nString eclipseContent = EclipseEOSExporter.toString(tunedFluid, config);\nSystem.out.println(eclipseContent);\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#generated-eclipse-keywords","title":"Generated Eclipse Keywords","text":"<p>The exporter produces standard Eclipse keywords:</p> <ul> <li>PVTO - Live oil PVT table (Rs, P, Bo, viscosity)</li> <li>PVTG - Wet gas PVT table (Rv, P, Bg, viscosity)  </li> <li>PVTW - Water PVT properties</li> <li>DENSITY - Stock tank densities (oil, water, gas)</li> </ul>"},{"location":"pvtsimulation/pvt_workflow/#unit-systems","title":"Unit Systems","text":"Unit System Pressure Density GOR/CGR Viscosity METRIC bar kg/m\u00b3 Sm\u00b3/Sm\u00b3 mPa\u00b7s FIELD psia lb/ft\u00b3 scf/stb cp"},{"location":"pvtsimulation/pvt_workflow/#step-7-export-csv-for-other-applications","title":"Step 7: Export CSV for Other Applications","text":"<p>Generate CSV files for spreadsheet analysis or other simulators:</p> <pre><code>// CCE data\nString cceCSV = report.generateCCECSV();\n\n// DLE data\nString dleCSV = report.generateDLECSV();\n\n// CVD data  \nString cvdCSV = report.generateCVDCSV();\n\n// Viscosity data\nString viscCSV = report.generateViscosityCSV();\n\n// Density data\nString densCSV = report.generateDensityCSV();\n\n// Swelling test\nString swellCSV = report.generateSwellingCSV();\n\n// GOR data\nString gorCSV = report.generateGORCSV();\n\n// MMP data\nString mmpCSV = report.generateMMPCSV();\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#available-regression-parameters","title":"Available Regression Parameters","text":"Parameter Description Typical Bounds <code>BIP_METHANE_C7PLUS</code> BIP between CH\u2084 and C7+ 0.0 - 0.10 <code>BIP_C2C6_C7PLUS</code> BIP between C2-C6 and C7+ 0.0 - 0.05 <code>BIP_CO2_HC</code> BIP between CO\u2082 and hydrocarbons 0.08 - 0.18 <code>BIP_N2_HC</code> BIP between N\u2082 and hydrocarbons 0.02 - 0.12 <code>VOLUME_SHIFT_C7PLUS</code> Volume shift multiplier for C7+ 0.8 - 1.2 <code>TC_MULTIPLIER_C7PLUS</code> Critical temperature multiplier 0.95 - 1.05 <code>PC_MULTIPLIER_C7PLUS</code> Critical pressure multiplier 0.95 - 1.05 <code>OMEGA_MULTIPLIER_C7PLUS</code> Acentric factor multiplier 0.90 - 1.10 <code>PLUS_MOLAR_MASS_MULTIPLIER</code> Plus fraction MW adjustment 0.90 - 1.10 <code>GAMMA_ALPHA</code> Whitson gamma distribution shape 0.5 - 4.0 <code>GAMMA_ETA</code> Whitson gamma min MW (\u03b7) 75.0 - 95.0 <code>VISCOSITY_LBC_MULTIPLIER</code> LBC viscosity correlation factor 0.8 - 1.5 <code>VISCOSITY_PEDERSEN_ALPHA</code> Pedersen viscosity parameter 0.5 - 2.0"},{"location":"pvtsimulation/pvt_workflow/#separator-optimization","title":"Separator Optimization","text":"<p>Find optimal separator conditions:</p> <pre><code>import neqsim.pvtsimulation.simulation.MultiStageSeparatorTest;\n\nMultiStageSeparatorTest sepTest = new MultiStageSeparatorTest(tunedFluid);\nsepTest.setReservoirConditions(250.0, 373.15);  // P(bar), T(K)\n\n// Add separator stages\nsepTest.addSeparatorStage(50.0, 40.0, \"HP Separator\");   // P(bar), T(\u00b0C)\nsepTest.addSeparatorStage(10.0, 30.0, \"LP Separator\");\nsepTest.addSeparatorStage(1.01325, 15.0, \"Stock Tank\");\n\n// Run simulation\nsepTest.run();\n\n// Optimize first stage pressure/temperature\nMultiStageSeparatorTest.OptimizationResult optResult = \n    sepTest.optimizeFirstStageSeparator(\n        5.0, 80.0, 16,    // pressure: min, max, steps\n        20.0, 60.0, 9     // temperature: min, max, steps\n    );\n\nSystem.out.println(\"Optimal P: \" + optResult.getOptimalPressure() + \" bara\");\nSystem.out.println(\"Optimal T: \" + optResult.getOptimalTemperature() + \" \u00b0C\");\nSystem.out.println(\"Max Recovery: \" + optResult.getMaximumOilRecovery());\nSystem.out.println(\"GOR at optimum: \" + optResult.getGorAtOptimum() + \" Sm\u00b3/Sm\u00b3\");\n</code></pre>"},{"location":"pvtsimulation/pvt_workflow/#complete-example","title":"Complete Example","text":"<p>See PVTRegressionTest.java for working examples.</p>"},{"location":"pvtsimulation/pvt_workflow/#related-documentation","title":"Related Documentation","text":"<ul> <li>Black Oil PVT Export</li> <li>Fluid Characterization Mathematics</li> <li>Whitson PVT Reader</li> </ul>"},{"location":"pvtsimulation/whitson_pvt_reader/","title":"Whitson PVT Parameter File Reader","text":"<p>The <code>WhitsonPVTReader</code> class enables NeqSim to read PVT parameter files exported from Whitson+ and similar PVT software, creating fully configured fluid systems with accurate thermodynamic properties.</p>"},{"location":"pvtsimulation/whitson_pvt_reader/#overview","title":"Overview","text":"<p>When working with PVT characterization software like Whitson+, you can export equation of state parameters and component properties to a tab-separated file format. The <code>WhitsonPVTReader</code> parses these files and creates NeqSim <code>SystemInterface</code> objects with:</p> <ul> <li>Correct EOS type (Peng-Robinson, SRK, or PR78)</li> <li>LBC viscosity model with custom parameters automatically applied</li> <li>C7+ gamma distribution parameters</li> <li>Custom Omega A and Omega B values</li> <li>Full component properties (MW, Tc, Pc, \u03c9, volume shift, etc.)</li> <li>Binary interaction parameters (complete matrix)</li> <li>Volume correction enabled by default</li> </ul>"},{"location":"pvtsimulation/whitson_pvt_reader/#file-format","title":"File Format","text":"<p>The Whitson PVT parameter file is a tab-separated text file with three main sections:</p>"},{"location":"pvtsimulation/whitson_pvt_reader/#1-parameters-section","title":"1. Parameters Section","text":"<p>Key-value pairs defining global EOS and model parameters:</p> <pre><code>Parameter   Value\nName    Predictive_EOS_Parameters\nEOS Type    PR\nLBC P0  0.1023\nLBC P1  0.023364\nLBC P2  0.058533\nLBC P3  -0.037734245\nLBC P4  0.00839916\nLBC F0  0.1\nC7+ Gamma Shape 0.677652\nC7+ Gamma Bound 94.9981\nOmega A, \u03a9A 0.457236\nOmega B, \u03a9B 0.0777961\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#2-component-table","title":"2. Component Table","text":"<p>Component properties with a header row and units row:</p> <pre><code>Component   MW  Pc  Tc  AF, \u03c9   Volume Shift, s ZcVisc  VcVisc  Vc  Zc  Pchor   SG  Tb  LMW\n-   -   bara    C   -   -   -   m3/kmol m3/kmol -   -   -   C   -\nCO2 44.01000    73.74000    30.97000    0.225000    0.001910    0.274330    0.09407 0.09407 0.274330    80.00   0.76193 -88.266 \nN2  28.01400    33.98000    -146.95000  0.037000    -0.167580   0.291780    0.09010 0.09010 0.291780    59.10   0.28339 -195.903    \nC1  16.04300    45.99000    -82.59000   0.011000    -0.149960   0.286200    0.09860 0.09860 0.286200    71.00   0.14609 -161.593    \n...\n</code></pre> <p>Column definitions: | Column | Description | Units | |--------|-------------|-------| | Component | Component name | - | | MW | Molecular weight | g/mol | | Pc | Critical pressure | bara | | Tc | Critical temperature | \u00b0C | | AF, \u03c9 | Acentric factor | - | | Volume Shift, s | Peneloux volume shift | - | | ZcVisc | Critical compressibility for viscosity | - | | VcVisc | Critical volume for viscosity | m\u00b3/kmol | | Vc | Critical volume | m\u00b3/kmol | | Zc | Critical compressibility | - | | Pchor | Parachor | - | | SG | Specific gravity | - | | Tb | Normal boiling point | \u00b0C | | LMW | Lumped molecular weight (optional) | g/mol |</p>"},{"location":"pvtsimulation/whitson_pvt_reader/#3-binary-interaction-parameters-bips","title":"3. Binary Interaction Parameters (BIPs)","text":"<p>Full symmetric matrix of binary interaction parameters:</p> <pre><code>BIPS    CO2 N2  C1  C2  C3  ...\nCO2 0.00    0.00    0.11    0.13    0.13    ...\nN2  0.00    0.00    0.03    0.01    0.09    ...\nC1  0.11    0.03    0.00    0.00    0.00    ...\n...\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#usage-examples","title":"Usage Examples","text":""},{"location":"pvtsimulation/whitson_pvt_reader/#basic-usage","title":"Basic Usage","text":"<p>Read a parameter file and create a fluid with equal molar composition:</p> <pre><code>import neqsim.thermo.util.readwrite.WhitsonPVTReader;\nimport neqsim.thermo.system.SystemInterface;\n\n// Read parameter file\nSystemInterface fluid = WhitsonPVTReader.read(\"path/to/volveparam.txt\");\n\n// Set conditions\nfluid.setTemperature(373.15);  // 100\u00b0C in Kelvin\nfluid.setPressure(200.0);       // 200 bar\n\n// Run flash calculation\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Get properties\ndouble density = fluid.getDensity(\"kg/m3\");\ndouble viscosity = fluid.getViscosity(\"cP\");\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#with-custom-composition","title":"With Custom Composition","text":"<p>Specify molar composition matching the component order in the file:</p> <pre><code>// Define composition (must match number of components in file)\ndouble[] composition = {\n    0.02,   // CO2\n    0.01,   // N2\n    0.70,   // C1\n    0.10,   // C2\n    0.05,   // C3\n    0.08,   // C7\n    0.04    // C10\n};\n\nSystemInterface fluid = WhitsonPVTReader.read(\"path/to/volveparam.txt\", composition);\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#accessing-parsed-parameters","title":"Accessing Parsed Parameters","text":"<p>The reader provides getters for extracted parameters:</p> <pre><code>WhitsonPVTReader reader = new WhitsonPVTReader();\nreader.parseFile(\"path/to/volveparam.txt\");\n\n// Get LBC viscosity parameters\ndouble[] lbcParams = reader.getLBCParameters();\n// Returns: [P0, P1, P2, P3, P4, F0]\n\n// Get C7+ gamma distribution parameters\ndouble[] gammaParams = reader.getGammaParameters();\n// Returns: [shape, bound]\n\n// Get Omega parameters\ndouble omegaA = reader.getOmegaA();\ndouble omegaB = reader.getOmegaB();\n\n// Get component information\nint numComponents = reader.getNumberOfComponents();\nList&lt;String&gt; names = reader.getComponentNames();\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#component-name-mapping","title":"Component Name Mapping","text":"<p>The reader automatically maps Whitson component names to NeqSim standard names:</p> Whitson Name NeqSim Name C1 methane C2 ethane C3 propane i-C4 i-butane n-C4 n-butane i-C5 i-pentane n-C5 n-pentane NEO-C5 22-dim-C3 C6 n-hexane N2 nitrogen CO2 CO2 H2S H2S H2O water <p>C7+ fractions (C7, C8, C9, ..., C36+) are added as pseudo-components with the suffix <code>_PC</code>.</p>"},{"location":"pvtsimulation/whitson_pvt_reader/#supported-eos-types","title":"Supported EOS Types","text":"File Value NeqSim Class PR SystemPrEos SRK SystemSrkEos PR78 SystemPrEos1978"},{"location":"pvtsimulation/whitson_pvt_reader/#integration-with-whitson-workflows","title":"Integration with Whitson+ Workflows","text":"<p>This reader enables seamless integration between Whitson+ PVT characterization and NeqSim process simulation:</p> <ol> <li>PVT Characterization: Use Whitson+ to fit EOS parameters to laboratory data (CCE, CVD, DLE, separator tests)</li> <li>Parameter Export: Export the fitted parameters to a tab-separated file</li> <li>NeqSim Import: Use <code>WhitsonPVTReader</code> to create a NeqSim fluid</li> <li>Process Simulation: Use the characterized fluid in NeqSim process simulations</li> </ol> <p>This workflow ensures consistency between PVT modeling and process simulation, using the same EOS parameters throughout.</p>"},{"location":"pvtsimulation/whitson_pvt_reader/#pvt-simulations-with-imported-fluids","title":"PVT Simulations with Imported Fluids","text":"<p>Once a fluid is created from a Whitson file, you can run standard PVT simulations:</p> <pre><code>import neqsim.pvtsimulation.simulation.*;\nimport neqsim.pvtsimulation.util.PVTReportGenerator;\n\n// Create fluid from Whitson file\ndouble[] composition = {0.02, 0.01, 0.70, 0.10, 0.05, 0.08, 0.04};\nSystemInterface fluid = WhitsonPVTReader.read(\"volveparam.txt\", composition);\n\n// Initialize\nfluid.setTemperature(373.15);  // 100\u00b0C\nfluid.setPressure(300.0);\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\n// Saturation pressure (dew point for gas condensate)\nSaturationPressure satPres = new SaturationPressure(fluid);\nsatPres.setTemperature(100.0, \"C\");\nsatPres.run();\ndouble psat = satPres.getSaturationPressure();\n\n// Constant Composition Expansion (CCE)\nConstantMassExpansion cce = new ConstantMassExpansion(fluid);\ncce.setTemperature(100.0, \"C\");\ncce.setPressures(new double[]{300, 250, 200, 150, 100});\ncce.runCalc();\ndouble[] relVol = cce.getRelativeVolume();\n\n// Multi-Stage Separator Test\nMultiStageSeparatorTest sepTest = new MultiStageSeparatorTest(fluid);\nsepTest.setReservoirConditions(300.0, 100.0);\nsepTest.addSeparatorStage(50.0, 40.0, \"HP Separator\");\nsepTest.addSeparatorStage(10.0, 30.0, \"LP Separator\");\nsepTest.addSeparatorStage(1.01325, 15.0, \"Stock Tank\");\nsepTest.run();\n\ndouble gor = sepTest.getTotalGOR();        // Sm\u00b3/Sm\u00b3\ndouble bo = sepTest.getBo();               // m\u00b3/Sm\u00b3\ndouble apiGravity = sepTest.getStockTankAPIGravity();\ndouble stockTankDensity = sepTest.getStockTankOilDensity();  // kg/m\u00b3\n\n// Get oil properties at each separator stage\nfor (var stage : sepTest.getStageResults()) {\n    double oilDensity = stage.getOilDensity();     // kg/m\u00b3\n    double oilViscosity = stage.getOilViscosity(); // cP\n}\n\n// Generate PVT Report\nPVTReportGenerator report = new PVTReportGenerator(fluid);\nreport.setProjectInfo(\"My Project\", \"Gas Condensate Sample\")\n      .setReservoirConditions(300.0, 100.0)\n      .setSaturationPressure(psat, false)  // false = dew point\n      .addCCE(cce)\n      .addSeparatorTest(sepTest);\n\nString markdownReport = report.generateMarkdownReport();\nSystem.out.println(markdownReport);\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#lbc-viscosity-model","title":"LBC Viscosity Model","text":"<p>The reader automatically applies the LBC viscosity model with the parameters from the Whitson file (P0-P4). The viscosity is calculated using:</p> <pre><code>// Viscosity is automatically calculated with LBC model\nfluid.initPhysicalProperties();\n\n// Gas phase viscosity\ndouble gasViscosity = fluid.getPhase(\"gas\").getPhysicalProperties().getViscosity();\ndouble gasViscosityCP = gasViscosity * 1000;  // Convert Pa\u00b7s to cP\n\n// Oil phase viscosity (if oil phase exists)\nif (fluid.hasPhaseType(\"oil\")) {\n    double oilViscosity = fluid.getPhase(\"oil\").getPhysicalProperties().getViscosity();\n    double oilViscosityCP = oilViscosity * 1000;  // Convert Pa\u00b7s to cP\n}\n</code></pre> <p>You can also use <code>ViscositySim</code> to calculate viscosity at multiple pressures:</p> <pre><code>import neqsim.pvtsimulation.simulation.ViscositySim;\n\nViscositySim viscSim = new ViscositySim(fluid);\ndouble[] pressures = {300.0, 250.0, 200.0, 150.0, 100.0};\ndouble[] temperatures = new double[pressures.length];\nArrays.fill(temperatures, 373.15);  // 100\u00b0C in Kelvin\nviscSim.setTemperaturesAndPressures(temperatures, pressures);\nviscSim.runCalc();\n\ndouble[] gasViscosity = viscSim.getGasViscosity();   // Pa\u00b7s (multiply by 1000 for cP)\ndouble[] oilViscosity = viscSim.getOilViscosity();   // Pa\u00b7s (multiply by 1000 for cP)\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#example-output","title":"Example Output","text":"<p>A typical PVT report for a gas condensate fluid created from a Whitson parameter file:</p> <pre><code># PVT Study Report\n\n## Project Information\n\n| Property | Value |\n|----------|-------|\n| Project | Whitson PVT Reader Test |\n| Fluid Name | Test Gas Condensate |\n| Report Date | 2025-12-15 12:59 |\n\n## Reservoir Conditions\n\n| Property | Value | Unit |\n|----------|-------|------|\n| Reservoir Pressure | 300.0 | bara |\n| Reservoir Temperature | 100.0 | \u00b0C |\n| Dew Point Pressure | 248.41 | bara |\n\n## Fluid Composition\n\n| Component | Mole Fraction | MW (g/mol) |\n|-----------|--------------|------------|\n| CO2 | 0.020000 | 44.01 |\n| nitrogen | 0.010000 | 28.01 |\n| methane | 0.700000 | 16.04 |\n| ethane | 0.100000 | 30.07 |\n| propane | 0.050000 | 44.10 |\n| C7_PC | 0.080000 | 97.63 |\n| C10_PC | 0.040000 | 134.47 |\n\n## Constant Composition Expansion (CCE)\n\n| Pressure (bara) | Rel. Volume | Y-Factor | Density (kg/m\u00b3) |\n|-----------------|-------------|----------|-----------------|\n| 298.1 | 0.8332 | - | 332.0 |\n| 273.2 | 0.8703 | - | 318.3 |\n| 248.4 | 0.9163 | - | 302.8 |\n| 223.6 | 1.0042 | 1.1212 | 234.5 |\n| 198.7 | 1.1188 | 1.0966 | 193.6 |\n| 173.9 | 1.2725 | 1.0707 | 160.5 |\n\n## Separator Test\n\n=== Multi-Stage Separator Test Results ===\n\nReservoir Conditions: P = 300.0 bara, T = 100.0 \u00b0C\nNumber of Stages: 3\n\nStage-by-Stage Results:\n| Stage | P (bara) | T (\u00b0C) | GOR (Sm\u00b3/Sm\u00b3) | Cum GOR (Sm\u00b3/Sm\u00b3) |\n|-------|----------|--------|---------------|-------------------|\n| HP Separator | 50.0 | 40.0 | 1096.9 | 1096.9 |\n| LP Separator | 10.0 | 30.0 | 53.9 | 1150.8 |\n| Stock Tank | 1.0 | 15.0 | 23.6 | 1174.4 |\n\nOverall Results:\n  Total GOR:           1174.4 Sm\u00b3/Sm\u00b3\n  Bo (FVF):            5.0880 rm\u00b3/Sm\u00b3\n  Stock Tank Density:  751.5 kg/m\u00b3\n  API Gravity:         56.6 \u00b0API\n\n## Quality Metrics\n\n---\n*Report generated by NeqSim PVT Report Generator*\n</code></pre>"},{"location":"pvtsimulation/whitson_pvt_reader/#additional-pvt-data","title":"Additional PVT Data","text":""},{"location":"pvtsimulation/whitson_pvt_reader/#gas-viscosity-lbc-model","title":"Gas Viscosity (LBC Model)","text":"Pressure (bara) Viscosity (cP) 300.0 0.0387 250.0 0.0340 200.0 0.0227 150.0 0.0178 100.0 0.0151"},{"location":"pvtsimulation/whitson_pvt_reader/#gas-density","title":"Gas Density","text":"Pressure (bara) Density (kg/m\u00b3) 300.0 333.04 250.0 303.87 200.0 195.47 150.0 132.69 100.0 82.11"},{"location":"pvtsimulation/whitson_pvt_reader/#separator-stage-oil-properties","title":"Separator Stage Oil Properties","text":"Stage P (bara) T (\u00b0C) Oil Density (kg/m\u00b3) Oil Viscosity (cP) HP Separator 50.0 40.0 - 0.6315 LP Separator 10.0 30.0 675.35 0.6143 Stock Tank 1.0 15.0 723.65 0.6643"},{"location":"pvtsimulation/whitson_pvt_reader/#oil-properties-vs-pressure","title":"Oil Properties vs Pressure","text":"<p>For gas condensates, an oil (condensate) phase forms below the dew point pressure. The properties are:</p> Pressure (bara) Density (kg/m\u00b3) Viscosity (cP) 200.0 482.81 0.0666 150.0 544.85 0.0903 <p>Note: Oil phase only exists below the dew point pressure (248.4 bara for this fluid).</p>"},{"location":"pvtsimulation/whitson_pvt_reader/#gas-condensate-metrics-summary","title":"Gas Condensate Metrics Summary","text":"Property Value Unit Dew Point Pressure 248.41 bara GOR 1174.4 Sm\u00b3/Sm\u00b3 CGR 5.4 bbl/MMscf Bo 5.0880 m\u00b3/Sm\u00b3 Stock Tank API 56.6 \u00b0API Stock Tank Density 751.5 kg/m\u00b3 Molar Mass 30.79 g/mol"},{"location":"pvtsimulation/whitson_pvt_reader/#see-also","title":"See Also","text":"<ul> <li>EclipseFluidReadWrite - Reader for Eclipse E300 PVT files</li> <li>Fluid Characterization - Mathematical background for C7+ characterization</li> <li>BIP Estimation - Binary interaction parameter correlations</li> <li>Viscosity Models - LBC and other viscosity model documentation</li> </ul>"},{"location":"safety/","title":"Safety Systems Documentation","text":"<p>Documentation for safety-related features and systems in NeqSim.</p>"},{"location":"safety/#overview","title":"Overview","text":"<p>This folder contains guides for implementing safety systems in process simulations, including Emergency Shutdown (ESD), High Integrity Pressure Protection Systems (HIPPS), blowdown analysis, and alarm management.</p>"},{"location":"safety/#documentation-index","title":"Documentation Index","text":""},{"location":"safety/#emergency-shutdown-esd","title":"Emergency Shutdown (ESD)","text":"Document Description ESD_BLOWDOWN_SYSTEM.md Complete ESD and blowdown system guide PRESSURE_MONITORING_ESD.md Pressure monitoring for ESD"},{"location":"safety/#hipps-high-integrity-pressure-protection","title":"HIPPS (High Integrity Pressure Protection)","text":"Document Description HIPPS_SUMMARY.md HIPPS overview and summary hipps_implementation.md HIPPS implementation details hipps_safety_logic.md HIPPS safety logic programming"},{"location":"safety/#safety-architecture","title":"Safety Architecture","text":"Document Description INTEGRATED_SAFETY_SYSTEMS.md Integrated safety systems overview layered_safety_architecture.md Layered safety architecture (defense in depth) sis_logic_implementation.md Safety Instrumented Systems (SIS) logic integration_safety_chain_tests.md Safety chain integration testing SAFETY_SIMULATION_ROADMAP.md Safety simulation development roadmap"},{"location":"safety/#fire-and-thermal-protection","title":"Fire and Thermal Protection","text":"Document Description fire_blowdown_capabilities.md Fire case blowdown simulation fire_heat_transfer_enhancements.md Fire heat transfer modeling"},{"location":"safety/#relief-systems","title":"Relief Systems","text":"Document Description psv_dynamic_sizing_example.md Pressure Safety Valve dynamic sizing rupture_disk_dynamic_behavior.md Rupture disk dynamic behavior"},{"location":"safety/#alarms","title":"Alarms","text":"Document Description alarm_system_guide.md Alarm system implementation guide alarm_triggered_logic_example.md Alarm-triggered logic examples"},{"location":"safety/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Process simulation overview</li> <li>Process Safety - Safety equipment classes</li> <li>Controllers - Controller devices</li> </ul>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/","title":"ESD Blowdown System Implementation","text":""},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#overview","title":"Overview","text":"<p>This implementation adds a complete Emergency Shutdown (ESD) blowdown system to NeqSim, including:</p> <ol> <li>BlowdownValve (BDValve) - A normally-closed valve that opens during ESD events</li> <li>PushButton - A manual instrument that can activate the blowdown valve</li> <li>Orifice - ISO 5167 pressure-driven flow restriction for controlled depressurization</li> <li>Flare Integration - Safe disposal of blowdown gas</li> </ol>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#components-created","title":"Components Created","text":""},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#1-blowdownvalve-class","title":"1. BlowdownValve Class","text":"<p>Location: <code>src/main/java/neqsim/process/equipment/valve/BlowdownValve.java</code></p> <p>Key Features: - Normally closed (fail-safe design) - Configurable opening time (default 5 seconds) - Activation tracking - Transient behavior during opening - Reset capability</p> <p>Usage Example: <pre><code>// Create blowdown valve\nBlowdownValve bdValve = new BlowdownValve(\"BD-101\", blowdownStream);\nbdValve.setOpeningTime(5.0); // 5 seconds to fully open\n\n// Activate in emergency\nbdValve.activate();\n\n// Check status\nif (bdValve.isActivated()) {\n    System.out.println(\"Blowdown in progress\");\n}\n</code></pre></p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#2-pushbutton-instrument","title":"2. PushButton Instrument","text":"<p>Location: <code>src/main/java/neqsim/process/measurementdevice/PushButton.java</code></p> <p>Key Features: - Binary state: pushed (1.0) or not pushed (0.0) - Links to BlowdownValve for automatic activation - Auto-activation can be enabled/disabled - Measured value integration with alarm systems - Safety feature: button reset doesn't reset valve</p> <p>Usage Example: <pre><code>// Create push button linked to BD valve\nPushButton esdButton = new PushButton(\"ESD-PB-101\", bdValve);\n\n// Operator pushes button in emergency\nesdButton.push(); // Automatically activates linked BD valve\n\n// Check button state\nif (esdButton.isPushed()) {\n    System.out.println(\"ESD button pushed - blowdown active\");\n}\n\n// Reset button (valve stays activated for safety)\nesdButton.reset();\n</code></pre></p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#3-orifice-class-transient-mode","title":"3. Orifice Class (Transient Mode)","text":"<p>Location: <code>src/main/java/neqsim/process/equipment/diffpressure/Orifice.java</code></p> <p>Key Features: - ISO 5167 compliant flow calculations - Pressure-driven flow in transient simulations - Reader-Harris/Gallagher discharge coefficient - Compressible flow with expansibility factor - Automatic flow calculation based on \u0394P</p> <p>Transient Behavior: In dynamic/transient mode, the orifice acts as a pressure-driven flow restriction device. Unlike steady-state mode where flow may be specified upstream, in transient mode the orifice calculates and determines the actual flow based on the pressure differential:</p> <p>Flow Equation (ISO 5167): <pre><code>m = A \u00d7 C \u00d7 \u03b5 \u00d7 \u221a(2\u03c1\u0394P / (1 - \u03b2\u2074))\n</code></pre></p> <p>Where: - A = orifice area (m\u00b2) - C = discharge coefficient - \u03b5 = expansibility factor (accounts for compressibility) - \u03c1 = fluid density at inlet (kg/m\u00b3) - \u0394P = pressure drop across orifice (Pa) - \u03b2 = diameter ratio (d/D)</p> <p>Usage Example: <pre><code>// Create orifice with ISO 5167 parameters\n// Orifice(name, pipeDiameter, orificeDiameter, P_upstream_ref, P_downstream, dischargeCoeff)\nOrifice bdOrifice = new Orifice(\"BD-Orifice\", \n    0.45,  // Pipe diameter (m)\n    0.18,  // Orifice diameter (m)\n    60.0,  // Upstream reference pressure (bara)\n    1.5,   // Downstream pressure - flare header (bara)\n    0.61); // Discharge coefficient\n\n// In transient simulation, the orifice automatically calculates flow\nbdOrifice.runTransient(timeStep, uuid);\n\n// As separator pressure drops, orifice flow decreases\n// Example: \u0394P 22.5\u21924.2 bar causes flow to drop 29,110\u21927,756 kg/hr (73% reduction)\n</code></pre></p> <p>Important Notes: - The <code>pressureDownstream</code> parameter sets the boundary pressure (e.g., flare header at 1.5 bara) - Flow automatically decreases as upstream pressure drops during blowdown - Properly models the \u221a(\u0394P) relationship - flow reduces as driving force decreases - Essential for realistic depressurization rate calculations</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#4-complete-esd-system-test","title":"4. Complete ESD System Test","text":"<p>Location: <code>src/test/java/neqsim/process/equipment/valve/BlowdownValveESDSystemTest.java</code></p> <p>Test Coverage: - Complete ESD blowdown scenario with dynamic simulation - Pressure-driven orifice flow validation (flow decreases with \u0394P) - Push button operation and integration - Manual mode (auto-activation disabled) - Blowdown valve behavior in isolation - Multiple blowdown sources to common flare - Pressure relief and monitoring scenarios</p> <p>Key Scenario: 1. Normal operation with gas to process 2. ESD activation via push button at t=10s 3. Splitter redirects gas from process to blowdown 4. BD valve opens over 5 seconds 5. Gas flows through orifice to flare - flow rate automatically decreases as separator depressurizes 6. Orifice demonstrates ISO 5167 behavior: flow \u221d \u221a(\u0394P) 7. Flare tracks heat release and emissions</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#5-demonstration-example","title":"5. Demonstration Example","text":"<p>Location: <code>src/main/java/neqsim/process/util/example/ESDBlowdownSystemExample.java</code></p> <p>A standalone runnable example showing: - System configuration - Normal operation - ESD activation via push button - Dynamic blowdown simulation - Performance summary</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#system-architecture","title":"System Architecture","text":"<pre><code>Separator (50 bara)\n    |\n    v\nGas Splitter\n    |\n    +----&gt; Process Stream (normal operation)\n    |\n    +----&gt; Blowdown Stream\n              |\n              v\n         BD Valve (BD-101) &lt;--- ESD Push Button (ESD-PB-101)\n              |\n              v\n         BD Orifice - ISO 5167 pressure-driven flow\n              |      Flow = f(\u221a\u0394P) - decreases as P\u2081 drops\n              |      Controls depressurization rate\n              v\n         Flare Header (1.5 bara)\n              |\n              v\n         Flare - Combusts blowdown gas\n</code></pre>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#physics-and-behavior","title":"Physics and Behavior","text":""},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#orifice-flow-dynamics","title":"Orifice Flow Dynamics","text":"<p>In transient simulations, the orifice flow is pressure-driven following ISO 5167:</p> <pre><code>Flow Rate \u221d \u221a(\u0394P)\n</code></pre> <p>Example from ESD Simulation: - t=10s: Separator at 24.02 bara, \u0394P=22.52 bar \u2192 Flow=29,110 kg/hr - t=30s: Separator at 5.68 bara, \u0394P=4.18 bar \u2192 Flow=7,756 kg/hr - Result: 88.6% pressure reduction \u2192 73.4% flow reduction</p> <p>This demonstrates realistic depressurization behavior where: 1. Initial flow is high due to large pressure differential 2. As separator depressurizes, driving force (\u0394P) decreases 3. Flow rate automatically reduces following \u221a(\u0394P) relationship 4. Prevents excessive depressurization rates at low pressures 5. Provides controlled, safe blowdown progression</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#why-this-matters-for-safety-studies","title":"Why This Matters for Safety Studies","text":"<p>Realistic Depressurization Profiles: - Flow isn't constant during blowdown - Initial high flow rates decrease over time - Matches real-world orifice behavior - Critical for flare load calculations - Important for time-to-depressurize estimates</p> <p>PSV/Rupture Disc Scenarios: - Accurate flow vs. pressure relationships - Proper flare sizing - Realistic heat release profiles - Better emissions estimates</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#key-design-features","title":"Key Design Features","text":""},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#safety","title":"Safety","text":"<ul> <li>Blowdown valve is normally closed (fail-safe)</li> <li>Push button reset does NOT reset valve (requires operator action)</li> <li>Orifice provides pressure-driven flow control (ISO 5167)</li> <li>Automatic flow reduction as pressure decreases - prevents over-depressurization</li> <li>All safety actions are logged and tracked</li> </ul>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#flexibility","title":"Flexibility","text":"<ul> <li>Auto-activation can be enabled/disabled</li> <li>Multiple blowdown sources can feed common flare</li> <li>Configurable opening times and flow capacities</li> <li>Integration with existing alarm systems</li> </ul>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#monitoring","title":"Monitoring","text":"<ul> <li>Real-time tracking of valve opening percentage</li> <li>Pressure-dependent flow rate through orifice</li> <li>Dynamic \u0394P and flow relationship validation</li> <li>Flare heat release and emissions</li> <li>Cumulative gas blown down</li> <li>System state tracking</li> </ul>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#running-the-example","title":"Running the Example","text":""},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#via-main-method","title":"Via Main Method:","text":"<pre><code>mvn exec:java -Dexec.mainClass=\"neqsim.process.util.example.ESDBlowdownSystemExample\"\n</code></pre>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#via-test","title":"Via Test:","text":"<pre><code>mvn test -Dtest=BlowdownValveESDSystemTest\n</code></pre>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#expected-output","title":"Expected Output","text":"<p>The system will show: 1. Configuration - System setup and parameters 2. Normal Operation - Initial steady state 3. ESD Activation - Push button activation 4. Dynamic Simulation - Blowdown progression over time 5. Summary - Total gas blown down, heat released, emissions</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#sample-output","title":"Sample Output:","text":"<pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551        EMERGENCY SHUTDOWN (ESD) BLOWDOWN SYSTEM TEST          \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n\u2550\u2550\u2550 SYSTEM CONFIGURATION \u2550\u2550\u2550\nSeparator operating pressure: 50.0 bara\nGas flow rate: 10000.0 kg/hr\nBlowdown valve: BD-101 (normally closed)\nESD Push Button: ESD-PB-101 (linked to BD-101)\nBD Orifice Cv: 150.0\nFlare header pressure: 1.5 bara\nBD valve opening time: 5.0 seconds\n\n&gt;&gt;&gt; OPERATOR PUSHES ESD BUTTON - BLOWDOWN INITIATED &lt;&lt;&lt;\n\nTime (s) | Sep Press | Process Flow | BD Flow    | BD Opening | Flare Flow | Heat Release\n         | (bara)    | (kg/hr)      | (kg/hr)    | (%)        | (kg/hr)    | (MW)\n---------|-----------|--------------|------------|------------|------------|-------------\n    10.0 |     50.00 |         0.0  |    10000.0 |        0.0 |        0.0 |         0.00\n    12.0 |     50.00 |         0.0  |    10000.0 |       40.0 |     4000.0 |        29.45\n    14.0 |     50.00 |         0.0  |    10000.0 |       80.0 |     8000.0 |        58.91\n    16.0 |     50.00 |         0.0  |    10000.0 |      100.0 |    10000.0 |        73.63\n\n\u2550\u2550\u2550 BLOWDOWN SUMMARY \u2550\u2550\u2550\nMaximum blowdown flow: 10000.0 kg/hr\nTotal gas blown down: 138.9 kg\nTotal heat released: 3.21 GJ\nTotal CO2 emissions: 382.5 kg\n\n\u2713 ESD push button successfully triggered blowdown\n\u2713 BD valve automatically activated by push button\n\u2713 Controlled depressurization through BD orifice\n</code></pre>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#integration-with-existing-neqsim-components","title":"Integration with Existing NeqSim Components","text":""},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#compatible-equipment","title":"Compatible Equipment:","text":"<ul> <li>Separator - Source of gas for blowdown</li> <li>Splitter - Directs flow between process and blowdown</li> <li>ThrottlingValve - Can be used as BD orifice</li> <li>Mixer - Flare header for multiple sources</li> <li>Flare - Combusts and tracks emissions</li> </ul>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#measurement-integration","title":"Measurement Integration:","text":"<ul> <li>PushButton extends <code>MeasurementDeviceBaseClass</code></li> <li>Compatible with alarm systems (<code>AlarmConfig</code>)</li> <li>Can be used with controllers</li> <li>Supports noise and delay simulation</li> </ul>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#testing","title":"Testing","text":"<p>All tests are in <code>BlowdownValveESDSystemTest.java</code>:</p> <ol> <li>testESDBlowdownSystem() - Complete dynamic simulation with orifice flow validation</li> <li>testPushButtonOperation() - Button activation and reset</li> <li>testPushButtonManualMode() - Manual control mode</li> <li>testBlowdownValveOperation() - Valve behavior</li> <li>testMultipleBlowdownSources() - Multiple BD sources to common flare</li> <li>testPressureReliefViaBlowdown() - Pressure buildup and relief scenario</li> </ol> <p>Orifice Flow Validation: The tests verify that orifice flow correctly responds to pressure changes: - Flow increases when upstream pressure increases - Flow decreases when upstream pressure decreases - Flow follows \u221a(\u0394P) relationship per ISO 5167 - Demonstrates realistic depressurization profiles</p> <p>Run all tests: <pre><code>mvn test -Dtest=BlowdownValveESDSystemTest\n</code></pre></p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions: - Integration with control systems - Automatic splitter control on activation - Pressure decay curve validation against API/ISO standards - Multi-component orifice calculations - Two-phase flow through orifices - Sonic flow limiting (choked flow) - Integration with process alarms - Time-to-depressurize calculations per API 521 - Multi-stage blowdown systems - Temperature effects on orifice sizing</p>"},{"location":"safety/ESD_BLOWDOWN_SYSTEM/#author","title":"Author","text":"<p>Implementation follows NeqSim architecture patterns and coding standards.</p>"},{"location":"safety/HIPPS_SUMMARY/","title":"HIPPS Implementation Summary for NeqSim","text":""},{"location":"safety/HIPPS_SUMMARY/#executive-summary","title":"Executive Summary","text":"<p>A complete HIPPS (High Integrity Pressure Protection System) implementation has been added to NeqSim for safety simulation and analysis. HIPPS is a Safety Instrumented System (SIS) that prevents overpressure by shutting down the source of pressure before it reaches unsafe levels, providing an alternative or complement to traditional pressure relief devices (PSVs/rupture disks).</p>"},{"location":"safety/HIPPS_SUMMARY/#files-created","title":"Files Created","text":""},{"location":"safety/HIPPS_SUMMARY/#1-core-implementation","title":"1. Core Implementation","text":"<p>File: <code>src/main/java/neqsim/process/equipment/valve/HIPPSValve.java</code> - Complete HIPPS valve class extending <code>ThrottlingValve</code> - ~700 lines of fully documented code - Implements SIL-rated safety logic</p> <p>Key Features: - \u2705 Multiple voting logic schemes (1oo1, 1oo2, 2oo2, 2oo3, 2oo4) - \u2705 Redundant pressure transmitter support - \u2705 SIL rating configuration (SIL 1, 2, 3) - \u2705 Configurable closure time (typical 2-5 seconds) - \u2705 Partial stroke testing capability - \u2705 Proof test interval tracking - \u2705 Diagnostic monitoring and trip history - \u2705 Bypass mode for maintenance - \u2705 Comprehensive state tracking</p>"},{"location":"safety/HIPPS_SUMMARY/#2-test-suite","title":"2. Test Suite","text":"<p>File: <code>src/test/java/neqsim/process/equipment/valve/HIPPSValveTest.java</code> - ~550 lines of comprehensive test coverage - 15 test methods covering all major functionality</p> <p>Test Coverage: - \u2705 Basic configuration and initialization - \u2705 All voting logic schemes (1oo1, 1oo2, 2oo2, 2oo3, 2oo4) - \u2705 Transient response and closure timing - \u2705 Reset and reopen procedures - \u2705 Bypass mode operation - \u2705 Partial stroke testing - \u2705 Proof test tracking - \u2705 Spurious trip detection - \u2705 HIPPS vs PSV integration - \u2705 Transmitter failure scenarios - \u2705 SIL rating validation - \u2705 Diagnostic output</p>"},{"location":"safety/HIPPS_SUMMARY/#3-documentation","title":"3. Documentation","text":"<p>File: <code>docs/hipps_implementation.md</code> - ~800 lines of comprehensive documentation - Complete user guide and API reference</p> <p>Documentation Includes: - \u2705 HIPPS concepts and principles - \u2705 HIPPS vs PSV comparison - \u2705 Voting logic explained - \u2705 5 detailed usage examples - \u2705 Safety simulation best practices - \u2705 Typical applications (subsea, blocked outlet, thermal expansion) - \u2705 Diagnostic and monitoring guide - \u2705 Industry standards references - \u2705 SIL requirements table</p>"},{"location":"safety/HIPPS_SUMMARY/#4-example-code","title":"4. Example Code","text":"<p>File: <code>src/main/java/neqsim/process/util/example/HIPPSExample.java</code> - ~300 lines of runnable demonstration code - Shows complete blocked outlet scenario</p> <p>Example Features: - \u2705 Complete HIPPS setup with 2oo3 voting (SIL 3) - \u2705 Redundant transmitter configuration - \u2705 Dynamic simulation of pressure ramp - \u2705 HIPPS preventing PSV from lifting - \u2705 Formatted console output with results - \u2705 Comprehensive diagnostics display</p>"},{"location":"safety/HIPPS_SUMMARY/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"safety/HIPPS_SUMMARY/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>ThrottlingValve (base)\n    \u2514\u2500\u2500 HIPPSValve (new)\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#integration-points","title":"Integration Points","text":"<pre><code>HIPPSValve\n    \u251c\u2500\u2500 MeasurementDeviceInterface (pressure transmitters)\n    \u251c\u2500\u2500 AlarmState (HIHI alarm monitoring)\n    \u251c\u2500\u2500 ProcessEquipmentBaseClass (standard equipment interface)\n    \u2514\u2500\u2500 Serializable (state persistence)\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#voting-logic-enum","title":"Voting Logic Enum","text":"<pre><code>public enum VotingLogic {\n    ONE_OUT_OF_ONE(\"1oo1\"),\n    ONE_OUT_OF_TWO(\"1oo2\"),\n    TWO_OUT_OF_TWO(\"2oo2\"),\n    TWO_OUT_OF_THREE(\"2oo3\"),  // Recommended for SIL 2/3\n    TWO_OUT_OF_FOUR(\"2oo4\")\n}\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#key-capabilities-for-safety-simulations","title":"Key Capabilities for Safety Simulations","text":""},{"location":"safety/HIPPS_SUMMARY/#1-redundancy-and-voting","title":"1. Redundancy and Voting","text":"<ul> <li>Supports multiple pressure transmitters</li> <li>Flexible voting logic prevents spurious trips</li> <li>Accounts for transmitter failures</li> <li>SIL \u2154 capable with 2oo3 voting</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#2-transient-behavior","title":"2. Transient Behavior","text":"<ul> <li>Realistic closure timing (2-5 seconds typical)</li> <li>Accounts for response delays</li> <li>Models valve travel dynamics</li> <li>Integrates with alarm confirmation delays</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#3-safety-validation","title":"3. Safety Validation","text":"<ul> <li>Partial stroke testing (required for SIL validation)</li> <li>Proof test interval tracking</li> <li>Trip history and diagnostics</li> <li>Spurious trip counting</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#4-failure-mode-analysis","title":"4. Failure Mode Analysis","text":"<ul> <li>Bypass mode for maintenance simulation</li> <li>Transmitter failure scenarios</li> <li>Integration with PSV backup</li> <li>Reset and recovery procedures</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#5-industry-compliance","title":"5. Industry Compliance","text":"<ul> <li>Follows IEC 61508/61511 principles</li> <li>API RP 14C compliant architecture</li> <li>Supports SIL 1, 2, and 3 ratings</li> <li>Proof test intervals per standards</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#usage-example-simple","title":"Usage Example (Simple)","text":"<pre><code>// Create HIPPS valve\nHIPPSValve hipps = new HIPPSValve(\"HIPPS-XV-001\", feedStream);\n\n// Add redundant transmitters\nhipps.addPressureTransmitter(PT1);\nhipps.addPressureTransmitter(PT2);\nhipps.addPressureTransmitter(PT3);\n\n// Configure for SIL 3\nhipps.setVotingLogic(HIPPSValve.VotingLogic.TWO_OUT_OF_THREE);\nhipps.setSILRating(3);\nhipps.setClosureTime(3.0); // 3 seconds\n\n// In transient simulation\nPT1.evaluateAlarm(pressure, dt, time);\nPT2.evaluateAlarm(pressure, dt, time);\nPT3.evaluateAlarm(pressure, dt, time);\nhipps.runTransient(dt, UUID.randomUUID());\n\nif (hipps.hasTripped()) {\n    System.out.println(\"HIPPS activated - overpressure prevented\");\n}\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#hipps-vs-psv-comparison","title":"HIPPS vs PSV Comparison","text":"Aspect HIPPS PSV Action Stops flow (isolation) Relieves pressure (venting) Trip Point Below MAWP (e.g., 90%) At/above MAWP Emissions Prevents flaring Releases to flare SIL Rating SIL 2 or SIL 3 Mechanical (non-SIL) Response 2-5 seconds Instantaneous Redundancy Multiple transmitters Single device Testing Partial stroke, proof tests Periodic inspection"},{"location":"safety/HIPPS_SUMMARY/#safety-simulation-benefits","title":"Safety Simulation Benefits","text":""},{"location":"safety/HIPPS_SUMMARY/#1-overpressure-prevention-modeling","title":"1. Overpressure Prevention Modeling","text":"<ul> <li>Model HIPPS preventing PSV from lifting</li> <li>Calculate pressure profiles during transients</li> <li>Validate trip point selection</li> <li>Verify adequate response time</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#2-emissions-reduction","title":"2. Emissions Reduction","text":"<ul> <li>Show HIPPS eliminating flaring events</li> <li>Calculate environmental benefits</li> <li>Support sustainability analysis</li> <li>Demonstrate compliance with emission limits</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#3-reliability-analysis","title":"3. Reliability Analysis","text":"<ul> <li>Model transmitter redundancy</li> <li>Analyze voting logic effectiveness</li> <li>Calculate spurious trip rates</li> <li>Evaluate SIL achievement</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#4-defense-in-depth","title":"4. Defense-in-Depth","text":"<ul> <li>HIPPS as primary protection</li> <li>PSV as backup (layered protection)</li> <li>Model failure scenarios</li> <li>Validate overall safety architecture</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#5-economic-analysis","title":"5. Economic Analysis","text":"<ul> <li>Compare HIPPS vs PSV sizing</li> <li>Calculate flaring cost savings</li> <li>Evaluate production continuity</li> <li>Analyze maintenance costs</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#running-the-examples","title":"Running the Examples","text":""},{"location":"safety/HIPPS_SUMMARY/#run-test-suite","title":"Run Test Suite","text":"<pre><code># Windows (cmd)\n.\\mvnw test -Dtest=HIPPSValveTest\n\n# Windows (PowerShell)\n.\\mvnw.cmd test -Dtest=HIPPSValveTest\n\n# Linux/Mac\n./mvnw test -Dtest=HIPPSValveTest\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#run-example","title":"Run Example","text":"<pre><code># Compile and run\n.\\mvnw exec:java -Dexec.mainClass=\"neqsim.process.util.example.HIPPSExample\"\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#integration-with-existing-neqsim-components","title":"Integration with Existing NeqSim Components","text":""},{"location":"safety/HIPPS_SUMMARY/#compatible-equipment","title":"Compatible Equipment","text":"<ul> <li>SafetyValve - PSV backup protection</li> <li>PSDValve - Process shutdown coordination</li> <li>BlowdownValve - Emergency depressurization</li> <li>PressureTransmitter - Redundant monitoring</li> <li>Separator - Protected equipment</li> <li>ProcessSystem - System-wide coordination</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#alarm-system-integration","title":"Alarm System Integration","text":"<pre><code>// HIPPS uses existing alarm infrastructure\nAlarmConfig hippsAlarm = AlarmConfig.builder()\n    .highHighLimit(90.0)\n    .deadband(2.0)\n    .delay(0.5)\n    .unit(\"bara\")\n    .build();\n\nPT.setAlarmConfig(hippsAlarm);\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#transient-simulation-integration","title":"Transient Simulation Integration","text":"<pre><code>// HIPPS participates in transient calculations\nhipps.runTransient(dt, UUID.randomUUID());\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#how-to-implement-hipps-for-safety-simulations","title":"How to Implement HIPPS for Safety Simulations","text":""},{"location":"safety/HIPPS_SUMMARY/#step-1-identify-protection-requirements","title":"Step 1: Identify Protection Requirements","text":"<ul> <li>Determine MAWP of protected equipment</li> <li>Calculate required trip point (typically 90-95% MAWP)</li> <li>Select appropriate SIL level</li> <li>Choose voting logic based on SIL and availability needs</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#step-2-configure-hipps-components","title":"Step 2: Configure HIPPS Components","text":"<pre><code>// Create redundant transmitters\nPressureTransmitter PT1 = new PressureTransmitter(\"PT-A\", stream);\nPressureTransmitter PT2 = new PressureTransmitter(\"PT-B\", stream);\nPressureTransmitter PT3 = new PressureTransmitter(\"PT-C\", stream);\n\n// Configure alarms at trip point\nAlarmConfig alarm = AlarmConfig.builder()\n    .highHighLimit(tripPoint)\n    .deadband(2.0)\n    .delay(0.5)\n    .unit(\"bara\")\n    .build();\n\n// Create HIPPS with voting\nHIPPSValve hipps = new HIPPSValve(\"HIPPS-XV-001\", stream);\nhipps.addPressureTransmitter(PT1);\nhipps.addPressureTransmitter(PT2);\nhipps.addPressureTransmitter(PT3);\nhipps.setVotingLogic(HIPPSValve.VotingLogic.TWO_OUT_OF_THREE);\nhipps.setSILRating(3);\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#step-3-add-psv-backup","title":"Step 3: Add PSV Backup","text":"<pre><code>// PSV provides backup protection\nSafetyValve psv = new SafetyValve(\"PSV-001\", stream);\npsv.setPressureSpec(mawp); // Set at MAWP\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#step-4-run-transient-simulation","title":"Step 4: Run Transient Simulation","text":"<pre><code>for (double time = 0; time &lt; totalTime; time += dt) {\n    // Update process conditions\n    // ...\n\n    // Evaluate alarms\n    PT1.evaluateAlarm(pressure, dt, time);\n    PT2.evaluateAlarm(pressure, dt, time);\n    PT3.evaluateAlarm(pressure, dt, time);\n\n    // Run HIPPS\n    hipps.runTransient(dt, UUID.randomUUID());\n\n    // Check protection status\n    if (hipps.hasTripped()) {\n        // HIPPS activated - analyze response\n    }\n}\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#step-5-analyze-results","title":"Step 5: Analyze Results","text":"<pre><code>// Get comprehensive diagnostics\nSystem.out.println(hipps.getDiagnostics());\n\n// Verify safety objectives\nboolean preventedPsvLift = !psv.getPercentValveOpening() &gt; 0;\nboolean belowMAWP = maxPressure &lt; mawp;\nboolean trippedCorrectly = hipps.hasTripped();\n</code></pre>"},{"location":"safety/HIPPS_SUMMARY/#standards-compliance","title":"Standards Compliance","text":""},{"location":"safety/HIPPS_SUMMARY/#iec-6150861511","title":"IEC 61508/61511","text":"<ul> <li>\u2705 SIL-rated architecture</li> <li>\u2705 Redundancy and voting</li> <li>\u2705 Diagnostic monitoring</li> <li>\u2705 Proof testing requirements</li> <li>\u2705 Failure mode analysis</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#api-rp-14c","title":"API RP 14C","text":"<ul> <li>\u2705 HIPPS as alternative to PSV</li> <li>\u2705 Response time requirements</li> <li>\u2705 Testing and validation</li> <li>\u2705 Layered protection</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#api-rp-521","title":"API RP 521","text":"<ul> <li>\u2705 Overpressure protection scenarios</li> <li>\u2705 Depressurization analysis</li> <li>\u2705 Flare load reduction</li> <li>\u2705 Environmental considerations</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#best-practices","title":"Best Practices","text":""},{"location":"safety/HIPPS_SUMMARY/#1-set-point-selection","title":"1. Set Point Selection","text":"<ul> <li>Set HIPPS trip at 90-95% of MAWP</li> <li>Ensure margin above normal operating pressure</li> <li>Account for instrument uncertainty</li> <li>Consider pressure surge effects</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#2-voting-logic-selection","title":"2. Voting Logic Selection","text":"Application Recommended Voting SIL Level Low risk, simple 1oo1 SIL 1 Medium risk 1oo2 or 2oo3 SIL 2 High risk, critical 2oo3 SIL 3"},{"location":"safety/HIPPS_SUMMARY/#3-response-time","title":"3. Response Time","text":"<ul> <li>Account for transmitter delay (100-500 ms)</li> <li>Model logic solver time (10-100 ms)</li> <li>Include valve closure time (2-5 seconds dominant)</li> <li>Verify pressure doesn't exceed MAWP during response</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#4-testing-and-validation","title":"4. Testing and Validation","text":"<ul> <li>Perform partial stroke tests (10-20% stroke)</li> <li>Track proof test intervals (typically annual)</li> <li>Monitor spurious trip rates</li> <li>Document all safety-critical events</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#5-integration-with-psv","title":"5. Integration with PSV","text":"<ul> <li>HIPPS provides primary protection</li> <li>PSV provides backup (never disabled)</li> <li>Model both success and failure scenarios</li> <li>Ensure PSV sized for HIPPS failure case</li> </ul>"},{"location":"safety/HIPPS_SUMMARY/#conclusion","title":"Conclusion","text":"<p>The HIPPS implementation in NeqSim provides comprehensive capabilities for safety simulation and analysis:</p> <p>\u2705 Complete SIS modeling with voting logic and redundancy \u2705 Realistic transient behavior including closure dynamics \u2705 SIL-rated configuration (SIL 1, 2, 3) per industry standards \u2705 Comprehensive testing support (partial stroke, proof tests) \u2705 Integration with existing safety systems (PSV, PSD, alarms) \u2705 Extensive documentation and working examples \u2705 Production-ready code with full test coverage</p> <p>Key Advantage: HIPPS prevents overpressure before it occurs, eliminating flaring and protecting equipment, while PSVs relieve pressure after it exceeds safe limits. For safety-critical applications, HIPPS + PSV provides robust defense-in-depth protection.</p>"},{"location":"safety/HIPPS_SUMMARY/#author","title":"Author","text":"<p>Implementation follows NeqSim architecture patterns and coding standards for process safety simulation, consistent with existing ESD, PSD, and safety valve implementations.</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/","title":"Integrated Safety Systems Example","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#overview","title":"Overview","text":"<p>The <code>IntegratedSafetySystemExample</code> demonstrates a comprehensive safety system implementation for process facilities, incorporating multiple layers of protection following the principles of Safety Instrumented Systems (SIS) and Defense in Depth.</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#safety-architecture","title":"Safety Architecture","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#protection-layers-onion-model","title":"Protection Layers (Onion Model)","text":"<p>The example implements a complete safety architecture with four distinct layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. High Pressure Alarm (SIL-1)     \u2502 \u2190 55.0 bara\n\u2502     \u251c\u2500 Operator intervention        \u2502\n\u2502     \u2514\u2500 Alarms and warnings          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  2. ESD System (SIL-2)               \u2502 \u2190 58.0 bara\n\u2502     \u251c\u2500 Emergency shutdown            \u2502\n\u2502     \u251c\u2500 Blowdown activation           \u2502\n\u2502     \u2514\u2500 Fire detection response       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  3. HIPPS (SIL-3)                    \u2502 \u2190 60.0 bara\n\u2502     \u251c\u2500 High integrity protection     \u2502\n\u2502     \u251c\u2500 Fast-acting valve closure     \u2502\n\u2502     \u2514\u2500 Redundant pressure monitoring \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  4. PSV (Mechanical)                 \u2502 \u2190 65.0 bara\n\u2502     \u2514\u2500 Final mechanical relief       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#system-components","title":"System Components","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#1-high-integrity-pressure-protection-system-hipps","title":"1. High Integrity Pressure Protection System (HIPPS)","text":"<p>Purpose: Prevent overpressure by rapidly closing inlet valve before pressure reaches dangerous levels.</p> <p>Safety Integrity Level: SIL-3 (PFD: 0.0001-0.001)</p> <p>Features: - Dual redundant pressure transmitters (PT-101A, PT-101B) - 2oo2 voting logic (both sensors must confirm high pressure) - Fast-acting valve closure (2 seconds) - Activation setpoint: 60.0 bara</p> <p>Implementation: <pre><code>HIPPSController hippsController = \n    new HIPPSController(\"HIPPS-Logic-001\", hippsPT1, hippsPT2, hippsValve);\n\n// 2oo2 voting for higher integrity\nif (p1 &gt;= HIPPS_ACTIVATION_PRESSURE &amp;&amp; p2 &gt;= HIPPS_ACTIVATION_PRESSURE) {\n    hippsValve.setPercentValveOpening(0.0); // Close immediately\n}\n</code></pre></p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#2-emergency-shutdown-esd-system","title":"2. Emergency Shutdown (ESD) System","text":"<p>Purpose: Shut down process and activate blowdown when emergency conditions are detected.</p> <p>Safety Integrity Level: SIL-2 (PFD: 0.001-0.01)</p> <p>Activation Conditions: - High-High pressure alarm (\u226558.0 bara) - Fire detection (\u2265150\u00b0C) - Manual ESD push button</p> <p>Actions on Activation: 1. Close inlet isolation valve 2. Activate blowdown valve 3. Redirect gas flow to flare system</p> <p>Implementation: <pre><code>ESDController esdController = \n    new ESDController(\"ESD-Logic-201\", separatorPT, separatorTT, \n                      esdButton, esdInletValve, bdValve);\n\n// Multiple trigger conditions\nif (pressure &gt;= HIGH_HIGH_PRESSURE_ALARM || \n    temperature &gt;= FIRE_DETECTION_TEMPERATURE || \n    manualESD.isPushed()) {\n    esdValve.setPercentValveOpening(0.0);\n    blowdownValve.activate();\n}\n</code></pre></p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#3-fire-detection-system","title":"3. Fire Detection System","text":"<p>Purpose: Detect fire conditions and trigger ESD.</p> <p>Configuration: - 3 temperature sensors (TT-401A, TT-401B, TT-401C) - 2oo3 voting logic (2 out of 3 sensors must detect fire) - Detection threshold: 150\u00b0C</p> <p>Implementation: <pre><code>FireDetectionSystem fireSystem = \n    new FireDetectionSystem(\n        new TemperatureTransmitter[] {fireTT1, fireTT2, fireTT3}, \n        2  // voting threshold\n    );\n</code></pre></p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#4-blowdown-system","title":"4. Blowdown System","text":"<p>Purpose: Rapidly depressurize equipment during emergency situations.</p> <p>Features: - Normally closed blowdown valve (BD-301) - Configurable opening time (5 seconds default) - Automatic activation via ESD controller - Routes to flare system</p> <p>Implementation: <pre><code>BlowdownValve bdValve = new BlowdownValve(\"BD-301\", blowdownStream);\nbdValve.setOpeningTime(5.0);\nbdValve.setCv(250.0);\n</code></pre></p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#5-pressure-safety-valve-psv","title":"5. Pressure Safety Valve (PSV)","text":"<p>Purpose: Final mechanical protection layer - relieves pressure if all other systems fail.</p> <p>Characteristics: - Set pressure: 65.0 bara - Full open pressure: 67.0 bara - Blowdown: 7% (reseats at 60.45 bara) - Hysteresis logic prevents chattering</p> <p>Implementation: <pre><code>SafetyValve psv = new SafetyValve(\"PSV-401\", separatorGasOut);\npsv.setPressureSpec(65.0);\npsv.setFullOpenPressure(67.0);\npsv.setBlowdown(7.0);\n</code></pre></p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#6-flare-system","title":"6. Flare System","text":"<p>Purpose: Safely combust and dispose of emergency relief gases.</p> <p>Features: - Accepts flows from both blowdown and PSV - Tracks cumulative gas burned - Monitors heat release and emissions - 60m flame height, 1.0m tip diameter</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#safety-scenarios","title":"Safety Scenarios","text":"<p>The example demonstrates four operational scenarios:</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#scenario-1-normal-operation","title":"Scenario 1: Normal Operation","text":"<ul> <li>All systems in standby</li> <li>Process gas flows to downstream equipment</li> <li>All safety systems monitoring</li> </ul> <p>Expected Behavior: - HIPPS: Normal - ESD: Normal - PSV: Closed - No flare flow</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#scenario-2-hipps-activation-sil-3","title":"Scenario 2: HIPPS Activation (SIL-3)","text":"<ul> <li>Feed pressure surge to 70 bara</li> <li>HIPPS detects overpressure on both transmitters</li> <li>Fast valve closure prevents further pressure increase</li> </ul> <p>Expected Behavior: - HIPPS activates when P \u2265 60 bara - Inlet valve closes in 2 seconds - Pressure controlled before ESD activation - PSV remains closed</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#scenario-3-esd-and-blowdown-sil-2","title":"Scenario 3: ESD and Blowdown (SIL-2)","text":"<ul> <li>Manual ESD activation by operator</li> <li>Inlet valve closes</li> <li>Blowdown valve opens progressively</li> <li>Gas routed to flare</li> </ul> <p>Expected Behavior: - ESD inlet valve closes in 5 seconds - Blowdown valve opens in 5 seconds - Pressure gradually reduced via controlled blowdown - Flare receives and combusts gas</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#scenario-4-psv-relief-final-protection","title":"Scenario 4: PSV Relief (Final Protection)","text":"<ul> <li>Extreme overpressure scenario</li> <li>HIPPS and ESD assumed failed</li> <li>PSV provides final mechanical protection</li> </ul> <p>Expected Behavior: - PSV opens when P \u2265 65 bara - Relief flow to flare - Continuous relief until pressure drops - PSV reseats when P \u2264 60.45 bara</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#sil-requirements-and-implementation","title":"SIL Requirements and Implementation","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#safety-integrity-levels-iec-6150861511","title":"Safety Integrity Levels (IEC 61508/61511)","text":"SIL Level PFD Range RRF Range Implementation SIL-3 10\u207b\u2074 to 10\u207b\u00b3 10,000 to 1,000 HIPPS with 2oo2 voting SIL-2 10\u207b\u00b3 to 10\u207b\u00b2 1,000 to 100 ESD with redundant sensors SIL-1 10\u207b\u00b2 to 10\u207b\u00b9 100 to 10 Alarms with operator action <p>PFD: Probability of Failure on Demand RRF: Risk Reduction Factor</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#voting-architectures","title":"Voting Architectures","text":"<p>2oo2 (HIPPS - SIL-3): - Both sensors must detect high pressure - Higher reliability (lower spurious trips) - Suitable for high-consequence scenarios</p> <p>2oo3 (Fire Detection): - 2 out of 3 sensors must detect fire - Balances reliability and availability - Reduces false alarms</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#key-design-principles","title":"Key Design Principles","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#1-defense-in-depth","title":"1. Defense in Depth","text":"<p>Multiple independent protection layers ensure safety even if individual layers fail.</p>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#2-fail-safe-design","title":"2. Fail-Safe Design","text":"<ul> <li>Blowdown valve: Normally closed (fail-closed)</li> <li>Safety valve: Spring-loaded mechanical (fail-open)</li> <li>HIPPS valve: Fast-acting closure</li> </ul>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#3-separation-of-functions","title":"3. Separation of Functions","text":"<ul> <li>HIPPS: Prevention (stop overpressure before it occurs)</li> <li>ESD: Emergency response (safe shutdown)</li> <li>PSV: Protection (final mechanical relief)</li> </ul>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#4-diversity","title":"4. Diversity","text":"<ul> <li>Different technologies (electronic, mechanical)</li> <li>Different activation mechanisms (automatic, manual)</li> <li>Different physical principles (sensors, springs)</li> </ul>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#usage-example","title":"Usage Example","text":"<pre><code>// Run the integrated safety system example\njava neqsim.process.util.example.IntegratedSafetySystemExample\n\n// Expected output:\n// - System configuration summary\n// - Four safety scenarios with detailed monitoring\n// - Verification of each protection layer\n</code></pre>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#output-interpretation","title":"Output Interpretation","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#normal-operation","title":"Normal Operation","text":"<pre><code>HIPPS status: NORMAL\nESD status: NORMAL\nFire detection: NORMAL\nPSV status: CLOSED\n</code></pre>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#during-hipps-activation","title":"During HIPPS Activation","text":"<pre><code>&gt;&gt;&gt; HIPPS ACTIVATED (SIL-3) - Both pressure sensors confirm &lt;&lt;&lt;\nHIPPS Valve: Closing from 100% to 0%\nSeparator pressure: Controlled below 60 bara\n</code></pre>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#during-esd-and-blowdown","title":"During ESD and Blowdown","text":"<pre><code>&gt;&gt;&gt; ESD ACTIVATED (SIL-2) - Manual Push Button &lt;&lt;&lt;\nESD inlet valve: Closing to 0%\nBD valve: Opening to 100%\nBlowdown flow: Increasing to flare\nSeparator pressure: Decreasing\n</code></pre>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#psv-relief","title":"PSV Relief","text":"<pre><code>Sep P &gt; 65.0 bara\nPSV status: RELIEVING\nPSV Flow: High flow to flare\n</code></pre>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#performance-metrics","title":"Performance Metrics","text":"<p>The example tracks and reports:</p> <ol> <li>Pressure profiles during each scenario</li> <li>Valve opening percentages over time</li> <li>Flow rates to flare system</li> <li>Cumulative emissions (gas burned, CO\u2082, heat)</li> <li>Response times of safety systems</li> </ol>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#related-documentation","title":"Related Documentation","text":"<ul> <li>ESD Blowdown System</li> <li>HIPPS Implementation</li> <li>PSV Dynamic Sizing</li> <li>Pressure Monitoring</li> </ul>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#api-reference","title":"API Reference","text":""},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#key-classes-used","title":"Key Classes Used","text":"<ul> <li><code>ThrottlingValve</code> - Control valves and isolation valves</li> <li><code>BlowdownValve</code> - Emergency depressurization valve</li> <li><code>SafetyValve</code> - Pressure relief valve with hysteresis</li> <li><code>PressureTransmitter</code> - Pressure measurement devices</li> <li><code>TemperatureTransmitter</code> - Temperature measurement devices</li> <li><code>PushButton</code> - Manual activation device</li> <li><code>Separator</code> - Process vessel with transient capability</li> <li><code>Flare</code> - Flare system with emission tracking</li> <li><code>ControllerDeviceBaseClass</code> - Base for custom controllers</li> </ul>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#best-practices","title":"Best Practices","text":"<ol> <li>Always implement multiple protection layers - Never rely on a single safety device</li> <li>Use appropriate SIL ratings - Match safety system integrity to risk level</li> <li>Test safety systems regularly - Proof test intervals per IEC 61511</li> <li>Document all safety logic - Clear, auditable control algorithms</li> <li>Monitor performance - Track activation rates and failure modes</li> <li>Train operators - Ensure understanding of safety system behavior</li> </ol>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#further-development","title":"Further Development","text":"<p>This example can be extended to include:</p> <ul> <li>Emergency shutdown valves (ESVs) on multiple process units</li> <li>High-High level trips on separators</li> <li>Low flow trips on critical services</li> <li>Integration with distributed control system (DCS)</li> <li>Cause and effect diagrams</li> <li>Safety instrumented function (SIF) verification</li> <li>Reliability calculations (PFD, SIL verification)</li> </ul>"},{"location":"safety/INTEGRATED_SAFETY_SYSTEMS/#references","title":"References","text":"<ul> <li>IEC 61508: Functional Safety of Electrical/Electronic/Programmable Electronic Safety-related Systems</li> <li>IEC 61511: Functional Safety - Safety Instrumented Systems for the Process Industry Sector</li> <li>API RP 521: Pressure-relieving and Depressuring Systems</li> <li>API STD 2000: Venting Atmospheric and Low-pressure Storage Tanks</li> </ul>"},{"location":"safety/PRESSURE_MONITORING_ESD/","title":"Pressure Monitoring in ESD Blowdown System","text":""},{"location":"safety/PRESSURE_MONITORING_ESD/#overview","title":"Overview","text":"<p>The ESD blowdown system now includes comprehensive pressure monitoring during transient calculations to verify that the separator pressure is properly released via the blowdown valve.</p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#key-features","title":"Key Features","text":""},{"location":"safety/PRESSURE_MONITORING_ESD/#1-continuous-pressure-monitoring","title":"1. Continuous Pressure Monitoring","text":"<p>The system tracks separator pressure at every time step: - Initial pressure - Baseline before any events - Maximum pressure - Peak pressure during simulation - Minimum pressure - Lowest pressure reached - Final pressure - End-state pressure</p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#2-pressure-relief-verification","title":"2. Pressure Relief Verification","text":"<p>Automated checks verify: - \u2713 Pressure decreases after blowdown activation - \u2713 Blowdown valve opens as expected - \u2713 Gas flows to flare system - \u2713 Pressure drop percentage calculated</p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#usage-examples","title":"Usage Examples","text":""},{"location":"safety/PRESSURE_MONITORING_ESD/#example-1-basic-pressure-monitoring-esdblowdownsystemexamplejava","title":"Example 1: Basic Pressure Monitoring (ESDBlowdownSystemExample.java)","text":"<pre><code>// Track pressure during blowdown\ndouble initialPressure = separator.getGasOutStream().getPressure(\"bara\");\ndouble minPressure = initialPressure;\ndouble maxPressure = initialPressure;\n\nfor (double time = 0.0; time &lt;= totalTime; time += timeStep) {\n    // Run equipment in transient mode\n    separator.run();\n    bdValve.runTransient(timeStep, uuid);\n    // ... other equipment\n\n    // Monitor separator pressure\n    double currentPressure = separator.getGasOutStream().getPressure(\"bara\");\n    minPressure = Math.min(minPressure, currentPressure);\n    maxPressure = Math.max(maxPressure, currentPressure);\n\n    System.out.printf(\"Time: %.1fs, Pressure: %.2f bara%n\", time, currentPressure);\n}\n\n// Verify pressure relief\nSystem.out.printf(\"Pressure drop: %.2f bar (%.1f%% reduction)%n\", \n    initialPressure - finalPressure, \n    100.0 * (initialPressure - finalPressure) / initialPressure);\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#example-2-pressure-buildup-and-relief-test","title":"Example 2: Pressure Buildup and Relief Test","text":"<p>The new test <code>testPressureReliefViaBlowdown()</code> demonstrates:</p> <p>Scenario: 1. Normal Operation (0-5s) - Separator at 60 bara, outlet valve 50% open 2. Outlet Blockage (5-10s) - Outlet valve closes to 5%, pressure rises 3. ESD Activation (10s) - Push button activates blowdown valve 4. Depressurization (10-30s) - Pressure drops as gas flows to flare</p> <p>Output: <pre><code>\u2550\u2550\u2550 PRESSURE PROFILE \u2550\u2550\u2550\nInitial pressure: 60.00 bara\nMaximum pressure reached: 65.23 bara\nPressure at ESD activation: 65.23 bara\nFinal pressure: 52.18 bara\nPressure rise before ESD: 5.23 bar (8.7% increase)\nPressure drop after ESD: 13.05 bar (20.0% reduction)\n\n\u2713 Pressure buildup detected: 60.00 bara \u2192 65.23 bara\n\u2713 ESD successfully activated at 65.23 bara\n\u2713 Pressure relieved to 52.18 bara (20.0% reduction)\n</code></pre></p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#monitoring-points","title":"Monitoring Points","text":""},{"location":"safety/PRESSURE_MONITORING_ESD/#separator-pressure","title":"Separator Pressure","text":"<pre><code>double sepPressure = separator.getPressure(\"bara\");\n// or\ndouble sepPressure = separator.getGasOutStream().getPressure(\"bara\");\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#blowdown-flow-rate","title":"Blowdown Flow Rate","text":"<pre><code>double bdFlow = blowdownStream.getFlowRate(\"kg/hr\");\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#valve-opening","title":"Valve Opening","text":"<pre><code>double opening = bdValve.getPercentValveOpening(); // 0-100%\nboolean isOpen = bdValve.getPercentValveOpening() &gt; 90.0;\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#flare-load","title":"Flare Load","text":"<pre><code>double heatRelease = flare.getHeatDuty(\"MW\");\ndouble totalGas = flare.getCumulativeGasBurned(\"kg\");\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#transient-calculation-pattern","title":"Transient Calculation Pattern","text":"<pre><code>// Initialize tracking variables\ndouble initialPressure = separator.getPressure(\"bara\");\ndouble maxPressure = initialPressure;\ndouble finalPressure = initialPressure;\n\n// Time loop\ndouble timeStep = 0.5; // seconds\nfor (double time = 0.0; time &lt;= simulationTime; time += timeStep) {\n\n    // 1. Update process conditions (if needed)\n    if (time &gt;= eventTime) {\n        esdButton.push(); // Trigger ESD\n        splitter.setSplitFactors(new double[] {0.0, 1.0});\n    }\n\n    // 2. Run all equipment\n    feedStream.run();\n    separator.run();\n    // ... other steady-state equipment\n\n    // 3. Run transient equipment\n    bdValve.runTransient(timeStep, UUID.randomUUID());\n\n    // ... more equipment\n\n    flare.run();\n    flare.updateCumulative(timeStep); // Track cumulative values\n\n    // 4. Monitor and record\n    double currentPressure = separator.getPressure(\"bara\");\n    maxPressure = Math.max(maxPressure, currentPressure);\n    finalPressure = currentPressure;\n\n    // 5. Output (optional)\n    System.out.printf(\"t=%.1fs: P=%.2f bara, BD=%.1f%%, Flow=%.1f kg/hr%n\",\n        time, currentPressure, bdValve.getPercentValveOpening(), \n        blowdownStream.getFlowRate(\"kg/hr\"));\n}\n\n// 6. Verify results\nif (finalPressure &lt; initialPressure) {\n    System.out.println(\"\u2713 Pressure successfully relieved\");\n}\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#verification-checks","title":"Verification Checks","text":""},{"location":"safety/PRESSURE_MONITORING_ESD/#automated-assertions","title":"Automated Assertions","text":"<pre><code>// Pressure should decrease after blowdown\nassertTrue(finalPressure &lt; pressureAtEsdActivation, \n    \"Pressure should decrease after ESD activation\");\n\n// Valve should be activated\nassertTrue(bdValve.isActivated(), \"BD valve should be activated\");\n\n// Gas should flow to flare\nassertTrue(flare.getCumulativeGasBurned(\"kg\") &gt; 0, \n    \"Gas should flow to flare\");\n\n// Valve should be fully open\nassertTrue(bdValve.getPercentValveOpening() &gt; 90.0, \n    \"BD valve should be nearly fully open\");\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#console-output-verification","title":"Console Output Verification","text":"<p>The system provides detailed output showing: - Time-series pressure data - Valve opening progression - Flow rates to flare - Status messages at key events</p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#running-the-examples","title":"Running the Examples","text":""},{"location":"safety/PRESSURE_MONITORING_ESD/#run-the-basic-example-with-pressure-monitoring","title":"Run the basic example with pressure monitoring:","text":"<pre><code>mvn exec:java -Dexec.mainClass=\"neqsim.process.util.example.ESDBlowdownSystemExample\"\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#run-the-comprehensive-test-suite","title":"Run the comprehensive test suite:","text":"<pre><code># Run all blowdown tests\nmvn test -Dtest=BlowdownValveESDSystemTest\n\n# Run specific pressure relief test\nmvn test -Dtest=BlowdownValveESDSystemTest#testPressureReliefViaBlowdown\n</code></pre>"},{"location":"safety/PRESSURE_MONITORING_ESD/#expected-results","title":"Expected Results","text":"<p>When the blowdown system is working correctly, you should observe:</p> <ol> <li>Pressure Decrease - Separator pressure drops after ESD activation</li> <li>Valve Opening - BD valve gradually opens to 100% over configured time</li> <li>Gas Flow - Significant flow rate through blowdown valve to flare</li> <li>Heat Release - Flare shows increasing heat duty as gas combusts</li> <li>Cumulative Tracking - Total gas burned and emissions tracked</li> </ol>"},{"location":"safety/PRESSURE_MONITORING_ESD/#typical-values","title":"Typical Values","text":"<ul> <li>Pressure drop: 10-30% reduction depending on flow rates and orifice sizing</li> <li>Opening time: 3-5 seconds for BD valve</li> <li>Blowdown rate: Controlled by orifice Cv (typically 100-200)</li> <li>Flare heat release: Proportional to gas flow rate and composition</li> </ul>"},{"location":"safety/PRESSURE_MONITORING_ESD/#troubleshooting","title":"Troubleshooting","text":"<p>If pressure is not relieved: 1. Check BD valve is activated: <code>bdValve.isActivated()</code> 2. Verify valve opening: <code>bdValve.getPercentValveOpening()</code> 3. Check flow to blowdown: <code>blowdownStream.getFlowRate(\"kg/hr\")</code> 4. Verify splitter redirects flow: <code>splitter.setSplitFactors(...)</code> 5. Check orifice pressure drop: <code>bdOrifice.getOutletPressure()</code></p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#integration-with-process-systems","title":"Integration with Process Systems","text":"<p>The pressure monitoring integrates with: - Alarm Systems - Can trigger on high/low pressure - Control Systems - Feedback for automatic control - Safety Systems - ESD interlock logic - Data Logging - Historical pressure trends - Flare Management - Load tracking and emissions</p>"},{"location":"safety/PRESSURE_MONITORING_ESD/#summary","title":"Summary","text":"<p>The enhanced ESD blowdown system provides: - \u2705 Real-time pressure monitoring during transient calculations - \u2705 Automated verification of pressure relief - \u2705 Detailed output showing system behavior - \u2705 Pressure buildup and relief scenarios - \u2705 Complete test coverage with assertions - \u2705 Integration with flare systems for emissions tracking</p> <p>This ensures that the blowdown valve correctly relieves pressure when activated, protecting equipment from overpressure conditions.</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/","title":"NeqSim Safety Simulation Roadmap","text":"<p>A comprehensive analysis of existing safety capabilities and a realistic implementation plan for enhancing NeqSim's safety simulation features.</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#executive-summary","title":"Executive Summary","text":"<p>NeqSim already has substantial safety infrastructure that covers approximately 90-95% of the proposed roadmap. </p> <p>Recently Implemented (2024): - \u2705 <code>LeakModel</code> - Choked/subsonic flow with time-series source terms - \u2705 <code>SourceTermResult</code> - Export to PHAST, FLACS, KFX, OpenFOAM - \u2705 <code>InitiatingEvent</code> enum - Standard safety scenario initiators - \u2705 <code>BoundaryConditions</code> - Environmental conditions with geographic presets - \u2705 <code>RiskModel</code> - Monte Carlo, event trees, sensitivity analysis (tornado diagrams) - \u2705 <code>RiskEvent</code> / <code>RiskResult</code> - Probabilistic risk quantification with F-N curves - \u2705 <code>SafetyEnvelopeCalculator</code> - Hydrate, wax, CO2, MDMT, phase envelope calculation - \u2705 <code>SafetyEnvelope</code> - P-T curve container with DCS/PI/Seeq export</p> <p>Remaining Gaps: 1. Dynamic PSV back-pressure modeling 2. Reaction force calculations per API 520 Annex D 3. Two-phase relief sizing (API 520 Section 4.6)</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#1-current-state-analysis","title":"1. Current State Analysis","text":""},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#31-native-safety-scenario-framework-largely-exists","title":"\u2705 3.1 Native Safety Scenario Framework \u2014 LARGELY EXISTS","text":"Feature Status Implementation <code>SafetyScenario</code> API \u2705 Exists <code>ProcessSafetyScenario</code> with Builder pattern Initiating events \u2705 Exists Blocked outlets, utility loss, controller overrides Custom manipulators \u2705 Exists Lambda-based equipment manipulation Scenario execution \u2705 Exists <code>ProcessSafetyAnalyzer.analyzeScenario()</code> Load case definition \u2705 Exists <code>ProcessSafetyLoadCase</code> Result repository \u2705 Exists <code>ProcessSafetyResultRepository</code> <p>Existing Code Location: <code>neqsim.process.safety.*</code></p> <pre><code>// Current API\nProcessSafetyScenario scenario = ProcessSafetyScenario.builder()\n    .name(\"Compressor blowdown\")\n    .blockedOutlet(\"V-101\")\n    .utilityLoss(\"Cooling-Water\")\n    .controllerSetPointOverride(\"PC-101\", 50.0)\n    .customManipulator(\"SEP-001\", eq -&gt; eq.setRegulatorOutSignal(0.0))\n    .build();\n\nProcessSafetyAnalyzer analyzer = new ProcessSafetyAnalyzer(processSystem);\nProcessSafetyLoadCase result = analyzer.analyzeScenario(scenario);\n</code></pre> <p>Implemented Additions: - [x] <code>InitiatingEvent</code> enum (ESD, PSV_LIFT, RUPTURE, LEAK_SMALL, LEAK_MEDIUM, LEAK_LARGE, FIRE_EXPOSURE, etc.) - [x] <code>BoundaryConditions</code> class (ambient temp, wind speed, humidity, stability class, presets for North Sea, Gulf of Mexico, etc.)</p> <p>Remaining Gaps: - [ ] Automatic inventory extraction from scenarios - [ ] Phase state tracking during scenario execution</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#32-dynamic-depressurization-blowdown-fully-implemented","title":"\u2705 3.2 Dynamic Depressurization &amp; Blowdown \u2014 FULLY IMPLEMENTED","text":"Feature Status Implementation Time-dependent pressure \u2705 Complete <code>VesselDepressurization.runTransient()</code> Time-dependent temperature \u2705 Complete Energy balance, adiabatic, isothermal modes Phase split evolution \u2705 Complete Two-phase support with separate wall temps Choked vs non-choked flow \u2705 Complete Critical pressure ratio calculation Real-gas speed of sound \u2705 Complete NeqSim thermodynamics MDMT prediction \u2705 Complete <code>getMinimumWallTemperatureReached()</code> Blowdown duration \u2705 Complete <code>getTimeToReachPressure()</code> Two-phase formation timing \u2705 Complete <code>hasLiquidRainout()</code> Valve/piping temperature \u2705 Complete <code>TransientWallHeatTransfer</code> Fire case (API 521) \u2705 Complete <code>setFireCase()</code>, heat flux models Valve dynamics \u2705 Complete <code>setValveOpeningTime()</code> Hydrate risk \u2705 Complete <code>getHydrateFormationTemperature()</code>, <code>hasHydrateRisk()</code> CO2 freezing risk \u2705 Complete <code>getCO2FreezingTemperature()</code>, <code>hasCO2FreezingRisk()</code> Export to CSV/JSON \u2705 Complete <code>exportResultsToCSV()</code>, <code>exportResultsToJSON()</code> <p>Existing Code Location:  - <code>neqsim.process.equipment.tank.VesselDepressurization</code> (~3000 lines) - <code>neqsim.process.util.fire.TransientWallHeatTransfer</code> - <code>neqsim.process.util.fire.VesselHeatTransferCalculator</code></p> <pre><code>// Current API\nVesselDepressurization vessel = new VesselDepressurization(\"Tank\", feed);\nvessel.setVolume(10.0);\nvessel.setOrificeDiameter(0.03);\nvessel.setCalculationType(CalculationType.ENERGY_BALANCE);\nvessel.setFireCase(true, 100.0); // 100 kW/m\u00b2 fire\n\nvessel.runTransient(dt, uuid);\n\n// Flow assurance\nMap&lt;String, String&gt; risks = vessel.assessFlowAssuranceRisks();\n</code></pre> <p>Status: COMPLETE \u2713</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#33-relief-and-vent-system-modeling-partially-exists","title":"\u26a0\ufe0f 3.3 Relief and Vent System Modeling \u2014 PARTIALLY EXISTS","text":"Feature Status Implementation SafetyValve class \u2705 Exists <code>SafetyValve</code> extends <code>ThrottlingValve</code> SafetyReliefValve \u2705 Exists <code>SafetyReliefValve</code> with lift dynamics Set pressure / blowdown \u2705 Exists <code>setPressureSpec()</code>, <code>setBlowdownPressure()</code> API 520 sizing \u2705 Exists <code>ReliefValveSizing.calculateRequiredArea()</code> API 521 fire heat input \u2705 Exists <code>calculateAPI521HeatInput()</code> Relieving scenarios \u2705 Exists <code>RelievingScenario</code> class Choked flow models \u2705 Exists Critical flow calculations Balanced-bellows support \u2705 Exists <code>isBalancedBellows</code> parameter Rupture disk combination \u2705 Exists <code>hasRuptureDisk</code> parameter Back pressure effects \u26a0\ufe0f Partial Static calculation, needs dynamic Reaction forces \u274c Missing Not implemented Flare connection \u26a0\ufe0f Partial <code>Flare</code> class exists, limited integration <p>Existing Code Location: - <code>neqsim.process.equipment.valve.SafetyValve</code> - <code>neqsim.process.equipment.valve.SafetyReliefValve</code> - <code>neqsim.process.util.fire.ReliefValveSizing</code></p> <p>Gaps to Address: - [ ] Dynamic back pressure model (time-dependent during relief) - [ ] Reaction force calculation per API 520 Annex D - [ ] Discharge piping pressure drop - [ ] Multiple PSV coordination - [ ] Two-phase relief sizing (API 520 Section 4.6)</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#34-leak-rupture-source-term-generator-implemented","title":"\u2705 3.4 Leak &amp; Rupture Source Term Generator \u2014 IMPLEMENTED","text":"Feature Status Implementation Leak model class \u2705 Complete <code>LeakModel</code> with Builder pattern Hole diameter specification \u2705 Complete <code>holeDiameter(double, String unit)</code> Mass flow vs time \u2705 Complete <code>calculateSourceTerm()</code> returns time series Gas/liquid split \u2705 Complete Vapor fraction tracked at each timestep Jet momentum \u2705 Complete <code>calculateJetMomentum()</code> Release temperature \u2705 Complete Temperature tracked with isentropic expansion Droplet size estimate \u2705 Complete SMD via modified Weber number correlation Export to PHAST/FLACS/KFX/OpenFOAM \u2705 Complete All export methods implemented <p>Implementation Location: <code>neqsim.process.safety.release.*</code></p> <ul> <li><code>LeakModel</code> - Main leak/rupture model with choked/subsonic flow</li> <li><code>SourceTermResult</code> - Time-series container with QRA tool export</li> <li><code>ReleaseOrientation</code> - Enum for release directions</li> <li><code>InitiatingEvent</code> - Enum for scenario initiating events (in <code>neqsim.process.safety</code>)</li> <li><code>BoundaryConditions</code> - Environmental conditions with presets (in <code>neqsim.process.safety</code>)</li> </ul> <pre><code>// Example usage\nLeakModel leak = LeakModel.builder()\n    .fluid(system)\n    .holeDiameter(25.0, \"mm\")\n    .vesselVolume(10.0)\n    .orientation(ReleaseOrientation.HORIZONTAL)\n    .scenarioName(\"HP Separator Leak\")\n    .build();\n\nSourceTermResult result = leak.calculateSourceTerm(600.0, 1.0); // 10 min, 1s step\nresult.exportToPHAST(\"leak_phast.csv\");\nresult.exportToFLACS(\"leak_flacs.csv\");\nresult.exportToKFX(\"leak_kfx.csv\");\nresult.exportToOpenFOAM(\"/path/to/openfoam/case\");\n</code></pre> <p>Original API design (now implemented):</p> <pre><code>// New package: neqsim.process.safety.release\n\npublic class LeakModel {\n    private double holeDiameter;  // m\n    private String location;\n    private LeakOrientation orientation; // HORIZONTAL, VERTICAL_UP, VERTICAL_DOWN\n\n    public SourceTermResult calculateSourceTerm(SystemInterface system);\n}\n\npublic class SourceTermResult {\n    private double[] time;           // s\n    private double[] massFlowRate;   // kg/s\n    private double[] temperature;    // K\n    private double[] vaporFraction;  // mol/mol\n    private double[] jetMomentum;    // N\n    private double[] liquidDropletSize; // m (SMD)\n\n    // Export methods\n    public void exportToPHAST(String filename);\n    public void exportToFLACS(String filename);\n    public void exportToKFX(String filename);\n    public void exportToOpenFOAM(String directory);\n}\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#35-probabilistic-risk-integration-implemented","title":"\u2705 3.5 Probabilistic &amp; Risk Integration \u2014 IMPLEMENTED","text":"Feature Status Implementation Monte Carlo analysis \u2705 Complete <code>RiskModel.runMonteCarloAnalysis(iterations)</code> Failure frequencies \u2705 Complete <code>RiskEvent</code> with frequency and error factors Conditional probabilities \u2705 Complete <code>RiskEvent</code> with parent events and conditional probability Event tree logic \u2705 Complete <code>RiskEvent.parentEvent()</code> for event tree branching Sensitivity analysis \u2705 Complete <code>RiskModel.runSensitivityAnalysis()</code> with tornado diagrams Risk quantification \u2705 Complete <code>RiskResult</code> with category frequencies and F-N curves Consequence categories \u2705 Complete <code>ConsequenceCategory</code> enum (NEGLIGIBLE to CATASTROPHIC) Export to CSV/JSON \u2705 Complete <code>RiskResult.exportToCSV()</code>, <code>exportToJSON()</code> <p>Implementation Location: <code>neqsim.process.safety.risk.*</code></p> <ul> <li><code>RiskEvent</code> - Individual risk event with frequency, probability, consequence category</li> <li><code>RiskModel</code> - Monte Carlo simulation and sensitivity analysis engine</li> <li><code>RiskResult</code> - Results container with F-N curves and export methods</li> <li><code>SensitivityResult</code> - Tornado diagram data and sensitivity indices</li> </ul> <pre><code>// Example usage\nRiskModel model = new RiskModel(\"HP Separator Study\");\nmodel.setRandomSeed(42);\n\n// Add initiating events with frequencies (per year)\nmodel.addInitiatingEvent(\"Small Leak\", 1e-3, ConsequenceCategory.MINOR);\nmodel.addInitiatingEvent(\"Medium Leak\", 1e-4, ConsequenceCategory.MODERATE);\nmodel.addInitiatingEvent(\"Large Rupture\", 1e-5, ConsequenceCategory.MAJOR);\n\n// Or use builder pattern for event trees\nRiskEvent fireEvent = RiskEvent.builder()\n    .name(\"Fire on Leak\")\n    .parentEvent(leakEvent)\n    .conditionalProbability(0.1)\n    .consequenceCategory(ConsequenceCategory.MAJOR)\n    .build();\nmodel.addEvent(fireEvent);\n\n// Run Monte Carlo analysis\nRiskResult result = model.runMonteCarloAnalysis(10000);\nresult.exportToCSV(\"risk_results.csv\");\n\n// Run sensitivity analysis (tornado diagram)\nSensitivityResult sensitivity = model.runSensitivityAnalysis(0.1, 10.0);\nsensitivity.exportToCSV(\"sensitivity.csv\");\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#36-safety-envelopes-operating-limits-implemented","title":"\u2705 3.6 Safety Envelopes &amp; Operating Limits \u2014 IMPLEMENTED","text":"Feature Status Implementation Hydrate envelope \u2705 Complete <code>SafetyEnvelopeCalculator.calculateHydrateEnvelope()</code> Wax appearance \u2705 Complete <code>SafetyEnvelopeCalculator.calculateWaxEnvelope()</code> MDMT/Brittle fracture \u2705 Complete <code>SafetyEnvelopeCalculator.calculateMDMTEnvelope()</code> CO2 solid formation \u2705 Complete <code>SafetyEnvelopeCalculator.calculateCO2FreezingEnvelope()</code> Phase envelope \u2705 Complete <code>SafetyEnvelopeCalculator.calculatePhaseEnvelope()</code> Temperature interpolation \u2705 Complete <code>SafetyEnvelope.getTemperatureAtPressure()</code> Operating point check \u2705 Complete <code>SafetyEnvelope.isOperatingPointSafe()</code> Safety margin calc \u2705 Complete <code>SafetyEnvelope.calculateMarginToLimit()</code> Export to CSV/JSON \u2705 Complete <code>SafetyEnvelope.exportToCSV()</code>, <code>exportToJSON()</code> Export to PI/Seeq \u2705 Complete <code>SafetyEnvelope.exportToPIFormat()</code>, <code>exportToSeeq()</code> <p>Implementation Location: <code>neqsim.process.safety.envelope.*</code></p> <ul> <li><code>SafetyEnvelope</code> - P-T curve container with interpolation and export methods</li> <li><code>SafetyEnvelopeCalculator</code> - Calculates hydrate, wax, CO2, MDMT, phase envelopes</li> <li><code>EnvelopeType</code> - Enum for HYDRATE, WAX, CO2_FREEZING, MDMT, PHASE_ENVELOPE, BRITTLE_FRACTURE</li> </ul> <pre><code>// Example usage\nSystemInterface naturalGas = new SystemSrkEos(300.0, 50.0);\nnaturalGas.addComponent(\"methane\", 0.85);\nnaturalGas.addComponent(\"ethane\", 0.10);\nnaturalGas.addComponent(\"propane\", 0.05);\nnaturalGas.setMixingRule(\"classic\");\n\nSafetyEnvelopeCalculator calc = new SafetyEnvelopeCalculator(naturalGas);\n\n// Calculate safety envelopes\nSafetyEnvelope hydrateEnv = calc.calculateHydrateEnvelope(1.0, 100.0, 20);\nSafetyEnvelope co2Env = calc.calculateCO2FreezingEnvelope(10.0, 100.0, 10);\nSafetyEnvelope mdmtEnv = calc.calculateMDMTEnvelope(1.0, 100.0, 300.0, 10);\n\n// Check operating point safety\nboolean safe = hydrateEnv.isOperatingPointSafe(50.0, 280.0);\ndouble margin = hydrateEnv.calculateMarginToLimit(50.0, 280.0);\n\n// Export for DCS/historian integration\nhydrateEnv.exportToCSV(\"hydrate_envelope.csv\");\nhydrateEnv.exportToPIFormat(\"hydrate_pi.csv\");\nhydrateEnv.exportToSeeq(\"hydrate_seeq.json\");\n\n// Calculate all envelopes at once\nSafetyEnvelope[] allEnvelopes = calc.calculateAllEnvelopes(1.0, 100.0, 20);\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#2-implementation-priority-matrix","title":"2. Implementation Priority Matrix","text":"Priority Feature Effort Impact Status 1 Leak/Release Source Term (3.4) High Critical \u274c Not started 2 Safety Envelope Calculator (3.6) Medium High \u274c Not started 3 Risk Model Framework (3.5) High High \u274c Not started 4 PSV Back Pressure Dynamics (3.3) Medium Medium \u26a0\ufe0f Partial 5 Initiating Event Enum (3.1) Low Medium \u274c Not started 6 Reaction Force Calculation (3.3) Low Low \u274c Not started"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#3-recommended-implementation-order","title":"3. Recommended Implementation Order","text":""},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#phase-1-complete-the-release-model-priority-1","title":"Phase 1: Complete the Release Model (Priority 1)","text":"<p>Timeline: 2-3 weeks</p> <p>Create <code>neqsim.process.safety.release</code> package with: 1. <code>LeakModel</code> - Hole/rupture specification 2. <code>SourceTermResult</code> - Time-series release data 3. <code>ReleaseExporter</code> - PHAST/FLACS/KFX/OpenFOAM export 4. Integration with <code>VesselDepressurization</code> for inventory tracking</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#phase-2-safety-envelope-calculator-priority-2","title":"Phase 2: Safety Envelope Calculator (Priority 2)","text":"<p>Timeline: 1-2 weeks</p> <p>Create <code>neqsim.process.safety.envelope</code> package with: 1. <code>SafetyEnvelopeCalculator</code> - Compute P-T envelopes 2. <code>SafetyEnvelope</code> - Data container with export 3. Integration with existing hydrate/CO2/MDMT calculations</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#phase-3-risk-framework-priority-3","title":"Phase 3: Risk Framework (Priority 3)","text":"<p>Timeline: 3-4 weeks</p> <p>Create <code>neqsim.process.safety.risk</code> package with: 1. <code>RiskModel</code> - Event tree / fault tree basics 2. <code>RiskEvent</code> - Frequencies and probabilities 3. <code>MonteCarloRiskAnalysis</code> - Uncertainty propagation 4. Integration with <code>ProcessSafetyScenario</code></p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#phase-4-enhanced-psv-modeling-priority-4","title":"Phase 4: Enhanced PSV Modeling (Priority 4)","text":"<p>Timeline: 1-2 weeks</p> <p>Enhance existing <code>SafetyValve</code> with: 1. Dynamic back pressure during relief 2. Two-phase relief flow 3. Reaction force calculation</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#4-existing-infrastructure-summary","title":"4. Existing Infrastructure Summary","text":"<pre><code>neqsim.process.safety/\n\u251c\u2500\u2500 ProcessSafetyScenario.java      \u2705 Scenario definition\n\u251c\u2500\u2500 ProcessSafetyAnalyzer.java      \u2705 Scenario execution\n\u251c\u2500\u2500 ProcessSafetyLoadCase.java      \u2705 Results container\n\u251c\u2500\u2500 ProcessSafetyResultRepository.java  \u2705 Results storage\n\u2514\u2500\u2500 ProcessSafetyAnalysisSummary.java   \u2705 Summary report\n\nneqsim.process.logic/\n\u251c\u2500\u2500 sis/\n\u2502   \u251c\u2500\u2500 SafetyInstrumentedFunction.java  \u2705 SIF with voting\n\u2502   \u251c\u2500\u2500 Detector.java                    \u2705 Fire/gas detectors\n\u2502   \u2514\u2500\u2500 VotingLogic.java                 \u2705 1oo1, 2oo3, etc.\n\u251c\u2500\u2500 hipps/                               \u2705 HIPPS logic\n\u251c\u2500\u2500 esd/                                 \u2705 ESD sequences\n\u251c\u2500\u2500 shutdown/                            \u2705 Shutdown logic\n\u2514\u2500\u2500 voting/                              \u2705 Voting patterns\n\nneqsim.process.equipment.valve/\n\u251c\u2500\u2500 SafetyValve.java                \u2705 PSV with hysteresis\n\u251c\u2500\u2500 SafetyReliefValve.java          \u2705 Relief valve dynamics\n\u2514\u2500\u2500 RelievingScenario.java          \u2705 Scenario definitions\n\nneqsim.process.util.fire/\n\u251c\u2500\u2500 ReliefValveSizing.java          \u2705 API 520/521 sizing\n\u251c\u2500\u2500 FireHeatLoadCalculator.java     \u2705 API 521 heat input\n\u251c\u2500\u2500 VesselRuptureCalculator.java    \u2705 Von Mises stress\n\u251c\u2500\u2500 SeparatorFireExposure.java      \u2705 Fire case wrapper\n\u251c\u2500\u2500 TransientWallHeatTransfer.java  \u2705 Wall temperature\n\u2514\u2500\u2500 VesselHeatTransferCalculator.java  \u2705 Heat transfer\n\nneqsim.process.equipment.tank/\n\u2514\u2500\u2500 VesselDepressurization.java     \u2705 Full blowdown (~3000 lines)\n    \u251c\u2500\u2500 5 calculation types\n    \u251c\u2500\u2500 Two-phase support\n    \u251c\u2500\u2500 Fire case (API 521)\n    \u251c\u2500\u2500 Valve dynamics\n    \u251c\u2500\u2500 Hydrate/CO2 risk\n    \u251c\u2500\u2500 MDMT monitoring\n    \u251c\u2500\u2500 Flare integration\n    \u2514\u2500\u2500 CSV/JSON export\n\nneqsim.process.equipment.flare/\n\u2514\u2500\u2500 Flare.java                      \u2705 Flare equipment\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#5-quick-wins-can-implement-now","title":"5. Quick Wins (Can Implement Now)","text":""},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#51-add-initiatingevent-enum","title":"5.1 Add InitiatingEvent Enum","text":"<pre><code>public enum InitiatingEvent {\n    ESD(\"Emergency Shutdown\"),\n    PSV_LIFT(\"Pressure Safety Valve Lift\"),\n    RUPTURE(\"Vessel/Pipe Rupture\"),\n    LEAK_SMALL(\"Small Leak (&lt; 10mm)\"),\n    LEAK_MEDIUM(\"Medium Leak (10-50mm)\"),\n    LEAK_LARGE(\"Large Leak (&gt; 50mm)\"),\n    BLOCKED_OUTLET(\"Blocked Outlet\"),\n    UTILITY_LOSS(\"Loss of Utility\"),\n    FIRE_EXPOSURE(\"Fire Exposure\"),\n    RUNAWAY_REACTION(\"Runaway Reaction\");\n\n    private final String description;\n    // ...\n}\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#52-add-boundaryconditions-class","title":"5.2 Add BoundaryConditions Class","text":"<pre><code>public class BoundaryConditions implements Serializable {\n    private double ambientTemperature = 288.15; // K\n    private double windSpeed = 5.0;             // m/s\n    private double relativeHumidity = 0.6;      // fraction\n    private double solarRadiation = 0.0;        // W/m\u00b2\n\n    // Builder pattern...\n}\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#53-hydrate-envelope-method-add-to-thermodynamicoperations","title":"5.3 Hydrate Envelope Method (Add to ThermodynamicOperations)","text":"<pre><code>public double[][] calculateHydrateEnvelope(double pMin, double pMax, int points) {\n    double[][] envelope = new double[2][points];\n    double pStep = (pMax - pMin) / (points - 1);\n\n    for (int i = 0; i &lt; points; i++) {\n        double p = pMin + i * pStep;\n        system.setPressure(p);\n        hydrateFormationTemperature();\n        envelope[0][i] = p;\n        envelope[1][i] = system.getTemperature();\n    }\n    return envelope;\n}\n</code></pre>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#6-conclusion","title":"6. Conclusion","text":"<p>NeqSim's safety simulation capabilities are more mature than initially apparent. The main gaps are:</p> <ol> <li>Source Term Generation \u2014 Critical for QRA, needs new package</li> <li>Safety Envelopes \u2014 Straightforward extension of existing calculations</li> <li>Risk Framework \u2014 Foundational work needed for probabilistic analysis</li> </ol> <p>The dynamic blowdown module (3.2) is fully complete with the <code>VesselDepressurization</code> class, including all requested features plus hydrate/CO2 risk assessment.</p>"},{"location":"safety/SAFETY_SIMULATION_ROADMAP/#references","title":"References","text":"<ul> <li>NeqSim Process Safety Documentation: <code>docs/fire_blowdown_capabilities.md</code></li> <li>HIPPS Implementation: <code>docs/hipps_implementation.md</code></li> <li>Alarm System Guide: <code>docs/alarm_system_guide.md</code></li> <li>VesselDepressurization Tutorial: <code>notebooks/VesselDepressurizationTutorial.ipynb</code></li> </ul>"},{"location":"safety/alarm_system_guide/","title":"NeqSim Alarm System Configuration Guide","text":""},{"location":"safety/alarm_system_guide/#overview","title":"Overview","text":"<p>The NeqSim alarm system provides a comprehensive framework for monitoring process variables and managing alarm states throughout the lifecycle of process operations. This guide demonstrates how to configure and handle alarms in a consistent and easy way.</p>"},{"location":"safety/alarm_system_guide/#key-components","title":"Key Components","text":""},{"location":"safety/alarm_system_guide/#1-alarmconfig-builder-pattern","title":"1. AlarmConfig (Builder Pattern)","text":"<p>Configure alarms using the fluent builder pattern:</p> <pre><code>AlarmConfig pressureAlarmConfig = AlarmConfig.builder()\n    .lowLowLimit(10.0)        // LOLO alarm threshold\n    .lowLimit(20.0)           // LO alarm threshold\n    .highLimit(80.0)          // HI alarm threshold\n    .highHighLimit(90.0)      // HIHI alarm threshold\n    .deadband(2.0)            // Deadband to prevent chattering\n    .delay(3.0)               // Time delay before activation (seconds)\n    .unit(\"bara\")             // Engineering unit\n    .build();\n</code></pre>"},{"location":"safety/alarm_system_guide/#2-alarm-levels","title":"2. Alarm Levels","text":"<p>Four standard alarm levels aligned with ISA-18.2:</p> <ul> <li>LOLO: Low-Low (most severe low alarm)</li> <li>LO: Low alarm</li> <li>HI: High alarm</li> <li>HIHI: High-High (most severe high alarm)</li> </ul>"},{"location":"safety/alarm_system_guide/#3-processalarmmanager","title":"3. ProcessAlarmManager","text":"<p>Centralized coordinator for all process alarms:</p> <pre><code>ProcessAlarmManager alarmManager = new ProcessAlarmManager();\n\n// Register measurement devices\nalarmManager.register(pressureTransmitter);\nalarmManager.register(temperatureTransmitter);\nalarmManager.register(flowTransmitter);\n\n// Evaluate alarms during simulation\ndouble measuredValue = transmitter.getMeasuredValue();\nList&lt;AlarmEvent&gt; events = alarmManager.evaluateMeasurement(\n    transmitter, measuredValue, dt, currentTime);\n\n// Acknowledge all active alarms\nList&lt;AlarmEvent&gt; ackEvents = alarmManager.acknowledgeAll(currentTime);\n\n// Get active alarms\nList&lt;AlarmStatusSnapshot&gt; activeAlarms = alarmManager.getActiveAlarms();\n\n// Get complete alarm history\nList&lt;AlarmEvent&gt; history = alarmManager.getHistory();\n</code></pre>"},{"location":"safety/alarm_system_guide/#alarm-configuration-examples","title":"Alarm Configuration Examples","text":""},{"location":"safety/alarm_system_guide/#pressure-alarms","title":"Pressure Alarms","text":"<pre><code>PressureTransmitter pt = new PressureTransmitter(\"PT-101\", stream);\n\nAlarmConfig pressureAlarms = AlarmConfig.builder()\n    .highLimit(55.0)          // HI: 55 bara\n    .highHighLimit(58.0)      // HIHI: 58 bara\n    .deadband(1.0)            // 1 bara deadband\n    .delay(2.0)               // 2 second delay\n    .unit(\"bara\")\n    .build();\n\npt.setAlarmConfig(pressureAlarms);\nalarmManager.register(pt);\n</code></pre>"},{"location":"safety/alarm_system_guide/#temperature-alarms","title":"Temperature Alarms","text":"<pre><code>TemperatureTransmitter tt = new TemperatureTransmitter(\"TT-101\", stream);\n\nAlarmConfig tempAlarms = AlarmConfig.builder()\n    .highLimit(45.0)          // HI: 45\u00b0C\n    .highHighLimit(60.0)      // HIHI: 60\u00b0C\n    .deadband(2.0)            // 2\u00b0C deadband\n    .delay(5.0)               // 5 second delay (slower response)\n    .unit(\"C\")\n    .build();\n\ntt.setAlarmConfig(tempAlarms);\nalarmManager.register(tt);\n</code></pre>"},{"location":"safety/alarm_system_guide/#flow-alarms-with-low-limits","title":"Flow Alarms (with Low Limits)","text":"<pre><code>FlowTransmitter ft = new FlowTransmitter(\"FT-201\", stream);\n\nAlarmConfig flowAlarms = AlarmConfig.builder()\n    .lowLowLimit(100.0)       // LOLO: 100 kg/hr\n    .lowLimit(500.0)          // LO: 500 kg/hr\n    .highLimit(20000.0)       // HI: 20000 kg/hr\n    .deadband(50.0)           // 50 kg/hr deadband\n    .delay(3.0)               // 3 second delay\n    .unit(\"kg/hr\")\n    .build();\n\nft.setAlarmConfig(flowAlarms);\nalarmManager.register(ft);\n</code></pre>"},{"location":"safety/alarm_system_guide/#level-alarms-full-range","title":"Level Alarms (Full Range)","text":"<pre><code>LevelTransmitter lt = new LevelTransmitter(\"LT-101\", separator);\n\nAlarmConfig levelAlarms = AlarmConfig.builder()\n    .lowLowLimit(15.0)        // LOLO: 15%\n    .lowLimit(30.0)           // LO: 30%\n    .highLimit(75.0)          // HI: 75%\n    .highHighLimit(90.0)      // HIHI: 90%\n    .deadband(2.0)            // 2% deadband\n    .delay(4.0)               // 4 second delay\n    .unit(\"%\")\n    .build();\n\nlt.setAlarmConfig(levelAlarms);\nalarmManager.register(lt);\n</code></pre>"},{"location":"safety/alarm_system_guide/#alarm-event-handling","title":"Alarm Event Handling","text":""},{"location":"safety/alarm_system_guide/#event-types","title":"Event Types","text":"<p>Three types of alarm events:</p> <ol> <li>ACTIVATED: Alarm becomes active</li> <li>CLEARED: Alarm returns to normal</li> <li>ACKNOWLEDGED: Operator acknowledges the alarm</li> </ol>"},{"location":"safety/alarm_system_guide/#processing-alarm-events","title":"Processing Alarm Events","text":"<pre><code>List&lt;AlarmEvent&gt; events = alarmManager.evaluateMeasurement(\n    transmitter, measuredValue, dt, time);\n\nfor (AlarmEvent event : events) {\n    switch (event.getType()) {\n        case ACTIVATED:\n            System.out.println(\"\u26a0 ALARM: \" + event.getSource() + \n                              \" \" + event.getLevel() + \n                              \" at \" + event.getValue());\n            // Trigger operator notification\n            // Log to SCADA system\n            break;\n\n        case CLEARED:\n            System.out.println(\"\u2713 CLEARED: \" + event.getSource() + \n                              \" \" + event.getLevel());\n            // Log clearance\n            break;\n\n        case ACKNOWLEDGED:\n            System.out.println(\"\u270b ACKNOWLEDGED: \" + event.getSource());\n            // Update alarm display\n            break;\n    }\n}\n</code></pre>"},{"location":"safety/alarm_system_guide/#alarm-status-monitoring","title":"Alarm Status Monitoring","text":""},{"location":"safety/alarm_system_guide/#get-active-alarms","title":"Get Active Alarms","text":"<pre><code>List&lt;AlarmStatusSnapshot&gt; activeAlarms = alarmManager.getActiveAlarms();\n\nSystem.out.println(\"Active Alarms: \" + activeAlarms.size());\nfor (AlarmStatusSnapshot alarm : activeAlarms) {\n    String status = alarm.isAcknowledged() ? \"[ACK]\" : \"[NEW]\";\n    System.out.println(status + \" \" + \n                      alarm.getLevel() + \" - \" + \n                      alarm.getSource() + \": \" + \n                      alarm.getValue());\n}\n</code></pre>"},{"location":"safety/alarm_system_guide/#alarm-history","title":"Alarm History","text":"<pre><code>List&lt;AlarmEvent&gt; history = alarmManager.getHistory();\n\n// Count events by type\nlong activations = history.stream()\n    .filter(e -&gt; e.getType() == AlarmEventType.ACTIVATED)\n    .count();\n\nlong clearances = history.stream()\n    .filter(e -&gt; e.getType() == AlarmEventType.CLEARED)\n    .count();\n\nlong acknowledged = history.stream()\n    .filter(e -&gt; e.getType() == AlarmEventType.ACKNOWLEDGED)\n    .count();\n</code></pre>"},{"location":"safety/alarm_system_guide/#integration-with-safety-logic","title":"Integration with Safety Logic","text":""},{"location":"safety/alarm_system_guide/#alarm-triggered-esd","title":"Alarm-Triggered ESD","text":"<p>Alarms can be integrated with ESD logic to trigger automatic actions:</p> <pre><code>// Monitor pressure alarms\nList&lt;AlarmEvent&gt; events = alarmManager.evaluateMeasurement(\n    pressureTransmitter, pressure, dt, time);\n\n// Check for HIHI alarm activation\nfor (AlarmEvent event : events) {\n    if (event.getType() == AlarmEventType.ACTIVATED &amp;&amp; \n        event.getLevel() == AlarmLevel.HIHI) {\n        // Trigger ESD logic\n        esdLogic.activate();\n        System.out.println(\"ESD triggered by HIHI pressure alarm\");\n    }\n}\n</code></pre>"},{"location":"safety/alarm_system_guide/#best-practices","title":"Best Practices","text":""},{"location":"safety/alarm_system_guide/#1-alarm-configuration","title":"1. Alarm Configuration","text":"<ul> <li>Use appropriate deadbands: Prevent alarm chattering (typically 1-5% of range)</li> <li>Set realistic delays: Balance responsiveness vs. nuisance alarms</li> <li>Fast processes: 1-3 seconds</li> <li>Slow processes: 5-10 seconds</li> <li>Safety critical: 0 seconds (immediate)</li> </ul>"},{"location":"safety/alarm_system_guide/#2-alarm-priorities","title":"2. Alarm Priorities","text":"<ul> <li>HIHI/LOLO: Immediate action required, potential safety impact</li> <li>HI/LO: Operator intervention needed, performance degradation</li> <li>Use alarm levels consistently across the plant</li> </ul>"},{"location":"safety/alarm_system_guide/#3-alarm-management","title":"3. Alarm Management","text":"<ul> <li>Monitor alarm rates: High alarm rates indicate poor tuning</li> <li>Acknowledge alarms promptly: Maintain operator awareness</li> <li>Review alarm history: Identify recurring issues</li> <li>Test alarm systems: Verify correct operation during commissioning</li> </ul>"},{"location":"safety/alarm_system_guide/#4-safety-integration","title":"4. Safety Integration","text":"<ul> <li>Safety-critical alarms: No delay, minimal deadband</li> <li>Voting systems (2oo3): Configure identical alarms on redundant sensors</li> <li>Automatic actions: Link HIHI/LOLO alarms to safety logic</li> <li>Operator alarms (HI/LO): Allow operator intervention before automatic action</li> </ul>"},{"location":"safety/alarm_system_guide/#example-application","title":"Example Application","text":"<p>See <code>ProcessLogicWithAlarmsExample.java</code> for a complete demonstration showing:</p> <ul> <li>Multi-level alarm configuration for pressure, temperature, flow, and level</li> <li>ProcessAlarmManager integration</li> <li>Alarm event handling and display</li> <li>Operator acknowledgement workflow</li> <li>Alarm history reporting</li> <li>Integration with ESD and startup logic</li> </ul>"},{"location":"safety/alarm_system_guide/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 ProcessAlarmManager                         \u2502\n\u2502  - Centralized alarm coordination                           \u2502\n\u2502  - Alarm history tracking                                   \u2502\n\u2502  - Active alarm monitoring                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502            \u2502            \u2502            \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Pressure TX  \u2502 \u2502 Temp TX \u2502 \u2502 Flow TX \u2502 \u2502Level TX \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 AlarmConfig  \u2502 \u2502AlarmCfg \u2502 \u2502AlarmCfg \u2502 \u2502AlarmCfg \u2502\n\u2502 - HI: 55     \u2502 \u2502- HI: 45 \u2502 \u2502- LO:500 \u2502 \u2502- HI: 75 \u2502\n\u2502 - HIHI: 58   \u2502 \u2502-HIHI:60 \u2502 \u2502-LOLO:100\u2502 \u2502-HIHI:90 \u2502\n\u2502 - Deadband:1 \u2502 \u2502-Dband:2 \u2502 \u2502-HI:20000\u2502 \u2502- LO: 30 \u2502\n\u2502 - Delay: 2s  \u2502 \u2502-Delay:5s\u2502 \u2502-Dband:50\u2502 \u2502-LOLO:15 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502            \u2502            \u2502            \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502     AlarmEvent Stream       \u2502\n        \u2502  - ACTIVATED                \u2502\n        \u2502  - CLEARED                  \u2502\n        \u2502  - ACKNOWLEDGED             \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502  Integration Points         \u2502\n        \u2502  - ESD Logic Triggers       \u2502\n        \u2502  - SCADA Display            \u2502\n        \u2502  - Historian Logging        \u2502\n        \u2502  - Operator Notifications   \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"safety/alarm_system_guide/#summary","title":"Summary","text":"<p>The NeqSim alarm system provides:</p> <p>\u2713 Consistent Configuration: Builder pattern for all alarm types \u2713 Flexible Limits: Support for LOLO, LO, HI, HIHI levels \u2713 Smart Behavior: Deadband and delay to prevent nuisance alarms \u2713 Centralized Management: ProcessAlarmManager for system-wide coordination \u2713 Event Tracking: Complete lifecycle from activation to acknowledgement \u2713 Safety Integration: Seamless connection to ESD and control logic  </p> <p>This framework enables reliable process monitoring with minimal code complexity while maintaining industrial alarm management best practices.</p>"},{"location":"safety/alarm_triggered_logic_example/","title":"Alarm-Triggered Process Logic Integration Example","text":""},{"location":"safety/alarm_triggered_logic_example/#overview","title":"Overview","text":"<p><code>ProcessLogicAlarmIntegratedExample.java</code> demonstrates a complete, production-ready integration of the NeqSim alarm system with process control and safety logic. This example shows how alarms can trigger automatic control actions, safety responses, and emergency shutdown sequences in a layered protection architecture.</p>"},{"location":"safety/alarm_triggered_logic_example/#key-features","title":"Key Features","text":""},{"location":"safety/alarm_triggered_logic_example/#1-layered-safety-architecture-with-alarm-integration","title":"1. Layered Safety Architecture with Alarm Integration","text":"<p>The example implements a comprehensive 5-layer safety system:</p> <pre><code>Layer 1 (Alarms - SIL-0):\n  \u251c\u2500 HI/LO Alarms \u2192 Operator notification and manual intervention\n  \u2502\nLayer 2 (Alarms + Control - SIL-1):\n  \u251c\u2500 HIHI/LOLO Alarms \u2192 Automatic control responses (valve throttling, etc.)\n  \u2502\nLayer 3 (HIPPS - SIL-2):\n  \u251c\u2500 Independent fast-acting pressure protection\n  \u251c\u2500 2oo3 voting logic on pressure transmitters\n  \u251c\u2500 Triggered by PT-HIPPS HIHI alarms (59 bara)\n  \u2502\nLayer 4 (ESD - SIL-2):\n  \u251c\u2500 Emergency shutdown system\n  \u251c\u2500 Triggered by PT-ESD-001 HIHI alarm (60 bara) or manual button\n  \u251c\u2500 Full isolation and blowdown sequence\n  \u2502\nLayer 5 (PSV - Mechanical):\n  \u2514\u2500 Pressure safety valve (65 bara set pressure)\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#2-multi-variable-alarm-monitoring","title":"2. Multi-Variable Alarm Monitoring","text":""},{"location":"safety/alarm_triggered_logic_example/#pressure-monitoring-pt-101","title":"Pressure Monitoring (PT-101)","text":"<pre><code>AlarmConfig pressureAlarmConfig = AlarmConfig.builder()\n    .highLimit(53.0)          // HI: Operator notification\n    .highHighLimit(56.0)      // HIHI: Auto throttle valve\n    .deadband(0.5)\n    .delay(1.0)\n    .unit(\"bara\")\n    .build();\n</code></pre> <p>Alarm Actions: - HI (53 bara): Operator notification only, no automatic action - HIHI (56 bara): Automatic valve throttling to 50% opening</p>"},{"location":"safety/alarm_triggered_logic_example/#temperature-monitoring-tt-101","title":"Temperature Monitoring (TT-101)","text":"<pre><code>AlarmConfig temperatureAlarmConfig = AlarmConfig.builder()\n    .highLimit(40.0)          // HI: Operator notification\n    .highHighLimit(55.0)      // HIHI: Trigger cooling\n    .deadband(2.0)\n    .delay(3.0)\n    .unit(\"C\")\n    .build();\n</code></pre> <p>Alarm Actions: - HI (40\u00b0C): Operator notification - HIHI (55\u00b0C): Trigger cooling actions (demonstrated in framework)</p>"},{"location":"safety/alarm_triggered_logic_example/#flow-monitoring-ft-201","title":"Flow Monitoring (FT-201)","text":"<pre><code>AlarmConfig flowAlarmConfig = AlarmConfig.builder()\n    .lowLimit(100.0)          // LO: Operator notification\n    .lowLowLimit(50.0)        // LOLO: Trigger shutdown\n    .highLimit(2000.0)        // HI: High flow warning\n    .deadband(10.0)\n    .delay(5.0)\n    .unit(\"m3/hr\")\n    .build();\n</code></pre> <p>Alarm Actions: - LO (100 m\u00b3/hr): Operator notification - LOLO (50 m\u00b3/hr): Controlled shutdown sequence</p>"},{"location":"safety/alarm_triggered_logic_example/#level-monitoring-lt-101","title":"Level Monitoring (LT-101)","text":"<pre><code>AlarmConfig levelAlarmConfig = AlarmConfig.builder()\n    .lowLowLimit(20.0)        // LOLO: Emergency shutdown\n    .lowLimit(30.0)           // LO: Operator notification\n    .highLimit(70.0)          // HI: High level warning\n    .highHighLimit(85.0)      // HIHI: Critical high level\n    .deadband(2.0)\n    .delay(2.0)\n    .unit(\"%\")\n    .build();\n</code></pre> <p>Alarm Actions: - LOLO (20%): Emergency shutdown to prevent dry running - LO (30%): Operator notification</p>"},{"location":"safety/alarm_triggered_logic_example/#3-safety-critical-alarm-configuration","title":"3. Safety-Critical Alarm Configuration","text":""},{"location":"safety/alarm_triggered_logic_example/#hipps-protection-pt-hipps-123","title":"HIPPS Protection (PT-HIPPS-\u00bd/3)","text":"<pre><code>AlarmConfig hippsAlarmConfig = AlarmConfig.builder()\n    .highHighLimit(59.0)      // Immediate HIPPS closure\n    .deadband(0.2)            // Minimal deadband\n    .delay(0.0)               // No delay - safety critical\n    .unit(\"bara\")\n    .build();\n</code></pre> <p>2oo3 Voting Logic: - Three independent pressure transmitters - HIPPS activates when 2 out of 3 transmitters exceed HIHI limit - No time delay for immediate protection</p>"},{"location":"safety/alarm_triggered_logic_example/#esd-trigger-pt-esd-001","title":"ESD Trigger (PT-ESD-001)","text":"<pre><code>AlarmConfig esdAlarmConfig = AlarmConfig.builder()\n    .highHighLimit(60.0)      // Full ESD sequence\n    .deadband(0.5)\n    .delay(0.0)               // Immediate ESD trigger\n    .unit(\"bara\")\n    .build();\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#demonstration-scenarios","title":"Demonstration Scenarios","text":"<p>The example runs six comprehensive scenarios demonstrating alarm-triggered logic:</p>"},{"location":"safety/alarm_triggered_logic_example/#scenario-1-normal-operation","title":"Scenario 1: Normal Operation","text":"<ul> <li>System startup with alarm monitoring</li> <li>All parameters within normal range</li> <li>No alarms active</li> </ul>"},{"location":"safety/alarm_triggered_logic_example/#scenario-2-hi-alarm-operator-notification","title":"Scenario 2: HI Alarm - Operator Notification","text":"<ul> <li>Feed pressure increased to 54 bara (above HI limit of 53 bara)</li> <li>PT-101 HI alarm activated</li> <li>Response: Operator notification only, no automatic action</li> <li>Demonstrates Layer 1 protection</li> </ul>"},{"location":"safety/alarm_triggered_logic_example/#scenario-3-hihi-alarm-automatic-control","title":"Scenario 3: HIHI Alarm - Automatic Control","text":"<ul> <li>Feed pressure increased to 57 bara (above HIHI limit of 56 bara)</li> <li>PT-101 HIHI alarm activated</li> <li>Response: Automatic valve throttling to 50% opening</li> <li>System pressure reduced through control action</li> <li>Alarm acknowledged after action</li> <li>Demonstrates Layer 2 protection</li> </ul>"},{"location":"safety/alarm_triggered_logic_example/#scenario-4-hipps-activation","title":"Scenario 4: HIPPS Activation","text":"<ul> <li>Feed pressure increased to 60 bara (HIPPS activation level)</li> <li>PT-HIPPS HIHI alarms triggered (2oo3 voting)</li> <li>Response: Immediate HIPPS valve closure (3 second stroke time)</li> <li>Demonstrates Layer 3 protection (SIL-2)</li> </ul>"},{"location":"safety/alarm_triggered_logic_example/#scenario-5-esd-triggered-by-alarm","title":"Scenario 5: ESD Triggered by Alarm","text":"<ul> <li>Feed pressure increased to 61 bara (ESD activation level)</li> <li>PT-ESD-001 HIHI alarm activated</li> <li>Response: Full ESD sequence:</li> <li>Close inlet isolation valves</li> <li>Route gas to blowdown system</li> <li>Depressurize to flare</li> <li>Switch separator to transient mode</li> <li>Demonstrates Layer 4 protection (SIL-2)</li> </ul>"},{"location":"safety/alarm_triggered_logic_example/#scenario-6-low-level-emergency-shutdown","title":"Scenario 6: Low Level Emergency Shutdown","text":"<ul> <li>Separator level drops to 20% (LOLO limit)</li> <li>LT-101 LOLO alarm activated</li> <li>Response: Emergency shutdown to prevent dry running</li> <li>Demonstrates process-specific alarm triggers</li> </ul>"},{"location":"safety/alarm_triggered_logic_example/#code-structure","title":"Code Structure","text":""},{"location":"safety/alarm_triggered_logic_example/#main-components","title":"Main Components","text":"<pre><code>// 1. Build process system\nProcessSystem processSystem = buildProcessSystem();\n\n// 2. Create alarm manager\nProcessAlarmManager alarmManager = new ProcessAlarmManager();\n\n// 3. Setup instrumentation with alarms\nInstrumentationSetup instruments = \n    setupInstrumentationWithAlarms(processSystem, alarmManager);\n\n// 4. Setup process logic\nProcessLogicSetup logicSetup = setupProcessLogic(processSystem, instruments);\n\n// 5. Run scenarios\nrunAlarmTriggeredScenarios(runner, alarmManager, instruments, \n                          logicSetup, processSystem);\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#alarm-evaluation-loop","title":"Alarm Evaluation Loop","text":"<pre><code>private static List&lt;AlarmEvent&gt; evaluateAndDisplayAlarms(\n    ProcessAlarmManager alarmManager,\n    InstrumentationSetup instruments, \n    ProcessSystem system, \n    double dt) {\n\n    List&lt;AlarmEvent&gt; allEvents = new ArrayList&lt;&gt;();\n\n    // Run process to get current values\n    system.run();\n\n    // Evaluate each measurement device\n    double sepPressure = instruments.separatorPT.getMeasuredValue();\n    allEvents.addAll(alarmManager.evaluateMeasurement(\n        instruments.separatorPT, sepPressure, dt, simulationTime));\n\n    // ... evaluate other transmitters ...\n\n    return allEvents;\n}\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#alarm-triggered-control-actions","title":"Alarm-Triggered Control Actions","text":"<pre><code>private static void handlePressureHIHIAlarm(List&lt;AlarmEvent&gt; events, \n                                           ProcessSystem system,\n                                           ProcessAlarmManager alarmManager) {\n\n    for (AlarmEvent event : events) {\n        if (event.getType() == AlarmEventType.ACTIVATED &amp;&amp; \n            event.getLevel() == AlarmLevel.HIHI &amp;&amp;\n            event.getSource().equals(\"PT-101\")) {\n\n            // Automatic control response\n            ControlValve inletValve = \n                (ControlValve) system.getUnit(\"Inlet Control Valve\");\n            inletValve.setPercentValveOpening(50.0);\n\n            // Run system with new valve position\n            system.run();\n\n            // Acknowledge alarm after action\n            alarmManager.acknowledgeAll(simulationTime);\n        }\n    }\n}\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#alarm-triggered-safety-logic","title":"Alarm-Triggered Safety Logic","text":"<pre><code>private static void handleHIPPSAlarm(List&lt;AlarmEvent&gt; events, \n                                    ESDLogic hippsLogic,\n                                    ProcessAlarmManager alarmManager) {\n\n    for (AlarmEvent event : events) {\n        if (event.getType() == AlarmEventType.ACTIVATED &amp;&amp; \n            event.getLevel() == AlarmLevel.HIHI &amp;&amp;\n            event.getSource().startsWith(\"PT-HIPPS\")) {\n\n            // Activate HIPPS logic\n            hippsLogic.activate();\n\n            alarmManager.acknowledgeAll(simulationTime);\n            break; // Only need one HIPPS transmitter to trigger\n        }\n    }\n}\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#output-reports","title":"Output Reports","text":"<p>The example generates comprehensive reports:</p>"},{"location":"safety/alarm_triggered_logic_example/#1-alarm-status-display","title":"1. Alarm Status Display","text":"<p>Shows currently active alarms with acknowledgement status: <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ALARM STATUS: After HIHI Alarm + Auto Control          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Active Alarms: 1                                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [ACK] HIHI - PT-101        : 57.00                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"safety/alarm_triggered_logic_example/#2-alarm-history-report","title":"2. Alarm History Report","text":"<p>Shows all alarm events with timestamps: <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    ALARM HISTORY REPORT                        \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  Total Events: 12                                              \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  Recent Events (last 10):                                      \u2551\n\u2551  \u26a0 30.0s ACTIVATED  PT-101          HI   53.50                \u2551\n\u2551  \u26a0 35.0s ACTIVATED  PT-101          HIHI 57.00                \u2551\n\u2551  \u270b 35.5s ACKNOWLEDGED PT-101       HIHI 57.00                \u2551\n\u2551  ...                                                           \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre></p>"},{"location":"safety/alarm_triggered_logic_example/#3-alarm-statistics","title":"3. Alarm Statistics","text":"<p>Aggregated statistics by type and level: <pre><code>\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n\u2551                    ALARM STATISTICS                            \u2551\n\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563\n\u2551  Total Activations:     8                                      \u2551\n\u2551  Total Clearances:      3                                      \u2551\n\u2551  Total Acknowledgements: 5                                     \u2551\n\u2551                                                                \u2551\n\u2551  By Level:                                                     \u2551\n\u2551    HIHI (Critical High): 4                                     \u2551\n\u2551    HI (High):            2                                     \u2551\n\u2551    LO (Low):             1                                     \u2551\n\u2551    LOLO (Critical Low):  1                                     \u2551\n\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n</code></pre></p>"},{"location":"safety/alarm_triggered_logic_example/#integration-patterns","title":"Integration Patterns","text":""},{"location":"safety/alarm_triggered_logic_example/#pattern-1-alarm-triggered-control-adjustment","title":"Pattern 1: Alarm-Triggered Control Adjustment","text":"<pre><code>// Monitor for HIHI alarm\nif (alarm.getLevel() == AlarmLevel.HIHI) {\n    // Implement automatic control response\n    valve.setPercentValveOpening(safeValue);\n    system.run();\n    alarmManager.acknowledgeAll(time);\n}\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#pattern-2-alarm-triggered-safety-logic","title":"Pattern 2: Alarm-Triggered Safety Logic","text":"<pre><code>// Monitor for safety-critical alarm\nif (alarm.getLevel() == AlarmLevel.HIHI &amp;&amp; \n    alarm.getSource().equals(\"PT-ESD-001\")) {\n    // Activate safety logic\n    esdLogic.activate();\n}\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#pattern-3-alarm-acknowledgement-workflow","title":"Pattern 3: Alarm Acknowledgement Workflow","text":"<pre><code>// Evaluate alarms\nList&lt;AlarmEvent&gt; events = evaluateAlarms();\n\n// Process events\nfor (AlarmEvent event : events) {\n    if (event.getType() == AlarmEventType.ACTIVATED) {\n        // Log alarm activation\n        logger.logAlarm(event);\n\n        // Notify operator\n        operatorPanel.displayAlarm(event);\n    }\n}\n\n// Acknowledge after operator review or automatic action\nalarmManager.acknowledgeAll(currentTime);\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#best-practices-demonstrated","title":"Best Practices Demonstrated","text":"<ol> <li> <p>Layered Protection: Multiple independent protection layers from alarms to mechanical safety devices</p> </li> <li> <p>Appropriate Delays: </p> </li> <li>Safety-critical alarms: 0 seconds (immediate)</li> <li> <p>Process alarms: 1-5 seconds (avoid nuisance trips)</p> </li> <li> <p>Deadband Configuration:</p> </li> <li>Safety alarms: Minimal (0.2-0.5)</li> <li> <p>Process alarms: Moderate (1-2% of range)</p> </li> <li> <p>Alarm Actions:</p> </li> <li>HI/LO: Operator notification</li> <li> <p>HIHI/LOLO: Automatic control or shutdown</p> </li> <li> <p>Acknowledgement:</p> </li> <li>Acknowledge after automatic actions</li> <li> <p>Track acknowledgement status</p> </li> <li> <p>Comprehensive Logging:</p> </li> <li>All alarm events recorded</li> <li>Statistics tracked by type and level</li> <li>History available for analysis</li> </ol>"},{"location":"safety/alarm_triggered_logic_example/#running-the-example","title":"Running the Example","text":"<pre><code># Compile\nmvn compile\n\n# Run\nmvn exec:java -Dexec.mainClass=\"neqsim.process.util.example.ProcessLogicAlarmIntegratedExample\"\n</code></pre>"},{"location":"safety/alarm_triggered_logic_example/#key-takeaways","title":"Key Takeaways","text":"<p>\u2705 Consistent Framework: All alarms configured using the same AlarmConfig builder pattern</p> <p>\u2705 Flexible Triggering: Alarms can trigger operator notifications, control actions, or safety logic</p> <p>\u2705 Centralized Management: ProcessAlarmManager coordinates all process alarms</p> <p>\u2705 Safety Integration: Seamless connection between alarms and SIL-rated safety systems</p> <p>\u2705 Production-Ready: Complete with logging, statistics, and acknowledgement workflows</p> <p>\u2705 ISA-18.2 Aligned: Four standard alarm levels (LOLO, LO, HI, HIHI)</p> <p>This example provides a complete template for implementing alarm-triggered process control and safety logic in industrial applications using NeqSim.</p>"},{"location":"safety/fire_blowdown_capabilities/","title":"Fire/blowdown helper capabilities","text":"<p>This note summarizes the current fire, heat-transfer, and structural integrity helpers available in NeqSim and how to apply them in process simulations.</p>"},{"location":"safety/fire_blowdown_capabilities/#fire-heat-load-modelling","title":"Fire heat-load modelling","text":"<ul> <li>API 521 pool fire: <code>FireHeatLoadCalculator.api521PoolFireHeatLoad(wettedArea, F)</code> returns the classic total heat input (W) using wetted area and environment factor.</li> <li>Generalized Stefan\u2013Boltzmann radiation: <code>FireHeatLoadCalculator.generalizedStefanBoltzmannHeatFlux(...)</code> calculates radiative heat flux (W/m\u00b2) from emissivity, view/configuration factor, and flame temperature so callers can compose pool or jet fire scenarios and include shielding/angle effects.</li> </ul>"},{"location":"safety/fire_blowdown_capabilities/#heat-transfer-wall-temperature-treatment","title":"Heat-transfer / wall-temperature treatment","text":"<ul> <li><code>FireHeatTransferCalculator</code> solves a steady 1-D wall model for wetted and unwetted regions using caller-supplied internal/external film coefficients.</li> <li><code>SurfaceTemperatureResult</code> reports inner/outer metal temperatures and heat flux for each region so process models can track thermal response during depressurization.</li> </ul>"},{"location":"safety/fire_blowdown_capabilities/#structural-integrity-rupture-logic","title":"Structural integrity / rupture logic","text":"<ul> <li><code>VesselRuptureCalculator</code> provides thin-wall von-Mises stress plus helpers to compute rupture margin or boolean likelihood when allowable tensile strength is supplied (optionally temperature-dependent when paired with wall temperatures from the heat-transfer step).</li> </ul>"},{"location":"safety/fire_blowdown_capabilities/#integration-with-process-equipment","title":"Integration with process equipment","text":"<ul> <li>Separators expose wetted and dry surface areas (<code>getWettedArea()</code>, <code>getUnwettedArea()</code>), allowing fire heat loads to follow liquid level during blowdown.</li> <li><code>SeparatorFireExposure.evaluate(...)</code> (also available via <code>separator.evaluateFireExposure(...)</code>) wraps area lookup, heat-load estimation, wall temperatures, and rupture checks into a single call to simplify use inside dynamic process simulations.</li> <li>Fire heat input is based on the separator\u2019s geometry and process temperature, not on how much gas is flowing to the flare; flare-rate changes will not alter the radiative or pool-fire heat loads unless they change level/area or temperature.</li> <li>Apply fire heat as a separator duty via <code>separator.setDuty(fireResult.totalFireHeat())</code>; the separator\u2019s <code>runTransient</code> call will consume that duty in its energy balance so the process temperature responds to fire loading without manual temperature edits.</li> <li>The runnable <code>SeparatorFireDepressurizationExample</code> demonstrates end-to-end use by routing a separator blowdown to a flare while evaluating fire loads, wall temperatures, and rupture margin over time.</li> </ul>"},{"location":"safety/fire_heat_transfer_enhancements/","title":"Fire and blowdown calculation enhancements","text":"<p>This note summarizes how to extend NeqSim blowdown calculations with rigorous fire exposure models.</p>"},{"location":"safety/fire_heat_transfer_enhancements/#heat-transfer-modelling-wetted-vs-unwetted","title":"Heat transfer modelling (wetted vs. unwetted)","text":"<ul> <li>Use the <code>FireHeatTransferCalculator</code> utility to compute inner/outer wall temperatures with   separate film coefficients for wetted and unwetted regions. The calculator solves a 1-D thermal   resistance network so that external fire temperatures and internal boiling/convective coefficients   can be applied consistently. Wetted and dry areas can be pulled directly from a <code>Separator</code> via   <code>getWettedArea()</code> / <code>getUnwettedArea()</code>, so dynamic level changes during blowdown feed into the   fire heat flux sizing automatically.</li> <li>Representative coefficients:</li> <li>Wetted zones: high internal film coefficients (nucleate boiling/forced convection)</li> <li>Unwetted zones: lower internal coefficients to reflect vapor-side natural convection</li> <li>The <code>SurfaceTemperatureResult</code> object reports heat flux and both metal surface temperatures so   material-strength checks can be driven by actual wall metal temperature.</li> </ul>"},{"location":"safety/fire_heat_transfer_enhancements/#fire-heat-loads","title":"Fire heat loads","text":"<ul> <li>Legacy API 521 pool fire: <code>FireHeatLoadCalculator.api521PoolFireHeatLoad(wettedArea, F)</code> gives   the classic correlation in Watts using the 6.19e6\u00b7F\u00b7A^0.82 metric form.</li> <li>Generalized Stefan\u2013Boltzmann: <code>FireHeatLoadCalculator.generalizedStefanBoltzmannHeatFlux(...)</code>   provides radiative heat flux using emissivity and view/configuration factors. Combine with   convective terms for jet fires or shielding adjustments.</li> <li>Live flare radiation: <code>SeparatorFireExposure.evaluate(config, flare, distanceM)</code> can fold in the   actual flare heat duty and radiant fraction (via <code>Flare.estimateRadiationHeatFlux</code>) at a specified   horizontal distance so you can compare environmental fire sizing vs. radiation from the burning   gas itself.</li> </ul>"},{"location":"safety/fire_heat_transfer_enhancements/#vessel-rupture-assessment-scandpower-guideline","title":"Vessel rupture assessment (Scandpower guideline)","text":"<ul> <li>Use <code>VesselRuptureCalculator.vonMisesStress(P, r, t)</code> to derive von Mises stress from hoop and   axial components for thin-walled vessels.</li> <li>Compare against material allowable tensile strength via <code>ruptureMargin</code> or   <code>isRuptureLikely</code> to flag impending rupture. Feeding these checks with the metal temperatures from   the heat-transfer calculator allows temperature-dependent strength curves to be implemented later.</li> </ul> <p>These utilities are designed to plug into existing blowdown scenarios and flare models so that transient depressurization can be tracked alongside external fire loads and structural integrity. The helper <code>SeparatorFireExposure.evaluate(...)</code> (or <code>separator.evaluateFireExposure(...)</code>) wraps area lookup, heat-load estimation, wall temperatures, and rupture checks into a single call so the fire calculations can be dropped into a process simulation loop without hand-wiring each piece. If you want the separator inventory to warm up from the calculated fire load, set the duty on the separator (<code>separator.setDuty(fireResult.totalFireHeat())</code>) and call <code>separator.runTransient(...)</code> so the energy balance absorbs that heat during the timestep.</p>"},{"location":"safety/fire_heat_transfer_enhancements/#separator-fire-blowdown-worked-example","title":"Separator fire blowdown worked example","text":"<p>The runnable <code>SeparatorFireDepressurizationExample</code> (<code>src/main/java/neqsim/process/util/example/SeparatorFireDepressurizationExample.java</code>) illustrates how to couple a separator depressurization to the flare with the fire utilities: - Dynamic separator blowdown via <code>BlowdownValve</code> + <code>Orifice</code> feeding a <code>Flare</code> - API 521 pool-fire loads plus generalized Stefan\u2013Boltzmann radiative flux - Wetted vs. unwetted wall temperatures from <code>FireHeatTransferCalculator</code> - Von Mises rupture margin from <code>VesselRuptureCalculator</code> - Optional separator temperature rise using <code>separator.setDuty(fireResult.totalFireHeat())</code></p> <p>To run the illustration: <pre><code>mvn -pl . -Dexec.mainClass=\"neqsim.process.util.example.SeparatorFireDepressurizationExample\" exec:java\n</code></pre> The output prints separator pressure, flow to flare, wall temperatures, rupture margin, and fire heat metrics at each timestep so the fire impact on depressurization can be reviewed end-to-end.</p>"},{"location":"safety/hipps_implementation/","title":"HIPPS (High Integrity Pressure Protection System) Implementation in NeqSim","text":""},{"location":"safety/hipps_implementation/#overview","title":"Overview","text":"<p>HIPPS is a Safety Instrumented System (SIS) designed to prevent overpressure by shutting down the source of pressure rather than relieving it through pressure safety valves (PSVs) or rupture disks. This document describes the HIPPS implementation in NeqSim and provides guidance for safety simulations.</p>"},{"location":"safety/hipps_implementation/#what-is-hipps","title":"What is HIPPS?","text":"<p>High Integrity Pressure Protection System (HIPPS) is an automated safety system that: - Prevents overpressure before it occurs (vs. PSV which relieves after reaching set pressure) - Eliminates or reduces flaring and emissions during upset conditions - Protects downstream equipment rated below upstream pressure - Provides SIL-rated protection (typically SIL 2 or SIL 3)</p>"},{"location":"safety/hipps_implementation/#hipps-vs-psv-comparison","title":"HIPPS vs. PSV Comparison","text":"Aspect HIPPS PSV (Pressure Safety Valve) Action Stops flow (isolation) Relieves pressure (venting) Trip Point Below MAWP (e.g., 90%) At or above MAWP Environmental Impact Prevents flaring Releases to flare Safety Rating SIL 2 or SIL 3 Mechanical (non-SIL) Testing Partial stroke, proof tests Periodic inspection Response Time 2-5 seconds typical Instantaneous (spring-loaded) Redundancy Multiple transmitters, voting logic Single device Failure Mode Fail-safe (close) or diagnosed Fail-safe (open) Cost Higher initial cost Lower initial cost Application Subsea, closed systems General overpressure protection"},{"location":"safety/hipps_implementation/#implementation-components","title":"Implementation Components","text":""},{"location":"safety/hipps_implementation/#1-hippsvalve-class","title":"1. HIPPSValve Class","text":"<p>Location: <code>src/main/java/neqsim/process/equipment/valve/HIPPSValve.java</code></p> <p>Key Features: - Redundant pressure transmitters with voting logic - Multiple voting schemes: 1oo1, 1oo2, 2oo2, 2oo3, 2oo4 - Fast closure: Configurable closure time (typical: 2-5 seconds) - SIL rating: SIL 1, 2, or 3 configuration - Partial stroke testing: Required for SIL validation - Proof test tracking: Monitors test intervals - Diagnostic monitoring: Trip history, spurious trip tracking - Bypass mode: For maintenance or testing</p>"},{"location":"safety/hipps_implementation/#2-voting-logic","title":"2. Voting Logic","text":"<p>HIPPS uses redundant pressure transmitters with voting logic to prevent spurious trips while maintaining safety:</p>"},{"location":"safety/hipps_implementation/#1oo1-1-out-of-1","title":"1oo1 (1 out of 1)","text":"<ul> <li>Single transmitter</li> <li>Simplest configuration</li> <li>Used for SIL 1 applications</li> <li>Higher spurious trip rate</li> <li>Lower availability</li> </ul>"},{"location":"safety/hipps_implementation/#1oo2-1-out-of-2","title":"1oo2 (1 out of 2)","text":"<ul> <li>Any one of two transmitters trips</li> <li>High availability (continues operating if one transmitter fails)</li> <li>Higher spurious trip rate</li> <li>Good for critical operations that can't tolerate downtime</li> </ul>"},{"location":"safety/hipps_implementation/#2oo2-2-out-of-2","title":"2oo2 (2 out of 2)","text":"<ul> <li>Both transmitters must trip</li> <li>Low spurious trip rate</li> <li>Lower availability (system fails if one transmitter fails)</li> <li>Used where spurious trips are very costly</li> </ul>"},{"location":"safety/hipps_implementation/#2oo3-2-out-of-3-recommended","title":"2oo3 (2 out of 3) - RECOMMENDED","text":"<ul> <li>Any two of three transmitters trip</li> <li>Balanced approach</li> <li>Typical for SIL 2 and SIL 3 applications</li> <li>Tolerates one transmitter failure</li> <li>Low spurious trip rate</li> <li>Industry standard for HIPPS</li> </ul>"},{"location":"safety/hipps_implementation/#2oo4-2-out-of-4","title":"2oo4 (2 out of 4)","text":"<ul> <li>Any two of four transmitters trip</li> <li>Highest availability</li> <li>More complex and expensive</li> <li>Used in very critical applications</li> </ul>"},{"location":"safety/hipps_implementation/#usage-examples","title":"Usage Examples","text":""},{"location":"safety/hipps_implementation/#example-1-basic-hipps-configuration-2oo3-voting","title":"Example 1: Basic HIPPS Configuration (2oo3 Voting)","text":"<pre><code>// Create high-pressure feed stream\nSystemInterface fluid = new SystemSrkEos(298.15, 100.0);\nfluid.addComponent(\"methane\", 85.0);\nfluid.addComponent(\"ethane\", 10.0);\nfluid.addComponent(\"propane\", 5.0);\nfluid.setMixingRule(\"classic\");\nfluid.createDatabase(true);\n\nStream feedStream = new Stream(\"HP Feed\", fluid);\nfeedStream.setFlowRate(20000.0, \"kg/hr\");\nfeedStream.setPressure(100.0, \"bara\");\nfeedStream.setTemperature(40.0, \"C\");\nfeedStream.run();\n\n// Create three redundant pressure transmitters\nPressureTransmitter PT1 = new PressureTransmitter(\"PT-101A\", feedStream);\nPressureTransmitter PT2 = new PressureTransmitter(\"PT-101B\", feedStream);\nPressureTransmitter PT3 = new PressureTransmitter(\"PT-101C\", feedStream);\n\n// Configure HIHI alarm at 90 bara (below 100 bara MAWP)\nAlarmConfig hippsAlarm = AlarmConfig.builder()\n    .highHighLimit(90.0)  // HIPPS trips at 90% of MAWP\n    .deadband(2.0)\n    .delay(0.5)          // 500ms confirmation delay\n    .unit(\"bara\")\n    .build();\n\nPT1.setAlarmConfig(hippsAlarm);\nPT2.setAlarmConfig(hippsAlarm);\nPT3.setAlarmConfig(hippsAlarm);\n\n// Create HIPPS valve with 2oo3 voting (SIL 3)\nHIPPSValve hippsValve = new HIPPSValve(\"HIPPS-XV-001\", feedStream);\nhippsValve.addPressureTransmitter(PT1);\nhippsValve.addPressureTransmitter(PT2);\nhippsValve.addPressureTransmitter(PT3);\nhippsValve.setVotingLogic(HIPPSValve.VotingLogic.TWO_OUT_OF_THREE);\nhippsValve.setClosureTime(3.0); // 3 second SIL-rated actuator\nhippsValve.setSILRating(3);\nhippsValve.setProofTestInterval(8760.0); // Annual proof test\n\n// Add to process system\nProcessSystem process = new ProcessSystem();\nprocess.add(hippsValve);\n</code></pre>"},{"location":"safety/hipps_implementation/#example-2-dynamic-simulation-with-hipps","title":"Example 2: Dynamic Simulation with HIPPS","text":"<pre><code>// Transient simulation with pressure ramp\ndouble timeStep = 0.5; // seconds\ndouble totalTime = 30.0;\n\nfor (double time = 0; time &lt;= totalTime; time += timeStep) {\n    // Update process conditions (e.g., blocked outlet scenario)\n    if (time &gt; 5.0) {\n        // Simulate pressure buildup\n        double pressure = 80.0 + (time - 5.0) * 2.0; // 2 bara/sec ramp\n        feedStream.setPressure(pressure, \"bara\");\n        feedStream.run();\n    }\n\n    // Evaluate alarms on all transmitters\n    double currentPressure = feedStream.getPressure(\"bara\");\n    PT1.evaluateAlarm(currentPressure, timeStep, time);\n    PT2.evaluateAlarm(currentPressure, timeStep, time);\n    PT3.evaluateAlarm(currentPressure, timeStep, time);\n\n    // Run HIPPS transient calculation\n    hippsValve.runTransient(timeStep, UUID.randomUUID());\n\n    // Check HIPPS status\n    if (hippsValve.hasTripped()) {\n        System.out.println(\"HIPPS activated at t=\" + time + \"s, P=\" + currentPressure + \" bara\");\n        System.out.println(\"Active transmitters: \" + hippsValve.getActiveTransmitterCount());\n        break;\n    }\n\n    // Continue processing downstream equipment...\n}\n</code></pre>"},{"location":"safety/hipps_implementation/#example-3-hipps-with-psv-backup","title":"Example 3: HIPPS with PSV Backup","text":"<pre><code>// HIPPS provides primary protection, PSV is backup\n\n// Create HIPPS (trips at 90 bara)\nHIPPSValve hippsValve = new HIPPSValve(\"HIPPS-XV-001\", feedStream);\n// ... configure as in Example 1 ...\n\n// Create PSV as backup (set at 100 bara MAWP)\nSafetyValve psv = new SafetyValve(\"PSV-001\", feedStream);\npsv.setPressureSpec(100.0); // PSV set pressure at MAWP\npsv.setFullOpenPressure(110.0); // Full open at 10% overpressure\npsv.setBlowdown(7.0); // 7% blowdown\n\n// In normal operation:\n// 1. Pressure rises due to upset condition\n// 2. HIPPS trips at 90 bara (prevents further pressure rise)\n// 3. PSV never lifts because HIPPS stopped the overpressure\n// 4. No flaring or emissions\n\n// In HIPPS failure scenario:\n// 1. Pressure continues to rise\n// 2. PSV lifts at 100 bara (backup protection)\n// 3. System is protected, but gas is flared\n</code></pre>"},{"location":"safety/hipps_implementation/#example-4-transmitter-failure-scenario","title":"Example 4: Transmitter Failure Scenario","text":"<pre><code>// Simulate a transmitter failure during operation\n\nHIPPSValve hippsValve = new HIPPSValve(\"HIPPS-XV-001\", feedStream);\nhippsValve.setVotingLogic(HIPPSValve.VotingLogic.TWO_OUT_OF_THREE);\n\nPressureTransmitter PT1 = new PressureTransmitter(\"PT-101A\", feedStream);\nPressureTransmitter PT2 = new PressureTransmitter(\"PT-101B\", feedStream);\nPressureTransmitter PT3 = new PressureTransmitter(\"PT-101C\", feedStream);\n\nhippsValve.addPressureTransmitter(PT1);\nhippsValve.addPressureTransmitter(PT2);\nhippsValve.addPressureTransmitter(PT3);\n\n// During operation, PT2 fails (diagnosed and bypassed)\nhippsValve.removePressureTransmitter(PT2);\n\n// Change voting to 1oo2 for continued operation\nhippsValve.setVotingLogic(HIPPSValve.VotingLogic.ONE_OUT_OF_TWO);\n\n// System continues operating with degraded redundancy\n// Schedule maintenance to repair PT2 and restore 2oo3 voting\n</code></pre>"},{"location":"safety/hipps_implementation/#example-5-partial-stroke-testing","title":"Example 5: Partial Stroke Testing","text":"<pre><code>// Perform partial stroke test (required for SIL validation)\n\nHIPPSValve hippsValve = new HIPPSValve(\"HIPPS-XV-001\", feedStream);\n\n// During normal operation, perform 15% stroke test\nhippsValve.performPartialStrokeTest(0.15); // 15% stroke\n\n// Simulation of partial stroke test\ndouble testDuration = 5.0; // seconds\ndouble timeStep = 0.1;\n\nfor (double time = 0; time &lt; testDuration; time += timeStep) {\n    hippsValve.runTransient(timeStep, UUID.randomUUID());\n\n    if (hippsValve.isPartialStrokeTestActive()) {\n        System.out.println(\"Test in progress: Opening = \" + \n            hippsValve.getPercentValveOpening() + \"%\");\n    }\n}\n\n// Valve returns to 100% open after test\n// Test validates valve can move (demonstrates functional operation)\n</code></pre>"},{"location":"safety/hipps_implementation/#safety-simulation-best-practices","title":"Safety Simulation Best Practices","text":""},{"location":"safety/hipps_implementation/#1-response-time-modeling","title":"1. Response Time Modeling","text":"<p>HIPPS response time includes: - Transmitter response: Typically 100-500 ms - Logic solver: 10-100 ms - Valve closure time: 2-5 seconds (dominant factor)</p> <pre><code>// Model realistic closure time\nhippsValve.setClosureTime(3.0); // 3 seconds typical for SIL-rated ball valve\n\n// Account for alarm confirmation delay\nAlarmConfig alarm = AlarmConfig.builder()\n    .highHighLimit(90.0)\n    .delay(0.5) // 500 ms confirmation delay\n    .build();\n</code></pre>"},{"location":"safety/hipps_implementation/#2-set-point-selection","title":"2. Set Point Selection","text":"<p>HIPPS trip point should be: - Below MAWP: Typically 90-95% of MAWP - Above normal operating pressure: Avoid spurious trips - Account for pressure surge: Consider water hammer effects</p> <pre><code>// Example: MAWP = 100 bara\n// Normal operation = 70-80 bara\n// HIPPS trip = 90 bara (10% margin below MAWP)\n// PSV set = 100 bara (at MAWP)\n\ndouble mawp = 100.0;\ndouble hippsTrip = mawp * 0.90; // 90% of MAWP\n</code></pre>"},{"location":"safety/hipps_implementation/#3-transmitter-placement","title":"3. Transmitter Placement","text":"<ul> <li>Install transmitters upstream of HIPPS valve</li> <li>Ensure transmitters measure same pressure point</li> <li>Consider impulse line dynamics in fast transients</li> <li>Protect from process effects (vibration, temperature)</li> </ul>"},{"location":"safety/hipps_implementation/#4-failure-mode-analysis","title":"4. Failure Mode Analysis","text":"<p>Model both success and failure scenarios:</p> <pre><code>// Scenario 1: HIPPS successful operation\n// - Transmitters detect overpressure\n// - Voting logic triggers\n// - Valve closes in 3 seconds\n// - Pressure stabilizes below MAWP\n\n// Scenario 2: HIPPS spurious trip\nhippsValve.recordSpuriousTrip();\n// - Production lost\n// - Economic impact\n// - Need to restart system\n\n// Scenario 3: HIPPS failure to close\nhippsValve.setTripEnabled(false); // Simulate failure\n// - PSV must provide protection\n// - Flaring occurs\n// - Verify PSV capacity adequate\n</code></pre>"},{"location":"safety/hipps_implementation/#5-integration-with-process-control","title":"5. Integration with Process Control","text":"<pre><code>// HIPPS should be independent of process control system\n// But can provide signals for:\n// - Alarm annunciation\n// - Automatic process shutdown\n// - Data logging\n\nif (hippsValve.hasTripped()) {\n    // Trigger alarms\n    // Shut down feed pumps/compressors\n    // Log event for investigation\n    System.out.println(hippsValve.getDiagnostics());\n}\n</code></pre>"},{"location":"safety/hipps_implementation/#6-proof-test-interval","title":"6. Proof Test Interval","text":"<pre><code>// Track proof test intervals for SIL validation\nhippsValve.setProofTestInterval(8760.0); // Annual proof test\n\n// During operation\nif (hippsValve.isProofTestDue()) {\n    // Schedule maintenance\n    // Perform full functional test\n    // Document results\n    hippsValve.performProofTest(); // Reset timer\n}\n</code></pre>"},{"location":"safety/hipps_implementation/#typical-applications","title":"Typical Applications","text":""},{"location":"safety/hipps_implementation/#1-subsea-pipeline-protection","title":"1. Subsea Pipeline Protection","text":"<pre><code>[Platform] --100 bara--&gt; [Subsea Pipeline] ---&gt; [HIPPS] --50 bara--&gt; [Receiving Platform]\n</code></pre> <ul> <li>Platform can generate 100 bara</li> <li>Receiving equipment rated for 50 bara</li> <li>HIPPS protects receiving platform</li> <li>Prevents costly subsea PSV installation</li> </ul>"},{"location":"safety/hipps_implementation/#2-blocked-outlet-scenario","title":"2. Blocked Outlet Scenario","text":"<pre><code>[Compressor] --&gt; [HIPPS] --&gt; [Valve] --&gt; [Process]\n</code></pre> <ul> <li>Downstream valve accidentally closes</li> <li>Pressure builds rapidly</li> <li>HIPPS isolates compressor before overpressure</li> <li>Prevents PSV lifting and flaring</li> </ul>"},{"location":"safety/hipps_implementation/#3-thermal-expansion","title":"3. Thermal Expansion","text":"<pre><code>[Storage] --liquid--&gt; [HIPPS] ---&gt; [Isolated Section] ---&gt; [Valve]\n</code></pre> <ul> <li>Liquid trapped between valves</li> <li>Sun/ambient heating causes thermal expansion</li> <li>HIPPS prevents overpressure rupture</li> <li>Common in pipeline systems</li> </ul>"},{"location":"safety/hipps_implementation/#diagnostic-and-monitoring","title":"Diagnostic and Monitoring","text":""},{"location":"safety/hipps_implementation/#getting-hipps-status","title":"Getting HIPPS Status","text":"<pre><code>// Basic status\nSystem.out.println(hippsValve.toString());\n\n// Comprehensive diagnostics\nSystem.out.println(hippsValve.getDiagnostics());\n\n// Key metrics\nint activeTx = hippsValve.getActiveTransmitterCount();\nboolean tripped = hippsValve.hasTripped();\nint spurious = hippsValve.getSpuriousTripCount();\ndouble lastTrip = hippsValve.getLastTripTime();\nboolean testDue = hippsValve.isProofTestDue();\n</code></pre>"},{"location":"safety/hipps_implementation/#output-example","title":"Output Example","text":"<pre><code>=== HIPPS DIAGNOSTICS ===\nSystem: HIPPS-XV-001\nSIL Rating: SIL 3\nConfiguration: 2oo3 voting\nClosure Time: 3.0 s\n\nTransmitter Status:\n  PT-1: ALARM (92.50 bara)\n  PT-2: ALARM (92.45 bara)\n  PT-3: OK (89.80 bara)\n\nOperational History:\n  Total Trips: 1\n  Spurious Trips: 0\n  Last Trip: 15.5 s\n  Runtime: 120.0 s\n\nMaintenance:\n  Proof Test Interval: 8760 hrs\n  Time Since Proof Test: 450.5 hrs\n  Status: OK\n</code></pre>"},{"location":"safety/hipps_implementation/#testing","title":"Testing","text":"<p>Comprehensive test suite located at: <code>src/test/java/neqsim/process/equipment/valve/HIPPSValveTest.java</code></p> <p>Tests cover: - \u2705 Basic configuration - \u2705 All voting logic schemes (1oo1, 1oo2, 2oo2, 2oo3, 2oo4) - \u2705 Transient response and closure timing - \u2705 Transmitter failure scenarios - \u2705 Partial stroke testing - \u2705 Proof test tracking - \u2705 Integration with PSV - \u2705 Spurious trip detection - \u2705 Reset and reopen procedures - \u2705 Bypass mode operation</p> <p>Run tests: <pre><code>mvnw test -Dtest=HIPPSValveTest\n</code></pre></p>"},{"location":"safety/hipps_implementation/#standards-and-references","title":"Standards and References","text":""},{"location":"safety/hipps_implementation/#industry-standards","title":"Industry Standards","text":"<ul> <li>IEC 61508: Functional Safety of Electrical/Electronic/Programmable Electronic Safety-related Systems</li> <li>IEC 61511: Functional Safety - Safety Instrumented Systems for the Process Industry Sector</li> <li>API RP 14C: Recommended Practice for Analysis, Design, Installation, and Testing of Safety Systems for Offshore Production Facilities</li> <li>API RP 521: Pressure-relieving and Depressuring Systems</li> </ul>"},{"location":"safety/hipps_implementation/#sil-requirements","title":"SIL Requirements","text":"SIL Level PFD (Probability of Failure on Demand) Typical Application SIL 1 10\u207b\u00b9 to 10\u207b\u00b2 Low risk, 1oo1 voting SIL 2 10\u207b\u00b2 to 10\u207b\u00b3 Medium risk, 1oo2 or 2oo3 voting SIL 3 10\u207b\u00b3 to 10\u207b\u2074 High risk, 2oo3 voting"},{"location":"safety/hipps_implementation/#summary","title":"Summary","text":"<p>HIPPS in NeqSim provides: - \u2705 Comprehensive SIS modeling for safety simulations - \u2705 Redundant architecture with multiple voting schemes - \u2705 Realistic transient behavior including closure time - \u2705 SIL-rated configuration (SIL 1, 2, 3) - \u2705 Partial stroke and proof testing support - \u2705 Diagnostic monitoring for safety validation - \u2705 Integration with PSVs for layered protection - \u2705 Transmitter failure scenarios for reliability analysis</p> <p>Key Advantage: HIPPS prevents overpressure before it occurs, eliminating flaring and protecting equipment, while PSVs relieve pressure after it exceeds safe limits.</p> <p>For safety-critical applications, HIPPS + PSV provides defense-in-depth protection strategy.</p>"},{"location":"safety/hipps_implementation/#author","title":"Author","text":"<p>Implementation follows NeqSim architecture patterns and coding standards for process safety simulation.</p>"},{"location":"safety/hipps_safety_logic/","title":"HIPPS Safety Logic Implementation","text":""},{"location":"safety/hipps_safety_logic/#overview","title":"Overview","text":"<p>High Integrity Pressure Protection System (HIPPS) is a Safety Instrumented System (SIS) designed to prevent overpressure in process equipment by rapidly closing isolation valves when pressure exceeds safe limits. HIPPS acts as the first line of defense before pressure relief devices (PSVs) or Emergency Shutdown (ESD) systems are activated.</p>"},{"location":"safety/hipps_safety_logic/#key-concepts","title":"Key Concepts","text":""},{"location":"safety/hipps_safety_logic/#what-is-hipps","title":"What is HIPPS?","text":"<p>HIPPS is an automated safety system that: - Prevents overpressure by rapidly closing isolation valves (typically &lt;2 seconds) - Operates at 90-95% of MAOP (Maximum Allowable Operating Pressure) - Prevents PSV activation, reducing flaring and environmental impact - Provides SIL 2 or SIL 3 protection per IEC 61508/61511 - Uses redundant sensors with voting logic for high reliability</p>"},{"location":"safety/hipps_safety_logic/#hipps-vs-esd","title":"HIPPS vs ESD","text":"Feature HIPPS ESD Activation Pressure 90-95% MAOP 98-99% MAOP Primary Function Prevent overpressure Emergency shutdown Response Time &lt;2 seconds 2-10 seconds Scope Local pressure protection Full facility shutdown SIL Level SIL 2 or SIL 3 SIL 1 or SIL 2 Typical Voting 2oo3 1oo2 or 2oo3"},{"location":"safety/hipps_safety_logic/#defense-in-depth","title":"Defense in Depth","text":"<p>A typical pressure safety system has multiple layers:</p> <ol> <li>Process Control System (PCS) - Normal control at 80-85% MAOP</li> <li>HIPPS - First safety layer at 90-95% MAOP</li> <li>ESD - Backup safety layer at 98% MAOP</li> <li>Pressure Relief Valves (PSVs) - Last resort at 100%+ MAOP</li> </ol>"},{"location":"safety/hipps_safety_logic/#architecture","title":"Architecture","text":""},{"location":"safety/hipps_safety_logic/#class-structure","title":"Class Structure","text":"<pre><code>HIPPSLogic (implements ProcessLogic)\n\u251c\u2500\u2500 VotingLogic (enum: 1oo1, 1oo2, 2oo2, 2oo3, 2oo4, 3oo4)\n\u251c\u2500\u2500 List&lt;Detector&gt; (pressure transmitters)\n\u251c\u2500\u2500 ThrottlingValve (isolation valve)\n\u2514\u2500\u2500 ProcessLogic (escalation logic - typically ESD)\n</code></pre>"},{"location":"safety/hipps_safety_logic/#key-components","title":"Key Components","text":""},{"location":"safety/hipps_safety_logic/#1-pressure-sensors-detectors","title":"1. Pressure Sensors (Detectors)","text":"<ul> <li>Type: Pressure transmitters with HIGH_HIGH alarm level</li> <li>Redundancy: Typically 3 sensors for 2oo3 voting</li> <li>Setpoint: 90-95% of MAOP</li> <li>Bypass: Maximum 1 sensor can be bypassed for maintenance</li> </ul>"},{"location":"safety/hipps_safety_logic/#2-logic-solver","title":"2. Logic Solver","text":"<ul> <li>Voting Logic: Evaluates sensor trips (typically 2oo3)</li> <li>Response: Immediate closure of isolation valve</li> <li>Escalation: Activates ESD if pressure remains high</li> </ul>"},{"location":"safety/hipps_safety_logic/#3-final-element","title":"3. Final Element","text":"<ul> <li>Valve Type: Full-bore ball valve or gate valve</li> <li>Closure Time: &lt;2 seconds (critical for HIPPS)</li> <li>Fail Position: Fail-closed (de-energize to close)</li> </ul>"},{"location":"safety/hipps_safety_logic/#implementation","title":"Implementation","text":""},{"location":"safety/hipps_safety_logic/#basic-hipps-setup","title":"Basic HIPPS Setup","text":"<pre><code>// Create HIPPS with 2oo3 voting (SIL 3)\nHIPPSLogic hipps = new HIPPSLogic(\"HIPPS-101\", VotingLogic.TWO_OUT_OF_THREE);\n\n// Add pressure transmitters\ndouble hippsSetpoint = 95.0; // 95 bara (95% of 100 bara MAOP)\nDetector pt1 = new Detector(\"PT-101A\", DetectorType.PRESSURE, \n                            AlarmLevel.HIGH_HIGH, hippsSetpoint, \"bara\");\nDetector pt2 = new Detector(\"PT-101B\", DetectorType.PRESSURE, \n                            AlarmLevel.HIGH_HIGH, hippsSetpoint, \"bara\");\nDetector pt3 = new Detector(\"PT-101C\", DetectorType.PRESSURE, \n                            AlarmLevel.HIGH_HIGH, hippsSetpoint, \"bara\");\n\nhipps.addPressureSensor(pt1);\nhipps.addPressureSensor(pt2);\nhipps.addPressureSensor(pt3);\n\n// Set isolation valve\nThrottlingValve isolationValve = new ThrottlingValve(\"HIPPS-Isolation-Valve\", stream);\nhipps.setIsolationValve(isolationValve);\n</code></pre>"},{"location":"safety/hipps_safety_logic/#hipps-with-esd-escalation","title":"HIPPS with ESD Escalation","text":"<pre><code>// Create ESD logic as backup\nESDLogic esdLogic = new ESDLogic(\"ESD Level 1\");\nesdLogic.addAction(new TripValveAction(esdValve), 0.0);\n\n// Link HIPPS to escalate to ESD after 5 seconds if pressure remains high\nhipps.linkToEscalationLogic(esdLogic, 5.0);\n</code></pre>"},{"location":"safety/hipps_safety_logic/#simulation-loop","title":"Simulation Loop","text":"<pre><code>// In transient simulation\nfor (double time = 0; time &lt; totalTime; time += timeStep) {\n    // Run process equipment\n    stream.run();\n    isolationValve.run();\n\n    // Get pressure from process\n    double pressure = stream.getPressure();\n\n    // Update HIPPS (all three sensors)\n    hipps.update(pressure, pressure, pressure);\n\n    // Execute HIPPS logic (checks for escalation)\n    hipps.execute(timeStep);\n\n    // Check status\n    if (hipps.isTripped()) {\n        System.out.println(\"HIPPS ACTIVATED: Isolation valve closed\");\n    }\n\n    if (hipps.hasEscalated()) {\n        System.out.println(\"ESCALATED TO ESD: HIPPS failed to control pressure\");\n    }\n}\n</code></pre>"},{"location":"safety/hipps_safety_logic/#voting-logic-patterns","title":"Voting Logic Patterns","text":""},{"location":"safety/hipps_safety_logic/#standard-patterns","title":"Standard Patterns","text":"Pattern Description Spurious Trip Rate Safety Integrity Typical Use 1oo1 1 out of 1 must trip High Low Low criticality 1oo2 1 out of 2 must trip Medium Medium Standard applications 2oo2 2 out of 2 must trip Very Low Low High availability needed 2oo3 2 out of 3 must trip Low High HIPPS standard (SIL 3) 2oo4 2 out of 4 must trip Very Low High Critical applications 3oo4 3 out of 4 must trip Low Very High Ultra-high reliability"},{"location":"safety/hipps_safety_logic/#why-2oo3-for-hipps","title":"Why 2oo3 for HIPPS?","text":"<p>The 2oo3 voting pattern is the industry standard for HIPPS because:</p> <ol> <li>High Safety Integrity: Two sensors must agree before trip (reduces false trips)</li> <li>Fault Tolerance: System remains operational if one sensor fails</li> <li>Maintenance Capability: One sensor can be bypassed without compromising safety</li> <li>Balanced Availability: Low spurious trip rate means fewer production interruptions</li> <li>SIL 3 Capable: Meets requirements for high-criticality applications</li> </ol>"},{"location":"safety/hipps_safety_logic/#configuration-options","title":"Configuration Options","text":""},{"location":"safety/hipps_safety_logic/#bypass-management","title":"Bypass Management","text":"<pre><code>// Bypass one sensor for maintenance (max 1 allowed)\nDetector pt1 = hipps.getPressureSensor(0);\npt1.setBypass(true);\n\n// Set maximum bypassed sensors (default is 1)\nhipps.setMaxBypassedSensors(1);\n</code></pre>"},{"location":"safety/hipps_safety_logic/#valve-closure-time","title":"Valve Closure Time","text":"<pre><code>// Set target closure time (default 2 seconds)\nhipps.setValveClosureTime(1.5); // Very fast closure\n</code></pre>"},{"location":"safety/hipps_safety_logic/#manual-override","title":"Manual Override","text":"<pre><code>// Override HIPPS (inhibit trip function)\n// WARNING: Requires management approval and risk assessment\nhipps.setOverride(true);\n\n// Check override status\nif (hipps.isOverridden()) {\n    System.out.println(\"WARNING: HIPPS is overridden\");\n}\n</code></pre>"},{"location":"safety/hipps_safety_logic/#reset-after-trip","title":"Reset After Trip","text":"<pre><code>// Reset HIPPS after pressure returns to normal\nif (hipps.reset()) {\n    System.out.println(\"HIPPS reset successful\");\n} else {\n    System.out.println(\"Cannot reset - pressure still high\");\n}\n</code></pre>"},{"location":"safety/hipps_safety_logic/#safety-considerations","title":"Safety Considerations","text":""},{"location":"safety/hipps_safety_logic/#sil-safety-integrity-level","title":"SIL (Safety Integrity Level)","text":"<p>HIPPS typically requires SIL 2 or SIL 3 per IEC 61511:</p> <ul> <li>SIL 2: 10\u207b\u00b3 to 10\u207b\u00b2 probability of failure on demand (PFD)</li> <li>SIL 3: 10\u207b\u2074 to 10\u207b\u00b3 probability of failure on demand (PFD)</li> </ul>"},{"location":"safety/hipps_safety_logic/#design-requirements","title":"Design Requirements","text":"<ol> <li>Independent Sensors: Three independent pressure transmitters</li> <li>Diverse Measurement: Consider different sensor technologies</li> <li>Rapid Response: Valve closure &lt;2 seconds</li> <li>Fail-Safe Design: De-energize to close (fail-closed)</li> <li>Regular Testing: Partial stroke testing, full stroke testing</li> <li>Bypass Constraints: Maximum 1 sensor bypassed at a time</li> <li>Escalation: Backup ESD system if HIPPS fails</li> </ol>"},{"location":"safety/hipps_safety_logic/#common-failure-modes","title":"Common Failure Modes","text":"Failure Mode Detection Mitigation Sensor failure Self-diagnostics, voting 2oo3 voting, regular testing Valve failure to close Position feedback, escalation ESD backup, proof testing Logic solver failure Watchdog, self-test Redundant processors Common cause failure Design diversity Different sensor technologies"},{"location":"safety/hipps_safety_logic/#standards-compliance","title":"Standards Compliance","text":""},{"location":"safety/hipps_safety_logic/#iec-61511-process-industry-sis","title":"IEC 61511 (Process Industry SIS)","text":"<ul> <li>Risk Assessment: SIL determination per layer of protection analysis (LOPA)</li> <li>Design: Redundancy, voting logic, bypass management</li> <li>Implementation: Independent validation, functional testing</li> <li>Operation: Bypass procedures, proof testing schedule</li> <li>Maintenance: Partial stroke testing, full stroke testing</li> </ul>"},{"location":"safety/hipps_safety_logic/#iec-61508-functional-safety","title":"IEC 61508 (Functional Safety)","text":"<ul> <li>Hardware Fault Tolerance: 2oo3 provides 1-fault tolerance</li> <li>Safe Failure Fraction: High SFF with diagnostics</li> <li>Systematic Capability: SC2 or SC3 depending on development process</li> </ul>"},{"location":"safety/hipps_safety_logic/#isa-84-ansiisa-840001","title":"ISA-84 / ANSI/ISA-84.00.01","text":"<ul> <li>SIF Design: Safety function specification</li> <li>Verification: Proof testing intervals</li> <li>Validation: Pre-startup acceptance testing</li> </ul>"},{"location":"safety/hipps_safety_logic/#performance-metrics","title":"Performance Metrics","text":""},{"location":"safety/hipps_safety_logic/#key-performance-indicators","title":"Key Performance Indicators","text":"<pre><code>// Trip statistics\ndouble tripTime = hipps.getTimeSinceTrip();\nboolean hasEscalated = hipps.hasEscalated();\n\n// Sensor status\nint trippedCount = 0;\nint bypassedCount = 0;\nfor (Detector sensor : hipps.getPressureSensors()) {\n    if (sensor.isTripped()) trippedCount++;\n    if (sensor.isBypassed()) bypassedCount++;\n}\n</code></pre>"},{"location":"safety/hipps_safety_logic/#typical-metrics-to-track","title":"Typical Metrics to Track","text":"<ul> <li>Spurious Trip Rate: Trips per year (target: &lt;0.1)</li> <li>Response Time: Time from pressure excursion to valve closure</li> <li>Escalation Rate: HIPPS failures requiring ESD activation</li> <li>Sensor Availability: Percentage time all sensors operational</li> <li>Proof Test Interval: 1-2 years typical</li> </ul>"},{"location":"safety/hipps_safety_logic/#example-scenarios","title":"Example Scenarios","text":""},{"location":"safety/hipps_safety_logic/#scenario-1-normal-hipps-trip","title":"Scenario 1: Normal HIPPS Trip","text":"<pre><code>Pressure: 50 bara \u2192 96 bara (exceeds 95 bara setpoint)\nResult: \n  - 3/3 sensors trip\n  - 2oo3 voting satisfied\n  - Isolation valve closes in &lt;2 seconds\n  - Pressure controlled\n  - ESD not activated\n</code></pre>"},{"location":"safety/hipps_safety_logic/#scenario-2-single-sensor-failure","title":"Scenario 2: Single Sensor Failure","text":"<pre><code>Pressure: 50 bara \u2192 96 bara\nSensor Status:\n  - PT-101A: TRIPPED\n  - PT-101B: TRIPPED\n  - PT-101C: FAULTY (not counted)\nResult:\n  - 2/2 active sensors trip\n  - 2oo3 voting satisfied (excludes faulty sensor)\n  - HIPPS activates successfully\n</code></pre>"},{"location":"safety/hipps_safety_logic/#scenario-3-hipps-failure-esd-escalation","title":"Scenario 3: HIPPS Failure - ESD Escalation","text":"<pre><code>Pressure: 50 bara \u2192 96 bara\nHIPPS: Trips and closes valve\nPressure: Remains at 96 bara (valve failure)\nTime: 5 seconds elapsed\nResult:\n  - HIPPS escalation timer expires\n  - ESD activated automatically\n  - Full shutdown initiated\n</code></pre>"},{"location":"safety/hipps_safety_logic/#scenario-4-maintenance-bypass","title":"Scenario 4: Maintenance Bypass","text":"<pre><code>Sensor Status:\n  - PT-101A: BYPASSED (maintenance)\n  - PT-101B: NORMAL\n  - PT-101C: NORMAL\nPressure: 50 bara \u2192 96 bara\nResult:\n  - PT-101B: TRIPPED\n  - PT-101C: TRIPPED\n  - 2/2 active sensors trip\n  - 2oo3 voting satisfied\n  - HIPPS activates successfully with 1 sensor bypassed\n</code></pre>"},{"location":"safety/hipps_safety_logic/#best-practices","title":"Best Practices","text":""},{"location":"safety/hipps_safety_logic/#design-phase","title":"Design Phase","text":"<ol> <li>SIL Determination: Perform LOPA to determine required SIL</li> <li>Voting Selection: Use 2oo3 for SIL 3, 1oo2 for SIL 2</li> <li>Setpoint Calculation: 90-95% MAOP (below ESD, above control)</li> <li>Valve Sizing: Full-bore valve for rapid closure</li> <li>Response Time Analysis: Model full loop response including valve stroking</li> </ol>"},{"location":"safety/hipps_safety_logic/#implementation-phase","title":"Implementation Phase","text":"<ol> <li>Sensor Installation: Independent tapping points, avoid process deadlegs</li> <li>Calibration: Factory calibration with certificates</li> <li>Logic Configuration: Test voting logic thoroughly</li> <li>Valve Testing: Partial stroke test before commissioning</li> <li>Integration Testing: Test escalation to ESD</li> </ol>"},{"location":"safety/hipps_safety_logic/#operational-phase","title":"Operational Phase","text":"<ol> <li>Bypass Procedures: Management of change (MOC) for bypasses</li> <li>Proof Testing: Annual full stroke test, quarterly partial stroke test</li> <li>Performance Monitoring: Track spurious trips, response times</li> <li>Incident Investigation: Analyze all HIPPS activations</li> <li>Training: Regular operator training on HIPPS operation</li> </ol>"},{"location":"safety/hipps_safety_logic/#maintenance-phase","title":"Maintenance Phase","text":"<ol> <li>Sensor Calibration: Annual verification</li> <li>Valve Maintenance: Lubrication, seal replacement per schedule</li> <li>Logic Solver Testing: Self-diagnostics, watchdog verification</li> <li>Spare Parts: Critical spares available (sensors, valves, solenoids)</li> </ol>"},{"location":"safety/hipps_safety_logic/#future-enhancements","title":"Future Enhancements","text":""},{"location":"safety/hipps_safety_logic/#planned-features","title":"Planned Features","text":"<ol> <li>Demand Rate Tracking: Calculate PFD based on activation history</li> <li>Proof Test Integration: Schedule and track proof test activities</li> <li>Partial Stroke Testing: Automated PST for valves</li> <li>Diagnostic Coverage: Calculate SFF (Safe Failure Fraction)</li> <li>LOPA Integration: Link to risk analysis tools</li> <li>Performance Dashboards: Real-time KPI visualization</li> </ol>"},{"location":"safety/hipps_safety_logic/#advanced-capabilities","title":"Advanced Capabilities","text":"<ul> <li>Time-based voting: Require sensors tripped for N seconds</li> <li>Rate-of-change detection: Trip on rapid pressure rise</li> <li>Pressure prediction: AI/ML for early warning</li> <li>Multi-stage HIPPS: Cascading pressure protection</li> <li>Dynamic setpoint adjustment: Based on operating mode</li> </ul>"},{"location":"safety/hipps_safety_logic/#references","title":"References","text":"<ul> <li>IEC 61511: Functional safety - Safety instrumented systems for the process industry sector</li> <li>IEC 61508: Functional safety of electrical/electronic/programmable electronic safety-related systems</li> <li>ISA-84.00.01: Application of Safety Instrumented Systems for the Process Industries</li> <li>API RP 14C: Recommended Practice for Analysis, Design, Installation, and Testing of Safety Systems for Offshore Production Facilities</li> <li>NORSOK S-001: Technical Safety (Norwegian offshore standard)</li> </ul>"},{"location":"safety/hipps_safety_logic/#see-also","title":"See Also","text":"<ul> <li>Process Logic Framework - Base architecture</li> <li>SIS Logic Implementation - Fire and gas detection</li> <li>ESD Logic - Emergency shutdown systems</li> <li>HIPPS Summary - High-level overview</li> </ul>"},{"location":"safety/integration_safety_chain_tests/","title":"Integrated HIPPS/ESD Safety Chain Tests","text":"<p>This repository now includes an integration test that links alarms, HIPPS isolation, and ESD depressurization logic against dynamic equipment models during a transient upset. The goal is to verify that layered safety functions respond coherently when feed pressure surges beyond high-high limits.</p>"},{"location":"safety/integration_safety_chain_tests/#what-the-test-covers","title":"What the test covers","text":"<ul> <li>Alarm validation: A separator pressure transmitter with HI/HIHI limits moves into alarm as the   feed surge pushes pressure upward.</li> <li>HIPPS isolation: Three redundant pressure detectors (2oo3 voting) trip HIPPS logic that drives   the <code>HIPPS Isolation Valve</code> closed in under two seconds.</li> <li>ESD escalation: If pressure remains high three seconds after HIPPS closure, HIPPS escalates to   <code>ESD Level 1</code>, closing inlet valves, opening the blowdown valve, and routing gas to the flare.</li> <li>Dynamic response: The scenario runs as a transient simulation, confirming separator pressure   falls while flare flow rises once ESD starts depressurizing.</li> </ul>"},{"location":"safety/integration_safety_chain_tests/#running-the-integration-test","title":"Running the integration test","text":"<p>Execute the JUnit test directly:</p> <pre><code>mvn -q -Dtest=IntegratedSafetyChainTransientTest test\n</code></pre> <p>The test lives at <code>src/test/java/neqsim/process/util/scenario/IntegratedSafetyChainTransientTest.java</code> and uses <code>ProcessScenarioRunner</code> to coordinate logic execution with the process model.</p>"},{"location":"safety/layered_safety_architecture/","title":"Layered Safety System Architecture","text":""},{"location":"safety/layered_safety_architecture/#overview","title":"Overview","text":"<p>NeqSim now implements a comprehensive defense-in-depth safety architecture with multiple independent protection layers. This document describes how HIPPS, fire/gas detection, and ESD systems work together to provide robust safety protection.</p>"},{"location":"safety/layered_safety_architecture/#safety-layer-hierarchy","title":"Safety Layer Hierarchy","text":""},{"location":"safety/layered_safety_architecture/#the-onion-model","title":"The Onion Model","text":"<p>Safety protection follows the \"onion model\" with multiple layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. Process Control System (PCS)                \u2502  \u2190 Normal operation\n\u2502     \u2022 Pressure controllers: 80-85% MAOP         \u2502\n\u2502     \u2022 Temperature controllers                    \u2502\n\u2502     \u2022 Level controllers                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502 If PCS fails \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  2. Basic Process Control Alarms (BPCS)         \u2502  \u2190 Operator intervention\n\u2502     \u2022 High pressure alarm: 90% MAOP             \u2502\n\u2502     \u2022 High temperature alarm                     \u2502\n\u2502     \u2022 Manual operator actions                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502 If operator fails \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  3. HIPPS (High Integrity Pressure Protection)  \u2502  \u2190 First SIS layer\n\u2502     \u2022 Activation: 90-95% MAOP                   \u2502  \n\u2502     \u2022 SIL: 2 or 3                               \u2502\n\u2502     \u2022 Response: &lt;2 seconds                      \u2502\n\u2502     \u2022 Action: Close isolation valve             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502 If HIPPS fails \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  4. Fire &amp; Gas Detection SIS                    \u2502  \u2190 Hazard detection\n\u2502     \u2022 Fire detectors: 2oo3 voting               \u2502\n\u2502     \u2022 Gas detectors: 2oo3 voting                \u2502\n\u2502     \u2022 SIL: 2 or 3                               \u2502\n\u2502     \u2022 Action: Activate ESD                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502 If hazard detected \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  5. ESD (Emergency Shutdown)                    \u2502  \u2190 Emergency response\n\u2502     \u2022 Activation: 98% MAOP or hazard            \u2502\n\u2502     \u2022 SIL: 1 or 2                               \u2502\n\u2502     \u2022 Response: 2-10 seconds                    \u2502\n\u2502     \u2022 Action: Full/partial shutdown             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502 If ESD fails \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  6. Pressure Relief (PSV/Rupture Disk)          \u2502  \u2190 Passive protection\n\u2502     \u2022 Activation: 100-110% MAOP                 \u2502\n\u2502     \u2022 Mechanical device (fail-safe)             \u2502\n\u2502     \u2022 Action: Vent to flare/atmosphere          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"safety/layered_safety_architecture/#implemented-safety-systems","title":"Implemented Safety Systems","text":""},{"location":"safety/layered_safety_architecture/#1-hipps-high-integrity-pressure-protection-system","title":"1. HIPPS (High Integrity Pressure Protection System)","text":"<p>Purpose: Prevent overpressure before PSV activation</p> <p>Key Features: - Voting Logic: 2oo3 (two out of three pressure transmitters) - Setpoint: 95% MAOP (adjustable 90-95%) - Response Time: &lt;2 seconds (rapid valve closure) - SIL Level: SIL 2 or SIL 3 - Escalation: Activates ESD after 5 seconds if pressure remains high</p> <p>When It Activates: <pre><code>Normal: 50 bara \u2192 Upset: 96 bara \u2192 HIPPS trips at 95 bara\nResult: Isolation valve closes, prevents PSV lifting\n</code></pre></p> <p>Code Example: <pre><code>HIPPSLogic hipps = new HIPPSLogic(\"HIPPS-101\", VotingLogic.TWO_OUT_OF_THREE);\nhipps.addPressureSensor(pt1);\nhipps.addPressureSensor(pt2);\nhipps.addPressureSensor(pt3);\nhipps.setIsolationValve(isolationValve);\nhipps.linkToEscalationLogic(esdLogic, 5.0);\n</code></pre></p> <p>Benefits: - \u2713 Prevents flaring (environmental benefit) - \u2713 Reduces emissions (economic benefit) - \u2713 Protects equipment from overpressure - \u2713 Maintains production (fast recovery)</p>"},{"location":"safety/layered_safety_architecture/#2-fire-gas-detection-sis","title":"2. Fire &amp; Gas Detection SIS","text":"<p>Purpose: Detect hazardous conditions and initiate safe shutdown</p> <p>Key Features: - Fire Detection: 2oo3 voting, temperature-based (60\u00b0C typical) - Gas Detection: 2oo3 voting, combustible gas (25% LEL typical) - Setpoint: Based on hazard assessment - SIL Level: SIL 2 or SIL 3 - Integration: Automatically activates ESD logic</p> <p>When It Activates: <pre><code>Fire: 2 of 3 detectors above 60\u00b0C \u2192 Fire SIF trips \u2192 ESD activated\nGas: 2 of 3 detectors above 25% LEL \u2192 Gas SIF trips \u2192 ESD activated\n</code></pre></p> <p>Code Example: <pre><code>SafetyInstrumentedFunction fireSIF = \n    new SafetyInstrumentedFunction(\"Fire Detection\", VotingLogic.TWO_OUT_OF_THREE);\nfireSIF.addDetector(fireDetector1);\nfireSIF.addDetector(fireDetector2);\nfireSIF.addDetector(fireDetector3);\nfireSIF.linkToLogic(esdLogic);\n</code></pre></p> <p>Benefits: - \u2713 Early hazard detection - \u2713 Automatic emergency response - \u2713 High reliability (2oo3 voting) - \u2713 Maintenance capability (bypass 1 detector)</p>"},{"location":"safety/layered_safety_architecture/#3-esd-emergency-shutdown","title":"3. ESD (Emergency Shutdown)","text":"<p>Purpose: Emergency shutdown of process facilities</p> <p>Key Features: - Activation Sources:   - HIPPS escalation (pressure control failure)   - Fire detection SIF (fire detected)   - Gas detection SIF (gas leak detected)   - Manual push button (operator initiated) - Actions: Sequential logic with timed delays - SIL Level: SIL 1 or SIL 2</p> <p>ESD Levels: <pre><code>ESD Level 1: Partial shutdown (specific area)\nESD Level 2: Full shutdown (entire facility)\nESD Level 3: Total evacuation + shutdown\n</code></pre></p> <p>Code Example: <pre><code>ESDLogic esdLogic = new ESDLogic(\"ESD Level 1\");\nesdLogic.addAction(new TripValveAction(esdValve), 0.0);      // Immediate\nesdLogic.addAction(new ActivateBlowdownAction(bdValve), 0.5); // After 0.5s\nesdLogic.addAction(new SetSplitterAction(splitter, [...]), 0.5); // After 1.0s\n</code></pre></p> <p>Benefits: - \u2713 Coordinated multi-equipment shutdown - \u2713 Timed action sequences - \u2713 Multiple activation sources - \u2713 Configurable logic</p>"},{"location":"safety/layered_safety_architecture/#integration-examples","title":"Integration Examples","text":""},{"location":"safety/layered_safety_architecture/#example-1-hipps-with-esd-escalation","title":"Example 1: HIPPS with ESD Escalation","text":"<p>Scenario: Pressure protection with backup</p> <pre><code>// Create HIPPS (first line of defense)\nHIPPSLogic hipps = new HIPPSLogic(\"HIPPS-101\", VotingLogic.TWO_OUT_OF_THREE);\nhipps.addPressureSensor(pt1); // 95 bara setpoint\nhipps.addPressureSensor(pt2);\nhipps.addPressureSensor(pt3);\nhipps.setIsolationValve(hippsValve);\n\n// Create ESD (backup)\nESDLogic esd = new ESDLogic(\"ESD Level 1\");\nesd.addAction(new TripValveAction(esdValve), 0.0);\n\n// Link HIPPS to escalate to ESD after 5 seconds if pressure remains high\nhipps.linkToEscalationLogic(esd, 5.0);\n\n// Simulation\nhipps.update(pressure, pressure, pressure);\nhipps.execute(timeStep);\n\n// Check status\nif (hipps.isTripped() &amp;&amp; !hipps.hasEscalated()) {\n    System.out.println(\"HIPPS controlling pressure\");\n} else if (hipps.hasEscalated()) {\n    System.out.println(\"HIPPS failed - ESD activated\");\n}\n</code></pre> <p>Flow: <pre><code>t=0s:   Pressure rises to 96 bara\nt=0s:   HIPPS trips (2/3 sensors above 95 bara)\nt=0s:   Isolation valve closes rapidly\nt=0-5s: HIPPS monitors pressure\nt=5s:   If pressure still high \u2192 Escalate to ESD\nt=5s:   ESD valve trips \u2192 Full shutdown\n</code></pre></p>"},{"location":"safety/layered_safety_architecture/#example-2-fire-detection-activating-esd","title":"Example 2: Fire Detection Activating ESD","text":"<p>Scenario: Fire detected in process area</p> <pre><code>// Create fire detection SIF\nSafetyInstrumentedFunction fireSIF = \n    new SafetyInstrumentedFunction(\"Fire Detection\", VotingLogic.TWO_OUT_OF_THREE);\nfireSIF.addDetector(new Detector(\"FD-101\", DetectorType.FIRE, AlarmLevel.HIGH, 60.0, \"\u00b0C\"));\nfireSIF.addDetector(new Detector(\"FD-102\", DetectorType.FIRE, AlarmLevel.HIGH, 60.0, \"\u00b0C\"));\nfireSIF.addDetector(new Detector(\"FD-103\", DetectorType.FIRE, AlarmLevel.HIGH, 60.0, \"\u00b0C\"));\n\n// Create ESD logic\nESDLogic esd = new ESDLogic(\"Fire ESD\");\nesd.addAction(new TripValveAction(esdValve), 0.0);\nesd.addAction(new ActivateBlowdownAction(blowdownValve), 0.5);\n\n// Link fire SIF to ESD\nfireSIF.linkToLogic(esd);\n\n// Simulation\nfireSIF.update(temp1, temp2, temp3);\n\n// Check status\nif (fireSIF.isTripped()) {\n    System.out.println(\"Fire detected - ESD activated\");\n}\n</code></pre> <p>Flow: <pre><code>t=0s:  Temperatures: FD-101=55\u00b0C, FD-102=65\u00b0C, FD-103=70\u00b0C\nt=0s:  Fire SIF evaluates: 2/3 detectors above 60\u00b0C \u2192 TRIP\nt=0s:  Fire SIF activates linked ESD logic\nt=0s:  ESD action 1: Trip ESD valve\nt=0.5s: ESD action 2: Activate blowdown\n</code></pre></p>"},{"location":"safety/layered_safety_architecture/#example-3-complete-layered-system","title":"Example 3: Complete Layered System","text":"<p>Scenario: All safety layers configured</p> <pre><code>// Layer 1: HIPPS for pressure protection\nHIPPSLogic hipps = new HIPPSLogic(\"HIPPS-101\", VotingLogic.TWO_OUT_OF_THREE);\nhipps.addPressureSensor(pt1); // 95 bara\nhipps.addPressureSensor(pt2);\nhipps.addPressureSensor(pt3);\nhipps.setIsolationValve(hippsValve);\n\n// Layer 2: Fire detection\nSafetyInstrumentedFunction fireSIF = \n    new SafetyInstrumentedFunction(\"Fire SIF\", VotingLogic.TWO_OUT_OF_THREE);\nfireSIF.addDetector(fd1); // 60\u00b0C\nfireSIF.addDetector(fd2);\nfireSIF.addDetector(fd3);\n\n// Layer 3: Gas detection\nSafetyInstrumentedFunction gasSIF = \n    new SafetyInstrumentedFunction(\"Gas SIF\", VotingLogic.TWO_OUT_OF_THREE);\ngasSIF.addDetector(gd1); // 25% LEL\ngasSIF.addDetector(gd2);\ngasSIF.addDetector(gd3);\n\n// Layer 4: ESD (final layer)\nESDLogic esd = new ESDLogic(\"ESD Level 1\");\nesd.addAction(new TripValveAction(esdValve), 0.0);\nesd.addAction(new ActivateBlowdownAction(blowdownValve), 0.5);\n\n// Integrate layers\nhipps.linkToEscalationLogic(esd, 5.0);\nfireSIF.linkToLogic(esd);\ngasSIF.linkToLogic(esd);\n\n// Simulation\nhipps.update(pressure, pressure, pressure);\nfireSIF.update(temp1, temp2, temp3);\ngasSIF.update(gas1, gas2, gas3);\nhipps.execute(timeStep);\n\n// Any layer can trigger ESD\nif (hipps.hasEscalated() || fireSIF.isTripped() || gasSIF.isTripped()) {\n    System.out.println(\"ESD activated from safety layer\");\n}\n</code></pre>"},{"location":"safety/layered_safety_architecture/#activation-matrix","title":"Activation Matrix","text":"Condition HIPPS Fire SIF Gas SIF ESD Result Normal operation \u2717 \u2717 \u2717 \u2717 All systems idle Pressure 96 bara \u2713 \u2717 \u2717 \u2717 HIPPS isolates, ESD standby Fire detected \u2717 \u2713 \u2717 \u2713 Fire SIF triggers ESD Gas leak \u2717 \u2717 \u2713 \u2713 Gas SIF triggers ESD HIPPS fails \u2713 \u2717 \u2717 \u2713 HIPPS escalates to ESD Fire + Gas \u2717 \u2713 \u2713 \u2713 Both SIFs trigger ESD All hazards \u2713 \u2713 \u2713 \u2713 Multiple layers activated"},{"location":"safety/layered_safety_architecture/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"safety/layered_safety_architecture/#setpoint-selection","title":"Setpoint Selection","text":"<pre><code>Process Control: 80-85% MAOP (PID controller setpoint)\nBPCS High Alarm: 90% MAOP (operator warning)\nHIPPS Activation: 95% MAOP (first SIS layer)\nESD Activation:   98% MAOP (backup SIS layer)\nPSV Set Pressure: 100% MAOP (passive protection)\n</code></pre> <p>Example for 100 bara MAOP: - Control setpoint: 85 bara - High alarm: 90 bara - HIPPS: 95 bara - ESD: 98 bara - PSV: 100 bara</p>"},{"location":"safety/layered_safety_architecture/#voting-logic-selection","title":"Voting Logic Selection","text":"Application Criticality Availability Need Recommended Voting HIPPS High High 2oo3 (SIL 3) Fire Detection High Medium 2oo3 (SIL \u2154) Gas Detection High Medium 2oo3 (SIL \u2154) ESD Medium Medium 1oo2 or 2oo3 (SIL \u00bd)"},{"location":"safety/layered_safety_architecture/#response-time-targets","title":"Response Time Targets","text":"System Target Response Typical HIPPS &lt;2 seconds 1-2 seconds Fire Detection &lt;5 seconds 2-5 seconds Gas Detection &lt;10 seconds 5-10 seconds ESD &lt;10 seconds 5-10 seconds"},{"location":"safety/layered_safety_architecture/#maintenance-and-testing","title":"Maintenance and Testing","text":""},{"location":"safety/layered_safety_architecture/#proof-testing-schedule","title":"Proof Testing Schedule","text":"Component Test Type Frequency Bypass Allowed Pressure transmitters Calibration Annual Yes (1 at a time) Fire detectors Functional test 6 months Yes (1 at a time) Gas detectors Calibration 6 months Yes (1 at a time) HIPPS valve Partial stroke Quarterly No HIPPS valve Full stroke Annual Yes (with backup) ESD valve Partial stroke Quarterly No ESD valve Full stroke Annual Yes (with backup)"},{"location":"safety/layered_safety_architecture/#bypass-management","title":"Bypass Management","text":"<pre><code>// Bypass detector for maintenance (max 1 at a time)\nDetector pt1 = hipps.getPressureSensor(0);\npt1.setBypass(true);\n\n// Check bypass status\nfor (Detector sensor : hipps.getPressureSensors()) {\n    if (sensor.isBypassed()) {\n        System.out.println(\"WARNING: \" + sensor.getName() + \" bypassed\");\n    }\n}\n\n// Verify bypass constraint\nif (bypassCount &gt; maxAllowed) {\n    System.out.println(\"ERROR: Too many sensors bypassed\");\n}\n</code></pre>"},{"location":"safety/layered_safety_architecture/#standards-compliance","title":"Standards Compliance","text":""},{"location":"safety/layered_safety_architecture/#iec-61511-process-industry-sis","title":"IEC 61511 (Process Industry SIS)","text":"<p>All implemented safety systems comply with IEC 61511: - \u2713 Risk-based SIL determination - \u2713 Voting logic for redundancy - \u2713 Bypass management procedures - \u2713 Proof testing requirements - \u2713 Functional safety assessment</p>"},{"location":"safety/layered_safety_architecture/#iec-61508-functional-safety","title":"IEC 61508 (Functional Safety)","text":"<ul> <li>\u2713 Hardware fault tolerance (2oo3 = 1 fault tolerant)</li> <li>\u2713 Systematic capability</li> <li>\u2713 Safe failure fraction</li> <li>\u2713 Diagnostic coverage</li> </ul>"},{"location":"safety/layered_safety_architecture/#isa-84-ansiisa-840001","title":"ISA-84 / ANSI/ISA-84.00.01","text":"<ul> <li>\u2713 SIF specification</li> <li>\u2713 SIL verification calculations</li> <li>\u2713 Pre-startup acceptance testing</li> </ul>"},{"location":"safety/layered_safety_architecture/#benefits-of-layered-approach","title":"Benefits of Layered Approach","text":""},{"location":"safety/layered_safety_architecture/#safety-benefits","title":"Safety Benefits","text":"<ol> <li>Defense in Depth: Multiple independent barriers</li> <li>Redundancy: Backup if primary layer fails</li> <li>High Reliability: 2oo3 voting reduces false trips and dangerous failures</li> <li>Fail-Safe Design: All systems fail to safe state</li> </ol>"},{"location":"safety/layered_safety_architecture/#operational-benefits","title":"Operational Benefits","text":"<ol> <li>Reduced Flaring: HIPPS prevents PSV lifting</li> <li>Faster Recovery: HIPPS trips are easier to reset than full ESD</li> <li>Maintenance Flexibility: Bypass capability without compromising safety</li> <li>Production Continuity: Lower spurious trip rate</li> </ol>"},{"location":"safety/layered_safety_architecture/#compliance-benefits","title":"Compliance Benefits","text":"<ol> <li>Standards Adherence: IEC 61511, IEC 61508, ISA-84</li> <li>SIL Achievement: Meets SIL \u2154 requirements</li> <li>Audit Trail: Complete activation and reset history</li> <li>Documentation: Comprehensive test and maintenance records</li> </ol>"},{"location":"safety/layered_safety_architecture/#future-enhancements","title":"Future Enhancements","text":""},{"location":"safety/layered_safety_architecture/#planned-features","title":"Planned Features","text":"<ol> <li>PFD Calculation: Automatic probability of failure on demand</li> <li>Proof Test Tracking: Integrated test scheduling and reporting</li> <li>Performance Dashboards: Real-time safety system KPIs</li> <li>Alarm Management: Integration with process alarms</li> <li>Event Logging: Comprehensive audit trail</li> </ol>"},{"location":"safety/layered_safety_architecture/#advanced-capabilities","title":"Advanced Capabilities","text":"<ul> <li>Predictive Maintenance: AI/ML for sensor drift detection</li> <li>Dynamic Risk Assessment: Real-time SIL verification</li> <li>Cyber Security: IEC 62443 compliance for safety systems</li> <li>Cloud Integration: Remote monitoring and diagnostics</li> </ul>"},{"location":"safety/layered_safety_architecture/#see-also","title":"See Also","text":"<ul> <li>HIPPS Safety Logic - Detailed HIPPS documentation</li> <li>SIS Logic Implementation - Fire and gas detection</li> <li>Process Logic Framework - Base architecture</li> <li>ESD Blowdown System - Emergency shutdown details</li> <li>HIPPS Summary - High-level overview</li> <li>HIPPS Implementation - Implementation details</li> </ul>"},{"location":"safety/psv_dynamic_sizing_example/","title":"PSV Dynamic Sizing Example","text":"<p>This example demonstrates how to perform a dynamic safety calculation for a pressure safety valve (PSV) sizing using NeqSim's transient simulation capabilities.</p>"},{"location":"safety/psv_dynamic_sizing_example/#scenario","title":"Scenario","text":"<p>A high-pressure separator operates at ~50 bara with gas output flowing through a splitter: - Stream 1: Goes to a pressure control valve (PCV) for normal operation (99.9% of flow) - Stream 2: Goes to a pressure safety valve (PSV) for overpressure protection (0.1% of flow)</p>"},{"location":"safety/psv_dynamic_sizing_example/#dynamic-event-sequence","title":"Dynamic Event Sequence","text":"<ol> <li>Normal operation (t=0-50s): Separator operates normally, PCV at 50% opening, PSV closed</li> <li>Blocked outlet (t=50s): PCV suddenly closes to 1% (simulating blocked outlet)</li> <li>Pressure rise (t=50-130s): Separator pressure increases from ~32 bara to 55 bara</li> <li>PSV opens (t=130s): PSV starts opening when pressure exceeds set pressure (55 bara)</li> <li>Relief phase (t=130-200s): PSV relieves gas to control pressure at ~58.7 bara</li> <li>Recovery (t=200s): PCV reopens to 50%, allowing normal flow path</li> <li>Pressure drops (t=200-260s): System pressure decreases as both valves relieve</li> <li>PSV closes (t=260s): PSV reseats when pressure drops to blowdown pressure (~51.15 bara)</li> </ol>"},{"location":"safety/psv_dynamic_sizing_example/#psv-hysteresis-behavior","title":"PSV Hysteresis Behavior","text":"<p>The PSV implements realistic hysteresis (blowdown) behavior to prevent valve chattering:</p> <ul> <li>Set Pressure: 55.0 bara - PSV starts opening at this pressure</li> <li>Full Open Pressure: 60.5 bara - PSV is 100% open (10% overpressure allowed)</li> <li>Blowdown Pressure: 51.15 bara - PSV reseats at 93% of set pressure (7% blowdown)</li> </ul> <p>Key Point: Once the PSV opens, it does NOT close immediately when pressure drops below the set pressure. It stays open until pressure drops to the blowdown/reseat pressure. This prevents rapid cycling (chattering) that could damage the valve.</p>"},{"location":"safety/psv_dynamic_sizing_example/#typical-blowdown-values","title":"Typical Blowdown Values","text":"<ul> <li>Gas service: 7-10% (default: 7%)</li> <li>Liquid service: 10-20%</li> <li>Steam service: 2-5%</li> </ul>"},{"location":"safety/psv_dynamic_sizing_example/#code-structure","title":"Code Structure","text":"<pre><code>// Setup equipment\nSeparator separator = new Separator(\"HP Separator\", feedStream);\nSplitter gasSplitter = new Splitter(\"Gas Splitter\", separator.getGasOutStream(), 2);\nThrottlingValve pressureControlValve = new ThrottlingValve(\"PCV-001\", gasSplitter.getSplitStream(0));\nSafetyValve pressureSafetyValve = new SafetyValve(\"PSV-001\", gasSplitter.getSplitStream(1));\n\n// Configure PSV with automatic opening\npressureSafetyValve.setPressureSpec(55.0);  // Set pressure (bara)\npressureSafetyValve.setFullOpenPressure(60.5);  // Full open at 110% of set\n// Blowdown is automatically set to 7% (reseat at 51.15 bara)\n\n// Alternative: Explicitly set blowdown percentage\npressureSafetyValve.setBlowdown(10.0);  // 10% blowdown for liquid service\n\n// Dynamic simulation loop\nfor (int i = 0; i &lt; numSteps; i++) {\n    currentTime = i * dt;\n\n    // Simulate events (blockage, recovery, etc.)\n    if (currentTime &gt;= 50.0 &amp;&amp; currentTime &lt; 51.0) {\n        pressureControlValve.setPercentValveOpening(1.0);  // Block outlet\n    }\n    if (currentTime &gt;= 200.0 &amp;&amp; currentTime &lt; 201.0) {\n        pressureControlValve.setPercentValveOpening(50.0);  // Recover\n    }\n\n    // Run transient calculations\n    // PSV opening is calculated automatically based on inlet pressure\n    separator.runTransient(dt, id);\n    gasSplitter.runTransient(dt, id);\n    pressureControlValve.runTransient(dt, id);\n    pressureSafetyValve.runTransient(dt, id);  // Automatic PSV control with hysteresis\n}\n</code></pre>"},{"location":"safety/psv_dynamic_sizing_example/#automatic-psv-control","title":"Automatic PSV Control","text":"<p>The <code>SafetyValve.runTransient()</code> method automatically: 1. Monitors inlet pressure 2. Calculates valve opening percentage based on:    - Set pressure (starts opening)    - Full open pressure (100% open)    - Current valve state (open/closed) 3. Implements hysteresis:    - When closed: Opens when P \u2265 P_set    - When open: Closes when P \u2264 P_blowdown (reseat pressure) 4. Prevents chattering through state tracking</p>"},{"location":"safety/psv_dynamic_sizing_example/#results","title":"Results","text":"<p>From the test simulation with 5000 kg/hr feed:</p> Parameter Value Feed flow rate 5000 kg/hr PSV set pressure 55.0 bara PSV full open pressure 60.5 bara PSV blowdown pressure 51.15 bara (7% blowdown) Maximum separator pressure 58.69 bara Maximum PSV relief flow 6086 kg/hr PSV opening at max pressure 67.1%"},{"location":"safety/psv_dynamic_sizing_example/#key-observations","title":"Key Observations","text":"<ol> <li> <p>PSV prevents catastrophic overpressure: Maximum pressure (58.69 bara) is well below the full open pressure (60.5 bara), demonstrating effective pressure control.</p> </li> <li> <p>Adequate relief capacity: PSV relieves 6086 kg/hr, which exceeds the feed rate (5000 kg/hr), ensuring the valve can handle the relief scenario.</p> </li> <li> <p>Hysteresis prevents chattering: </p> </li> <li>PSV opens at 55.0 bara</li> <li>PSV stays open even when pressure drops to 52-54 bara</li> <li> <p>PSV only closes when pressure reaches 50.95 bara (below the 51.15 bara blowdown)</p> </li> <li> <p>Smooth pressure control: The automatic PSV control provides smooth pressure regulation during both pressure buildup and recovery phases.</p> </li> </ol>"},{"location":"safety/psv_dynamic_sizing_example/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use dynamic mode: Set <code>setCalculateSteadyState(false)</code> for all equipment in transient simulations</p> </li> <li> <p>Size PSV conservatively: Ensure PSV can handle at least 100% of the feed flow rate</p> </li> <li> <p>Set appropriate blowdown: Use 7-10% for gas, 10-20% for liquid service to prevent chattering</p> </li> <li> <p>Use unique UUID: Create one UUID per simulation run to track transient state correctly</p> </li> <li> <p>Choose appropriate time step: 0.5 seconds provides good resolution for PSV dynamics</p> </li> <li> <p>Monitor key parameters: Track separator pressure, valve openings, and flow rates throughout the simulation</p> </li> </ol>"},{"location":"safety/psv_dynamic_sizing_example/#see-also","title":"See Also","text":"<ul> <li>Test implementation: <code>SafetyValveDynamicSizingTest.java</code></li> <li>SafetyValve class: <code>src/main/java/neqsim/process/equipment/valve/SafetyValve.java</code></li> <li>API 520 - Sizing, Selection, and Installation of Pressure-relieving Devices</li> </ul>"},{"location":"safety/rupture_disk_dynamic_behavior/","title":"Rupture Disk Dynamic Behavior","text":"<p>This document explains the rupture disk implementation in NeqSim, demonstrating the key difference between rupture disks and pressure safety valves (PSVs).</p>"},{"location":"safety/rupture_disk_dynamic_behavior/#what-is-a-rupture-disk","title":"What is a Rupture Disk?","text":"<p>A rupture disk (also called a bursting disc) is a non-reclosing pressure relief device that: - Bursts at a specific set pressure - Opens rapidly and remains fully open - Cannot reseat - it's a one-time use device - Must be physically replaced after activation</p> <p>This is fundamentally different from a safety valve which: - Opens at set pressure - Closes again when pressure drops to blowdown/reseat pressure - Can cycle multiple times - Uses hysteresis to prevent chattering</p>"},{"location":"safety/rupture_disk_dynamic_behavior/#applications","title":"Applications","text":"<p>Rupture disks are typically used for: 1. Primary relief for rapid pressure rise scenarios (runaway reactions) 2. Backup protection in series with safety valves 3. Corrosive/fouling services where PSVs would fail 4. Emergency relief where instant full opening is required 5. Low maintenance applications</p>"},{"location":"safety/rupture_disk_dynamic_behavior/#implementation","title":"Implementation","text":""},{"location":"safety/rupture_disk_dynamic_behavior/#rupturedisk-class","title":"RuptureDisk Class","text":"<pre><code>RuptureDisk disk = new RuptureDisk(\"RD-001\", inletStream);\ndisk.setBurstPressure(55.0);  // bara - disk ruptures at this pressure\ndisk.setFullOpenPressure(57.75);  // bara - fully open (typically 5% above burst)\ndisk.setOutletPressure(1.0, \"bara\");\ndisk.setCv(150.0);\ndisk.setCalculateSteadyState(false);\n</code></pre>"},{"location":"safety/rupture_disk_dynamic_behavior/#key-parameters","title":"Key Parameters","text":"Parameter Description Typical Value Burst Pressure Pressure at which disk ruptures Set by design Full Open Pressure Pressure for 100% opening 105-110% of burst Cv Flow coefficient Sized for relief scenario"},{"location":"safety/rupture_disk_dynamic_behavior/#automatic-behavior-in-runtransient","title":"Automatic Behavior in runTransient()","text":"<p>The rupture disk automatically: 1. Monitors inlet pressure each time step 2. Ruptures when pressure \u2265 burst pressure 3. Remains fully open regardless of subsequent pressure changes 4. Tracks state with <code>hasRuptured()</code> flag</p>"},{"location":"safety/rupture_disk_dynamic_behavior/#comparison-rupture-disk-vs-safety-valve","title":"Comparison: Rupture Disk vs Safety Valve","text":""},{"location":"safety/rupture_disk_dynamic_behavior/#safety-valve-psv-with-hysteresis","title":"Safety Valve (PSV) with Hysteresis","text":"<pre><code>Pressure rises \u2192 Opens at 55 bara \u2192 Relieves pressure\nPressure drops \u2192 Stays open until 51.15 bara (blowdown)\nPressure below blowdown \u2192 Closes \u2192 Can reopen if needed\n</code></pre>"},{"location":"safety/rupture_disk_dynamic_behavior/#rupture-disk","title":"Rupture Disk","text":"<pre><code>Pressure rises \u2192 Bursts at 55 bara \u2192 Relieves pressure\nPressure drops \u2192 STAYS 100% OPEN\nPressure at any level \u2192 STAYS 100% OPEN (one-time device)\n</code></pre>"},{"location":"safety/rupture_disk_dynamic_behavior/#example-blocked-outlet-scenario","title":"Example: Blocked Outlet Scenario","text":"<pre><code>// Setup separator with gas splitter\nSeparator separator = new Separator(\"HP Separator\", feedStream);\nSplitter gasSplitter = new Splitter(\"Gas Splitter\", separator.getGasOutStream(), 2);\n\n// Normal operation path\nThrottlingValve pcv = new ThrottlingValve(\"PCV-001\", gasSplitter.getSplitStream(0));\npcv.setPercentValveOpening(50.0);\n\n// Emergency relief path\nRuptureDisk disk = new RuptureDisk(\"RD-001\", gasSplitter.getSplitStream(1));\ndisk.setBurstPressure(55.0);\ndisk.setFullOpenPressure(57.75);\n\n// Dynamic simulation\nUUID id = UUID.randomUUID();\nfor (int i = 0; i &lt; numSteps; i++) {\n    double time = i * dt;\n\n    // Simulate PCV blockage at t=50s\n    if (time &gt;= 50.0 &amp;&amp; time &lt; 51.0) {\n        pcv.setPercentValveOpening(1.0);\n    }\n\n    // Simulate PCV recovery at t=200s\n    if (time &gt;= 200.0 &amp;&amp; time &lt; 201.0) {\n        pcv.setPercentValveOpening(50.0);\n    }\n\n    // Run transient - disk bursts automatically\n    separator.runTransient(dt, id);\n    gasSplitter.runTransient(dt, id);\n    pcv.runTransient(dt, id);\n    disk.runTransient(dt, id);  // Automatic rupture control\n}\n</code></pre>"},{"location":"safety/rupture_disk_dynamic_behavior/#test-results","title":"Test Results","text":"<p>From <code>RuptureDiskDynamicTest</code>:</p>"},{"location":"safety/rupture_disk_dynamic_behavior/#behavior-sequence","title":"Behavior Sequence","text":"<pre><code>Time:   0-120s: Normal operation, disk closed, pressure below 55 bara\nTime:   ~130s: Disk ruptures at 55 bara\nTime: 140-200s: Pressure controlled at ~53 bara, disk 100% open\nTime: 200-300s: PCV reopens, pressure drops to 30 bara\n              \u2192 Disk STILL 100% open!\n</code></pre>"},{"location":"safety/rupture_disk_dynamic_behavior/#key-observations","title":"Key Observations","text":"Metric Value Burst pressure 55.0 bara Max pressure 55.35 bara Max relief flow 5950 kg/hr Final pressure 30.5 bara Final disk opening 100% <p>Critical Behavior: Disk remained fully open even though pressure dropped 24.5 bara below the burst pressure!</p>"},{"location":"safety/rupture_disk_dynamic_behavior/#disk-reset-simulation-only","title":"Disk Reset (Simulation Only)","text":"<p>For simulation purposes, you can reset a ruptured disk:</p> <pre><code>disk.reset();  // Simulates disk replacement\n// Disk is now unruptured and closed\n// In reality, you would physically replace the disk\n</code></pre>"},{"location":"safety/rupture_disk_dynamic_behavior/#best-practices","title":"Best Practices","text":"<ol> <li>Sizing: Size rupture disks for full relief capacity - they open instantly</li> <li>Series Protection: Often used upstream of PSVs to protect them from corrosion</li> <li>Burst Tolerance: Account for manufacturing tolerance (typically \u00b15%)</li> <li>Rapid Opening: Full open pressure is typically 5% above burst (vs 10% for PSV)</li> <li>One-Time Use: Plan for system shutdown and disk replacement after rupture</li> <li>Testing: Use <code>reset()</code> method in simulations to test multiple scenarios</li> </ol>"},{"location":"safety/rupture_disk_dynamic_behavior/#when-to-use-rupture-disk-vs-psv","title":"When to Use Rupture Disk vs PSV","text":""},{"location":"safety/rupture_disk_dynamic_behavior/#use-rupture-disk-when","title":"Use Rupture Disk When:","text":"<ul> <li>\u2705 Pressure rise is extremely rapid</li> <li>\u2705 Medium is highly corrosive or fouling</li> <li>\u2705 Instant full area opening is required</li> <li>\u2705 Low maintenance is critical</li> <li>\u2705 Operating as backup to PSV</li> </ul>"},{"location":"safety/rupture_disk_dynamic_behavior/#use-safety-valve-when","title":"Use Safety Valve When:","text":"<ul> <li>\u2705 Pressure relief is cyclic</li> <li>\u2705 Need reseating capability</li> <li>\u2705 Clean, non-fouling service</li> <li>\u2705 Controlled gradual opening preferred</li> <li>\u2705 Want to avoid system shutdown</li> </ul>"},{"location":"safety/rupture_disk_dynamic_behavior/#see-also","title":"See Also","text":"<ul> <li>Rupture disk class: <code>RuptureDisk.java</code></li> <li>Test implementation: <code>RuptureDiskDynamicTest.java</code></li> <li>PSV comparison: <code>psv_dynamic_sizing_example.md</code></li> <li>ASME Section VIII - Pressure Relief Devices</li> <li>API 520 Part 1 - Sizing and Selection</li> </ul>"},{"location":"safety/sis_logic_implementation/","title":"Safety Instrumented System (SIS) Logic Implementation","text":""},{"location":"safety/sis_logic_implementation/#overview","title":"Overview","text":"<p>Implemented a comprehensive Safety Instrumented System (SIS) framework for NeqSim following IEC 61511 standards, enabling realistic fire and gas detection with voting logic and automatic ESD triggering.</p>"},{"location":"safety/sis_logic_implementation/#components-implemented","title":"Components Implemented","text":""},{"location":"safety/sis_logic_implementation/#1-votinglogic-enum-neqsimprocesslogicsis","title":"1. VotingLogic Enum (<code>neqsim.process.logic.sis</code>)","text":"<p>Represents standard voting patterns for redundant sensors:</p> <ul> <li>1oo1 - Single sensor (low cost, high spurious trips)</li> <li>1oo2 - At least 1 of 2 must trip</li> <li>2oo2 - Both sensors must trip (very low spurious trips)</li> <li>2oo3 - At least 2 of 3 must trip (standard for high reliability)</li> <li>2oo4, 3oo4 - Higher redundancy patterns</li> </ul> <pre><code>VotingLogic voting = VotingLogic.TWO_OUT_OF_THREE;\nboolean shouldTrip = voting.evaluate(trippedCount); // true if \u22652 tripped\n</code></pre>"},{"location":"safety/sis_logic_implementation/#2-detector-class-neqsimprocesslogicsis","title":"2. Detector Class (<code>neqsim.process.logic.sis</code>)","text":"<p>Represents fire, gas, or process detectors with:</p> <ul> <li>Detector Types: FIRE, GAS, PRESSURE, TEMPERATURE, LEVEL, FLOW</li> <li>Alarm Levels: LOW, LOW_LOW, HIGH, HIGH_HIGH</li> <li>Trip Logic: Automatic evaluation against setpoint</li> <li>Bypass Capability: For maintenance without compromising safety</li> <li>Fault Detection: Identifies faulty detectors</li> <li>Manual Trip/Reset: For testing and recovery</li> </ul> <pre><code>Detector fireDetector = new Detector(\"FD-101\", DetectorType.FIRE, \n                                      AlarmLevel.HIGH, 60.0, \"\u00b0C\");\nfireDetector.update(temperatureValue); // Evaluates trip condition\nif (fireDetector.isTripped()) {\n  // Detector has tripped\n}\n</code></pre>"},{"location":"safety/sis_logic_implementation/#3-safetyinstrumentedfunction-sif-class-neqsimprocesslogicsis","title":"3. SafetyInstrumentedFunction (SIF) Class (<code>neqsim.process.logic.sis</code>)","text":"<p>Complete SIF implementation following IEC 61511 architecture:</p> <p>Key Features: - Voting Logic: Configurable voting patterns (1oo1, 2oo3, etc.) - Multiple Detectors: Add N detectors per voting requirement - Bypass Management: Max 1 bypassed detector (configurable) - Logic Linking: Automatically activates linked ESD logic sequences - Manual Override: For testing/maintenance (requires authorization) - Reset Permissives: Requires all detectors clear before reset</p> <pre><code>// Create fire SIF with 2oo3 voting\nSafetyInstrumentedFunction fireSIF = \n    new SafetyInstrumentedFunction(\"Fire Detection SIF\", VotingLogic.TWO_OUT_OF_THREE);\n\n// Add 3 detectors\nfireSIF.addDetector(new Detector(\"FD-101\", DetectorType.FIRE, AlarmLevel.HIGH, 60.0, \"\u00b0C\"));\nfireSIF.addDetector(new Detector(\"FD-102\", DetectorType.FIRE, AlarmLevel.HIGH, 60.0, \"\u00b0C\"));\nfireSIF.addDetector(new Detector(\"FD-103\", DetectorType.FIRE, AlarmLevel.HIGH, 60.0, \"\u00b0C\"));\n\n// Link to ESD logic\nfireSIF.linkToLogic(esdLogic);\n\n// Update detector values\nfireSIF.update(temp1, temp2, temp3);\n\n// Check if SIF tripped (2 of 3 detectors exceeded setpoint)\nif (fireSIF.isTripped()) {\n  // ESD logic automatically activated\n}\n</code></pre>"},{"location":"safety/sis_logic_implementation/#iec-61511-compliance","title":"IEC 61511 Compliance","text":""},{"location":"safety/sis_logic_implementation/#safety-integrity-level-sil-features","title":"Safety Integrity Level (SIL) Features","text":"<ol> <li>Redundancy</li> <li>Multiple detectors per hazard</li> <li>Voting logic prevents spurious trips</li> <li> <p>One detector can fail without losing safety function</p> </li> <li> <p>Bypass Management</p> </li> <li>Maximum bypassed detectors enforced (typically 1)</li> <li>2oo3 with 1 bypassed becomes effectively 2oo2</li> <li> <p>Safety function maintained during maintenance</p> </li> <li> <p>Fault Handling</p> </li> <li>Faulty detectors excluded from voting</li> <li>System enters FAILED state if too many bypassed</li> <li> <p>Alarm on fault conditions</p> </li> <li> <p>Reset Logic</p> </li> <li>Requires all trip conditions cleared</li> <li>Operator acknowledgment</li> <li>Linked logic sequences also reset</li> </ol>"},{"location":"safety/sis_logic_implementation/#example-fire-gas-detection-system","title":"Example: Fire &amp; Gas Detection System","text":"<p>The <code>FireGasSISExample</code> demonstrates a complete safety system:</p>"},{"location":"safety/sis_logic_implementation/#system-architecture","title":"System Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Fire Detection (2oo3)          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502FD-101\u2502 \u2502FD-102\u2502 \u2502FD-103\u2502     \u2502\n\u2502  \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2514\u2500\u2500\u252c\u2500\u2500\u2518       \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n\u2502         2/3 must trip            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502         \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Gas Detection (2oo3)            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510        \u2502\n\u2502  \u2502GD-101\u2502 \u2502GD-102\u2502 \u2502GD-103\u2502      \u2502\n\u2502  \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2514\u2500\u2500\u252c\u2500\u2500\u2518        \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n\u2502         2/3 must trip             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n               \u25bc\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502  ESD Logic     \u2502\n      \u2502  1. Trip ESD   \u2502\n      \u2502  2. Open BD    \u2502\n      \u2502  3. Redirect   \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"safety/sis_logic_implementation/#scenarios-demonstrated","title":"Scenarios Demonstrated","text":""},{"location":"safety/sis_logic_implementation/#scenario-1-normal-operation","title":"Scenario 1: Normal Operation","text":"<ul> <li>All detectors reading normal values</li> <li>No trips, process continues</li> <li>Continuous monitoring active</li> </ul>"},{"location":"safety/sis_logic_implementation/#scenario-2-single-detector-trip-13","title":"Scenario 2: Single Detector Trip (\u2153)","text":"<ul> <li>FD-101 detects elevated temperature</li> <li>Voting not satisfied (need \u2154)</li> <li>ESD NOT activated</li> <li>Alarm raised for investigation</li> </ul>"},{"location":"safety/sis_logic_implementation/#scenario-3-fire-detected-23","title":"Scenario 3: Fire Detected (\u2154)","text":"<ul> <li>FD-101 and FD-102 both detect fire</li> <li>Voting satisfied: 2 out of 3 tripped</li> <li>SIF automatically activates ESD logic</li> <li>Coordinated shutdown sequence executes</li> </ul>"},{"location":"safety/sis_logic_implementation/#scenario-4-bypass-capability","title":"Scenario 4: Bypass Capability","text":"<ul> <li>GD-101 bypassed for maintenance</li> <li>GD-102 and GD-103 detect gas</li> <li>Voting still works: 2/2 active detectors tripped</li> <li>Safety function maintained with 1 bypassed</li> </ul>"},{"location":"safety/sis_logic_implementation/#integration-with-process-logic-framework","title":"Integration with Process Logic Framework","text":"<p>The SIS components integrate seamlessly with the existing process logic framework:</p> <pre><code>// Create SIF\nSafetyInstrumentedFunction fireSIF = \n    new SafetyInstrumentedFunction(\"Fire SIF\", VotingLogic.TWO_OUT_OF_THREE);\nfireSIF.addDetector(fireDetector1);\nfireSIF.addDetector(fireDetector2);\nfireSIF.addDetector(fireDetector3);\n\n// Create ESD logic with actions\nESDLogic esdLogic = new ESDLogic(\"ESD Level 1\");\nesdLogic.addAction(new TripValveAction(esdValve), 0.0);\nesdLogic.addAction(new ActivateBlowdownAction(bdValve), 0.5);\nesdLogic.addAction(new SetSplitterAction(splitter, factors), 0.0);\n\n// Link SIF to ESD logic\nfireSIF.linkToLogic(esdLogic);\n\n// Push button can also trigger ESD\nPushButton esdButton = new PushButton(\"ESD-PB-101\");\nesdButton.linkToLogic(esdLogic);\n\n// In simulation loop:\nfireSIF.update(temp1, temp2, temp3); // Automatic evaluation\n// or\nesdButton.push(); // Manual trigger\n</code></pre>"},{"location":"safety/sis_logic_implementation/#key-benefits","title":"Key Benefits","text":""},{"location":"safety/sis_logic_implementation/#1-realistic-safety-systems","title":"1. Realistic Safety Systems","text":"<ul> <li>Industry-standard voting logic</li> <li>Follows IEC 61511 architecture</li> <li>Suitable for safety integrity calculations</li> </ul>"},{"location":"safety/sis_logic_implementation/#2-operational-flexibility","title":"2. Operational Flexibility","text":"<ul> <li>Bypass for maintenance</li> <li>Manual override capability</li> <li>Multiple SIFs can trigger same ESD</li> </ul>"},{"location":"safety/sis_logic_implementation/#3-reduced-spurious-trips","title":"3. Reduced Spurious Trips","text":"<ul> <li>2oo3 voting eliminates single-point failures</li> <li>Continues operating with 1 detector bypassed/faulty</li> <li>Balances safety and availability</li> </ul>"},{"location":"safety/sis_logic_implementation/#4-integration-ready","title":"4. Integration Ready","text":"<ul> <li>Works with existing process logic framework</li> <li>Compatible with all valve types</li> <li>Extensible to pressure, level, flow transmitters</li> </ul>"},{"location":"safety/sis_logic_implementation/#voting-logic-comparison","title":"Voting Logic Comparison","text":"Pattern Spurious Trip Rate Safety Integrity Availability Common Use 1oo1 High Low Low Low criticality 1oo2 Low Medium High Balance needed 2oo2 Very Low Low Medium Rare 2oo3 Low High High Standard choice 2oo4 Very Low High Very High Critical systems"},{"location":"safety/sis_logic_implementation/#files-created","title":"Files Created","text":""},{"location":"safety/sis_logic_implementation/#core-sis-framework-3-files","title":"Core SIS Framework (3 files)","text":"<ul> <li><code>VotingLogic.java</code> - Voting pattern enumeration</li> <li><code>Detector.java</code> - Fire/gas/process detector</li> <li><code>SafetyInstrumentedFunction.java</code> - Complete SIF implementation</li> </ul>"},{"location":"safety/sis_logic_implementation/#examples-1-file","title":"Examples (1 file)","text":"<ul> <li><code>FireGasSISExample.java</code> - Comprehensive demonstration</li> </ul>"},{"location":"safety/sis_logic_implementation/#example-output-highlights","title":"Example Output Highlights","text":"<pre><code>SCENARIO 3: FIRE DETECTED - 2oo3 VOTING SATISFIED\n&gt;&gt;&gt; FD-101 and FD-102 detect fire &lt;&lt;&lt;\nFire Detection SIF [2oo3] - TRIPPED (2/3 tripped)\n  FD-101: TRIPPED\n  FD-102: TRIPPED\n  FD-103: NORMAL\nSIF Status: TRIPPED - ESD ACTIVATED\nESD Logic: ESD Level 1 - RUNNING (Step 1/3: Trip ESD valve ESD-XV-101)\n\nTime (s) | Fire SIF | Gas SIF  | ESD Step | ESD Valve (%) | BD Valve (%)\n---------|----------|----------|----------|---------------|-------------\n     0.0 |  TRIPPED |  NORMAL  | Step 1/3 |          80.0 |          0.0\n     1.0 |  TRIPPED |  NORMAL  | Step 1/3 |          60.0 |          0.0\n     ...\n     5.0 |  TRIPPED |  NORMAL  | Step 2/3 |           0.0 |          0.0\n     ...\n</code></pre>"},{"location":"safety/sis_logic_implementation/#future-enhancements","title":"Future Enhancements","text":""},{"location":"safety/sis_logic_implementation/#phase-2-recommended","title":"Phase 2 (Recommended)","text":"<ol> <li>Time-based voting - Require N detectors tripped for T seconds</li> <li>Demand rate tracking - Calculate SIF demand frequency</li> <li>Proof test tracking - Record detector testing intervals</li> <li>PFD calculations - Probability of Failure on Demand</li> </ol>"},{"location":"safety/sis_logic_implementation/#phase-3-advanced","title":"Phase 3 (Advanced)","text":"<ol> <li>Dynamic voting - Adjust voting based on operational mode</li> <li>Partial stroke testing - Test valves without full trip</li> <li>SIL verification - Built-in SIL calculations per IEC 61508</li> <li>LOPA integration - Layers of Protection Analysis</li> </ol>"},{"location":"safety/sis_logic_implementation/#standards-compliance","title":"Standards Compliance","text":""},{"location":"safety/sis_logic_implementation/#iec-61511-functional-safety-process-industry","title":"IEC 61511 (Functional Safety - Process Industry)","text":"<p>\u2713 SIF architecture (sensor \u2192 logic \u2192 final element) \u2713 Voting logic patterns \u2713 Bypass management \u2713 Proof test considerations</p>"},{"location":"safety/sis_logic_implementation/#iec-61508-functional-safety-generic","title":"IEC 61508 (Functional Safety - Generic)","text":"<p>\u2713 Safety integrity levels \u2713 Systematic failure prevention \u2713 Diagnostic coverage</p>"},{"location":"safety/sis_logic_implementation/#isa-84-ansiisa-840001","title":"ISA-84 / ANSI/ISA-84.00.01","text":"<p>\u2713 Safety instrumented systems \u2713 Safety lifecycle management \u2713 SIS design requirements</p>"},{"location":"safety/sis_logic_implementation/#conclusion","title":"Conclusion","text":"<p>The SIS logic framework provides NeqSim with industry-standard fire and gas detection capabilities, enabling realistic simulation of safety-critical process control systems. The 2oo3 voting implementation balances safety integrity with operational availability, making it suitable for modeling high-reliability applications.</p> <p>Combined with the process logic framework, NeqSim now supports comprehensive modeling of: - Emergency shutdown systems - Fire and gas detection - Automated safety responses - Startup/shutdown sequences (future) - Batch operations (future)</p> <p>All following recognized international standards for process safety instrumentation.</p>"},{"location":"simulation/","title":"Process Simulation Guides","text":"<p>Advanced guides for process simulation features in NeqSim.</p>"},{"location":"simulation/#overview","title":"Overview","text":"<p>This folder contains guides for advanced process simulation topics including process logic, parallel simulation, graph-based simulation, and equipment-specific modeling.</p>"},{"location":"simulation/#documentation-index","title":"Documentation Index","text":""},{"location":"simulation/#process-logic","title":"Process Logic","text":"Document Description process_logic_framework.md Process logic framework architecture advanced_process_logic.md Advanced logic patterns ProcessLogicEnhancements.md Logic enhancements process_logic_implementation_summary.md Implementation summary RuntimeLogicFlexibility.md Runtime logic flexibility process_calculator.md Process calculators"},{"location":"simulation/#simulation-techniques","title":"Simulation Techniques","text":"Document Description parallel_process_simulation.md Parallel and multi-threaded simulation graph_based_process_simulation.md Graph-based process simulation recycle_acceleration_guide.md Recycle convergence acceleration differentiable_thermodynamics.md Auto-differentiation for optimization INTEGRATED_WORKFLOW_GUIDE.md Integrated workflow guide"},{"location":"simulation/#equipment-modeling","title":"Equipment Modeling","text":"Document Description turboexpander_compressor_model.md Turboexpander and compressor modeling equipment_factory.md Equipment factory patterns"},{"location":"simulation/#well-and-reservoir","title":"Well and Reservoir","text":"Document Description well_simulation_guide.md Well simulation guide well_and_choke_simulation.md Choke valve simulation field_development_engine.md Field development engine"},{"location":"simulation/#related-documentation","title":"Related Documentation","text":"<ul> <li>Process Package - Process equipment and systems</li> <li>Process Equipment - Equipment documentation</li> <li>Thermodynamic Operations - Flash calculations</li> </ul>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/","title":"NeqSim as an Integrated Thermodynamic Backbone","text":"<p>A strategic guide for using NeqSim to unify production, flow assurance, and process safety workflows across the asset lifecycle.</p>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#executive-summary","title":"Executive Summary","text":"<p>NeqSim can serve as a shared physics layer that makes production, flow assurance, and process safety work faster, more consistent, and less conservative\u2014while improving technical quality.</p> <p>One-sentence takeaway: NeqSim replaces fragmented assumptions with a shared, physics-based thermodynamic backbone across the entire asset lifecycle.</p>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#table-of-contents","title":"Table of Contents","text":"<ol> <li>The Core Problem Today</li> <li>NeqSim's Strategic Role</li> <li>Integrated Work Chain</li> <li>Concrete Efficiency Gains</li> <li>Digital Twin &amp; Lifecycle Benefits</li> <li>Organizational Impact</li> <li>NeqSim Implementation Status</li> <li>Getting Started</li> </ol>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#1-the-core-problem-today","title":"1. The Core Problem Today","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#discipline-silos-in-oil-gas-organizations","title":"Discipline Silos in Oil &amp; Gas Organizations","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     TYPICAL DISCIPLINE SILOS                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502    Production    \u2502    \u2502  Flow Assurance  \u2502    \u2502  Process Safety  \u2502       \u2502\n\u2502  \u2502    Engineers     \u2502    \u2502    Engineers     \u2502    \u2502    Engineers     \u2502       \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524       \u2502\n\u2502  \u2502 \u2022 Steady-state   \u2502    \u2502 \u2022 OLGA/LEDaFlow  \u2502    \u2502 \u2022 PHAST/FLACS    \u2502       \u2502\n\u2502  \u2502   simulators     \u2502    \u2502 \u2022 Spreadsheets   \u2502    \u2502 \u2022 Handbook       \u2502       \u2502\n\u2502  \u2502 \u2022 HYSYS/UniSim   \u2502    \u2502 \u2022 In-house tools \u2502    \u2502   assumptions    \u2502       \u2502\n\u2502  \u2502 \u2022 PRO/II         \u2502    \u2502                  \u2502    \u2502 \u2022 API correlations\u2502      \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502           \u2502                       \u2502                       \u2502                  \u2502\n\u2502           \u2502    Different          \u2502    Different          \u2502                  \u2502\n\u2502           \u2502    fluid models       \u2502    fluid models       \u2502                  \u2502\n\u2502           \u25bc                       \u25bc                       \u25bc                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502                      INCONSISTENCY ZONE                           \u2502       \u2502\n\u2502  \u2502  \u2022 Different compositions      \u2022 Different EOS parameters         \u2502       \u2502\n\u2502  \u2502  \u2022 Different JT coefficients   \u2022 Different phase split methods    \u2502       \u2502\n\u2502  \u2502  \u2022 Different Cp/Cv values      \u2022 Different water handling         \u2502       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#typical-pain-points","title":"Typical Pain Points","text":"Issue Description Consequence Different fluid models Each discipline defines fluid independently Inconsistent predictions Manual composition transfer Re-entry of compositions between tools Transcription errors Inconsistent assumptions Different JT, Cp, phase split methods Conflicting results Conservative stacking Each discipline adds safety margin Over-design, wasted CAPEX Slow iteration Changes require re-work in all disciplines Long lead times"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#the-result","title":"The Result","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  \u274c Long lead times (weeks for iteration cycles)            \u2502\n\u2502  \u274c Excessive conservatism (stacked safety margins)         \u2502\n\u2502  \u274c Fragile safety margins (based on assumptions)           \u2502\n\u2502  \u274c Documentation burden (reconciling different models)     \u2502\n\u2502  \u274c Late-stage surprises (when models disagree)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#2-neqsims-strategic-role","title":"2. NeqSim's Strategic Role","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#shared-physics-layer","title":"Shared Physics Layer","text":"<p>NeqSim acts as a single thermodynamic backbone that feeds all disciplines consistently:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NEQSIM AS SHARED PHYSICS LAYER                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                 \u2502\n\u2502                         \u2502      NeqSim      \u2502                                 \u2502\n\u2502                         \u2502  Thermodynamic   \u2502                                 \u2502\n\u2502                         \u2502     Backbone     \u2502                                 \u2502\n\u2502                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                 \u2502\n\u2502                                  \u2502                                           \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                       \u2502\n\u2502              \u2502                   \u2502                   \u2502                       \u2502\n\u2502              \u25bc                   \u25bc                   \u25bc                       \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502\n\u2502     \u2502   Production   \u2502  \u2502 Flow Assurance \u2502  \u2502 Process Safety \u2502              \u2502\n\u2502     \u2502    Models      \u2502  \u2502     Models     \u2502  \u2502    Studies     \u2502              \u2502\n\u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n\u2502                                                                              \u2502\n\u2502     Same fluid \u2502 Same EOS \u2502 Same water handling \u2502 Same hydrate logic        \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#key-principle","title":"Key Principle","text":"<p>NeqSim does not replace specialist tools\u2014it feeds them consistently.</p> Specialist Tool NeqSim's Role HYSYS / UniSim Provide consistent fluid packages OLGA / LEDaFlow Provide boundary conditions and fluid tables PHAST / FLACS / KFX Provide source terms and release conditions QRA platforms Provide risk event frequencies and consequences"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#3-integrated-work-chain","title":"3. Integrated Work Chain","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#step-1-single-source-of-truth-for-fluids","title":"Step 1: Single Source of Truth for Fluids","text":"<pre><code>import neqsim.thermo.system.*;\n\n// NeqSim defines the fluid ONCE for all disciplines\npublic class AssetFluidDefinition {\n\n    public static SystemInterface createProductionFluid() {\n        // Single definition used everywhere\n        SystemInterface fluid = new SystemSrkCPAstatoil(300.0, 80.0);\n\n        // Hydrocarbon composition\n        fluid.addComponent(\"nitrogen\", 0.01);\n        fluid.addComponent(\"CO2\", 0.02);\n        fluid.addComponent(\"methane\", 0.78);\n        fluid.addComponent(\"ethane\", 0.08);\n        fluid.addComponent(\"propane\", 0.05);\n        fluid.addComponent(\"i-butane\", 0.02);\n        fluid.addComponent(\"n-butane\", 0.02);\n        fluid.addComponent(\"n-pentane\", 0.01);\n        fluid.addComponent(\"n-hexane\", 0.01);\n\n        // Water and inhibitors (CPA handles association)\n        fluid.addComponent(\"water\", 0.005);\n        fluid.addComponent(\"MEG\", 0.002);\n\n        fluid.setMixingRule(\"classic\");\n        fluid.createDatabase(true);\n\n        return fluid;\n    }\n}\n</code></pre> <p>Benefits:</p> Benefit Description \u2705 EOS consistency Same equation of state across all disciplines \u2705 Pseudo-component alignment Heavy ends handled identically \u2705 Water/MEG handling CPA or other models applied consistently \u2705 Hydrate model alignment Same hydrate predictions everywhere \u2705 Eliminates re-tuning No need to match fluid between tools"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#step-2-production-flow-assurance-handover","title":"Step 2: Production \u2192 Flow Assurance Handover","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#traditional-handover-manual","title":"Traditional Handover (Manual)","text":"<pre><code>Production delivers:                Flow assurance receives:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Flow rates                        \u2022 Simplified compositions\n\u2022 P/T at key nodes                  \u2022 Handbook properties\n\u2022 Basic composition                 \u2022 Re-tuned fluid model\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#neqsim-enhanced-handover","title":"NeqSim-Enhanced Handover","text":"<pre><code>import neqsim.process.equipment.stream.*;\nimport neqsim.thermo.system.*;\n\npublic class ProductionToFlowAssuranceHandover {\n\n    /**\n     * Creates a complete handover package for flow assurance.\n     */\n    public FlowAssuranceHandover createHandover(Stream productionNode) {\n        SystemInterface fluid = productionNode.getThermoSystem();\n        ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n\n        FlowAssuranceHandover handover = new FlowAssuranceHandover();\n\n        // Complete thermodynamic state\n        handover.pressure_bara = fluid.getPressure();\n        handover.temperature_K = fluid.getTemperature();\n        handover.massFlowRate_kg_s = productionNode.getFlowRate(\"kg/sec\");\n\n        // Phase fractions\n        handover.vaporFraction = fluid.getPhase(0).getBeta();\n        handover.liquidFraction = 1.0 - handover.vaporFraction;\n        handover.waterFraction = fluid.getPhase(\"aqueous\") != null \n            ? fluid.getPhase(\"aqueous\").getBeta() : 0.0;\n\n        // Gas properties\n        handover.gasDensity_kg_m3 = fluid.getPhase(\"gas\").getDensity(\"kg/m3\");\n        handover.gasViscosity_cP = fluid.getPhase(\"gas\").getViscosity(\"cP\");\n        handover.gasCp_J_kgK = fluid.getPhase(\"gas\").getCp(\"J/kgK\");\n        handover.gasZ = fluid.getPhase(\"gas\").getZ();\n\n        // Liquid properties (if present)\n        if (handover.liquidFraction &gt; 0.001) {\n            handover.liquidDensity_kg_m3 = fluid.getPhase(\"oil\").getDensity(\"kg/m3\");\n            handover.liquidViscosity_cP = fluid.getPhase(\"oil\").getViscosity(\"cP\");\n        }\n\n        // Joule-Thomson coefficient\n        handover.JT_K_bar = fluid.getJouleThomsonCoefficient();\n\n        // Hydrate equilibrium temperature\n        ops.hydrateFormationTemperature();\n        handover.hydrateTemperature_K = fluid.getTemperature();\n        handover.hydrateMargin_K = productionNode.getTemperature(\"K\") \n            - handover.hydrateTemperature_K;\n\n        // Wax appearance temperature (if applicable)\n        try {\n            ops.calcWAT();\n            handover.waxTemperature_K = fluid.getTemperature();\n        } catch (Exception e) {\n            handover.waxTemperature_K = Double.NaN;\n        }\n\n        return handover;\n    }\n}\n</code></pre> <p>Flow Assurance Benefits:</p> Benefit Impact Better inlet conditions Accurate boundary for OLGA/LEDaFlow Reduced uncertainty Slugging, liquid dropout, thermal profiles Hydrate margins Pre-calculated, consistent with production Real JT coefficients Not handbook values"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#step-3-flow-assurance-safety-handover","title":"Step 3: Flow Assurance \u2192 Safety Handover","text":"<p>This is where NeqSim provides the most value.</p>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#typical-safety-problem","title":"Typical Safety Problem","text":"<p>\"What is released if this line ruptures at node X?\"</p> <p>Traditional approach: - Flow assurance model is dynamic but not safety-oriented - Safety engineer re-estimates properties manually - Uses handbook values for JT, Cp/Cv, phase split</p>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#neqsim-enhanced-safety-handover","title":"NeqSim-Enhanced Safety Handover","text":"<pre><code>import neqsim.process.safety.release.*;\nimport neqsim.process.equipment.tank.*;\n\npublic class FlowAssuranceToSafetyHandover {\n\n    /**\n     * Creates source terms for safety analysis from flow assurance node.\n     */\n    public SafetySourceTerm createSafetyHandover(\n            SystemInterface fluidAtNode,\n            double holeDiameter_mm,\n            double inventoryVolume_m3) {\n\n        // Create leak model with exact local fluid state\n        LeakModel leak = LeakModel.builder()\n            .fluid(fluidAtNode)\n            .holeDiameter(holeDiameter_mm, \"mm\")\n            .dischargeCoefficient(0.62)\n            .vesselVolume(inventoryVolume_m3)\n            .build();\n\n        // Calculate transient source term\n        SourceTermResult result = leak.calculateSourceTerm(600.0, 1.0);\n\n        SafetySourceTerm handover = new SafetySourceTerm();\n\n        // Release characteristics\n        handover.peakMassFlow_kg_s = result.getPeakMassFlowRate();\n        handover.releaseTemperature_K = result.getTemperature()[0];\n        handover.isChoked = result.isChoked()[0];\n        handover.vaporFraction = result.getVaporFraction()[0];\n\n        // For minimum metal temperature assessment\n        if (inventoryVolume_m3 &gt; 0) {\n            VesselDepressurization blowdown = createBlowdownCase(\n                fluidAtNode, inventoryVolume_m3, holeDiameter_mm);\n            handover.minimumTemperature_K = blowdown.getMinimumWallTemperatureReached();\n            handover.timeToMinTemp_s = blowdown.getTimeToMinimumTemperature();\n        }\n\n        // Export for consequence tools\n        result.exportToPHAST(\"node_\" + holeDiameter_mm + \"mm_phast.csv\");\n        result.exportToFLACS(\"node_\" + holeDiameter_mm + \"mm_flacs.csv\");\n\n        return handover;\n    }\n}\n</code></pre> <p>Safety Benefits:</p> Benefit Impact Realistic source terms Based on actual fluid, not assumptions Exact phase split Not conservative \"all liquid\" or \"all gas\" Correct release temperature Isenthalpic expansion properly modeled MDMT assessment Minimum metal temperature from transient Consistent assumptions Same as production and flow assurance"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#step-4-unified-treatment-of-transient-events","title":"Step 4: Unified Treatment of Transient Events","text":"<p>NeqSim sits at the center of transient scenarios that span all disciplines:</p> Scenario Production View Flow Assurance View Safety View Start-up Flow ramp-up Liquid loading, hydrate risk Cold vent risk Shutdown Rate decay Holdup redistribution Blowdown cooling ESD Valve closure Pressure waves Rupture / PSV lift Restart Thermal mismatch Hydrates in dead legs Ignition risk Turndown Low flow Slugging, liquid accumulation PSV sizing margin"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#neqsim-provides-unified-physics","title":"NeqSim Provides Unified Physics","text":"<pre><code>import neqsim.process.safety.envelope.*;\n\npublic class TransientScenarioAnalysis {\n\n    /**\n     * Analyzes a transient scenario across all discipline concerns.\n     */\n    public TransientAnalysisResult analyzeScenario(\n            SystemInterface fluid,\n            double initialPressure,\n            double finalPressure,\n            double ambientTemperature) {\n\n        TransientAnalysisResult result = new TransientAnalysisResult();\n\n        // Safety envelope calculator\n        SafetyEnvelopeCalculator envCalc = new SafetyEnvelopeCalculator(fluid);\n\n        // Calculate all relevant envelopes\n        SafetyEnvelope hydrateEnv = envCalc.calculateHydrateEnvelope(\n            finalPressure, initialPressure, 20);\n        SafetyEnvelope mdmtEnv = envCalc.calculateMDMTEnvelope(\n            finalPressure, initialPressure, ambientTemperature + 273.15, 20);\n        SafetyEnvelope co2Env = envCalc.calculateCO2FreezingEnvelope(\n            finalPressure, initialPressure, 10);\n\n        // Check operating path against envelopes\n        result.hydrateRiskDuringTransient = !hydrateEnv.isOperatingPointSafe(\n            initialPressure / 2, ambientTemperature + 273.15);\n        result.mdmtRiskDuringBlowdown = !mdmtEnv.isOperatingPointSafe(\n            finalPressure, ambientTemperature + 273.15 - 50);\n        result.co2FreezingRisk = !co2Env.isOperatingPointSafe(\n            finalPressure, 220.0);\n\n        // Calculate thermodynamic path\n        result.thermodynamicPath = calculateDepressurizationPath(\n            fluid, initialPressure, finalPressure);\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#4-concrete-efficiency-gains","title":"4. Concrete Efficiency Gains","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#41-faster-iteration-loops","title":"4.1 Faster Iteration Loops","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#without-neqsim","title":"Without NeqSim","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    TRADITIONAL ITERATION LOOP                                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502  Production \u2500\u2500\u25ba Flow Assurance \u2500\u2500\u25ba Safety \u2500\u2500\u25ba Back to Production            \u2502\n\u2502                                                                              \u2502\n\u2502  Timeline: WEEKS                                                             \u2502\n\u2502                                                                              \u2502\n\u2502  \u2022 Each discipline re-defines fluid                                         \u2502\n\u2502  \u2022 Manual handover documents                                                \u2502\n\u2502  \u2022 Review cycles for consistency                                            \u2502\n\u2502  \u2022 Reconciliation meetings                                                  \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#with-neqsim","title":"With NeqSim","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NEQSIM-ENABLED ITERATION LOOP                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                          \u2502\n\u2502                    \u2502   Change     \u2502                                          \u2502\n\u2502                    \u2502 (P/T/comp)   \u2502                                          \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                          \u2502\n\u2502                           \u2502                                                  \u2502\n\u2502                           \u25bc                                                  \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                          \u2502\n\u2502                    \u2502    NeqSim    \u2502                                          \u2502\n\u2502                    \u2502   Update     \u2502                                          \u2502\n\u2502                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                          \u2502\n\u2502                           \u2502                                                  \u2502\n\u2502              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                     \u2502\n\u2502              \u25bc            \u25bc            \u25bc                                     \u2502\n\u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                \u2502\n\u2502         \u2502Updated \u2502  \u2502 Updated  \u2502  \u2502Updated \u2502                                \u2502\n\u2502         \u2502  FA    \u2502  \u2502  Safety  \u2502  \u2502  Prod  \u2502                                \u2502\n\u2502         \u2502Inputs  \u2502  \u2502  Inputs  \u2502  \u2502 Inputs \u2502                                \u2502\n\u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                \u2502\n\u2502                                                                              \u2502\n\u2502  Timeline: HOURS TO DAYS                                                     \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Especially powerful for:</p> Application Time Savings Late-phase design changes Days \u2192 Hours Brownfield modifications Weeks \u2192 Days Debottlenecking studies Weeks \u2192 Days What-if scenarios Days \u2192 Hours Sensitivity studies Manual \u2192 Automated"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#42-reduced-conservatism-without-reducing-safety","title":"4.2 Reduced Conservatism (Without Reducing Safety)","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#sources-of-conservatism-today","title":"Sources of Conservatism Today","text":"Source Traditional Approach NeqSim Approach Ideal gas assumptions Handbook \u03b3 = 1.3 Actual \u03b3 from EOS Worst-case phase \"Assume all liquid\" Actual flash calculation Handbook JT values Generic curves Composition-specific JT Safety margin stacking Each discipline adds margin Single, transparent margin"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#impact-example-psv-sizing","title":"Impact Example: PSV Sizing","text":"<pre><code>// Traditional: Conservative assumptions\ndouble traditionalArea = calculatePSVArea_Traditional(\n    flowRate,\n    gamma_assumed = 1.3,           // Handbook value\n    Z_assumed = 1.0,               // Ideal gas\n    MW_assumed = 18.0              // Light estimate\n);\n\n// NeqSim: Case-specific thermodynamics\nSystemInterface fluid = getActualFluid();\ndouble neqsimArea = calculatePSVArea_NeqSim(\n    flowRate,\n    gamma = fluid.getGamma(),       // Actual: 1.18\n    Z = fluid.getZ(),               // Actual: 0.85\n    MW = fluid.getMolarMass()       // Actual: 21.5\n);\n\n// Result: NeqSim area may be 15-25% smaller\n// \u2192 Same safety level, smaller/cheaper valve\n</code></pre> <p>Key insight:</p> <p>Safety decisions become risk-based, not assumption-based</p>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#43-fewer-handover-errors","title":"4.3 Fewer Handover Errors","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#error-sources-eliminated","title":"Error Sources Eliminated","text":"Error Type Traditional With NeqSim Composition transcription Common Eliminated Unit conversion mistakes Occasional Eliminated EOS mismatch Frequent Eliminated Water content disagreement Common Eliminated Hydrate model differences Frequent Eliminated"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#quantified-impact","title":"Quantified Impact","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              HANDOVER ERROR REDUCTION                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  Documentation errors:      \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 100% \u2192 \u2593\u2593 20%           \u2502\n\u2502  Review comments:           \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 100% \u2192 \u2593\u2593\u2593 30%          \u2502\n\u2502  Late-stage surprises:      \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 100% \u2192 \u2593 10%            \u2502\n\u2502  Reconciliation meetings:   \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 100% \u2192 \u2593\u2593\u2593\u2593 40%         \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#5-digital-twin-lifecycle-benefits","title":"5. Digital Twin &amp; Lifecycle Benefits","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#real-time-operations-integration","title":"Real-Time Operations Integration","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NEQSIM IN DIGITAL TWIN ARCHITECTURE                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                              \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n\u2502  \u2502   Field     \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502   NeqSim    \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502  Decision   \u2502           \u2502\n\u2502  \u2502   Data      \u2502         \u2502   Engine    \u2502         \u2502   Support   \u2502           \u2502\n\u2502  \u2502  (PI/OPC)   \u2502         \u2502             \u2502         \u2502             \u2502           \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2502\n\u2502                                 \u2502                                           \u2502\n\u2502                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                              \u2502\n\u2502                    \u25bc                         \u25bc                              \u2502\n\u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u2502\n\u2502           \u2502  Real-Time      \u2502       \u2502  Safety         \u2502                    \u2502\n\u2502           \u2502  Monitoring     \u2502       \u2502  Assessment     \u2502                    \u2502\n\u2502           \u2502  \u2022 Hydrate      \u2502       \u2502  \u2022 Barrier      \u2502                    \u2502\n\u2502           \u2502    margin       \u2502       \u2502    status       \u2502                    \u2502\n\u2502           \u2502  \u2022 Two-phase    \u2502       \u2502  \u2022 SIMOPS       \u2502                    \u2502\n\u2502           \u2502    risk         \u2502       \u2502    evaluation   \u2502                    \u2502\n\u2502           \u2502  \u2022 MDMT during  \u2502       \u2502  \u2022 Degraded     \u2502                    \u2502\n\u2502           \u2502    blowdown     \u2502       \u2502    mode ops     \u2502                    \u2502\n\u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2502\n\u2502                                                                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#during-operations","title":"During Operations","text":"<pre><code>import neqsim.process.safety.envelope.*;\n\npublic class RealTimeMonitoring {\n\n    private SafetyEnvelopeCalculator envelopeCalc;\n    private SystemInterface currentFluid;\n\n    /**\n     * Called periodically with live data from field.\n     */\n    public MonitoringResult updateFromLiveData(\n            double pressure_bara,\n            double temperature_K,\n            Map&lt;String, Double&gt; composition) {\n\n        // Update fluid state\n        currentFluid.setTemperature(temperature_K);\n        currentFluid.setPressure(pressure_bara);\n        ThermodynamicOperations ops = new ThermodynamicOperations(currentFluid);\n        ops.TPflash();\n\n        MonitoringResult result = new MonitoringResult();\n\n        // Hydrate margin assessment\n        ops.hydrateFormationTemperature();\n        double hydrateTemp = currentFluid.getTemperature();\n        result.hydrateMargin_K = temperature_K - hydrateTemp;\n        result.hydrateAlarm = result.hydrateMargin_K &lt; 5.0;\n\n        // Two-phase risk\n        result.vaporFraction = currentFluid.getPhase(0).getBeta();\n        result.twoPhaseRisk = result.vaporFraction &gt; 0.05 &amp;&amp; result.vaporFraction &lt; 0.95;\n\n        // MDMT risk during potential blowdown\n        SafetyEnvelope mdmtEnv = envelopeCalc.calculateMDMTEnvelope(\n            1.0, pressure_bara, temperature_K, 10);\n        result.blowdownMinTemp_K = mdmtEnv.getTemperature()[9]; // At 1 bara\n        result.mdmtAlarm = result.blowdownMinTemp_K &lt; 233.0; // -40\u00b0C\n\n        return result;\n    }\n}\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#during-safety-management","title":"During Safety Management","text":"Assessment NeqSim Capability Barrier effectiveness Real-time calculation of relief capacity Safety envelope monitoring Live comparison to calculated limits SIMOPS evaluation Impact of concurrent operations Degraded mode operation Assessment of reduced barriers"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#lifecycle-integration","title":"Lifecycle Integration","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                                  \u2502\n\u2502     Design \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Operate \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba Safeguard      \u2502\n\u2502        \u25b2                     \u2502                       \u2502          \u2502\n\u2502        \u2502                     \u2502                       \u2502          \u2502\n\u2502        \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u2502          \u2502\n\u2502        \u2502         \u2502        NeqSim         \u2502          \u2502          \u2502\n\u2502        \u2502         \u2502  Thermodynamic Core   \u2502          \u2502          \u2502\n\u2502        \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502          \u2502\n\u2502        \u2502                     \u2502                       \u2502          \u2502\n\u2502        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n\u2502                        Feedback Loop                             \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#6-organizational-impact","title":"6. Organizational Impact","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#technical-benefits","title":"Technical Benefits","text":"Impact Description Cross-discipline language Shared terminology and units Early assumption alignment Agreed EOS and methods upfront Reduced tool-ownership silos Focus on physics, not software Audit trail Transparent, reproducible calculations"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#team-benefits","title":"Team Benefits","text":"Impact Description Reuse of PhD/research work Academic contributions directly usable Open, auditable calculations No \"black box\" concerns Easier onboarding New engineers learn one system Knowledge preservation Methods captured in code"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#project-benefits","title":"Project Benefits","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              PROJECT EFFICIENCY IMPROVEMENTS                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  Engineering hours:         Reduced 20-30%                      \u2502\n\u2502  Review cycles:             Reduced 40-50%                      \u2502\n\u2502  Late changes impact:       Reduced 50-60%                      \u2502\n\u2502  Documentation effort:      Reduced 30-40%                      \u2502\n\u2502  Consistency issues:        Reduced 70-80%                      \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#7-neqsim-implementation-status","title":"7. NeqSim Implementation Status","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#standardized-handover-objects","title":"Standardized Handover Objects","text":"Object Status Package <code>SystemInterface</code> (Fluid State) \u2705 Complete <code>neqsim.thermo.system</code> <code>SourceTermResult</code> \u2705 Complete <code>neqsim.process.safety.release</code> <code>SafetyEnvelope</code> \u2705 Complete <code>neqsim.process.safety.envelope</code> <code>RiskEvent</code> / <code>RiskResult</code> \u2705 Complete <code>neqsim.process.safety.risk</code> <code>ProcessSafetyScenario</code> \u2705 Complete <code>neqsim.process.safety</code> <code>BoundaryConditions</code> \u2705 Complete <code>neqsim.process.safety</code>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#dynamic-capabilities","title":"Dynamic Capabilities","text":"Capability Status Implementation Blowdown transient \u2705 Complete <code>VesselDepressurization</code> Leak/rupture source term \u2705 Complete <code>LeakModel</code> Phase envelope \u2705 Complete <code>ThermodynamicOperations</code> Hydrate formation \u2705 Complete <code>ThermodynamicOperations</code> WAT/Wax \u2705 Complete <code>ThermodynamicOperations</code>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#export-adapters","title":"Export Adapters","text":"Target Status Method PHAST \u2705 Complete <code>exportToPHAST()</code> FLACS \u2705 Complete <code>exportToFLACS()</code> KFX \u2705 Complete <code>exportToKFX()</code> OpenFOAM \u2705 Complete <code>exportToOpenFOAM()</code> CSV (generic) \u2705 Complete <code>exportToCSV()</code> JSON (generic) \u2705 Complete <code>exportToJSON()</code> PI Format \u2705 Complete <code>exportToPIFormat()</code> Seeq \u2705 Complete <code>exportToSeeq()</code> OLGA PVT tables \ud83d\udd04 Partial Under development"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#assumption-transparency","title":"Assumption Transparency","text":"Feature Status Description EOS selection \u2705 Explicit <code>SystemSrkEos</code>, <code>SystemPrEos</code>, etc. Mixing rules \u2705 Explicit <code>setMixingRule()</code> Flash type \u2705 Explicit <code>TPflash()</code>, <code>PHflash()</code>, etc. Discharge model \u2705 Documented HEM, isenthalpic expansion Hydrate model \u2705 Explicit CPA, van der Waals-Platteeuw"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#8-getting-started","title":"8. Getting Started","text":""},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#quick-start-define-asset-fluid","title":"Quick Start: Define Asset Fluid","text":"<pre><code>import neqsim.thermo.system.*;\n\n// Step 1: Create fluid with appropriate EOS\nSystemInterface fluid = new SystemSrkCPAstatoil(300.0, 80.0);\n\n// Step 2: Add components (single definition for all disciplines)\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.08);\nfluid.addComponent(\"propane\", 0.04);\nfluid.addComponent(\"n-butane\", 0.02);\nfluid.addComponent(\"water\", 0.01);\n\n// Step 3: Set mixing rules\nfluid.setMixingRule(\"classic\");\nfluid.createDatabase(true);\n\n// Step 4: Flash to get equilibrium state\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Now this fluid can feed:\n// - Production models\n// - Flow assurance boundary conditions\n// - Safety source terms\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#quick-start-generate-safety-source-terms","title":"Quick Start: Generate Safety Source Terms","text":"<pre><code>import neqsim.process.safety.release.*;\n\n// Create leak model from asset fluid\nLeakModel leak = LeakModel.builder()\n    .fluid(fluid)\n    .holeDiameter(25.0, \"mm\")\n    .dischargeCoefficient(0.62)\n    .vesselVolume(10.0)\n    .build();\n\n// Calculate and export\nSourceTermResult result = leak.calculateSourceTerm(600.0, 1.0);\nresult.exportToPHAST(\"source_term.csv\");\nresult.exportToFLACS(\"source_term_flacs.csv\");\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#quick-start-calculate-safety-envelopes","title":"Quick Start: Calculate Safety Envelopes","text":"<pre><code>import neqsim.process.safety.envelope.*;\n\n// Create envelope calculator\nSafetyEnvelopeCalculator calc = new SafetyEnvelopeCalculator(fluid);\n\n// Calculate all relevant envelopes\nSafetyEnvelope hydrate = calc.calculateHydrateEnvelope(1.0, 100.0, 20);\nSafetyEnvelope mdmt = calc.calculateMDMTEnvelope(1.0, 100.0, 300.0, 20);\n\n// Export for DCS/historian\nhydrate.exportToPIFormat(\"hydrate_limits.csv\");\nmdmt.exportToPIFormat(\"mdmt_limits.csv\");\n</code></pre>"},{"location":"simulation/INTEGRATED_WORKFLOW_GUIDE/#references","title":"References","text":"<ul> <li>NeqSim QRA Integration Guide</li> <li>Safety Simulation Roadmap</li> <li>NeqSim Documentation</li> <li>NeqSim GitHub Repository</li> </ul> <p>Document version: 1.0 Last updated: December 2024</p>"},{"location":"simulation/ProcessLogicEnhancements/","title":"Process Logic and Scenario Simulation Enhancements","text":"<p>This document describes the enhancements made to the NeqSim process logic framework to support advanced safety system simulation with logic sequences and scenario testing.</p>"},{"location":"simulation/ProcessLogicEnhancements/#new-core-components-added","title":"New Core Components Added","text":""},{"location":"simulation/ProcessLogicEnhancements/#1-logic-actions-srcmainjavaneqsimprocesslogicaction","title":"1. Logic Actions (<code>src/main/java/neqsim/process/logic/action/</code>)","text":""},{"location":"simulation/ProcessLogicEnhancements/#setvalveopeningactionjava","title":"<code>SetValveOpeningAction.java</code>","text":"<ul> <li>Sets throttling valve to specific opening percentage (0-100%)</li> <li>Considers action complete when within 1% of target</li> <li>Used for controlled valve positioning</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#openvalveactionjava","title":"<code>OpenValveAction.java</code>","text":"<ul> <li>Fully opens a throttling valve (100% opening)</li> <li>Simple action for emergency or startup valve opening</li> <li>Considers complete when &gt;95% open</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#closevalveactionjava","title":"<code>CloseValveAction.java</code>","text":"<ul> <li>Fully closes a throttling valve (0% opening)</li> <li>Simple action for emergency valve closure</li> <li>Considers complete when &lt;5% open</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#setseparatormodeactionjava","title":"<code>SetSeparatorModeAction.java</code>","text":"<ul> <li>Switches separator between steady-state and transient calculation modes</li> <li>Critical for dynamic process simulation during upsets</li> <li>Instantaneous action</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#2-logic-conditions-srcmainjavaneqsimprocesslogiccondition","title":"2. Logic Conditions (<code>src/main/java/neqsim/process/logic/condition/</code>)","text":""},{"location":"simulation/ProcessLogicEnhancements/#valvepositionconditionjava","title":"<code>ValvePositionCondition.java</code>","text":"<ul> <li>Monitors valve opening percentage with comparison operators</li> <li>Supports &gt;, &gt;=, &lt;, &lt;=, ==, != with configurable tolerance</li> <li>Essential for startup permissives and safety interlocks</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#3-scenario-execution-framework-srcmainjavaneqsimprocessutilscenario","title":"3. Scenario Execution Framework (<code>src/main/java/neqsim/process/util/scenario/</code>)","text":""},{"location":"simulation/ProcessLogicEnhancements/#processscenariorunnerjava","title":"<code>ProcessScenarioRunner.java</code>","text":"<ul> <li>Coordinates process system simulation with logic execution</li> <li>Applies <code>ProcessSafetyScenario</code> perturbations automatically</li> <li>Provides real-time monitoring and status reporting</li> <li>Handles multiple logic sequences concurrently</li> <li>Integrates with transient simulation framework</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#scenarioexecutionsummaryjava","title":"<code>ScenarioExecutionSummary.java</code>","text":"<ul> <li>Captures complete scenario execution results</li> <li>Tracks logic sequence final states and status descriptions</li> <li>Records errors, warnings, and performance metrics</li> <li>Enables automated testing and validation</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#enhanced-pushbutton-integration","title":"Enhanced PushButton Integration","text":"<p>The existing <code>PushButton</code> class already supported linking to multiple <code>ProcessLogic</code> sequences via the <code>linkToLogic()</code> method, enabling: - Manual ESD activation - Startup sequence initiation - Multi-logic coordination from single operator action</p>"},{"location":"simulation/ProcessLogicEnhancements/#example-implementation","title":"Example Implementation","text":""},{"location":"simulation/ProcessLogicEnhancements/#processlogicintegratedexamplejava","title":"<code>ProcessLogicIntegratedExample.java</code>","text":"<p>This comprehensive example demonstrates:</p> <ol> <li>Process System Construction</li> <li>High-pressure gas separation process</li> <li>Safety valves, blowdown systems, and flare</li> <li> <p>Complete instrumentation setup</p> </li> <li> <p>ESD Logic Implementation <pre><code>ESDLogic esdLogic = new ESDLogic(\"ESD Level 1\");\nesdLogic.addAction(new CloseValveAction(inletValve), 0.0);\nesdLogic.addAction(new SetSplitterAction(gasSplitter, new double[]{0.0, 1.0}), 0.5);\nesdLogic.addAction(new ActivateBlowdownAction(bdValve), 0.5);\nesdLogic.addAction(new SetSeparatorModeAction(separator, false), 1.0);\n</code></pre></p> </li> <li> <p>Startup Logic with Permissives <pre><code>StartupLogic startupLogic = new StartupLogic(\"System Startup\");\nstartupLogic.addPermissive(new PressureCondition(separator, 5.0, \"&lt;\"));\nstartupLogic.addPermissive(new ValvePositionCondition(bdValve, \"&lt;\", 5.0));\nstartupLogic.addPermissive(new TimerCondition(10.0));\n</code></pre></p> </li> <li> <p>Scenario Testing <pre><code>ProcessScenarioRunner runner = new ProcessScenarioRunner(processSystem);\nrunner.addLogic(esdLogic);\nrunner.addLogic(startupLogic);\n\nProcessSafetyScenario scenario = ProcessSafetyScenario.builder(\"High Pressure\")\n    .customManipulator(\"HP Feed\", stream -&gt; stream.setPressure(70.0, \"bara\"))\n    .build();\n\nrunner.runScenario(\"High Pressure Test\", scenario, 60.0, 1.0);\n</code></pre></p> </li> </ol>"},{"location":"simulation/ProcessLogicEnhancements/#key-benefits","title":"Key Benefits","text":""},{"location":"simulation/ProcessLogicEnhancements/#1-reusable-components","title":"1. Reusable Components","text":"<ul> <li>All logic actions and conditions are reusable across different examples</li> <li><code>ProcessScenarioRunner</code> can be used for any process system</li> <li>Standard patterns for safety system implementation</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#2-comprehensive-testing","title":"2. Comprehensive Testing","text":"<ul> <li>Automated scenario execution with perturbation application</li> <li>Real-time monitoring of logic sequence states</li> <li>Detailed execution summaries for validation</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#3-safety-system-integration","title":"3. Safety System Integration","text":"<ul> <li>Multi-layer protection (ESD, startup permissives, PSV)</li> <li>Proper sequencing with timing delays</li> <li>Automatic mode switching for dynamic simulation</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#4-industry-best-practices","title":"4. Industry Best Practices","text":"<ul> <li>Follows IEC 61511 safety lifecycle concepts</li> <li>Implements defense-in-depth protection philosophy</li> <li>Supports SIL (Safety Integrity Level) classifications</li> </ul>"},{"location":"simulation/ProcessLogicEnhancements/#usage-patterns","title":"Usage Patterns","text":""},{"location":"simulation/ProcessLogicEnhancements/#basic-esd-implementation","title":"Basic ESD Implementation","text":"<pre><code>ESDLogic esd = new ESDLogic(\"Emergency Shutdown\");\nesd.addAction(new CloseValveAction(inletValve), 0.0);\nesd.addAction(new ActivateBlowdownAction(blowdownValve), 1.0);\npushButton.linkToLogic(esd);\n</code></pre>"},{"location":"simulation/ProcessLogicEnhancements/#startup-with-permissives","title":"Startup with Permissives","text":"<pre><code>StartupLogic startup = new StartupLogic(\"Safe Startup\");\nstartup.addPermissive(new PressureCondition(vessel, 2.0, \"&lt;\"));\nstartup.addPermissive(new TemperatureCondition(vessel, 40.0, \"&lt;\"));\nstartup.addPermissive(new TimerCondition(30.0));\nstartup.addAction(new OpenValveAction(feedValve), 0.0);\n</code></pre>"},{"location":"simulation/ProcessLogicEnhancements/#scenario-testing","title":"Scenario Testing","text":"<pre><code>ProcessScenarioRunner runner = new ProcessScenarioRunner(system);\nrunner.addLogic(esdLogic);\n\nProcessSafetyScenario overpressure = ProcessSafetyScenario.builder(\"Overpressure\")\n    .customManipulator(\"Feed\", s -&gt; s.setPressure(80.0, \"bara\"))\n    .build();\n\nScenarioExecutionSummary result = runner.runScenario(\"Test\", overpressure, 120.0, 1.0);\n</code></pre>"},{"location":"simulation/ProcessLogicEnhancements/#future-enhancements","title":"Future Enhancements","text":"<p>The framework is designed for easy extension: - Additional logic actions (pump control, compressor sequencing) - More sophisticated conditions (flow rate trending, multi-variable) - Advanced scenario types (Monte Carlo analysis, optimization) - Integration with external safety systems - Real-time process historian connectivity</p> <p>This implementation provides a solid foundation for complex process safety simulation while maintaining the clean architecture and patterns established in the NeqSim framework.</p>"},{"location":"simulation/RuntimeLogicFlexibility/","title":"Runtime Logic Flexibility in NeqSim Process Framework","text":""},{"location":"simulation/RuntimeLogicFlexibility/#summary","title":"Summary","text":"<p>YES, it is extremely easy to add new logic programmatically without pre-compilation!</p> <p>The NeqSim process logic framework is designed with excellent runtime flexibility through its interface-based architecture. You can create, modify, and execute complex process logic sequences entirely at runtime without any need for pre-compilation.</p>"},{"location":"simulation/RuntimeLogicFlexibility/#key-flexibility-features","title":"Key Flexibility Features","text":""},{"location":"simulation/RuntimeLogicFlexibility/#1-interface-based-design","title":"1. Interface-Based Design","text":"<ul> <li><code>LogicAction</code> and <code>LogicCondition</code> are interfaces that can be implemented dynamically</li> <li><code>ProcessLogic</code> implementations accept actions/conditions at runtime</li> <li>No dependencies on specific compiled action types</li> </ul>"},{"location":"simulation/RuntimeLogicFlexibility/#2-runtime-logic-creation","title":"2. Runtime Logic Creation","text":"<p>All logic is created programmatically:</p> <pre><code>// Create ESD logic at runtime\nESDLogic esdLogic = new ESDLogic(\"Dynamic ESD\");\nesdLogic.addAction(new CloseValveAction(valve), 0.0);\nesdLogic.addAction(new SetSplitterAction(splitter, new double[]{0.0, 1.0}), 0.5);\n\n// Create startup logic with conditions\nStartupLogic startup = new StartupLogic(\"Dynamic Startup\");\nstartup.addPermissive(new PressureCondition(separator, 5.0, \"&lt;\"));\nstartup.addPermissive(new ValvePositionCondition(valve, \"&lt;\", 5.0));\n</code></pre>"},{"location":"simulation/RuntimeLogicFlexibility/#3-dynamic-actioncondition-creation","title":"3. Dynamic Action/Condition Creation","text":"<p>Create custom actions using anonymous classes or lambda expressions:</p> <pre><code>// Custom action with anonymous class\nLogicAction customAction = new LogicAction() {\n    private boolean executed = false;\n\n    @Override\n    public void execute() {\n        if (!executed) {\n            valve.setPercentValveOpening(75.0);\n            executed = true;\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Custom throttle to 75%\";\n    }\n\n    @Override\n    public boolean isComplete() {\n        return executed &amp;&amp; Math.abs(valve.getPercentValveOpening() - 75.0) &lt; 1.0;\n    }\n\n    @Override\n    public String getTargetName() {\n        return valve.getName();\n    }\n};\n</code></pre>"},{"location":"simulation/RuntimeLogicFlexibility/#4-configuration-based-logic","title":"4. Configuration-Based Logic","text":"<p>Load logic from external configuration files:</p> <pre><code>// Configuration format: ACTION_TYPE:EQUIPMENT:PARAMETER:DELAY\nString[] esdConfig = {\n    \"VALVE_CLOSE:Control Valve:0:0.0\",\n    \"VALVE_SET:Backup Valve:25.0:0.5\", \n    \"SEPARATOR_MODE:Test Separator:transient:1.0\"\n};\n\nESDLogic configuredESD = factory.createESDFromConfig(\"Configured ESD\", esdConfig);\n</code></pre>"},{"location":"simulation/RuntimeLogicFlexibility/#5-runtime-logic-modification","title":"5. Runtime Logic Modification","text":"<p>Modify logic sequences during execution:</p> <pre><code>ESDLogic modifiableLogic = new ESDLogic(\"Modifiable Logic\");\nmodifiableLogic.addAction(initialAction, 0.0);\n\n// Later, based on runtime conditions:\nif (emergencyCondition()) {\n    modifiableLogic.addAction(emergencyAction, 2.0);\n}\n</code></pre>"},{"location":"simulation/RuntimeLogicFlexibility/#demonstration-examples","title":"Demonstration Examples","text":""},{"location":"simulation/RuntimeLogicFlexibility/#1-dynamiclogicexamplejava","title":"1. DynamicLogicExample.java","text":"<p>Shows how to create logic entirely at runtime: - Custom actions with anonymous classes - Custom conditions with time-based logic - Dynamic logic sequences based on scenarios - Runtime modification of existing logic</p>"},{"location":"simulation/RuntimeLogicFlexibility/#2-configurablelogicexamplejava","title":"2. ConfigurableLogicExample.java","text":"<p>Demonstrates loading logic from configurations: - String-based configuration parsing - Configuration file parsing (simulated) - Logic factory pattern for creating actions/conditions - User input-driven logic creation</p>"},{"location":"simulation/RuntimeLogicFlexibility/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"simulation/RuntimeLogicFlexibility/#factory-pattern-for-actions","title":"Factory Pattern for Actions","text":"<pre><code>private LogicAction createActionFromConfig(String config) {\n    String[] parts = config.split(\":\");\n    String actionType = parts[0];\n    String equipmentName = parts[1];\n    String parameter = parts[2];\n\n    switch (actionType) {\n        case \"VALVE_CLOSE\":\n            return createValveCloseAction((ThrottlingValve) equipment.get(equipmentName));\n        case \"VALVE_SET\":\n            return createValveSetAction((ThrottlingValve) equipment.get(equipmentName), \n                                      Double.parseDouble(parameter));\n        // ... more action types\n    }\n}\n</code></pre>"},{"location":"simulation/RuntimeLogicFlexibility/#adaptive-logic-creation","title":"Adaptive Logic Creation","text":"<pre><code>String scenario = determineRuntimeScenario(); // Based on process conditions\nESDLogic adaptiveLogic = createAdaptiveLogic(scenario, valve, separator);\n\nswitch (scenario) {\n    case \"High Pressure Response\":\n        adaptiveLogic.addAction(createAction(\"Close valve rapidly\", valve, 5.0), 0.0);\n        break;\n    case \"Fire Emergency\":\n        adaptiveLogic.addAction(createAction(\"Emergency closure\", valve, 0.0), 0.0);\n        break;\n}\n</code></pre>"},{"location":"simulation/RuntimeLogicFlexibility/#benefits-of-runtime-flexibility","title":"Benefits of Runtime Flexibility","text":""},{"location":"simulation/RuntimeLogicFlexibility/#1-no-recompilation-required","title":"1. No Recompilation Required","text":"<ul> <li>Logic changes can be deployed without rebuilding the application</li> <li>Configuration files can be updated in production</li> <li>Hot-swapping of logic sequences during maintenance</li> </ul>"},{"location":"simulation/RuntimeLogicFlexibility/#2-dynamic-adaptation","title":"2. Dynamic Adaptation","text":"<ul> <li>Logic can adapt to current process conditions</li> <li>Different logic for different operating modes</li> <li>Scenario-based logic selection</li> </ul>"},{"location":"simulation/RuntimeLogicFlexibility/#3-easy-integration","title":"3. Easy Integration","text":"<ul> <li>External systems can define logic via APIs</li> <li>Configuration management systems can update logic</li> <li>Machine learning systems can generate optimized logic</li> </ul>"},{"location":"simulation/RuntimeLogicFlexibility/#4-rapid-development","title":"4. Rapid Development","text":"<ul> <li>Test new logic sequences without compilation cycles</li> <li>Prototype complex control strategies quickly</li> <li>Debug logic sequences with runtime inspection</li> </ul>"},{"location":"simulation/RuntimeLogicFlexibility/#architecture-benefits","title":"Architecture Benefits","text":"<p>The framework's interface-based design provides:</p> <ul> <li>Extensibility: New action/condition types can be added without modifying existing code</li> <li>Testability: Logic sequences can be unit tested with mock equipment</li> <li>Maintainability: Logic is separated from equipment implementation</li> <li>Reusability: Common actions/conditions can be shared across different logic types</li> </ul>"},{"location":"simulation/RuntimeLogicFlexibility/#conclusion","title":"Conclusion","text":"<p>The NeqSim process logic framework excels at runtime flexibility. You can:</p> <ol> <li>\u2705 Create entirely new logic sequences at runtime</li> <li>\u2705 Load logic from configuration files or external sources  </li> <li>\u2705 Modify existing logic sequences during execution</li> <li>\u2705 Create custom actions and conditions dynamically</li> <li>\u2705 Adapt logic based on runtime conditions</li> <li>\u2705 Deploy logic changes without recompilation</li> </ol> <p>This makes it ideal for: - Dynamic process control systems - Configuration-driven safety systems - Adaptive automation platforms - Rapid prototyping of control strategies - Integration with external control systems</p> <p>The examples demonstrate that complex process logic can be created, modified, and executed entirely at runtime with no pre-compilation requirements.</p>"},{"location":"simulation/advanced_process_logic/","title":"Advanced Process Logic Features","text":""},{"location":"simulation/advanced_process_logic/#overview","title":"Overview","text":"<p>NeqSim's process logic framework has been extended with powerful advanced features for complex process control, startup/shutdown sequences, and decision-making. This document covers the new capabilities added to the framework.</p>"},{"location":"simulation/advanced_process_logic/#new-features-summary","title":"New Features Summary","text":"Feature Purpose Key Classes Status Startup Logic Permissive-based startup sequences <code>StartupLogic</code>, <code>LogicCondition</code> \u2713 Complete Shutdown Logic Controlled/emergency ramp-down <code>ShutdownLogic</code> \u2713 Complete Conditional Branching If-then-else decision making <code>ConditionalAction</code> \u2713 Complete Parallel Execution Simultaneous action execution <code>ParallelActionGroup</code> \u2713 Complete Voting Logic Redundant sensor evaluation <code>VotingEvaluator</code>, <code>VotingPattern</code> \u2713 Complete Logic Conditions Runtime condition checking <code>PressureCondition</code>, <code>TemperatureCondition</code>, <code>TimerCondition</code> \u2713 Complete"},{"location":"simulation/advanced_process_logic/#1-startup-logic-with-permissive-checks","title":"1. Startup Logic with Permissive Checks","text":""},{"location":"simulation/advanced_process_logic/#purpose","title":"Purpose","text":"<p>Ensures all required conditions are met before starting equipment, following industry best practices for safe process startup.</p>"},{"location":"simulation/advanced_process_logic/#key-features","title":"Key Features","text":"<ul> <li>Permissive checks: Verify temperature, pressure, level, timer conditions</li> <li>Timeout handling: Abort if permissives not met within configured time</li> <li>Sequential execution: Actions execute in order after permissives satisfied</li> <li>Automatic abort: If permissives lost during startup</li> </ul>"},{"location":"simulation/advanced_process_logic/#example","title":"Example","text":"<pre><code>StartupLogic startup = new StartupLogic(\"Compressor Startup\");\n\n// Add permissives (ALL must be true before starting)\nstartup.addPermissive(new TemperatureCondition(cooler, 50.0, \"&lt;\"));  // Cooled down\nstartup.addPermissive(new PressureCondition(suction, 3.0, \"&gt;\"));     // Min pressure\nstartup.addPermissive(new TimerCondition(60.0));                     // Warm-up time\n\n// Add startup actions\nstartup.addAction(new OpenValveAction(suctionValve), 0.0);   // Immediate\nstartup.addAction(new StartPumpAction(lubePump), 2.0);       // After 2s\nstartup.addAction(new StartCompressorAction(compressor), 10.0); // After 10s\n\n// Activate and execute\nstartup.activate();\nwhile (!startup.isComplete()) {\n    warmupTimer.update(timeStep);\n    startup.execute(timeStep);\n}\n</code></pre>"},{"location":"simulation/advanced_process_logic/#status-output","title":"Status Output","text":"<pre><code>Separator Startup - WAITING FOR PERMISSIVES (2.0s / 300.0s)\n  Permissives:\n    \u2713 Pressure &gt; 5.0 bara: MET (current: 10.0 bara)\n    \u2713 Temperature &lt; 50.0\u00b0C: MET (current: 25.0\u00b0C)\n    \u2717 Wait 5.0 seconds: NOT MET (current: 4.0 s)\n</code></pre>"},{"location":"simulation/advanced_process_logic/#2-shutdown-logic-with-ramp-down","title":"2. Shutdown Logic with Ramp-Down","text":""},{"location":"simulation/advanced_process_logic/#purpose_1","title":"Purpose","text":"<p>Provides controlled, gradual equipment shutdown to prevent thermal shock, pressure surges, or process upsets.</p>"},{"location":"simulation/advanced_process_logic/#key-features_1","title":"Key Features","text":"<ul> <li>Controlled shutdown: Gradual ramp over configurable time (default 5 minutes)</li> <li>Emergency mode: Accelerated shutdown (5-10x faster)</li> <li>Sequential actions: Time-based action execution</li> <li>Progress tracking: Real-time completion percentage</li> </ul>"},{"location":"simulation/advanced_process_logic/#example_1","title":"Example","text":"<pre><code>ShutdownLogic shutdown = new ShutdownLogic(\"Reactor Shutdown\");\nshutdown.setRampDownTime(600.0);  // 10 minutes controlled\n\n// Add ramp-down actions\nshutdown.addAction(new ReduceFeedAction(feedValve, 75.0), 0.0);   // 75% immediately\nshutdown.addAction(new ReduceFeedAction(feedValve, 50.0), 120.0); // 50% after 2 min\nshutdown.addAction(new ReduceFeedAction(feedValve, 25.0), 300.0); // 25% after 5 min\nshutdown.addAction(new StopHeaterAction(heater), 450.0);          // Stop at 7.5 min\nshutdown.addAction(new CloseFeedAction(feedValve), 600.0);        // Close at 10 min\n\n// Controlled shutdown\nshutdown.activate();\n\n// Or emergency shutdown (much faster)\nshutdown.setEmergencyMode(true);\nshutdown.setEmergencyShutdownTime(30.0); // Complete in 30s\nshutdown.activate();\n</code></pre>"},{"location":"simulation/advanced_process_logic/#output-comparison","title":"Output Comparison","text":"<pre><code>CONTROLLED (10 minutes):\nTime: 0.0s   \u2192 Valve: 75%   \u2192 Progress: 0%\nTime: 120.0s \u2192 Valve: 50%   \u2192 Progress: 20%\nTime: 600.0s \u2192 Valve: 0%    \u2192 Progress: 100%\n\nEMERGENCY (30 seconds):\nTime: 0.0s  \u2192 Valve: 0%     \u2192 Progress: 100% (all actions accelerated)\n</code></pre>"},{"location":"simulation/advanced_process_logic/#3-conditional-branching-if-then-else","title":"3. Conditional Branching (If-Then-Else)","text":""},{"location":"simulation/advanced_process_logic/#purpose_2","title":"Purpose","text":"<p>Enables dynamic decision-making within process sequences based on runtime conditions.</p>"},{"location":"simulation/advanced_process_logic/#key-features_2","title":"Key Features","text":"<ul> <li>If-then-else logic: Execute different actions based on conditions</li> <li>Runtime evaluation: Condition checked when action executes</li> <li>Optional alternative: Can have if-then without else</li> <li>Nestable: Conditionals can contain other conditionals</li> </ul>"},{"location":"simulation/advanced_process_logic/#example_2","title":"Example","text":"<pre><code>// If temperature &gt; 100\u00b0C, open cooling valve; else open bypass valve\nLogicCondition highTemp = new TemperatureCondition(reactor, 100.0, \"&gt;\");\nLogicAction openCooling = new OpenValveAction(coolingValve);\nLogicAction openBypass = new OpenValveAction(bypassValve);\n\nConditionalAction conditional = new ConditionalAction(\n    highTemp, \n    openCooling,      // If true\n    openBypass,       // If false\n    \"Temperature Control\"\n);\n\n// Add to sequence\nstartupLogic.addAction(conditional, 0.0);\n\n// At runtime, evaluates temperature and opens appropriate valve\nconditional.execute();\n</code></pre>"},{"location":"simulation/advanced_process_logic/#use-cases","title":"Use Cases","text":"<ul> <li>Temperature-based equipment selection</li> <li>Pressure-based bypass activation</li> <li>Level-based pump staging</li> <li>Time-based mode switching</li> </ul>"},{"location":"simulation/advanced_process_logic/#4-parallel-action-execution","title":"4. Parallel Action Execution","text":""},{"location":"simulation/advanced_process_logic/#purpose_3","title":"Purpose","text":"<p>Executes multiple actions simultaneously to reduce total sequence time and coordinate equipment.</p>"},{"location":"simulation/advanced_process_logic/#key-features_3","title":"Key Features","text":"<ul> <li>Simultaneous execution: All actions run at once</li> <li>Completion tracking: Group complete when ALL actions done</li> <li>Progress monitoring: Track individual and overall completion</li> <li>Error handling: Continues executing even if one action fails</li> </ul>"},{"location":"simulation/advanced_process_logic/#example_3","title":"Example","text":"<pre><code>// Open 3 valves simultaneously\nParallelActionGroup parallelOpen = new ParallelActionGroup(\"Open All Inlet Valves\");\nparallelOpen.addAction(new OpenValveAction(valve1));\nparallelOpen.addAction(new OpenValveAction(valve2));\nparallelOpen.addAction(new OpenValveAction(valve3));\n\n// Add to sequence\nstartupLogic.addAction(parallelOpen, 0.0);\n\n// Executes all valves at once (saves time vs sequential)\nparallelOpen.execute();\n\nSystem.out.printf(\"Progress: %d/%d complete (%.0f%%)\\n\",\n    parallelOpen.getCompletedCount(),\n    parallelOpen.getTotalCount(),\n    parallelOpen.getCompletionPercentage());\n</code></pre>"},{"location":"simulation/advanced_process_logic/#benefits","title":"Benefits","text":"<ul> <li>Time savings: 3 actions in parallel take same time as 1 sequential</li> <li>Coordination: Equipment starts together (e.g., all pumps)</li> <li>Simplicity: Easier than managing multiple timers</li> </ul>"},{"location":"simulation/advanced_process_logic/#5-voting-logic-enhanced","title":"5. Voting Logic (Enhanced)","text":""},{"location":"simulation/advanced_process_logic/#purpose_4","title":"Purpose","text":"<p>Generic voting logic for redundant sensors or conditions, applicable beyond just safety systems.</p>"},{"location":"simulation/advanced_process_logic/#key-features_4","title":"Key Features","text":"<ul> <li>Digital voting: Boolean conditions (1oo2, 2oo3, etc.)</li> <li>Analog voting: Continuous values (median, average, mid-value)</li> <li>Fault handling: Excludes faulty sensors from voting</li> <li>Standard patterns: 1oo1, 1oo2, 2oo2, 2oo3, 2oo4, 3oo4</li> </ul>"},{"location":"simulation/advanced_process_logic/#example-digital-voting","title":"Example - Digital Voting","text":"<pre><code>// 2 out of 3 pressure switches must be high\nVotingEvaluator&lt;Boolean&gt; voting = new VotingEvaluator&lt;&gt;(VotingPattern.TWO_OUT_OF_THREE);\nvoting.addInput(pt1.isHigh(), pt1.isFaulty());\nvoting.addInput(pt2.isHigh(), pt2.isFaulty());\nvoting.addInput(pt3.isHigh(), pt3.isFaulty());\n\nboolean alarmActive = voting.evaluateDigital();\n</code></pre>"},{"location":"simulation/advanced_process_logic/#example-analog-voting","title":"Example - Analog Voting","text":"<pre><code>// Median of 3 temperature sensors (best for safety)\nVotingEvaluator&lt;Double&gt; tempVoting = new VotingEvaluator&lt;&gt;(VotingPattern.TWO_OUT_OF_THREE);\ntempVoting.addInput(tt1.getValue(), tt1.isFaulty());\ntempVoting.addInput(tt2.getValue(), tt2.isFaulty());\ntempVoting.addInput(tt3.getValue(), tt3.isFaulty());\n\ndouble temperature = tempVoting.evaluateMedian();  // Most reliable\ndouble tempAvg = tempVoting.evaluateAverage();     // Alternative\ndouble tempMid = tempVoting.evaluateMidValue();    // For 3 sensors\n</code></pre>"},{"location":"simulation/advanced_process_logic/#applications","title":"Applications","text":"<ul> <li>Critical process measurements (pressure, temperature, flow)</li> <li>Safety systems (HIPPS, Fire &amp; Gas, ESD)</li> <li>Quality control measurements</li> <li>Redundant control loops</li> </ul>"},{"location":"simulation/advanced_process_logic/#6-logic-conditions","title":"6. Logic Conditions","text":""},{"location":"simulation/advanced_process_logic/#purpose_5","title":"Purpose","text":"<p>Define runtime conditions that can be checked by startup logic, conditional actions, or custom logic.</p>"},{"location":"simulation/advanced_process_logic/#available-conditions","title":"Available Conditions","text":""},{"location":"simulation/advanced_process_logic/#pressurecondition","title":"PressureCondition","text":"<pre><code>// Check if pressure meets criteria\nPressureCondition minPressure = new PressureCondition(stream, 5.0, \"&gt;\");   // &gt; 5 bara\nPressureCondition stable = new PressureCondition(stream, 10.0, \"==\", 0.5); // \u00b10.5 bara\n</code></pre>"},{"location":"simulation/advanced_process_logic/#temperaturecondition","title":"TemperatureCondition","text":"<pre><code>// Check if temperature meets criteria\nTemperatureCondition cooled = new TemperatureCondition(heater, 80.0, \"&lt;\");  // &lt; 80\u00b0C\nTemperatureCondition ready = new TemperatureCondition(reactor, 150.0, \"&gt;=\"); // \u2265 150\u00b0C\n</code></pre>"},{"location":"simulation/advanced_process_logic/#timercondition","title":"TimerCondition","text":"<pre><code>// Wait for specified duration\nTimerCondition warmup = new TimerCondition(60.0);  // 60 seconds\nwarmup.start();\n\n// In loop\nwarmup.update(timeStep);\nif (warmup.evaluate()) {\n    // Time elapsed\n}\n</code></pre>"},{"location":"simulation/advanced_process_logic/#supported-operators","title":"Supported Operators","text":"<ul> <li><code>&gt;</code> : Greater than</li> <li><code>&gt;=</code> : Greater than or equal</li> <li><code>&lt;</code> : Less than</li> <li><code>&lt;=</code> : Less than or equal</li> <li><code>==</code> : Equal (within tolerance)</li> <li><code>!=</code> : Not equal</li> </ul>"},{"location":"simulation/advanced_process_logic/#integration-examples","title":"Integration Examples","text":""},{"location":"simulation/advanced_process_logic/#complete-startup-sequence","title":"Complete Startup Sequence","text":"<pre><code>// Compressor startup with all features\nStartupLogic startup = new StartupLogic(\"Gas Compressor Startup\");\n\n// 1. Permissives\nstartup.addPermissive(new PressureCondition(suction, 3.0, \"&gt;\"));\nstartup.addPermissive(new TemperatureCondition(oil, 40.0, \"&gt;\"));\nstartup.addPermissive(new TimerCondition(120.0));\n\n// 2. Parallel valve opening\nParallelActionGroup openValves = new ParallelActionGroup(\"Open Inlet Valves\");\nopenValves.addAction(new OpenValveAction(suctionValve));\nopenValves.addAction(new OpenValveAction(recycleValve));\nstartup.addAction(openValves, 0.0);\n\n// 3. Conditional lubrication\nLogicCondition oilPressureLow = new PressureCondition(oilSystem, 2.0, \"&lt;\");\nConditionalAction startAuxOilPump = new ConditionalAction(\n    oilPressureLow,\n    new StartPumpAction(auxOilPump),\n    \"Auxiliary Oil Pump\"\n);\nstartup.addAction(startAuxOilPump, 2.0);\n\n// 4. Start compressor\nstartup.addAction(new StartCompressorAction(compressor), 10.0);\n\n// Execute\nstartup.activate();\n</code></pre>"},{"location":"simulation/advanced_process_logic/#layered-safety-system","title":"Layered Safety System","text":"<pre><code>// HIPPS \u2192 Fire/Gas \u2192 ESD with voting\nVotingEvaluator&lt;Double&gt; pressureVoting = new VotingEvaluator&lt;&gt;(VotingPattern.TWO_OUT_OF_THREE);\npressureVoting.addInput(pt1.getValue(), pt1.isFaulty());\npressureVoting.addInput(pt2.getValue(), pt2.isFaulty());\npressureVoting.addInput(pt3.getValue(), pt3.isFaulty());\n\ndouble votedPressure = pressureVoting.evaluateMedian();\n\n// Use voted pressure for HIPPS\nif (votedPressure &gt; hippsSetpoint) {\n    hipps.activate();\n}\n</code></pre>"},{"location":"simulation/advanced_process_logic/#best-practices","title":"Best Practices","text":""},{"location":"simulation/advanced_process_logic/#startup-logic","title":"Startup Logic","text":"<ol> <li>Order permissives by criticality (most important first)</li> <li>Use reasonable timeouts (5 minutes default is good)</li> <li>Test permissives before going live</li> <li>Add delays between actions for stabilization</li> </ol>"},{"location":"simulation/advanced_process_logic/#shutdown-logic","title":"Shutdown Logic","text":"<ol> <li>Gradual ramp-down prevents thermal shock (10-30 minutes typical)</li> <li>Emergency mode for critical situations only</li> <li>Monitor progress to verify controlled shutdown</li> <li>Cool down before stopping agitation/mixing</li> </ol>"},{"location":"simulation/advanced_process_logic/#voting-logic","title":"Voting Logic","text":"<ol> <li>2oo3 is standard for safety systems (good balance)</li> <li>Median is preferred over average for safety (outlier rejection)</li> <li>Track faulty sensors and enforce bypass limits</li> <li>Test voting logic with sensor failures</li> </ol>"},{"location":"simulation/advanced_process_logic/#conditional-logic","title":"Conditional Logic","text":"<ol> <li>Keep conditions simple - one comparison per condition</li> <li>Provide alternatives when feasible (else path)</li> <li>Test both paths in simulation</li> <li>Document decisions in descriptions</li> </ol>"},{"location":"simulation/advanced_process_logic/#parallel-execution","title":"Parallel Execution","text":"<ol> <li>Group related actions (all valves, all pumps)</li> <li>Check completion before proceeding</li> <li>Independent actions only (no dependencies)</li> <li>Monitor individual actions for failures</li> </ol>"},{"location":"simulation/advanced_process_logic/#performance-considerations","title":"Performance Considerations","text":"Feature Overhead Typical Use Startup Logic Low Once per startup (minutes) Shutdown Logic Low Once per shutdown (minutes/hours) Conditional Action Very Low Infrequent (mode changes) Parallel Group Very Low Startup/shutdown only Voting Logic Very Low Every control loop (seconds) Conditions Very Low Continuous monitoring <p>All features are designed for real-time performance with minimal overhead.</p>"},{"location":"simulation/advanced_process_logic/#see-also","title":"See Also","text":"<ul> <li>Process Logic Framework - Base architecture</li> <li>SIS Logic Implementation - Safety systems</li> <li>HIPPS Safety Logic - Pressure protection</li> <li>Layered Safety Architecture - Defense in depth</li> <li>Advanced Process Logic Example - Complete code example</li> </ul>"},{"location":"simulation/advanced_process_logic/#summary","title":"Summary","text":"<p>The advanced process logic features provide industrial-grade capabilities for: - \u2713 Safe equipment startup with permissive verification - \u2713 Controlled shutdown with thermal protection - \u2713 Dynamic decision-making with conditional branching - \u2713 Efficient parallel operation coordination - \u2713 Reliable redundant sensor voting - \u2713 Flexible runtime condition checking</p> <p>These features follow industry best practices from standards like ISA-88 (batch), ISA-84 (SIS), and IEC 61131-3 (PLC programming) to provide robust, production-ready process control logic.</p>"},{"location":"simulation/differentiable_thermodynamics/","title":"Differentiable Thermodynamics","text":"<p>NeqSim provides automatic differentiation capabilities for thermodynamic calculations through the <code>neqsim.thermo.util.derivatives</code> package. This enables gradient-based optimization, integration with ML frameworks, and sensitivity analysis.</p>"},{"location":"simulation/differentiable_thermodynamics/#overview","title":"Overview","text":"<p>The key classes are:</p> <ul> <li><code>DifferentiableFlash</code> - Computes gradients of flash calculation results using the implicit function theorem</li> <li><code>FlashGradients</code> - Container for K-value and phase fraction sensitivities</li> <li><code>PropertyGradient</code> - Container for scalar property derivatives (density, enthalpy, Cp, etc.)</li> <li><code>FugacityJacobian</code> - Jacobian matrix of fugacity coefficients</li> </ul>"},{"location":"simulation/differentiable_thermodynamics/#quick-start","title":"Quick Start","text":""},{"location":"simulation/differentiable_thermodynamics/#computing-flash-gradients","title":"Computing Flash Gradients","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.util.derivatives.DifferentiableFlash;\nimport neqsim.thermo.util.derivatives.FlashGradients;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create and flash a system\nSystemInterface system = new SystemSrkEos(300.0, 50.0);\nsystem.addComponent(\"methane\", 0.8);\nsystem.addComponent(\"ethane\", 0.15);\nsystem.addComponent(\"propane\", 0.05);\nsystem.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(system);\nops.TPflash();\n\n// Compute gradients (automatically calls init(3) for fugacity derivatives)\nDifferentiableFlash diffFlash = new DifferentiableFlash(system);\nFlashGradients grads = diffFlash.computeFlashGradients();\n\nif (grads.isValid()) {\n    // Get K-value sensitivities\n    double[] dKdT = grads.getDKdT();  // dK_i/dT for all components\n    double[] dKdP = grads.getDKdP();  // dK_i/dP for all components\n\n    // Get vapor fraction sensitivities\n    double dBetadT = grads.getDBetadT();  // d\u03b2/dT\n    double dBetadP = grads.getDBetadP();  // d\u03b2/dP\n\n    System.out.println(\"dK_methane/dT = \" + dKdT[0] + \" 1/K\");\n    System.out.println(\"d\u03b2/dP = \" + dBetadP + \" 1/bar\");\n}\n</code></pre>"},{"location":"simulation/differentiable_thermodynamics/#computing-property-gradients","title":"Computing Property Gradients","text":"<pre><code>import neqsim.thermo.util.derivatives.PropertyGradient;\n\n// Compute density gradient\nPropertyGradient densityGrad = diffFlash.computePropertyGradient(\"density\");\n\ndouble dRhodT = densityGrad.getDerivativeWrtTemperature();  // d(density)/dT\ndouble dRhodP = densityGrad.getDerivativeWrtPressure();     // d(density)/dP\ndouble[] dRhodz = densityGrad.getDerivativeWrtComposition(); // d(density)/dz_i\n\nSystem.out.println(\"Density = \" + densityGrad.getValue() + \" kg/m\u00b3\");\nSystem.out.println(\"dDensity/dT = \" + dRhodT + \" kg/m\u00b3/K\");\n\n// Compute heat capacity gradient\nPropertyGradient cpGrad = diffFlash.computePropertyGradient(\"Cp\");\n\ndouble dCpdT = cpGrad.getDerivativeWrtTemperature();  // dCp/dT\ndouble dCpdP = cpGrad.getDerivativeWrtPressure();     // dCp/dP\n\nSystem.out.println(\"Cp = \" + cpGrad.getValue() + \" \" + cpGrad.getUnit());\nSystem.out.println(\"dCp/dT = \" + dCpdT + \" J/mol/K\u00b2\");\n</code></pre>"},{"location":"simulation/differentiable_thermodynamics/#accessing-fugacity-jacobian","title":"Accessing Fugacity Jacobian","text":"<pre><code>import neqsim.thermo.util.derivatives.FugacityJacobian;\n\n// Note: computeFlashGradients() automatically calls init(3) to compute\n// fugacity derivatives. If accessing the Jacobian directly, ensure\n// init(3) has been called on the system first.\n\n// Get fugacity derivatives for vapor phase\nFugacityJacobian jacV = diffFlash.extractFugacityJacobian(1);\n\ndouble[] lnPhi = jacV.getLnPhi();           // ln(\u03c6_i)\ndouble[] dlnPhidT = jacV.getDlnPhidT();     // d(ln \u03c6_i)/dT\ndouble[] dlnPhidP = jacV.getDlnPhidP();     // d(ln \u03c6_i)/dP\ndouble[][] dlnPhidn = jacV.getDlnPhidn();   // d(ln \u03c6_i)/dn_j (composition derivatives)\n</code></pre>"},{"location":"simulation/differentiable_thermodynamics/#integration-with-pythonjax","title":"Integration with Python/JAX","text":"<p>The gradients can be used to create custom backward passes for JAX:</p> <pre><code>import jax\nfrom jax import custom_vjp\nimport jpype\n\n# Start JVM and import NeqSim classes\njpype.startJVM(classpath=['neqsim.jar'])\nfrom neqsim.thermo.system import SystemSrkEos\nfrom neqsim.thermo.util.derivatives import DifferentiableFlash\nfrom neqsim.thermodynamicoperations import ThermodynamicOperations\n\n@custom_vjp\ndef flash_density(T, P, z):\n    \"\"\"JAX-differentiable flash calculation returning density.\"\"\"\n    system = create_system(z)\n    system.setTemperature(float(T))\n    system.setPressure(float(P))\n\n    ops = ThermodynamicOperations(system)\n    ops.TPflash()\n\n    return system.getDensity(\"kg/m3\")\n\ndef flash_density_fwd(T, P, z):\n    \"\"\"Forward pass: compute density and cache gradients.\"\"\"\n    value = flash_density(T, P, z)\n\n    # Get analytical gradients from NeqSim\n    diff_flash = DifferentiableFlash(system)\n    grads = diff_flash.computePropertyGradient(\"density\")\n\n    return value, grads\n\ndef flash_density_bwd(grads, g):\n    \"\"\"Backward pass: use NeqSim's analytical gradients.\"\"\"\n    dT = g * grads.getDerivativeWrtTemperature()\n    dP = g * grads.getDerivativeWrtPressure()\n    dz = g * jnp.array(grads.getDerivativeWrtComposition())\n    return (dT, dP, dz)\n\nflash_density.defvjp(flash_density_fwd, flash_density_bwd)\n\n# Now you can use JAX's grad!\ngrad_fn = jax.grad(flash_density, argnums=(0, 1))\ndT, dP = grad_fn(300.0, 50.0, z)\n</code></pre>"},{"location":"simulation/differentiable_thermodynamics/#mathematical-background","title":"Mathematical Background","text":""},{"location":"simulation/differentiable_thermodynamics/#implicit-function-theorem","title":"Implicit Function Theorem","text":"<p>The key insight is that we don't need to differentiate through the iterative flash solver. At equilibrium, the residual equations \\(F(y; \\theta) = 0\\) are satisfied, where: - \\(y = (K_1, \\ldots, K_n, \\beta)\\) are solution variables - \\(\\theta = (T, P, z)\\) are parameters</p> <p>By the implicit function theorem:</p> \\[\\frac{dy}{d\\theta} = -\\left(\\frac{\\partial F}{\\partial y}\\right)^{-1} \\frac{\\partial F}{\\partial \\theta}\\] <p>This gives exact gradients at the converged solution.</p>"},{"location":"simulation/differentiable_thermodynamics/#equilibrium-equations","title":"Equilibrium Equations","text":"<p>For vapor-liquid equilibrium:</p> \\[F_i = \\ln K_i + \\ln \\phi_i^L - \\ln \\phi_i^V = 0 \\quad \\text{for } i = 1, \\ldots, n_c\\] \\[F_{n_c+1} = \\sum_i \\frac{z_i(K_i - 1)}{1 + \\beta(K_i - 1)} = 0 \\quad \\text{(Rachford-Rice)}\\]"},{"location":"simulation/differentiable_thermodynamics/#supported-properties","title":"Supported Properties","text":"Property Name Unit Density <code>\"density\"</code> kg/m\u00b3 Enthalpy <code>\"enthalpy\"</code> J/mol Entropy <code>\"entropy\"</code> J/mol/K Heat capacity <code>\"cp\"</code> J/mol/K Compressibility <code>\"compressibility\"</code> - Molar volume <code>\"molarvolume\"</code> m\u00b3/mol"},{"location":"simulation/differentiable_thermodynamics/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Gradient computation is O(n\u00b3) due to matrix inversion, where n is the number of components</li> <li>Cache results when computing multiple property gradients - the flash gradients only need to be computed once</li> <li>Use analytical gradients over finite differences when available - they're more accurate and often faster</li> <li>init(3) is called automatically by <code>computeFlashGradients()</code> to ensure fugacity derivatives are computed</li> </ol>"},{"location":"simulation/differentiable_thermodynamics/#validation","title":"Validation","text":"<p>The analytical gradients have been validated against numerical finite differences with excellent agreement (ratio \u2248 1.00) for: - K-value gradients (\u2202K/\u2202T, \u2202K/\u2202P) - Vapor fraction gradients (\u2202\u03b2/\u2202T, \u2202\u03b2/\u2202P) - Density gradients (\u2202\u03c1/\u2202T, \u2202\u03c1/\u2202P) - Heat capacity gradients (\u2202Cp/\u2202T, \u2202Cp/\u2202P)</p> <p>See <code>DifferentiableFlashTest.java</code> for validation tests.</p>"},{"location":"simulation/differentiable_thermodynamics/#see-also","title":"See Also","text":"<ul> <li>AI Platform Integration Guide for ML workflows</li> <li>MPC Integration Guide for model predictive control</li> </ul>"},{"location":"simulation/equipment_factory/","title":"Equipment factory usage","text":"<p>The <code>EquipmentFactory</code> provides a single entry-point for instantiating process equipment that can be automatically wired into a <code>ProcessSystem</code>. The factory supports every value listed in <code>EquipmentEnum</code>, including the energy storage and production classes (<code>WindTurbine</code>, <code>BatteryStorage</code>, and <code>SolarPanel</code>).</p>"},{"location":"simulation/equipment_factory/#basic-creation","title":"Basic creation","text":"<pre><code>ProcessEquipmentInterface pump = EquipmentFactory.createEquipment(\"pump1\", EquipmentEnum.Pump);\nProcessEquipmentInterface stream = EquipmentFactory.createEquipment(\"feed\", \"stream\");\n</code></pre> <p>The string based overload is tolerant of the common aliases that existed historically (for example <code>valve</code> and <code>separator_3phase</code>). Unknown identifiers now throw an exception instead of silently creating the wrong equipment.</p>"},{"location":"simulation/equipment_factory/#equipment-with-mandatory-collaborators","title":"Equipment with mandatory collaborators","text":"<p>Some equipment types cannot be instantiated without additional collaborators. The factory now prevents creation of partially initialised objects and exposes dedicated helpers instead:</p> <pre><code>StreamInterface motive = new Stream(\"motive\");\nStreamInterface suction = new Stream(\"suction\");\nEjector ejector = EquipmentFactory.createEjector(\"ej-1\", motive, suction);\n\nSystemInterface reservoirFluid = new SystemSrkEos(273.15, 100.0);\nReservoirCVDsim cvd = EquipmentFactory.createReservoirCVDsim(\"cvd\", reservoirFluid);\n</code></pre> <p>Attempting to create these units through the generic method now results in an informative exception message that points to the correct helper method.</p>"},{"location":"simulation/field_development_engine/","title":"Field Development Engine","text":"<p>The Field Development Engine is a rapid concept screening toolkit within NeqSim designed to accelerate early-phase field development decisions. It enables engineers to quickly evaluate multiple development concepts, comparing technical feasibility, economics, emissions, and safety aspects in hours rather than weeks.</p>"},{"location":"simulation/field_development_engine/#overview","title":"Overview","text":""},{"location":"simulation/field_development_engine/#purpose","title":"Purpose","text":"<p>Traditional field development concept screening involves: - Weeks of manual process simulation setup - Separate tools for flow assurance, economics, and emissions - Difficulty comparing many alternatives quickly - Inconsistent assumptions across studies</p> <p>The Field Development Engine addresses these challenges by providing: - Rapid Concept Definition: Builder-pattern APIs for defining reservoirs, wells, and infrastructure - Automated Facility Generation: Process blocks that auto-configure based on fluid properties - Integrated Screening: Flow assurance, safety, economics, and emissions in one workflow - Batch Evaluation: Run hundreds of concepts with sensitivity analysis</p>"},{"location":"simulation/field_development_engine/#architecture","title":"Architecture","text":"<p>The engine is organized into four packages:</p> <pre><code>neqsim.process.fielddevelopment\n\u251c\u2500\u2500 concept/       # Input data structures (reservoir, wells, infrastructure)\n\u251c\u2500\u2500 facility/      # Process block configuration and facility builder\n\u251c\u2500\u2500 screening/     # Technical screeners (flow assurance, safety, economics, emissions)\n\u2514\u2500\u2500 evaluation/    # Concept evaluation and batch processing\n</code></pre>"},{"location":"simulation/field_development_engine/#quick-start","title":"Quick Start","text":""},{"location":"simulation/field_development_engine/#basic-concept-definition","title":"Basic Concept Definition","text":"<pre><code>import neqsim.process.fielddevelopment.concept.*;\nimport neqsim.process.fielddevelopment.evaluation.*;\n\n// Define reservoir properties\nReservoirInput reservoir = ReservoirInput.builder()\n    .fluidType(FluidType.RICH_GAS)\n    .reservoirTempC(85.0)\n    .reservoirPressureBara(350.0)\n    .co2Percent(3.5)\n    .h2sPercent(0.0)\n    .waterCutPercent(5.0)\n    .gor(5000.0)  // Sm3/Sm3\n    .build();\n\n// Define well configuration\nWellsInput wells = WellsInput.builder()\n    .producerCount(4)\n    .injectorCount(2)\n    .ratePerWellSm3d(500000.0)  // 0.5 MSm3/d per well\n    .tubeheadPressure(120.0)    // bara\n    .build();\n\n// Define infrastructure\nInfrastructureInput infrastructure = InfrastructureInput.builder()\n    .processingLocation(ProcessingLocation.PLATFORM)\n    .exportType(ExportType.PIPELINE_GAS)\n    .tiebackLengthKm(25.0)\n    .waterDepthM(120.0)\n    .powerSource(PowerSource.GAS_TURBINE)\n    .build();\n\n// Create field concept\nFieldConcept concept = FieldConcept.builder()\n    .name(\"Platform Concept A\")\n    .reservoir(reservoir)\n    .wells(wells)\n    .infrastructure(infrastructure)\n    .build();\n</code></pre>"},{"location":"simulation/field_development_engine/#running-concept-evaluation","title":"Running Concept Evaluation","text":"<pre><code>// Create evaluator and run\nConceptEvaluator evaluator = new ConceptEvaluator();\nConceptKPIs kpis = evaluator.evaluate(concept);\n\n// Access results\nSystem.out.println(\"Flow Assurance: \" + kpis.getFlowAssuranceReport().getSummary());\nSystem.out.println(\"Total CAPEX: \" + kpis.getEconomicsReport().getTotalCapexMUSD() + \" MUSD\");\nSystem.out.println(\"CO2 Intensity: \" + kpis.getEmissionsReport().getCo2IntensityKgPerBoe() + \" kg/boe\");\nSystem.out.println(\"Safety Grade: \" + kpis.getSafetyReport().getOverallGrade());\n</code></pre>"},{"location":"simulation/field_development_engine/#detailed-usage","title":"Detailed Usage","text":""},{"location":"simulation/field_development_engine/#reservoir-input","title":"Reservoir Input","text":"<p>The <code>ReservoirInput</code> class captures fluid and reservoir properties:</p> Property Type Description <code>fluidType</code> <code>FluidType</code> LEAN_GAS, RICH_GAS, GAS_CONDENSATE, VOLATILE_OIL, BLACK_OIL, HEAVY_OIL <code>reservoirTempC</code> double Reservoir temperature (\u00b0C) <code>reservoirPressureBara</code> double Initial reservoir pressure (bara) <code>co2Percent</code> double CO2 content (mol%) <code>h2sPercent</code> double H2S content (mol%) <code>waterCutPercent</code> double Initial water cut (%) <code>gor</code> double Gas-oil ratio (Sm3/Sm3) <pre><code>// High CO2 gas field example\nReservoirInput highCO2Gas = ReservoirInput.builder()\n    .fluidType(FluidType.LEAN_GAS)\n    .reservoirTempC(95.0)\n    .reservoirPressureBara(400.0)\n    .co2Percent(15.0)  // High CO2 requiring removal\n    .h2sPercent(0.5)   // Some H2S\n    .waterCutPercent(0.0)\n    .gor(Double.POSITIVE_INFINITY)  // Dry gas\n    .build();\n</code></pre>"},{"location":"simulation/field_development_engine/#wells-input","title":"Wells Input","text":"<p>The <code>WellsInput</code> class defines well count and deliverability:</p> Property Type Description <code>producerCount</code> int Number of production wells <code>injectorCount</code> int Number of injection wells (water/gas) <code>ratePerWellSm3d</code> double Production rate per well (Sm3/d) <code>tubeheadPressure</code> double Wellhead pressure (bara) <pre><code>// High-rate gas wells\nWellsInput highRateGas = WellsInput.builder()\n    .producerCount(6)\n    .injectorCount(0)  // No injection\n    .ratePerWellSm3d(2000000.0)  // 2 MSm3/d per well\n    .tubeheadPressure(150.0)\n    .build();\n</code></pre>"},{"location":"simulation/field_development_engine/#infrastructure-input","title":"Infrastructure Input","text":"<p>The <code>InfrastructureInput</code> class defines facility type and export route:</p> Property Type Description <code>processingLocation</code> <code>ProcessingLocation</code> PLATFORM, FPSO, SUBSEA, ONSHORE <code>exportType</code> <code>ExportType</code> PIPELINE_GAS, PIPELINE_OIL, LNG, SHUTTLE_TANKER <code>tiebackLengthKm</code> double Distance to host/shore (km) <code>waterDepthM</code> double Water depth (m) <code>powerSource</code> <code>PowerSource</code> GAS_TURBINE, POWER_FROM_SHORE, HYBRID <pre><code>// Deep water FPSO with shuttle tanker\nInfrastructureInput deepwaterFPSO = InfrastructureInput.builder()\n    .processingLocation(ProcessingLocation.FPSO)\n    .exportType(ExportType.SHUTTLE_TANKER)\n    .tiebackLengthKm(5.0)  // Short subsea tieback to FPSO\n    .waterDepthM(1200.0)   // Deep water\n    .powerSource(PowerSource.GAS_TURBINE)\n    .build();\n</code></pre>"},{"location":"simulation/field_development_engine/#facility-configuration-optional","title":"Facility Configuration (Optional)","text":"<p>For more detailed estimates, you can define specific process blocks:</p> <pre><code>import neqsim.process.fielddevelopment.facility.*;\n\nFacilityConfig facility = FacilityBuilder.builder()\n    .addBlock(BlockConfig.of(BlockType.INLET_SEPARATION))\n    .addBlock(BlockConfig.of(BlockType.THREE_PHASE_SEPARATOR))\n    .addBlock(BlockConfig.of(BlockType.CO2_REMOVAL_AMINE)\n        .withParameter(\"capacity_mmscfd\", 200.0))\n    .addBlock(BlockConfig.of(BlockType.TEG_DEHYDRATION))\n    .addBlock(BlockConfig.of(BlockType.COMPRESSION)\n        .withParameter(\"stages\", 3))\n    .addBlock(BlockConfig.of(BlockType.FLARE_SYSTEM))\n    .build();\n\n// Use facility in evaluation\nConceptKPIs kpis = evaluator.evaluate(concept, facility);\n</code></pre>"},{"location":"simulation/field_development_engine/#available-block-types","title":"Available Block Types","text":"Block Type Description Typical CAPEX (MUSD) <code>INLET_SEPARATION</code> Inlet slug catcher/separator 20 <code>TWO_PHASE_SEPARATOR</code> Gas-liquid separation 20 <code>THREE_PHASE_SEPARATOR</code> Oil-water-gas separation 20 <code>COMPRESSION</code> Gas compression (per stage) 40 <code>TEG_DEHYDRATION</code> Glycol dehydration 35 <code>CO2_REMOVAL_AMINE</code> Amine-based CO2 removal 120 <code>CO2_REMOVAL_MEMBRANE</code> Membrane CO2 removal 80 <code>H2S_REMOVAL</code> Sulfur recovery/scavenging 60 <code>NGL_RECOVERY</code> NGL extraction 100 <code>OIL_STABILIZATION</code> Crude stabilization 30 <code>WATER_TREATMENT</code> Produced water treatment 25 <code>SUBSEA_BOOSTING</code> Subsea multiphase pumping 150 <code>POWER_GENERATION</code> Gas turbine power generation 100 <code>FLARE_SYSTEM</code> Emergency flare system 20"},{"location":"simulation/field_development_engine/#screening-reports","title":"Screening Reports","text":""},{"location":"simulation/field_development_engine/#flow-assurance-report","title":"Flow Assurance Report","text":"<p>Evaluates hydrate, wax, corrosion, and other flow assurance risks:</p> <pre><code>FlowAssuranceReport fa = kpis.getFlowAssuranceReport();\n\n// Check hydrate risk\nif (fa.getHydrateResult() == FlowAssuranceResult.FAIL) {\n    System.out.println(\"Hydrate formation temp: \" + fa.getHydrateFormationTemp() + \"\u00b0C\");\n    System.out.println(\"Margin to operating temp: \" + fa.getHydrateMargin() + \"\u00b0C\");\n}\n\n// Get mitigation recommendations\nfa.getRecommendations().forEach((category, recommendation) -&gt; {\n    System.out.println(category + \": \" + recommendation);\n});\n\n// Get mitigation options\nfa.getMitigationOptions().forEach((id, description) -&gt; {\n    System.out.println(\"  Option: \" + description);\n});\n</code></pre>"},{"location":"simulation/field_development_engine/#economics-report","title":"Economics Report","text":"<p>Provides CAPEX/OPEX estimates with \u00b140% accuracy (AACE Class 5):</p> <pre><code>EconomicsEstimator.EconomicsReport econ = kpis.getEconomicsReport();\n\nSystem.out.println(\"Total CAPEX: \" + econ.getTotalCapexMUSD() + \" MUSD\");\nSystem.out.println(\"  Range: \" + econ.getCapexLowMUSD() + \" - \" + econ.getCapexHighMUSD());\nSystem.out.println(\"Annual OPEX: \" + econ.getAnnualOpexMUSD() + \" MUSD/year\");\nSystem.out.println(\"CAPEX per boe: \" + econ.getCapexPerBoeUSD() + \" USD/boe\");\n\n// CAPEX breakdown\necon.getCapexBreakdown().forEach((category, cost) -&gt; {\n    System.out.println(\"  \" + category + \": \" + cost + \" MUSD\");\n});\n</code></pre>"},{"location":"simulation/field_development_engine/#emissions-report","title":"Emissions Report","text":"<p>Tracks CO2 emissions and intensity:</p> <pre><code>EmissionsTracker.EmissionsReport emissions = kpis.getEmissionsReport();\n\nSystem.out.println(\"Annual CO2: \" + emissions.getAnnualCO2TonnesPerYear() + \" tonnes/year\");\nSystem.out.println(\"CO2 Intensity: \" + emissions.getCo2IntensityKgPerBoe() + \" kg/boe\");\nSystem.out.println(\"Power Source: \" + emissions.getPowerSource());\n\n// Emissions breakdown\nemissions.getEmissionsBreakdown().forEach((source, tonnes) -&gt; {\n    System.out.println(\"  \" + source + \": \" + tonnes + \" tonnes/year\");\n});\n</code></pre>"},{"location":"simulation/field_development_engine/#safety-report","title":"Safety Report","text":"<p>Assesses safety considerations:</p> <pre><code>SafetyScreener.SafetyReport safety = kpis.getSafetyReport();\n\nSystem.out.println(\"Overall Grade: \" + safety.getOverallGrade());\nSystem.out.println(\"ESD Complexity: \" + safety.getEsdComplexity());\nSystem.out.println(\"Fire Protection Grade: \" + safety.getFireProtectionGrade());\nSystem.out.println(\"Manned Status: \" + (safety.isNormallyManned() ? \"Manned\" : \"Unmanned\"));\n\n// Safety recommendations\nsafety.getRecommendations().forEach(rec -&gt; {\n    System.out.println(\"  - \" + rec);\n});\n</code></pre>"},{"location":"simulation/field_development_engine/#batch-processing","title":"Batch Processing","text":""},{"location":"simulation/field_development_engine/#comparing-multiple-concepts","title":"Comparing Multiple Concepts","text":"<pre><code>import neqsim.process.fielddevelopment.evaluation.BatchConceptRunner;\n\n// Create multiple concepts\nList&lt;FieldConcept&gt; concepts = Arrays.asList(\n    createPlatformConcept(),\n    createFPSOConcept(),\n    createSubseaConcept()\n);\n\n// Run batch evaluation\nBatchConceptRunner runner = new BatchConceptRunner();\nMap&lt;String, ConceptKPIs&gt; results = runner.runAll(concepts);\n\n// Compare results\nresults.forEach((name, kpis) -&gt; {\n    System.out.printf(\"%s: CAPEX=%.0f MUSD, CO2=%.1f kg/boe%n\",\n        name,\n        kpis.getEconomicsReport().getTotalCapexMUSD(),\n        kpis.getEmissionsReport().getCo2IntensityKgPerBoe());\n});\n\n// Get ranked results\nList&lt;ConceptKPIs&gt; rankedByCAPEX = runner.rankBy(results, \n    kpis -&gt; kpis.getEconomicsReport().getTotalCapexMUSD());\n</code></pre>"},{"location":"simulation/field_development_engine/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<pre><code>// Create base concept\nFieldConcept baseConcept = createBaseConcept();\n\n// Define parameter ranges\ndouble[] waterDepths = {100, 300, 500, 800, 1200};\ndouble[] co2Levels = {2.0, 5.0, 10.0, 15.0};\n\n// Run sensitivities\nfor (double depth : waterDepths) {\n    for (double co2 : co2Levels) {\n        FieldConcept variant = baseConcept.toBuilder()\n            .infrastructure(baseConcept.getInfrastructure().toBuilder()\n                .waterDepthM(depth)\n                .build())\n            .reservoir(baseConcept.getReservoir().toBuilder()\n                .co2Percent(co2)\n                .build())\n            .name(\"Depth=\" + depth + \"m, CO2=\" + co2 + \"%\")\n            .build();\n\n        ConceptKPIs kpis = evaluator.evaluate(variant);\n        // Store/analyze results...\n    }\n}\n</code></pre>"},{"location":"simulation/field_development_engine/#integration-with-neqsim-process-simulation","title":"Integration with NeqSim Process Simulation","text":"<p>The Field Development Engine integrates with NeqSim's full process simulation capabilities:</p> <pre><code>import neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.equipment.stream.Stream;\n\n// Generate facility from concept\nFacilityBuilder facilityBuilder = new FacilityBuilder();\nProcessSystem processSystem = facilityBuilder.buildProcessSystem(concept);\n\n// Run detailed simulation\nprocessSystem.run();\n\n// Access detailed results\nStream exportStream = (Stream) processSystem.getUnit(\"export\");\ndouble exportRate = exportStream.getFlowRate(\"MSm3/day\");\ndouble exportPressure = exportStream.getPressure(\"bara\");\n</code></pre>"},{"location":"simulation/field_development_engine/#cost-estimation-methodology","title":"Cost Estimation Methodology","text":""},{"location":"simulation/field_development_engine/#capex-basis","title":"CAPEX Basis","text":"<p>The economics estimator uses screening-level cost factors:</p> Category Basis Notes Platform 400 MUSD base Adjusted for water depth FPSO 800 MUSD base Adjusted for water depth Subsea template 100 MUSD each Per wellhead cluster Platform wells 50 MUSD each Includes completions Subsea wells 100 MUSD each Includes trees and controls Pipeline 2 MUSD/km Varies with diameter Umbilical 1.5 MUSD/km For subsea systems"},{"location":"simulation/field_development_engine/#depth-factor","title":"Depth Factor","text":"<p>Water depth increases costs according to: <pre><code>depthFactor = 1.0 + (waterDepth / 500m) \u00d7 0.5\n</code></pre></p> <p>For example: - 100m depth: factor = 1.1 - 500m depth: factor = 1.5 - 1000m depth: factor = 2.0</p>"},{"location":"simulation/field_development_engine/#accuracy","title":"Accuracy","text":"<p>All cost estimates carry \u00b140% accuracy (AACE Class 5), appropriate for: - Concept screening - Alternative comparison - Order-of-magnitude budgeting</p> <p>For FEED-level estimates (\u00b120%), use detailed process simulation and vendor quotes.</p>"},{"location":"simulation/field_development_engine/#emissions-methodology","title":"Emissions Methodology","text":""},{"location":"simulation/field_development_engine/#sources-tracked","title":"Sources Tracked","text":"<ol> <li>Fuel gas combustion: Based on power demand and turbine efficiency</li> <li>Flaring: Calculated from upset/safety flaring estimates</li> <li>Fugitive emissions: 0.01% of hydrocarbon throughput (industry typical)</li> <li>Venting: Based on process configuration</li> </ol>"},{"location":"simulation/field_development_engine/#co2-intensity-calculation","title":"CO2 Intensity Calculation","text":"<pre><code>CO2 Intensity (kg/boe) = Annual CO2 (tonnes) \u00d7 1000 / Annual Production (boe)\n</code></pre>"},{"location":"simulation/field_development_engine/#power-source-impact","title":"Power Source Impact","text":"Power Source Emission Factor Gas turbine ~50 kg CO2/MWh (depends on efficiency) Power from shore 50 kg CO2/MWh (Norwegian grid) Hybrid Weighted average"},{"location":"simulation/field_development_engine/#best-practices","title":"Best Practices","text":""},{"location":"simulation/field_development_engine/#1-start-simple","title":"1. Start Simple","text":"<p>Begin with basic concept definition and add detail as needed:</p> <pre><code>// Minimal concept for initial screening\nFieldConcept simple = FieldConcept.builder()\n    .name(\"Quick Screen\")\n    .reservoir(ReservoirInput.builder()\n        .fluidType(FluidType.LEAN_GAS)\n        .co2Percent(5.0)\n        .build())\n    .build();\n\nConceptKPIs kpis = evaluator.quickEvaluate(simple);\n</code></pre>"},{"location":"simulation/field_development_engine/#2-use-consistent-assumptions","title":"2. Use Consistent Assumptions","text":"<p>When comparing concepts, ensure consistent: - Reservoir properties (same fluid for all concepts) - Economic assumptions (same cost year basis) - Operating philosophy (same manning assumptions)</p>"},{"location":"simulation/field_development_engine/#3-document-deviations","title":"3. Document Deviations","text":"<p>Track any manual overrides or custom assumptions:</p> <pre><code>FieldConcept concept = FieldConcept.builder()\n    .name(\"Concept A - Modified\")\n    .description(\"Base case with reduced compression due to high reservoir pressure\")\n    // ... other properties\n    .build();\n</code></pre>"},{"location":"simulation/field_development_engine/#4-validate-against-benchmarks","title":"4. Validate Against Benchmarks","text":"<p>Compare screening results against: - Recent project sanctions in similar environments - Industry cost databases (IHS, Wood Mackenzie) - Operator internal benchmarks</p>"},{"location":"simulation/field_development_engine/#troubleshooting","title":"Troubleshooting","text":""},{"location":"simulation/field_development_engine/#common-issues","title":"Common Issues","text":"<p>1. \"Table COMP not found\" error</p> <p>Ensure the thermodynamic system has database initialized: <pre><code>fluid.setMixingRule(\"classic\");\nfluid.createDatabase(true);  // Required!\n</code></pre></p> <p>2. Hydrate calculation fails</p> <p>This typically occurs with unusual compositions. The screener falls back to correlation-based estimates and flags for detailed analysis.</p> <p>3. Negative margins in flow assurance</p> <p>A negative margin indicates operating conditions are within the risk envelope. This is flagged as FAIL with mandatory mitigation.</p>"},{"location":"simulation/field_development_engine/#debug-mode","title":"Debug Mode","text":"<p>Enable detailed logging for troubleshooting:</p> <pre><code>// Set log level for field development package\nLogger logger = LogManager.getLogger(\"neqsim.process.fielddevelopment\");\nConfigurator.setLevel(logger.getName(), Level.DEBUG);\n</code></pre>"},{"location":"simulation/field_development_engine/#api-reference","title":"API Reference","text":""},{"location":"simulation/field_development_engine/#package-neqsimprocessfielddevelopmentconcept","title":"Package: <code>neqsim.process.fielddevelopment.concept</code>","text":"Class Description <code>FieldConcept</code> Main concept container with reservoir, wells, infrastructure <code>ReservoirInput</code> Fluid and reservoir properties <code>WellsInput</code> Well count and deliverability <code>InfrastructureInput</code> Facility type and export route"},{"location":"simulation/field_development_engine/#package-neqsimprocessfielddevelopmentfacility","title":"Package: <code>neqsim.process.fielddevelopment.facility</code>","text":"Class Description <code>FacilityBuilder</code> Constructs facility configurations <code>FacilityConfig</code> Immutable facility configuration <code>BlockConfig</code> Individual process block configuration <code>BlockType</code> Enumeration of available process blocks"},{"location":"simulation/field_development_engine/#package-neqsimprocessfielddevelopmentscreening","title":"Package: <code>neqsim.process.fielddevelopment.screening</code>","text":"Class Description <code>FlowAssuranceScreener</code> Hydrate, wax, corrosion screening <code>FlowAssuranceReport</code> Flow assurance results and recommendations <code>FlowAssuranceResult</code> PASS/MARGINAL/FAIL classification <code>EconomicsEstimator</code> CAPEX/OPEX estimation <code>EmissionsTracker</code> CO2 emissions calculation <code>SafetyScreener</code> Safety assessment"},{"location":"simulation/field_development_engine/#package-neqsimprocessfielddevelopmentevaluation","title":"Package: <code>neqsim.process.fielddevelopment.evaluation</code>","text":"Class Description <code>ConceptEvaluator</code> Main evaluation orchestrator <code>ConceptKPIs</code> Aggregated KPIs from all screeners <code>BatchConceptRunner</code> Parallel batch processing"},{"location":"simulation/field_development_engine/#version-history","title":"Version History","text":"Version Date Changes 1.0 2025-12 Initial release with core screening capabilities"},{"location":"simulation/field_development_engine/#references","title":"References","text":"<ul> <li>AACE International Recommended Practice No. 18R-97: Cost Estimate Classification System</li> <li>NORSOK P-002: Process System Design</li> <li>NACE MR0175/ISO 15156: Materials for Sour Service</li> <li>API RP 14C: Recommended Practice for Analysis, Design, Installation, and Testing of Safety Systems</li> </ul>"},{"location":"simulation/field_development_engine/#contributing","title":"Contributing","text":"<p>See CONTRIBUTING.md for guidelines on contributing to the Field Development Engine.</p> <p>For questions or feature requests, open an issue on the NeqSim GitHub repository.</p>"},{"location":"simulation/graph_based_process_simulation/","title":"Graph-Based Process Simulation in NeqSim","text":""},{"location":"simulation/graph_based_process_simulation/#overview","title":"Overview","text":"<p>NeqSim now supports graph-based process representation, enabling topology-aware simulation execution, automatic parallelization, and advanced analysis of process flowsheets. This document explains the theory, demonstrates all functionality, and compares the new approach with traditional sequential execution.</p>"},{"location":"simulation/graph_based_process_simulation/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Theory and Motivation</li> <li>Core Components</li> <li>Basic Usage</li> <li>Parallel Execution</li> <li>Cycle and Recycle Detection</li> <li>Sensitivity-Based Tear Stream Selection</li> <li>Process Sensitivity Analysis</li> <li>Comparison: Old vs New Approach</li> <li>API Reference</li> <li>Best Practices</li> </ol>"},{"location":"simulation/graph_based_process_simulation/#theory-and-motivation","title":"Theory and Motivation","text":""},{"location":"simulation/graph_based_process_simulation/#process-flowsheets-as-directed-graphs","title":"Process Flowsheets as Directed Graphs","text":"<p>A chemical process flowsheet is naturally represented as a directed graph (digraph) where:</p> <ul> <li>Nodes represent unit operations (streams, heaters, separators, compressors, etc.)</li> <li>Edges represent material/energy flow connections between units</li> </ul> <pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502  Feed   \u2502\n        \u2502 Stream  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 Heater  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502Separator\u251c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502Gas Out  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502Liquid   \u2502\n        \u2502 Out     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#why-graph-representation","title":"Why Graph Representation?","text":"<p>Traditional process simulators execute equipment in insertion order - the order in which units were added to the flowsheet. This has limitations:</p> <ol> <li>No dependency awareness: If equipment B depends on A's output, but A was added after B, simulation may fail or produce incorrect results</li> <li>No parallelization: All units execute sequentially even when independent</li> <li>No structural analysis: Cannot automatically detect recycle loops, independent branches, or optimal execution paths</li> </ol> <p>Graph-based representation solves these problems by:</p> <ol> <li>Automatic dependency resolution via topological sorting</li> <li>Parallel execution of independent equipment</li> <li>Cycle detection for recycle loop identification</li> <li>Structural validation before simulation</li> </ol>"},{"location":"simulation/graph_based_process_simulation/#mathematical-foundation","title":"Mathematical Foundation","text":""},{"location":"simulation/graph_based_process_simulation/#topological-sorting-kahns-algorithm","title":"Topological Sorting (Kahn's Algorithm)","text":"<p>For a Directed Acyclic Graph (DAG), topological sort produces an ordering where for every edge \\((u, v)\\), node \\(u\\) appears before \\(v\\). This ensures all inputs are available before a unit executes.</p> <p>Algorithm complexity: \\(O(V + E)\\) where \\(V\\) = nodes, \\(E\\) = edges</p>"},{"location":"simulation/graph_based_process_simulation/#strongly-connected-components-tarjans-algorithm","title":"Strongly Connected Components (Tarjan's Algorithm)","text":"<p>SCCs identify groups of nodes that form cycles (recycle loops). In process terms, an SCC with more than one node indicates a recycle that requires iterative convergence.</p> <p>Algorithm complexity: \\(O(V + E)\\)</p>"},{"location":"simulation/graph_based_process_simulation/#parallel-partitioning-longest-path","title":"Parallel Partitioning (Longest Path)","text":"<p>Equipment is grouped into levels based on the longest path from any source node. Units at the same level have no dependencies on each other and can execute in parallel.</p> <pre><code>Level 0: [feed1, feed2, feed3]     \u2190 All independent, run in parallel\nLevel 1: [heater1, heater2, heater3]  \u2190 Depend only on Level 0\nLevel 2: [sep1, sep2, sep3]        \u2190 Depend only on Level 1\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#core-components","title":"Core Components","text":""},{"location":"simulation/graph_based_process_simulation/#processgraph","title":"ProcessGraph","text":"<p>The main graph data structure containing nodes and edges.</p> <pre><code>ProcessGraph graph = process.buildGraph();\n\n// Get basic info\nint nodeCount = graph.getNodeCount();\nint edgeCount = graph.getEdgeCount();\n\n// Get calculation order\nList&lt;ProcessEquipmentInterface&gt; order = graph.getCalculationOrder();\n\n// Check for cycles\nboolean hasCycles = graph.hasCycles();\n\n// Get summary\nSystem.out.println(graph.getSummary());\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#processnode","title":"ProcessNode","text":"<p>Represents a unit operation in the graph.</p> <pre><code>ProcessNode node = graph.getNode(heater);\n\n// Check connectivity\nboolean isSource = node.isSource();  // No incoming edges (e.g., feed stream)\nboolean isSink = node.isSink();      // No outgoing edges (e.g., product)\n\n// Get connections\nList&lt;ProcessEdge&gt; incoming = node.getIncomingEdges();\nList&lt;ProcessEdge&gt; outgoing = node.getOutgoingEdges();\n\n// Get feature vector (for ML/GNN applications)\ndouble[] features = node.getFeatureVector(typeMapping, numTypes);\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#processedge","title":"ProcessEdge","text":"<p>Represents a stream connection between units.</p> <pre><code>ProcessEdge edge = graph.getEdge(stream);\n\nProcessNode source = edge.getSource();\nProcessNode target = edge.getTarget();\nboolean isBackEdge = edge.isBackEdge();  // Part of a recycle loop\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#processgraphbuilder","title":"ProcessGraphBuilder","text":"<p>Automatically constructs the graph by analyzing stream connections.</p> <pre><code>// Automatic construction\nProcessGraph graph = ProcessGraphBuilder.buildGraph(processSystem);\n\n// Or via ProcessSystem convenience method\nProcessGraph graph = process.buildGraph();\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#supported-equipment-types","title":"Supported Equipment Types","text":"<p>The <code>ProcessGraphBuilder</code> automatically detects stream connections for the following equipment:</p> Category Equipment Outlets Detected Two-Port Stream, Heater, Cooler, Pump, Compressor, Valve, etc. Single outlet Separators Separator Gas + liquid outlets ThreePhaseSeparator Gas + oil + aqueous outlets Mixers/Splitters Mixer Single outlet Splitter Multiple split streams Manifold Multiple outlets (N\u2192M routing) Heat Exchange HeatExchanger Both hot/cold side outlets MultiStreamHeatExchanger All stream outlets Turbomachinery TurboExpanderCompressor Expander + compressor outlets Columns DistillationColumn Condenser + reboiler outlets"},{"location":"simulation/graph_based_process_simulation/#basic-usage","title":"Basic Usage","text":""},{"location":"simulation/graph_based_process_simulation/#example-1-simple-linear-process","title":"Example 1: Simple Linear Process","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.heatexchanger.Heater;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create fluid\nSystemInterface fluid = new SystemSrkEos(298.0, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// Build process\nProcessSystem process = new ProcessSystem(\"Simple Process\");\n\nStream feed = new Stream(\"feed\", fluid);\nfeed.setFlowRate(10000, \"kg/hr\");\nfeed.setTemperature(25.0, \"C\");\nfeed.setPressure(50.0, \"bara\");\nprocess.add(feed);\n\nHeater heater = new Heater(\"heater\", feed);\nheater.setOutTemperature(350.0);\nprocess.add(heater);\n\nSeparator separator = new Separator(\"separator\", heater.getOutletStream());\nprocess.add(separator);\n\n// Build and analyze graph\nProcessGraph graph = process.buildGraph();\n\nSystem.out.println(\"=== Graph Analysis ===\");\nSystem.out.println(\"Nodes: \" + graph.getNodeCount());\nSystem.out.println(\"Edges: \" + graph.getEdgeCount());\nSystem.out.println(\"Has cycles: \" + graph.hasCycles());\nSystem.out.println();\n\n// Get topological order\nSystem.out.println(\"Calculation Order:\");\nfor (ProcessEquipmentInterface unit : graph.getCalculationOrder()) {\n    System.out.println(\"  \" + unit.getName());\n}\n\n// Run with graph-based execution\nprocess.setUseGraphBasedExecution(true);\nprocess.run();\n</code></pre> <p>Output: <pre><code>=== Graph Analysis ===\nNodes: 3\nEdges: 2\nHas cycles: false\n\nCalculation Order:\n  feed\n  heater\n  separator\n</code></pre></p>"},{"location":"simulation/graph_based_process_simulation/#example-2-process-with-splitter-and-mixer","title":"Example 2: Process with Splitter and Mixer","text":"<pre><code>ProcessSystem process = new ProcessSystem(\"Split-Mix Process\");\n\n// Feed\nStream feed = new Stream(\"feed\", fluid.clone());\nfeed.setFlowRate(10000, \"kg/hr\");\nprocess.add(feed);\n\n// Split into two branches\nSplitter splitter = new Splitter(\"splitter\", feed);\nsplitter.setSplitFactors(new double[] {0.6, 0.4});\nprocess.add(splitter);\n\n// Branch 1: Heat\nHeater heater = new Heater(\"heater\", splitter.getSplitStream(0));\nheater.setOutTemperature(350.0);\nprocess.add(heater);\n\n// Branch 2: Cool\nCooler cooler = new Cooler(\"cooler\", splitter.getSplitStream(1));\ncooler.setOutTemperature(280.0);\nprocess.add(cooler);\n\n// Merge branches\nMixer mixer = new Mixer(\"mixer\");\nmixer.addStream(heater.getOutletStream());\nmixer.addStream(cooler.getOutletStream());\nprocess.add(mixer);\n\n// Final separation\nSeparator separator = new Separator(\"separator\", mixer.getOutletStream());\nprocess.add(separator);\n\n// Analyze graph structure\nProcessGraph graph = process.buildGraph();\nProcessGraph.ParallelPartition partition = graph.partitionForParallelExecution();\n\nSystem.out.println(\"Parallel Levels: \" + partition.getLevelCount());\nSystem.out.println(\"Max Parallelism: \" + partition.getMaxParallelism());\n\nfor (int i = 0; i &lt; partition.getLevelCount(); i++) {\n    System.out.print(\"Level \" + i + \": \");\n    for (ProcessNode node : partition.getLevels().get(i)) {\n        System.out.print(node.getName() + \" \");\n    }\n    System.out.println();\n}\n</code></pre> <p>Output: <pre><code>Parallel Levels: 5\nMax Parallelism: 2\n\nLevel 0: feed\nLevel 1: splitter\nLevel 2: heater cooler     \u2190 These can run in parallel!\nLevel 3: mixer\nLevel 4: separator\n</code></pre></p>"},{"location":"simulation/graph_based_process_simulation/#parallel-execution","title":"Parallel Execution","text":""},{"location":"simulation/graph_based_process_simulation/#automatic-parallel-execution","title":"Automatic Parallel Execution","text":"<p>For processes with independent branches, NeqSim can automatically execute units in parallel:</p> <pre><code>// Create process with multiple independent branches\nProcessSystem process = new ProcessSystem(\"Parallel Process\");\n\n// Add 4 independent processing trains\nfor (int i = 1; i &lt;= 4; i++) {\n    SystemInterface fluid = new SystemSrkEos(298.0, 50.0);\n    fluid.addComponent(\"methane\", 0.90);\n    fluid.addComponent(\"ethane\", 0.10);\n    fluid.setMixingRule(\"classic\");\n\n    Stream feed = new Stream(\"feed\" + i, fluid);\n    feed.setFlowRate(5000, \"kg/hr\");\n    process.add(feed);\n\n    Heater heater = new Heater(\"heater\" + i, feed);\n    heater.setOutTemperature(350.0);\n    process.add(heater);\n\n    Separator sep = new Separator(\"separator\" + i, heater.getOutletStream());\n    process.add(sep);\n}\n\n// Check parallelization potential\nSystem.out.println(\"Units: \" + process.getUnitOperations().size());\nSystem.out.println(\"Parallel beneficial: \" + process.isParallelExecutionBeneficial());\nSystem.out.println(\"Max parallelism: \" + process.getParallelPartition().getMaxParallelism());\n\n// Run with automatic parallel execution\nprocess.runParallel();  // Explicit parallel\n// or\nprocess.runOptimal();   // Auto-selects best strategy\n</code></pre> <p>Output: <pre><code>Units: 12\nParallel beneficial: true\nMax parallelism: 4\n\nParallel Levels:\n  Level 0: feed1 feed2 feed3 feed4        \u2190 4 parallel\n  Level 1: heater1 heater2 heater3 heater4  \u2190 4 parallel\n  Level 2: separator1 separator2 separator3 separator4  \u2190 4 parallel\n</code></pre></p>"},{"location":"simulation/graph_based_process_simulation/#execution-methods-comparison","title":"Execution Methods Comparison","text":"Method Description Use Case <code>run()</code> Sequential execution (insertion or topological order) Standard simulation <code>runParallel()</code> Parallel execution using thread pool Feed-forward processes with independent branches <code>runOptimal()</code> Auto-selects parallel or sequential General use - best of both worlds"},{"location":"simulation/graph_based_process_simulation/#when-parallel-execution-is-used","title":"When Parallel Execution is Used","text":"<p><code>runOptimal()</code> uses parallel execution when:</p> <pre><code>process.isParallelExecutionBeneficial()\n</code></pre> <p>Returns <code>true</code> if: - Process has \u2265 4 units (to justify thread overhead) - No Recycle units (require iterative convergence) - No Adjuster units (require iterative convergence) - Max parallelism \u2265 2 (something to parallelize)</p>"},{"location":"simulation/graph_based_process_simulation/#cycle-and-recycle-detection","title":"Cycle and Recycle Detection","text":""},{"location":"simulation/graph_based_process_simulation/#detecting-recycle-loops","title":"Detecting Recycle Loops","text":"<p>Recycle loops appear as cycles in the process graph. NeqSim uses Tarjan's SCC algorithm to detect them:</p> <pre><code>ProcessSystem process = new ProcessSystem(\"Recycle Process\");\n\n// ... add equipment with recycle ...\n\nProcessGraph graph = process.buildGraph();\n\n// Check for cycles\nProcessGraph.CycleAnalysisResult cycles = graph.analyzeCycles();\nSystem.out.println(\"Has cycles: \" + cycles.hasCycles());\nSystem.out.println(\"Cycle count: \" + cycles.getCycleCount());\nSystem.out.println(\"Back edges: \" + cycles.getBackEdges().size());\n\n// Find strongly connected components (recycle blocks)\nProcessGraph.SCCResult scc = graph.findStronglyConnectedComponents();\nSystem.out.println(\"SCCs: \" + scc.getComponentCount());\n\nfor (List&lt;ProcessNode&gt; component : scc.getRecycleLoops()) {\n    System.out.print(\"Recycle loop: \");\n    for (ProcessNode node : component) {\n        System.out.print(node.getName() + \" \");\n    }\n    System.out.println();\n}\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#recycle-block-report","title":"Recycle Block Report","text":"<pre><code>String report = process.getRecycleBlockReport();\nSystem.out.println(report);\n</code></pre> <p>Example Output: <pre><code>=== Recycle Block Analysis ===\nTotal SCCs: 5\nRecycle loops (SCCs with &gt;1 node): 1\n\nRecycle Block 1 (3 nodes):\n  - mixer\n  - heater\n  - separator\n  Back edges forming this loop:\n    - recycle_stream (separator -&gt; mixer)\n==============================\n</code></pre></p>"},{"location":"simulation/graph_based_process_simulation/#sensitivity-based-tear-stream-selection","title":"Sensitivity-Based Tear Stream Selection","text":""},{"location":"simulation/graph_based_process_simulation/#concept","title":"Concept","text":"<p>In process simulation with recycle loops, the choice of tear stream (where to break the loop for iterative solving) significantly affects convergence speed. The graph-based approach enables automatic sensitivity analysis to select optimal tear streams.</p>"},{"location":"simulation/graph_based_process_simulation/#sensitivity-metric","title":"Sensitivity Metric","text":"<p>The sensitivity of a stream as a tear point is calculated based on:</p> <ol> <li>Path Length Factor - Streams further from the recycle unit are less sensitive</li> <li>Equipment Type Weight - Different equipment types affect sensitivity differently:</li> <li>Separators: 1.5\u00d7 (phase separation amplifies perturbations)</li> <li>Heat exchangers: 1.3\u00d7 (temperature changes propagate)</li> <li>Compressors: 1.2\u00d7 (pressure-flow coupling)</li> <li>Standard equipment: 1.0\u00d7</li> <li>Branching Factor - Streams feeding multiple downstream units have higher sensitivity</li> </ol> <p>Formula: $\\(\\text{sensitivity} = \\frac{\\text{path length factor} \\times \\text{equipment weight}}{\\text{branching factor}}\\)$</p> <p>Lower sensitivity = Better tear stream (more stable convergence)</p>"},{"location":"simulation/graph_based_process_simulation/#usage","title":"Usage","text":"<pre><code>// Build process graph\nProcessGraph graph = process.buildGraph();\n\n// Analyze sensitivity for all recycle loops\nList&lt;SensitivityAnalysisResult&gt; results = graph.analyzeTearStreamSensitivity();\n\nfor (SensitivityAnalysisResult result : results) {\n    System.out.println(\"Loop with \" + result.getLoopNodes().size() + \" nodes\");\n    System.out.println(\"Best tear stream: \" + result.getRecommendedTearStream());\n    System.out.println(\"Sensitivity: \" + result.getSensitivity());\n}\n\n// Get formatted report\nSystem.out.println(graph.getSensitivityAnalysisReport());\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#example-output","title":"Example Output","text":"<pre><code>=== Tear Stream Sensitivity Analysis ===\nRecycle Loop 1 (10 nodes):\n  Nodes: Main Recycle -&gt; JT Valve -&gt; Gas Splitter -&gt; HP Separator -&gt; ...\n  Tear stream candidates (ranked by sensitivity):\n    1. Recycle Gas -&gt; Feed Mixer [sensitivity=0.2711] (marked as recycle)\n    2. JT Valve -&gt; Recycle [sensitivity=0.3587] (marked as recycle)\n    3. Gas Splitter -&gt; JT Valve [sensitivity=0.5857]\n    4. HP Separator -&gt; Gas Splitter [sensitivity=0.7174]\n    ...\n  Recommended tear: Recycle Gas\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#automatic-selection","title":"Automatic Selection","text":"<pre><code>// Automatically select optimal tear streams for all loops\nMap&lt;Integer, ProcessEdge&gt; optimalTears = graph.selectTearStreamsWithSensitivity();\n\nfor (Map.Entry&lt;Integer, ProcessEdge&gt; entry : optimalTears.entrySet()) {\n    System.out.println(\"Loop \" + entry.getKey() + \": Tear at \" + \n                       entry.getValue().getSource().getName() + \" -&gt; \" +\n                       entry.getValue().getTarget().getName());\n}\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#benefits","title":"Benefits","text":"<ul> <li>Faster convergence: Lower sensitivity tears require fewer iterations</li> <li>Better stability: Less sensitive streams are more tolerant of perturbations</li> <li>Automatic: No manual tear stream selection required</li> <li>Diagnostic: Helps understand process coupling</li> </ul>"},{"location":"simulation/graph_based_process_simulation/#process-sensitivity-analysis","title":"Process Sensitivity Analysis","text":"<p>The <code>ProcessSensitivityAnalyzer</code> provides comprehensive sensitivity analysis for any process, computing how output properties change with respect to input properties.</p>"},{"location":"simulation/graph_based_process_simulation/#fluent-api","title":"Fluent API","text":"<pre><code>ProcessSensitivityAnalyzer analyzer = new ProcessSensitivityAnalyzer(process);\n\nSensitivityMatrix result = analyzer\n    .withInput(\"feed\", \"temperature\", \"C\")\n    .withInput(\"feed\", \"pressure\", \"bara\")\n    .withInput(\"feed\", \"flowRate\", \"kg/hr\")\n    .withOutput(\"separator\", \"temperature\")\n    .withOutput(\"compressor\", \"power\", \"kW\")\n    .compute();\n\n// Query individual sensitivities\ndouble dT_dP = result.getSensitivity(\"separator.temperature\", \"feed.pressure\");\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#integration-with-broyden-convergence","title":"Integration with Broyden Convergence","text":"<p>When a process has recycles using Broyden acceleration, the analyzer automatically reuses the convergence Jacobian for tear stream sensitivities - this is essentially free!</p> <pre><code>// Run process with Broyden acceleration\nrecycle.setAccelerationMethod(AccelerationMethod.BROYDEN);\nprocess.run();\n\n// Analyzer checks for Broyden Jacobian first\nSensitivityMatrix result = analyzer\n    .withInput(\"recycle1\", \"temperature\")\n    .withOutput(\"recycle1\", \"pressure\")\n    .compute();  // Uses Broyden Jacobian if available, else FD\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#finite-difference-options","title":"Finite Difference Options","text":"<pre><code>// Forward differences (default): 1 extra simulation per input\nanalyzer.withCentralDifferences(false);\n\n// Central differences: 2 extra simulations per input, more accurate\nanalyzer.withCentralDifferences(true);\n\n// Custom perturbation size (default: 0.001 = 0.1%)\nanalyzer.withPerturbation(0.01);\n\n// Force finite differences only (ignore Broyden)\nSensitivityMatrix fdResult = analyzer.computeFiniteDifferencesOnly();\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#report-generation","title":"Report Generation","text":"<pre><code>String report = analyzer.generateReport(result);\nSystem.out.println(report);\n</code></pre> <p>Output: <pre><code>=== Process Sensitivity Analysis Report ===\n\nInputs:\n  - feed.temperature [C]\n  - feed.pressure [bara]\n\nOutputs:\n  - separator.temperature\n  - compressor.power [kW]\n\nSensitivity Matrix (d_output / d_input):\n\n                                    temperature        pressure\n        separator.temperature        1.0000e+00      -2.3400e-02\n           compressor.power          4.5600e+01       1.2300e+02\n\nMost Influential Inputs:\n  separator.temperature: feed.temperature (sensitivity: 1.0000e+00)\n  compressor.power: feed.pressure (sensitivity: 1.2300e+02)\n</code></pre></p>"},{"location":"simulation/graph_based_process_simulation/#use-cases","title":"Use Cases","text":"<ol> <li>Design Optimization: Identify which inputs most affect key outputs</li> <li>Uncertainty Propagation: Combine with input uncertainties for output bounds</li> <li>Control System Design: Understand input-output relationships</li> <li>Model Validation: Compare sensitivities against expected physics</li> </ol>"},{"location":"simulation/graph_based_process_simulation/#comparison-old-vs-new-approach","title":"Comparison: Old vs New Approach","text":""},{"location":"simulation/graph_based_process_simulation/#traditional-sequential-execution-old","title":"Traditional Sequential Execution (Old)","text":"<pre><code>ProcessSystem process = new ProcessSystem();\nprocess.add(feed);\nprocess.add(heater);\nprocess.add(separator);\nprocess.run();  // Executes in insertion order\n</code></pre> <p>Characteristics: - Units execute in the order they were added - No awareness of dependencies - No parallelization - Simple implementation</p>"},{"location":"simulation/graph_based_process_simulation/#graph-based-execution-new","title":"Graph-Based Execution (New)","text":"<pre><code>ProcessSystem process = new ProcessSystem();\nprocess.add(heater);      // Added first, but depends on feed\nprocess.add(separator);   // Added second\nprocess.add(feed);        // Added last, but should run first!\n\nprocess.setUseGraphBasedExecution(true);\nprocess.run();  // Executes: feed \u2192 heater \u2192 separator (correct order!)\n</code></pre> <p>Characteristics: - Units execute in topologically sorted order - Dependency-aware - Supports parallelization - More complex implementation</p>"},{"location":"simulation/graph_based_process_simulation/#performance-comparison","title":"Performance Comparison","text":"Aspect Sequential Graph-Based Graph + Parallel Dependency handling Manual ordering required Automatic Automatic Parallel execution No No Yes Recycle detection Manual Automatic Automatic Overhead Minimal Graph build ~0.5ms Graph build + thread mgmt Best for Simple linear processes Complex dependencies Multi-train processes"},{"location":"simulation/graph_based_process_simulation/#benchmark-results","title":"Benchmark Results","text":"<pre><code>=== Performance Benchmark (12 units, 4 parallel branches) ===\nSequential execution:    2.83 ms\nGraph-based sequential:  2.76 ms  (3% faster due to optimal ordering)\nGraph-based parallel:    2.06 ms  (27% faster due to parallelism)\nSpeedup from parallel:   1.38x\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#pros-and-cons","title":"Pros and Cons","text":""},{"location":"simulation/graph_based_process_simulation/#sequential-execution-traditional","title":"Sequential Execution (Traditional)","text":"<p>Pros: - \u2705 Simple and predictable - \u2705 Minimal overhead - \u2705 Works for all process types including recycles - \u2705 Easy to debug (clear execution order)</p> <p>Cons: - \u274c Requires careful manual ordering of equipment - \u274c No parallelization benefits - \u274c No automatic structural validation - \u274c Cannot detect configuration errors (wrong connections)</p>"},{"location":"simulation/graph_based_process_simulation/#graph-based-execution","title":"Graph-Based Execution","text":"<p>Pros: - \u2705 Automatic dependency resolution - \u2705 Order-independent equipment addition - \u2705 Structural validation (detect disconnected units) - \u2705 Enables parallel execution - \u2705 Automatic recycle loop detection - \u2705 Foundation for advanced analysis (optimization, ML)</p> <p>Cons: - \u274c Small overhead for graph construction - \u274c More complex implementation - \u274c Parallel execution not suitable for recycle processes - \u274c Thread pool overhead for small processes</p>"},{"location":"simulation/graph_based_process_simulation/#recommendation","title":"Recommendation","text":"Process Type Recommended Method Simple linear process (&lt;4 units) <code>run()</code> Complex dependencies <code>run()</code> with <code>setUseGraphBasedExecution(true)</code> Recycle loops <code>run()</code> (sequential with convergence) Multiple independent trains <code>runParallel()</code> or <code>runOptimal()</code> General/unknown <code>runOptimal()</code> (auto-selects)"},{"location":"simulation/graph_based_process_simulation/#api-reference","title":"API Reference","text":""},{"location":"simulation/graph_based_process_simulation/#processsystem-methods","title":"ProcessSystem Methods","text":"<pre><code>// Graph construction\nProcessGraph buildGraph()                    // Build/get cached graph\nvoid invalidateGraph()                       // Clear cached graph\n\n// Execution control\nvoid setUseGraphBasedExecution(boolean use)  // Enable topological ordering\nboolean isUseGraphBasedExecution()           // Check if enabled\n\n// Execution methods\nvoid run()                                   // Standard execution\nvoid runParallel()                           // Parallel execution\nvoid runOptimal()                            // Auto-select best strategy\n\n// Analysis\nList&lt;ProcessEquipmentInterface&gt; getTopologicalOrder()  // Get sorted order\nProcessGraph.ParallelPartition getParallelPartition()  // Get parallel levels\nboolean isParallelExecutionBeneficial()     // Check if parallel helps\nString getRecycleBlockReport()              // Get recycle analysis\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#processgraph-methods","title":"ProcessGraph Methods","text":"<pre><code>// Structure\nint getNodeCount()\nint getEdgeCount()\nProcessNode getNode(ProcessEquipmentInterface equipment)\nProcessEdge getEdge(StreamInterface stream)\nList&lt;ProcessNode&gt; getSourceNodes()          // Nodes with no inputs\nList&lt;ProcessNode&gt; getSinkNodes()            // Nodes with no outputs\n\n// Analysis\nList&lt;ProcessEquipmentInterface&gt; getCalculationOrder()  // Topological sort\nboolean hasCycles()\nCycleAnalysisResult analyzeCycles()\nSCCResult findStronglyConnectedComponents()\nParallelPartition partitionForParallelExecution()\n\n// Sensitivity Analysis (NEW)\nList&lt;SensitivityAnalysisResult&gt; analyzeTearStreamSensitivity()  // Analyze all loops\nMap&lt;Integer, ProcessEdge&gt; selectTearStreamsWithSensitivity()    // Auto-select optimal tears\nString getSensitivityAnalysisReport()                           // Get formatted report\n\n// Validation\nList&lt;String&gt; validate()                     // Check for issues\nString getSummary()                         // Get text summary\n\n// GNN/ML support\ndouble[][] getNodeFeatureMatrix()\nint[][] getEdgeIndexTensor()\ndouble[][] getEdgeFeatureMatrix()\nMap&lt;Integer, List&lt;Integer&gt;&gt; getAdjacencyList()\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#sensitivityanalysisresult-class-new","title":"SensitivityAnalysisResult Class (NEW)","text":"<pre><code>// Get the nodes in this recycle loop\nList&lt;ProcessNode&gt; getLoopNodes()\n\n// Get all candidate edges with their sensitivity scores\nMap&lt;ProcessEdge, Double&gt; getEdgeSensitivities()\n\n// Get the recommended tear stream (lowest sensitivity)\nProcessEdge getRecommendedTearStream()\ndouble getSensitivity()  // Sensitivity score of recommended tear\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#processsensitivityanalyzer-class-new","title":"ProcessSensitivityAnalyzer Class (NEW)","text":"<p>A comprehensive analyzer for computing sensitivities of any output property with respect to any input property. It intelligently leverages Broyden Jacobians when available, falling back to finite differences only when necessary.</p> <pre><code>// Create analyzer for a process\nProcessSensitivityAnalyzer analyzer = new ProcessSensitivityAnalyzer(process);\n\n// Fluent API for defining inputs and outputs\nanalyzer\n    .withInput(\"feed\", \"temperature\", \"C\")      // equipment, property, unit\n    .withInput(\"feed\", \"flowRate\", \"kg/hr\")\n    .withOutput(\"product\", \"temperature\")\n    .withOutput(\"product\", \"pressure\", \"bara\")\n    .withCentralDifferences(true)               // More accurate (2x cost)\n    .withPerturbation(0.001);                   // Relative perturbation size\n\n// Compute sensitivities (uses Broyden Jacobian if available)\nSensitivityMatrix result = analyzer.compute();\n\n// Query specific sensitivities\ndouble dT_dFlow = result.getSensitivity(\"product.temperature\", \"feed.flowRate\");\n\n// Generate human-readable report\nString report = analyzer.generateReport(result);\n\n// Force finite differences only (ignores Broyden)\nSensitivityMatrix fdResult = analyzer.computeFiniteDifferencesOnly();\n</code></pre> <p>Key Features:</p> Feature Description Broyden Integration Automatically uses convergence Jacobian for tear streams (free!) Fluent API Easy specification of any equipment.property pair Unit Support Specify units for proper value access/setting Central/Forward FD Choose accuracy vs speed tradeoff Report Generation Formatted sensitivity report with most influential inputs"},{"location":"simulation/graph_based_process_simulation/#best-practices","title":"Best Practices","text":""},{"location":"simulation/graph_based_process_simulation/#1-use-runoptimal-for-new-code","title":"1. Use <code>runOptimal()</code> for New Code","text":"<pre><code>// Let NeqSim decide the best execution strategy\nprocess.runOptimal();\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#2-validate-graph-structure","title":"2. Validate Graph Structure","text":"<pre><code>ProcessGraph graph = process.buildGraph();\nList&lt;String&gt; issues = graph.validate();\nif (!issues.isEmpty()) {\n    System.out.println(\"Warning: \" + issues);\n}\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#3-check-parallelization-potential","title":"3. Check Parallelization Potential","text":"<pre><code>if (process.isParallelExecutionBeneficial()) {\n    System.out.println(\"This process can benefit from parallel execution\");\n    ProcessGraph.ParallelPartition p = process.getParallelPartition();\n    System.out.println(\"Max speedup potential: \" + p.getMaxParallelism() + \"x\");\n}\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#4-debug-with-graph-summary","title":"4. Debug with Graph Summary","text":"<pre><code>System.out.println(process.buildGraph().getSummary());\n</code></pre> <p>Output: <pre><code>ProcessGraph Summary:\n  Nodes: 12\n  Edges: 11\n  Sources: 4\n  Sinks: 4\n  Has cycles: false\n  SCCs: 12\n  Recycle loops: 0\n  Parallel levels: 3\n  Max parallelism: 4\n</code></pre></p>"},{"location":"simulation/graph_based_process_simulation/#5-handle-recycles-properly","title":"5. Handle Recycles Properly","text":"<pre><code>// Recycle processes should use sequential execution\nif (processHasRecycles) {\n    process.run();  // Uses convergence iteration\n} else {\n    process.runOptimal();  // May use parallel\n}\n\n// Or let runOptimal() decide automatically\nprocess.runOptimal();  // Auto-detects recycles and uses sequential\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#advanced-topics","title":"Advanced Topics","text":""},{"location":"simulation/graph_based_process_simulation/#integration-with-machine-learning","title":"Integration with Machine Learning","text":"<p>The graph representation provides feature matrices suitable for Graph Neural Networks (GNNs):</p> <pre><code>ProcessGraph graph = process.buildGraph();\n\n// Get tensors for GNN\ndouble[][] nodeFeatures = graph.getNodeFeatureMatrix();  // [N, F]\nint[][] edgeIndex = graph.getEdgeIndexTensor();          // [2, E]\ndouble[][] edgeFeatures = graph.getEdgeFeatureMatrix();  // [E, F]\n\n// Use with PyTorch Geometric, DGL, etc.\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#custom-graph-analysis","title":"Custom Graph Analysis","text":"<pre><code>ProcessGraph graph = process.buildGraph();\n\n// Find all paths between two nodes\n// Identify critical equipment (high betweenness centrality)\n// Optimize equipment sizing based on flow patterns\n// etc.\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#processmodule-support","title":"ProcessModule Support","text":"<p>For hierarchical processes using <code>ProcessModule</code>:</p> <pre><code>ProcessModule module = new ProcessModule(\"LNG Train\");\nmodule.add(inlet);\nmodule.add(scrubber);\nmodule.add(deethanizer);\n// ...\n\n// Build hierarchical graph\nProcessModelGraph modelGraph = new ProcessModelGraph(module);\nProcessGraph flatGraph = modelGraph.getFlattenedGraph();\n\n// Get sub-system dependencies\nMap&lt;String, Set&lt;String&gt;&gt; deps = modelGraph.getSubSystemDependencies();\n\n// Check if parallel execution of sub-systems is beneficial\nif (modelGraph.isParallelSubSystemExecutionBeneficial()) {\n    // Get parallel partition of sub-systems\n    ProcessModelGraph.ModuleParallelPartition partition = \n        modelGraph.partitionSubSystemsForParallelExecution();\n\n    System.out.println(\"Parallel levels: \" + partition.getLevelCount());\n    System.out.println(\"Max parallelism: \" + partition.getMaxParallelism());\n\n    // Each level contains independent sub-systems that can run in parallel\n    for (int i = 0; i &lt; partition.getLevelCount(); i++) {\n        List&lt;String&gt; systemsAtLevel = partition.getLevels().get(i);\n        System.out.println(\"Level \" + i + \": \" + systemsAtLevel);\n    }\n}\n</code></pre>"},{"location":"simulation/graph_based_process_simulation/#conclusion","title":"Conclusion","text":"<p>Graph-based process simulation in NeqSim provides:</p> <ol> <li>Robustness: Automatic dependency handling prevents ordering errors</li> <li>Performance: Parallel execution for suitable processes</li> <li>Insight: Structural analysis reveals process topology</li> <li>Extensibility: Foundation for optimization and ML applications</li> </ol>"},{"location":"simulation/graph_based_process_simulation/#for-most-users-simply-using-processrunoptimal-provides-the-best-of-both-worlds-automatic-selection-of-the-optimal-execution-strategy-based-on-process-structure","title":"For most users, simply using <code>process.runOptimal()</code> provides the best of both worlds - automatic selection of the optimal execution strategy based on process structure.","text":""},{"location":"simulation/graph_based_process_simulation/#jupyter-notebook-example","title":"Jupyter Notebook Example","text":"<p>A complete interactive example is available in the notebooks directory:</p> <p>\ud83d\udcd3 GraphBasedProcessSimulation.ipynb</p> <p>The notebook demonstrates: - Graph construction and analysis - Cycle detection and recycle block identification - Sensitivity-based tear stream selection - Acceleration method comparison (Direct Substitution vs Wegstein vs Broyden) - Parallel execution for multi-train processes</p> <p>Last updated: December 2025</p>"},{"location":"simulation/parallel_process_simulation/","title":"Parallel Process Simulation with NeqSimThreadPool","text":"<p>NeqSim provides a global thread pool for running multiple process simulations concurrently. This enables significant performance improvements when running independent simulations, sensitivity analyses, or optimization studies.</p>"},{"location":"simulation/parallel_process_simulation/#overview","title":"Overview","text":"<p>The <code>NeqSimThreadPool</code> class provides a managed thread pool that:</p> <ul> <li>Uses daemon threads (won't prevent JVM shutdown)</li> <li>Defaults to using all available CPU cores</li> <li>Supports configurable pool size</li> <li>Provides both <code>Future&lt;?&gt;</code> and <code>Callable&lt;T&gt;</code> interfaces for flexible result handling</li> </ul>"},{"location":"simulation/parallel_process_simulation/#java-usage","title":"Java Usage","text":""},{"location":"simulation/parallel_process_simulation/#basic-usage-running-multiple-processes-in-parallel","title":"Basic Usage - Running Multiple Processes in Parallel","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\nimport neqsim.util.NeqSimThreadPool;\nimport java.util.concurrent.Future;\nimport java.util.List;\nimport java.util.ArrayList;\n\n// Create multiple independent process systems\nList&lt;ProcessSystem&gt; processes = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; 20; i++) {\n    ProcessSystem process = createYourProcess(i);  // Your process setup\n    processes.add(process);\n}\n\n// Submit all processes to run in parallel\nList&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();\nfor (ProcessSystem process : processes) {\n    Future&lt;?&gt; future = process.runAsTask();  // Non-blocking, returns immediately\n    futures.add(future);\n}\n\n// Wait for all to complete\nfor (Future&lt;?&gt; future : futures) {\n    future.get();  // Blocks until this task completes\n}\n\n// All processes are now complete - access results\nfor (ProcessSystem process : processes) {\n    double result = process.getUnit(\"MySeparator\").getOutletStream().getFlowRate(\"kg/hr\");\n    System.out.println(\"Result: \" + result);\n}\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#using-callable-for-direct-result-return","title":"Using Callable for Direct Result Return","text":"<pre><code>import neqsim.util.NeqSimThreadPool;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\n\n// Define a task that returns a result\nCallable&lt;Double&gt; simulationTask = () -&gt; {\n    ProcessSystem process = createProcess();\n    process.run();\n    return process.getUnit(\"Separator\").getOutletStream().getFlowRate(\"kg/hr\");\n};\n\n// Submit and get result\nFuture&lt;Double&gt; future = NeqSimThreadPool.submit(simulationTask);\nDouble flowRate = future.get();  // Returns the result directly\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#configuring-the-thread-pool","title":"Configuring the Thread Pool","text":"<pre><code>import neqsim.util.NeqSimThreadPool;\n\n// Get current pool size (defaults to available processors)\nint currentSize = NeqSimThreadPool.getPoolSize();\n\n// Set custom pool size (e.g., for HPC clusters)\nNeqSimThreadPool.setPoolSize(32);\n\n// Reset to default (number of available processors)\nNeqSimThreadPool.resetPoolSize();\n\n// Shutdown pool when application exits (optional - uses daemon threads)\nNeqSimThreadPool.shutdown();\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#complete-example-sensitivity-analysis","title":"Complete Example - Sensitivity Analysis","text":"<pre><code>import neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.valve.ThrottlingValve;\nimport neqsim.process.processmodel.ProcessSystem;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\nimport neqsim.util.NeqSimThreadPool;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Future;\n\npublic class ParallelSensitivityAnalysis {\n\n    public static void main(String[] args) throws Exception {\n        // Define pressure range for sensitivity study\n        double[] pressures = {10, 20, 30, 40, 50, 60, 70, 80};\n\n        List&lt;ProcessSystem&gt; processes = new ArrayList&lt;&gt;();\n        List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();\n\n        // Create and submit all processes\n        for (int i = 0; i &lt; pressures.length; i++) {\n            ProcessSystem process = createProcess(i, pressures[i]);\n            processes.add(process);\n            futures.add(process.runAsTask());\n        }\n\n        // Wait for completion and collect results\n        for (int i = 0; i &lt; futures.size(); i++) {\n            futures.get(i).get();\n\n            ProcessSystem process = processes.get(i);\n            Separator sep = (Separator) process.getUnit(\"Separator\");\n            double gasFlow = sep.getGasOutStream().getFlowRate(\"kg/hr\");\n            double liquidFlow = sep.getLiquidOutStream().getFlowRate(\"kg/hr\");\n\n            System.out.printf(\"P=%.0f bar: Gas=%.2f kg/hr, Liquid=%.2f kg/hr%n\",\n                pressures[i], gasFlow, liquidFlow);\n        }\n    }\n\n    private static ProcessSystem createProcess(int id, double feedPressure) {\n        SystemInterface fluid = new SystemSrkEos(298.15, feedPressure);\n        fluid.addComponent(\"methane\", 0.8);\n        fluid.addComponent(\"ethane\", 0.12);\n        fluid.addComponent(\"propane\", 0.05);\n        fluid.addComponent(\"n-butane\", 0.03);\n        fluid.setMixingRule(\"classic\");\n\n        ProcessSystem process = new ProcessSystem();\n\n        Stream feed = new Stream(\"Feed\", fluid);\n        feed.setFlowRate(1000.0, \"kg/hr\");\n        feed.setTemperature(25.0, \"C\");\n        feed.setPressure(feedPressure, \"bara\");\n\n        ThrottlingValve valve = new ThrottlingValve(\"Valve\", feed);\n        valve.setOutletPressure(5.0);\n\n        Separator separator = new Separator(\"Separator\", valve.getOutletStream());\n\n        process.add(feed);\n        process.add(valve);\n        process.add(separator);\n\n        return process;\n    }\n}\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#reporting-results-in-completion-order","title":"Reporting Results in Completion Order","text":"<p>When running many simulations, you may want to process results as they finish rather than waiting for all to complete. Use the built-in <code>newCompletionService()</code> method:</p> <pre><code>import java.util.concurrent.CompletionService;\n\n// Create CompletionService using the convenience method\nCompletionService&lt;Integer&gt; completionService = NeqSimThreadPool.newCompletionService();\n\n// Submit all processes, returning their index when done\nfor (int i = 0; i &lt; processes.size(); i++) {\n    final int index = i;\n    final ProcessSystem process = processes.get(i);\n    completionService.submit(() -&gt; {\n        process.run();\n        return index;  // Return the index so we know which one completed\n    });\n}\n\n// Process results as they complete\nfor (int i = 0; i &lt; numProcesses; i++) {\n    // take() blocks until the next result is available\n    Future&lt;Integer&gt; completedFuture = completionService.take();\n    int completedIndex = completedFuture.get();\n\n    ProcessSystem process = processes.get(completedIndex);\n    Separator sep = (Separator) process.getUnit(\"Separator\");\n    double gasFlow = sep.getGasOutStream().getFlowRate(\"kg/hr\");\n\n    System.out.printf(\"Process %d completed: gas flow = %.2f kg/hr%n\", \n        completedIndex, gasFlow);\n}\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#polling-for-completion-non-blocking","title":"Polling for Completion (Non-blocking)","text":"<p>For non-blocking checks, poll futures with <code>isDone()</code>:</p> <pre><code>boolean[] reported = new boolean[numProcesses];\nint completedCount = 0;\n\nwhile (completedCount &lt; numProcesses) {\n    for (int i = 0; i &lt; numProcesses; i++) {\n        if (!reported[i] &amp;&amp; futures.get(i).isDone()) {\n            // This one just completed\n            ProcessSystem process = processes.get(i);\n            System.out.printf(\"Process %d completed!%n\", i);\n\n            reported[i] = true;\n            completedCount++;\n        }\n    }\n\n    // Do other work here while waiting...\n    Thread.sleep(10);\n}\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#python-usage-via-jpype","title":"Python Usage (via JPype)","text":""},{"location":"simulation/parallel_process_simulation/#setup","title":"Setup","text":"<pre><code>import jpype\nimport jpype.imports\nfrom jpype.types import *\n\n# Start JVM with NeqSim\nneqsim_path = \"/path/to/neqsim.jar\"\njpype.startJVM(classpath=[neqsim_path])\n\n# Import Java classes\nfrom neqsim.process.processmodel import ProcessSystem\nfrom neqsim.process.equipment.stream import Stream\nfrom neqsim.process.equipment.separator import Separator\nfrom neqsim.process.equipment.valve import ThrottlingValve\nfrom neqsim.thermo.system import SystemSrkEos\nfrom neqsim.util import NeqSimThreadPool\nfrom java.util.concurrent import TimeUnit\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#basic-parallel-execution","title":"Basic Parallel Execution","text":"<pre><code>def create_process(process_id, pressure):\n    \"\"\"Create a simple process system.\"\"\"\n    fluid = SystemSrkEos(298.15, pressure)\n    fluid.addComponent(\"methane\", 0.8)\n    fluid.addComponent(\"ethane\", 0.12)\n    fluid.addComponent(\"propane\", 0.05)\n    fluid.addComponent(\"n-butane\", 0.03)\n    fluid.setMixingRule(\"classic\")\n\n    process = ProcessSystem()\n    process.setName(f\"Process-{process_id}\")\n\n    feed = Stream(f\"Feed-{process_id}\", fluid)\n    feed.setFlowRate(1000.0, \"kg/hr\")\n    feed.setTemperature(25.0, \"C\")\n    feed.setPressure(pressure, \"bara\")\n\n    valve = ThrottlingValve(f\"Valve-{process_id}\", feed)\n    valve.setOutletPressure(5.0)\n\n    separator = Separator(f\"Separator-{process_id}\", valve.getOutletStream())\n\n    process.add(feed)\n    process.add(valve)\n    process.add(separator)\n\n    return process\n\n# Create multiple processes\npressures = [20, 30, 40, 50, 60, 70, 80, 90]\nprocesses = [create_process(i, p) for i, p in enumerate(pressures)]\n\n# Submit all to thread pool\nfutures = [process.runAsTask() for process in processes]\n\n# Wait for all to complete\nfor future in futures:\n    future.get()  # Blocks until complete\n\n# Collect results\nresults = []\nfor i, process in enumerate(processes):\n    sep = process.getUnit(f\"Separator-{i}\")\n    gas_flow = sep.getGasOutStream().getFlowRate(\"kg/hr\")\n    liquid_flow = sep.getLiquidOutStream().getFlowRate(\"kg/hr\")\n    results.append({\n        'pressure': pressures[i],\n        'gas_flow': gas_flow,\n        'liquid_flow': liquid_flow\n    })\n\n# Display results\nfor r in results:\n    print(f\"P={r['pressure']} bar: Gas={r['gas_flow']:.2f}, Liquid={r['liquid_flow']:.2f} kg/hr\")\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#reporting-results-in-completion-order-python","title":"Reporting Results in Completion Order (Python)","text":"<p>Use the <code>newCompletionService()</code> method to get results as they finish:</p> <pre><code>from java.util.concurrent import Callable\n\n# Create CompletionService using the convenience method\ncompletion_service = NeqSimThreadPool.newCompletionService()\n\n# Submit tasks that return their index when complete\n@jpype.JImplements(Callable)\nclass IndexedSimulation:\n    def __init__(self, index, process):\n        self.index = index\n        self.process = process\n\n    @jpype.JOverride\n    def call(self):\n        self.process.run()\n        return self.index\n\n# Submit all processes\nfor i, process in enumerate(processes):\n    completion_service.submit(IndexedSimulation(i, process))\n\n# Get results in completion order\nprint(\"Results in completion order:\")\nfor _ in range(len(processes)):\n    completed_future = completion_service.take()  # Blocks until next completes\n    index = completed_future.get()\n\n    process = processes[index]\n    sep = process.getUnit(f\"Separator-{index}\")\n    gas_flow = sep.getGasOutStream().getFlowRate(\"kg/hr\")\n\n    print(f\"  Process {index} completed: gas flow = {gas_flow:.2f} kg/hr\")\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#polling-for-completion-python","title":"Polling for Completion (Python)","text":"<pre><code># Track completion\nreported = [False] * len(processes)\ncompleted = 0\n\nwhile completed &lt; len(processes):\n    for i, future in enumerate(futures):\n        if not reported[i] and future.isDone():\n            process = processes[i]\n            sep = process.getUnit(f\"Separator-{i}\")\n            gas_flow = sep.getGasOutStream().getFlowRate(\"kg/hr\")\n\n            print(f\"Process {i} completed: gas flow = {gas_flow:.2f} kg/hr\")\n\n            reported[i] = True\n            completed += 1\n\n    # Do other work while waiting...\n    import time\n    time.sleep(0.01)\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#using-callable-for-direct-results","title":"Using Callable for Direct Results","text":"<pre><code>from java.util.concurrent import Callable\n\n# Create a Java Callable using JPype's @JImplements decorator\n@jpype.JImplements(Callable)\nclass SimulationTask:\n    def __init__(self, pressure):\n        self.pressure = pressure\n\n    @jpype.JOverride\n    def call(self):\n        process = create_process(0, self.pressure)\n        process.run()\n        sep = process.getUnit(\"Separator-0\")\n        return float(sep.getGasOutStream().getFlowRate(\"kg/hr\"))\n\n# Submit callable tasks\ntasks = [SimulationTask(p) for p in [20, 40, 60, 80]]\nfutures = [NeqSimThreadPool.submit(task) for task in tasks]\n\n# Get results directly\nresults = [future.get() for future in futures]\nprint(\"Gas flows:\", results)\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#configuring-thread-pool-from-python","title":"Configuring Thread Pool from Python","text":"<pre><code># Check default pool size\nprint(f\"Default pool size: {NeqSimThreadPool.getDefaultPoolSize()}\")\nprint(f\"Current pool size: {NeqSimThreadPool.getPoolSize()}\")\n\n# Set custom pool size for HPC\nNeqSimThreadPool.setPoolSize(64)\n\n# Reset to default\nNeqSimThreadPool.resetPoolSize()\n\n# Check pool status\nprint(f\"Pool shutdown: {NeqSimThreadPool.isShutdown()}\")\nprint(f\"Pool terminated: {NeqSimThreadPool.isTerminated()}\")\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#advanced-parallel-monte-carlo-simulation","title":"Advanced: Parallel Monte Carlo Simulation","text":"<pre><code>import random\nimport numpy as np\n\ndef run_monte_carlo(n_samples=100, n_parallel=20):\n    \"\"\"Run Monte Carlo simulation with parallel process execution.\"\"\"\n\n    results = []\n\n    # Process in batches\n    for batch_start in range(0, n_samples, n_parallel):\n        batch_end = min(batch_start + n_parallel, n_samples)\n        batch_size = batch_end - batch_start\n\n        # Create processes with random parameters\n        processes = []\n        params = []\n        for i in range(batch_size):\n            pressure = random.uniform(20, 80)\n            temperature = random.uniform(20, 40)\n            params.append({'pressure': pressure, 'temperature': temperature})\n\n            process = create_process_with_temp(i, pressure, temperature)\n            processes.append(process)\n\n        # Run batch in parallel\n        futures = [p.runAsTask() for p in processes]\n        for f in futures:\n            f.get()\n\n        # Collect results\n        for i, process in enumerate(processes):\n            sep = process.getUnit(f\"Separator-{i}\")\n            results.append({\n                **params[i],\n                'gas_flow': sep.getGasOutStream().getFlowRate(\"kg/hr\")\n            })\n\n    return results\n\n# Run simulation\nmc_results = run_monte_carlo(n_samples=200, n_parallel=20)\n\n# Analyze results\ngas_flows = [r['gas_flow'] for r in mc_results]\nprint(f\"Mean gas flow: {np.mean(gas_flows):.2f} kg/hr\")\nprint(f\"Std deviation: {np.std(gas_flows):.2f} kg/hr\")\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#timeout-handling","title":"Timeout Handling","text":"<pre><code>from java.util.concurrent import TimeoutException\n\nfutures = [process.runAsTask() for process in processes]\n\nfor i, future in enumerate(futures):\n    try:\n        # Wait with timeout (60 seconds)\n        future.get(60, TimeUnit.SECONDS)\n    except TimeoutException:\n        print(f\"Process {i} timed out!\")\n        future.cancel(True)  # Cancel the task\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#performance-tips","title":"Performance Tips","text":"<ol> <li> <p>Pool Size: The default pool size equals available CPU cores. For I/O-bound tasks, you may increase it. For CPU-intensive calculations, the default is usually optimal.</p> </li> <li> <p>Independent Processes: Ensure each process has its own fluid system (use <code>clone()</code> or create new). Shared state between processes causes race conditions.</p> </li> <li> <p>Batch Processing: For very large numbers of simulations (1000+), process in batches to manage memory:    <pre><code>batch_size = 50\nfor i in range(0, n_total, batch_size):\n    batch = create_batch(i, batch_size)\n    run_parallel(batch)\n    collect_results(batch)\n    # batch goes out of scope, allowing GC\n</code></pre></p> </li> <li> <p>Result Collection: Collect results immediately after <code>future.get()</code> to allow process objects to be garbage collected.</p> </li> </ol>"},{"location":"simulation/parallel_process_simulation/#api-reference","title":"API Reference","text":""},{"location":"simulation/parallel_process_simulation/#neqsimthreadpool","title":"NeqSimThreadPool","text":"Method Description <code>submit(Runnable task)</code> Submit a task, returns <code>Future&lt;?&gt;</code> <code>submit(Callable&lt;T&gt; task)</code> Submit a task with result, returns <code>Future&lt;T&gt;</code> <code>execute(Runnable task)</code> Fire-and-forget execution <code>newCompletionService()</code> Create a <code>CompletionService&lt;T&gt;</code> for completion-order results <code>getPool()</code> Get the underlying <code>ExecutorService</code> <code>getPoolSize()</code> Get current pool size <code>setPoolSize(int size)</code> Set pool size (recreates pool if needed) <code>getDefaultPoolSize()</code> Get default size (available processors) <code>resetPoolSize()</code> Reset to default size <code>setMaxQueueCapacity(int)</code> Set bounded queue capacity (0 = unbounded) <code>getMaxQueueCapacity()</code> Get current queue capacity setting <code>setAllowCoreThreadTimeout(boolean)</code> Enable/disable idle thread termination <code>isAllowCoreThreadTimeout()</code> Check if core thread timeout is enabled <code>setKeepAliveTimeSeconds(long)</code> Set idle thread keep-alive time <code>getKeepAliveTimeSeconds()</code> Get current keep-alive time <code>shutdown()</code> Orderly shutdown <code>shutdownNow()</code> Immediate shutdown <code>shutdownAndAwait(timeout, unit)</code> Shutdown and wait for completion <code>isShutdown()</code> Check if pool is shutdown <code>isTerminated()</code> Check if all tasks completed"},{"location":"simulation/parallel_process_simulation/#processsystem-processmodule-processmodel","title":"ProcessSystem, ProcessModule, ProcessModel","text":"Method Description <code>runAsTask()</code> Submit to thread pool, returns <code>Future&lt;?&gt;</code> <code>runAsThread()</code> Deprecated - Creates unmanaged thread"},{"location":"simulation/parallel_process_simulation/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"simulation/parallel_process_simulation/#bounded-queue-for-hpc","title":"Bounded Queue for HPC","text":"<p>For extreme load scenarios (HPC clusters with thousands of simulations), you can limit the queue size to prevent memory exhaustion:</p> <pre><code>// Set bounded queue with 10,000 task capacity\nNeqSimThreadPool.setMaxQueueCapacity(10_000);\n\n// Submit tasks - will throw RejectedExecutionException if queue overflows\ntry {\n    for (int i = 0; i &lt; numSimulations; i++) {\n        process.runAsTask();\n    }\n} catch (RejectedExecutionException e) {\n    System.err.println(\"Queue full - consider reducing batch size\");\n}\n\n// Reset to unbounded queue\nNeqSimThreadPool.setMaxQueueCapacity(0);\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#core-thread-timeout-for-long-running-processes","title":"Core Thread Timeout for Long-Running Processes","text":"<p>By default, threads in the pool stay alive forever waiting for new tasks. For long-running Python processes or memory-constrained environments, you can enable core thread timeout so idle threads are terminated after a period of inactivity:</p> <pre><code>// Enable core thread timeout (threads die after being idle)\nNeqSimThreadPool.setAllowCoreThreadTimeout(true);\n\n// Optionally set custom keep-alive time (default is 600 seconds = 10 minutes)\nNeqSimThreadPool.setKeepAliveTimeSeconds(300);  // 5 minutes\n\n// Now idle threads will be terminated after 5 minutes\n// This frees memory when the pool is not in use\n</code></pre> <p>Python example for long-running services:</p> <pre><code>from neqsim.util import NeqSimThreadPool\n\n# Enable core thread timeout for memory efficiency in long-running processes\nNeqSimThreadPool.setAllowCoreThreadTimeout(True)\nNeqSimThreadPool.setKeepAliveTimeSeconds(300)  # 5 minutes\n\n# Now use the pool normally - idle threads will be cleaned up automatically\nfutures = [process.runAsTask() for process in batch]\nfor future in futures:\n    future.get()\n\n# After 5 minutes of no activity, all threads will be terminated\n# New tasks will create new threads as needed\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#exception-handling","title":"Exception Handling","text":"<p>The thread pool includes an <code>UncaughtExceptionHandler</code> that logs any exceptions that escape thread execution. This prevents silent failures during simulations:</p> <pre><code>// Exceptions are logged automatically\nFuture&lt;?&gt; future = NeqSimThreadPool.submit(() -&gt; {\n    // If this throws, it will be logged AND captured in the Future\n    riskyOperation();\n});\n\n// Check for exceptions\ntry {\n    future.get();\n} catch (ExecutionException e) {\n    System.err.println(\"Simulation failed: \" + e.getCause().getMessage());\n}\n</code></pre>"},{"location":"simulation/parallel_process_simulation/#migration-from-runasthread","title":"Migration from runAsThread()","text":"<p>The <code>runAsThread()</code> method is now deprecated. Migrate as follows:</p> <pre><code>// Old way (deprecated)\nThread thread = process.runAsThread();\nthread.join();\n\n// New way (recommended)\nFuture&lt;?&gt; future = process.runAsTask();\nfuture.get();\n</code></pre> <p>Benefits of <code>runAsTask()</code>: - Managed thread pool (no thread explosion) - Better resource utilization - <code>Future</code> API for cancellation and timeout - Consistent with modern Java concurrency patterns - Automatic exception logging</p>"},{"location":"simulation/parallel_process_simulation/#performance-comparison-runasthread-vs-runastask","title":"Performance Comparison: runAsThread() vs runAsTask()","text":"<p>Benchmark running 20 process simulations across 3 iterations:</p> Metric runAsThread() runAsTask() Run 1 (cold start) 50 ms 10 ms Run 2 6 ms 4 ms Run 3 5 ms 4 ms Average 20.3 ms 6.0 ms Improvement - 70% faster"},{"location":"simulation/parallel_process_simulation/#why-runastask-is-faster","title":"Why runAsTask() is Faster","text":"<ol> <li> <p>Thread reuse: The thread pool creates threads once and reuses them, eliminating thread creation overhead on subsequent calls.</p> </li> <li> <p>Cold start: The first run shows the biggest difference (50ms vs 10ms) because <code>runAsThread()</code> must create 20 new threads, while <code>runAsTask()</code> creates pool threads once.</p> </li> <li> <p>Bounded resources: With 1000+ processes, <code>runAsThread()</code> would create 1000+ threads (potentially crashing), while <code>runAsTask()</code> queues tasks safely.</p> </li> </ol>"},{"location":"simulation/parallel_process_simulation/#api-comparison","title":"API Comparison","text":"Feature runAsThread() runAsTask() Return type <code>Thread</code> <code>Future&lt;?&gt;</code> Wait for completion <code>thread.join()</code> <code>future.get()</code> Timeout support Manual implementation <code>future.get(timeout, unit)</code> Cancellation <code>thread.interrupt()</code> <code>future.cancel(true)</code> Check completion <code>thread.isAlive()</code> <code>future.isDone()</code> Exception handling Uncaught by default Captured in Future + logged Thread management Unbounded (dangerous) Bounded pool (safe)"},{"location":"simulation/parallel_process_simulation/#code-example","title":"Code Example","text":"<pre><code>// OLD WAY (deprecated) - creates new thread each time\nList&lt;Thread&gt; threads = new ArrayList&lt;&gt;();\nfor (ProcessSystem process : processes) {\n    Thread t = process.runAsThread();\n    threads.add(t);\n}\nfor (Thread t : threads) {\n    t.join();  // No timeout support\n}\n\n// NEW WAY (recommended) - uses managed thread pool\nList&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();\nfor (ProcessSystem process : processes) {\n    Future&lt;?&gt; future = process.runAsTask();\n    futures.add(future);\n}\nfor (Future&lt;?&gt; future : futures) {\n    future.get(60, TimeUnit.SECONDS);  // Built-in timeout\n}\n</code></pre>"},{"location":"simulation/process_calculator/","title":"Process Calculator","text":"<p>The <code>Calculator</code> unit operation in NeqSim provides a flexible way to perform custom calculations and data manipulation within a process simulation. It allows users to define arbitrary logic that can read properties from input process equipment and modify properties of output process equipment. Custom lambdas are the recommended hook for AI-generated calculations so you can swap in new behavior without rebuilding the process topology.</p> <p>This is particularly useful for: - Calculating derived properties (e.g., total energy, efficiency). - Transferring data between unconnected parts of a process. - Implementing simple control logic or adjustments based on calculated values (e.g., adjusting a stream temperature based on combustion energy).</p>"},{"location":"simulation/process_calculator/#usage","title":"Usage","text":"<p>The <code>Calculator</code> class is located in <code>neqsim.process.equipment.util</code>.</p>"},{"location":"simulation/process_calculator/#basic-setup","title":"Basic Setup","text":"<ol> <li>Create the Calculator: Instantiate the <code>Calculator</code> with a name.</li> <li>Add Inputs: Use <code>addInputVariable()</code> to add one or more process equipment objects (e.g., Streams) that will be used in the calculation.</li> <li>Set Output: Use <code>setOutputVariable()</code> to set the target process equipment that will be modified by the calculation.</li> <li>Define Logic: Use <code>setCalculationMethod()</code> to define the custom calculation logic. This method accepts a <code>BiConsumer&lt;ArrayList&lt;ProcessEquipmentInterface&gt;, ProcessEquipmentInterface&gt;</code>, which can be easily implemented using a Java Lambda expression or a declarative preset.</li> </ol>"},{"location":"simulation/process_calculator/#example-energy-calculation-and-temperature-adjustment","title":"Example: Energy Calculation and Temperature Adjustment","text":"<p>The following example demonstrates how to calculate the total energy of an inlet stream (based on Lower Calorific Value) and use that energy to adjust the temperature of an outlet stream.</p> <pre><code>import neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.util.Calculator;\nimport neqsim.thermo.system.SystemSrkEos;\n\npublic class CalculatorExample {\n    public static void main(String[] args) {\n        // 1. Setup the simulation objects\n        SystemSrkEos testSystem = new SystemSrkEos(298.15, 10.0);\n        testSystem.addComponent(\"methane\", 100.0);\n\n        Stream inletStream = new Stream(\"inlet stream\", testSystem);\n        inletStream.setFlowRate(1000.0, \"kg/hr\");\n        inletStream.run();\n\n        Stream outletStream = new Stream(\"outlet stream\", testSystem.clone());\n        outletStream.setFlowRate(1000.0, \"kg/hr\");\n        outletStream.setTemperature(20.0, \"C\");\n        outletStream.run();\n\n        // 2. Create the Calculator\n        Calculator energyCalculator = new Calculator(\"Energy Calculator\");\n\n        // 3. Configure Inputs and Outputs\n        energyCalculator.addInputVariable(inletStream);\n        energyCalculator.setOutputVariable(outletStream);\n\n        // 4. Define the Custom Calculation Logic\n        energyCalculator.setCalculationMethod((inputs, output) -&gt; {\n            Stream in = (Stream) inputs.get(0);\n            Stream out = (Stream) output;\n\n            // Calculate total energy flow (Energy = LCV * FlowRate)\n            // LCV() returns J/Sm3, so we multiply by Sm3/hr to get J/hr\n            double lcv = in.LCV(); // J/Sm3\n            double flowRate = in.getFlowRate(\"Sm3/hr\");\n            double totalEnergyFlow = lcv * flowRate; // J/hr\n\n            // Example logic: Assume we burn this gas and heat the outlet stream.\n            // Let's say we want to set the outlet temperature based on this energy.\n            // (This is a simplified example logic)\n\n            double targetTemperature = 300.0 + (totalEnergyFlow / 1.0e7); \n\n            out.setTemperature(targetTemperature, \"K\");\n\n            System.out.println(\"Calculated Energy Flow: \" + totalEnergyFlow + \" J/hr\");\n            System.out.println(\"Adjusted Outlet Temperature: \" + targetTemperature + \" K\");\n        });\n\n        // 5. Run the Calculator\n        // In a ProcessSystem, this would happen automatically when the system is run.\n        energyCalculator.run();\n\n        // Verify the result\n        System.out.println(\"Final Outlet Temperature: \" + outletStream.getTemperature(\"K\") + \" K\");\n    }\n}\n</code></pre>"},{"location":"simulation/process_calculator/#declarative-presets-for-common-calculations","title":"Declarative presets for common calculations","text":"<p>When you want standardized behavior without re-implementing a lambda, use the presets in <code>CalculatorLibrary</code>:</p> <pre><code>Calculator preset = new Calculator(\"energy balancer\");\npreset.addInputVariable(inletStream);\npreset.setOutputVariable(outletStream);\n\n// Resolve by enum\npreset.setCalculationMethod(CalculatorLibrary.preset(CalculatorLibrary.Preset.ENERGY_BALANCE));\n\n// ...or dynamically by name from metadata/AI text\n// preset.setCalculationMethod(CalculatorLibrary.byName(\"energyBalance\"));\n</code></pre> <p>Available presets:</p> <ul> <li>ENERGY_BALANCE: flashes the output stream at its current pressure so its enthalpy equals the sum of input enthalpies.</li> <li>DEW_POINT_TARGETING: sets the output stream temperature to the hydrocarbon dew point of the first input stream at the output pressure. Use <code>CalculatorLibrary.dewPointTargeting(double marginKelvin)</code> to add a temperature margin above dew point.</li> </ul>"},{"location":"simulation/process_calculator/#api-reference","title":"API Reference","text":""},{"location":"simulation/process_calculator/#calculator","title":"<code>Calculator</code>","text":"<ul> <li><code>addInputVariable(ProcessEquipmentInterface unit)</code>: Adds a unit operation to the list of inputs available during calculation.</li> <li><code>setOutputVariable(ProcessEquipmentInterface unit)</code>: Sets the primary unit operation that will be modified by the calculation.</li> <li><code>setCalculationMethod(BiConsumer&lt;ArrayList&lt;ProcessEquipmentInterface&gt;, ProcessEquipmentInterface&gt; method)</code>: Sets the custom logic to be executed when <code>run()</code> is called.<ul> <li>The lambda receives two arguments:<ol> <li><code>inputs</code>: An <code>ArrayList</code> of the input equipment added via <code>addInputVariable</code>.</li> <li><code>output</code>: The output equipment set via <code>setOutputVariable</code>.</li> </ol> </li> </ul> </li> </ul>"},{"location":"simulation/process_calculator/#related-functionality","title":"Related Functionality","text":"<p>Similar flexibility has been added to <code>Adjuster</code> and <code>SetPoint</code> classes.</p>"},{"location":"simulation/process_calculator/#adjuster","title":"<code>Adjuster</code>","text":"<p>The <code>Adjuster</code> class can now use a custom function to calculate the current value of the target variable, instead of relying on hardcoded property strings.</p> <ul> <li><code>setTargetValueCalculator(Function&lt;ProcessEquipmentInterface, Double&gt; calculator)</code>: Sets a function that calculates the current value from the target equipment.</li> </ul>"},{"location":"simulation/process_calculator/#setpoint","title":"<code>SetPoint</code>","text":"<p>The <code>SetPoint</code> class can now use a custom function to calculate the value to be set on the target equipment, based on the source equipment.</p> <ul> <li><code>setSourceValueCalculator(Function&lt;ProcessEquipmentInterface, Double&gt; calculator)</code>: Sets a function that calculates the value to set from the source equipment.</li> </ul>"},{"location":"simulation/process_logic_framework/","title":"Process Logic Framework for NeqSim","text":""},{"location":"simulation/process_logic_framework/#overview","title":"Overview","text":"<p>This document describes the proposed process logic framework for NeqSim, enabling complex automation sequences including ESD, startup, shutdown, and general process control logic.</p>"},{"location":"simulation/process_logic_framework/#architecture","title":"Architecture","text":""},{"location":"simulation/process_logic_framework/#core-components","title":"Core Components","text":""},{"location":"simulation/process_logic_framework/#1-processlogic-interface","title":"1. ProcessLogic (Interface)","text":"<p>Base interface for all process logic implementations.</p> <pre><code>public interface ProcessLogic {\n  String getName();\n  LogicState getState();\n  void activate();\n  void deactivate();\n  void reset();\n  void execute(double timeStep);\n  boolean isActive();\n  List&lt;LogicAction&gt; getActions();\n  List&lt;ProcessEquipmentInterface&gt; getTargetEquipment();\n}\n</code></pre>"},{"location":"simulation/process_logic_framework/#2-logicsequence","title":"2. LogicSequence","text":"<p>Executes ordered steps with timing, conditions, and actions.</p> <pre><code>public class LogicSequence implements ProcessLogic {\n  private List&lt;SequenceStep&gt; steps;\n  private int currentStep;\n  private double elapsedTime;\n  private LogicState state; // IDLE, RUNNING, PAUSED, COMPLETED, FAILED\n\n  public void addStep(SequenceStep step);\n  public void executeCurrentStep(double timeStep);\n  public boolean canProceedToNextStep();\n}\n</code></pre>"},{"location":"simulation/process_logic_framework/#3-sequencestep","title":"3. SequenceStep","text":"<p>Individual step in a logic sequence.</p> <pre><code>public class SequenceStep {\n  private String name;\n  private List&lt;LogicAction&gt; actions;\n  private List&lt;LogicCondition&gt; preconditions;\n  private List&lt;LogicCondition&gt; completionConditions;\n  private double minimumDuration; // Min time in step\n  private double maximumDuration; // Max time (timeout)\n  private double delay; // Initial delay before executing\n\n  public void execute();\n  public boolean isComplete();\n  public boolean hasTimedOut();\n}\n</code></pre>"},{"location":"simulation/process_logic_framework/#4-logicaction","title":"4. LogicAction","text":"<p>Represents an action on equipment.</p> <pre><code>public interface LogicAction {\n  void execute();\n  String getDescription();\n  boolean isComplete();\n}\n\n// Common implementations:\n// - ValveAction (open, close, set position)\n// - PumpAction (start, stop, set speed)\n// - SeparatorAction (switch mode)\n// - SplitterAction (set split factors)\n// - AlarmAction (raise, acknowledge, reset)\n</code></pre>"},{"location":"simulation/process_logic_framework/#5-logiccondition","title":"5. LogicCondition","text":"<p>Boolean condition that must be satisfied.</p> <pre><code>public interface LogicCondition {\n  boolean evaluate();\n  String getDescription();\n}\n\n// Common implementations:\n// - PressureCondition (above/below setpoint)\n// - TemperatureCondition\n// - FlowCondition\n// - LevelCondition\n// - ValvePositionCondition\n// - TimerCondition\n// - EquipmentStateCondition\n</code></pre>"},{"location":"simulation/process_logic_framework/#logic-types","title":"Logic Types","text":""},{"location":"simulation/process_logic_framework/#a-esd-logic-esdlogic","title":"A. ESD Logic (<code>ESDLogic</code>)","text":"<p>Implements emergency shutdown procedures following IEC 61511 patterns.</p> <p>Features: - Multiple ESD levels (L1, L2, L3) - Cause-and-effect matrix - Voting logic (1oo1, 1oo2, 2oo3, etc.) - Override capabilities - Reset logic with permissives</p> <p>Example: <pre><code>ESDLogic esdL1 = new ESDLogic(\"ESD Level 1\");\n\n// Add triggers\nesdL1.addTrigger(new ManualTrigger(pushButton));\nesdL1.addTrigger(new PressureTrigger(separator, \"HIHI\", 55.0, \"bara\"));\n\n// Define sequence\nesdL1.addStep(\"Close inlet valves\")\n    .addAction(new TripValveAction(esdValve1))\n    .addAction(new TripValveAction(esdValve2))\n    .withDelay(0.0);\n\nesdL1.addStep(\"Open blowdown valve\")\n    .addAction(new ActivateValveAction(bdValve))\n    .withDelay(0.5); // 0.5s after inlet closure\n\nesdL1.addStep(\"Stop feed pumps\")\n    .addAction(new StopPumpAction(feedPump1))\n    .addAction(new StopPumpAction(feedPump2))\n    .withDelay(1.0);\n\nesdL1.addStep(\"Switch to dynamic mode\")\n    .addAction(new SeparatorModeAction(separator, false))\n    .withDelay(0.0);\n\n// Add reset permissives\nesdL1.addResetPermissive(new PressureCondition(separator, \"&lt;\", 10.0, \"bara\"));\nesdL1.addResetPermissive(new ManualPermissive(\"Operator approval\"));\n</code></pre></p>"},{"location":"simulation/process_logic_framework/#b-startup-logic-startuplogic","title":"B. Startup Logic (<code>StartupLogic</code>)","text":"<p>Implements sequential startup procedures with interlocks.</p> <p>Features: - Step-by-step equipment startup - Permissive checks before each step - Automatic vs. manual mode - Parallel and sequential operations - Rollback on failure</p> <p>Example: <pre><code>StartupLogic startup = new StartupLogic(\"Separator Train Startup\");\n\nstartup.addStep(\"Pre-startup checks\")\n    .addCondition(new ValvePositionCondition(bdValve, \"&lt;\", 1.0)) // BD closed\n    .addCondition(new PressureCondition(separator, \"&lt;\", 5.0, \"bara\")) // Depressurized\n    .withTimeout(60.0);\n\nstartup.addStep(\"Open feed isolation\")\n    .addAction(new EnergizeValveAction(esdValve))\n    .withDelay(2.0)\n    .withMinDuration(5.0); // Wait for valve to fully open\n\nstartup.addStep(\"Start feed flow\")\n    .addAction(new SetValveOpeningAction(controlValve, 10.0)) // 10% opening\n    .addCondition(new FlowCondition(feedStream, \"&gt;\", 100.0, \"kg/hr\"))\n    .withTimeout(30.0);\n\nstartup.addStep(\"Ramp up to normal flow\")\n    .addAction(new RampValveAction(controlValve, 10.0, 50.0, 120.0)) // 10% to 50% over 120s\n    .withMinDuration(120.0);\n\nstartup.addStep(\"Enable process control\")\n    .addAction(new EnableControllerAction(pressureController))\n    .addAction(new EnableControllerAction(levelController));\n</code></pre></p>"},{"location":"simulation/process_logic_framework/#c-shutdown-logic-shutdownlogic","title":"C. Shutdown Logic (<code>ShutdownLogic</code>)","text":"<p>Implements orderly shutdown procedures.</p> <p>Features: - Normal vs. emergency shutdown - Controlled ramp-down - Equipment isolation sequence - Depressurization logic</p> <p>Example: <pre><code>ShutdownLogic normalShutdown = new ShutdownLogic(\"Normal Shutdown\");\n\nnormalShutdown.addStep(\"Reduce feed rate\")\n    .addAction(new RampValveAction(controlValve, 50.0, 5.0, 300.0)) // 5 min ramp\n    .withMinDuration(300.0);\n\nnormalShutdown.addStep(\"Stop feed\")\n    .addAction(new SetValveOpeningAction(controlValve, 0.0));\n\nnormalShutdown.addStep(\"Depressurize\")\n    .addAction(new SetSplitterAction(gasSplitter, new double[]{0.0, 1.0}))\n    .addCondition(new PressureCondition(separator, \"&lt;\", 5.0, \"bara\"))\n    .withTimeout(600.0);\n\nnormalShutdown.addStep(\"Close isolation\")\n    .addAction(new TripValveAction(esdValve));\n</code></pre></p>"},{"location":"simulation/process_logic_framework/#integration-with-existing-components","title":"Integration with Existing Components","text":""},{"location":"simulation/process_logic_framework/#updated-pushbutton","title":"Updated PushButton","text":"<pre><code>public class PushButton extends MeasurementDeviceBaseClass {\n  private List&lt;ProcessLogic&gt; linkedLogics = new ArrayList&lt;&gt;();\n\n  public void linkToLogic(ProcessLogic logic) {\n    linkedLogics.add(logic);\n  }\n\n  public void push() {\n    isPushed = true;\n    // Activate all linked logic sequences\n    for (ProcessLogic logic : linkedLogics) {\n      logic.activate();\n    }\n  }\n}\n</code></pre>"},{"location":"simulation/process_logic_framework/#equipment-modifications","title":"Equipment Modifications","text":"<p>All equipment should implement <code>LogicTarget</code> interface: <pre><code>public interface LogicTarget {\n  void acceptLogicAction(LogicAction action);\n  Map&lt;String, Object&gt; getLogicState();\n}\n</code></pre></p>"},{"location":"simulation/process_logic_framework/#logic-execution-model","title":"Logic Execution Model","text":""},{"location":"simulation/process_logic_framework/#transient-simulation-integration","title":"Transient Simulation Integration","text":"<pre><code>public class ProcessSystem {\n  private List&lt;ProcessLogic&gt; activeLogics = new ArrayList&lt;&gt;();\n\n  public void runTransient(double timeStep, UUID id) {\n    // 1. Evaluate logic triggers\n    for (ProcessLogic logic : activeLogics) {\n      if (logic.shouldActivate()) {\n        logic.activate();\n      }\n    }\n\n    // 2. Execute active logic sequences\n    for (ProcessLogic logic : activeLogics) {\n      if (logic.isActive()) {\n        logic.execute(timeStep);\n      }\n    }\n\n    // 3. Run equipment\n    for (ProcessEquipmentInterface equipment : unitOperations) {\n      equipment.runTransient(timeStep, id);\n    }\n  }\n}\n</code></pre>"},{"location":"simulation/process_logic_framework/#usage-examples","title":"Usage Examples","text":""},{"location":"simulation/process_logic_framework/#example-1-esd-system-with-multiple-levels","title":"Example 1: ESD System with Multiple Levels","text":"<pre><code>// ESD Level 1 - Process Shutdown\nESDLogic esdL1 = new ESDLogic(\"ESD-L1\");\nesdL1.addTrigger(new ManualTrigger(pushButton1));\nesdL1.addTrigger(new PressureTrigger(separator, \"HH\", 55.0));\nesdL1.addStep(/* ... */);\n\n// ESD Level 2 - Blowdown\nESDLogic esdL2 = new ESDLogic(\"ESD-L2\");\nesdL2.addTrigger(new ManualTrigger(pushButton2));\nesdL2.addTrigger(new PressureTrigger(separator, \"HIHI\", 60.0));\nesdL2.addTrigger(new CascadeTrigger(esdL1)); // L1 also triggers L2\nesdL2.addStep(/* ... */);\n\n// Link push button to both levels\npushButton1.linkToLogic(esdL1);\npushButton2.linkToLogic(esdL2);\n</code></pre>"},{"location":"simulation/process_logic_framework/#example-2-complete-startup-sequence","title":"Example 2: Complete Startup Sequence","text":"<pre><code>StartupLogic startup = new StartupLogic(\"Full Process Startup\");\n\n// Add all startup steps with proper interlocks\nstartup.enableAutoMode(); // Automatic progression between steps\nstartup.setFailureAction(new RollbackAction()); // Rollback on failure\n\n// Execute\nstartup.activate();\nwhile (!startup.isComplete()) {\n  startup.execute(timeStep);\n  processSystem.runTransient(timeStep, UUID.randomUUID());\n}\n</code></pre>"},{"location":"simulation/process_logic_framework/#example-3-coordinated-multi-unit-operation","title":"Example 3: Coordinated Multi-Unit Operation","text":"<pre><code>ProcessLogic multiUnitLogic = new LogicSequence(\"Train A Startup\");\n\n// Start compressor first\nmultiUnitLogic.addStep(\"Start compressor\")\n    .addAction(new StartCompressorAction(comp1))\n    .addCondition(new RPMCondition(comp1, \"&gt;\", 3000));\n\n// Then open inlet valve\nmultiUnitLogic.addStep(\"Open inlet\")\n    .addAction(new EnergizeValveAction(inletValve))\n    .addPrecondition(new CompressorRunningCondition(comp1));\n\n// Start separator\nmultiUnitLogic.addStep(\"Start separator\")\n    .addAction(new StartSeparatorAction(sep1))\n    .withParallel(new StartPumpAction(exportPump));\n</code></pre>"},{"location":"simulation/process_logic_framework/#implementation-priority","title":"Implementation Priority","text":""},{"location":"simulation/process_logic_framework/#phase-1-core-framework-immediate","title":"Phase 1: Core Framework (Immediate)","text":"<ol> <li><code>ProcessLogic</code> interface</li> <li><code>LogicSequence</code> class</li> <li><code>SequenceStep</code> class</li> <li>Basic <code>LogicAction</code> implementations (valve, pump)</li> <li>Basic <code>LogicCondition</code> implementations (pressure, flow)</li> </ol>"},{"location":"simulation/process_logic_framework/#phase-2-esd-logic-high-priority","title":"Phase 2: ESD Logic (High Priority)","text":"<ol> <li><code>ESDLogic</code> class</li> <li><code>ESDLevel</code> enum</li> <li>Manual trigger integration</li> <li>Automatic trigger (pressure, temp, level)</li> <li>Updated <code>PushButton</code> to support multiple targets</li> </ol>"},{"location":"simulation/process_logic_framework/#phase-3-startupshutdown-medium-priority","title":"Phase 3: Startup/Shutdown (Medium Priority)","text":"<ol> <li><code>StartupLogic</code> class</li> <li><code>ShutdownLogic</code> class</li> <li>Permissive checking</li> <li>Rollback capabilities</li> </ol>"},{"location":"simulation/process_logic_framework/#phase-4-advanced-features-future","title":"Phase 4: Advanced Features (Future)","text":"<ol> <li>Voting logic (1oo2, 2oo3)</li> <li>Override management</li> <li>Cause-and-effect matrices</li> <li>Visual logic editor integration</li> <li>IEC 61131-3 function block style</li> </ol>"},{"location":"simulation/process_logic_framework/#benefits","title":"Benefits","text":"<ol> <li>Reusability: Define logic once, use across multiple simulations</li> <li>Maintainability: Clear separation of logic from equipment</li> <li>Testability: Logic can be unit tested independently</li> <li>Flexibility: Easy to modify sequences without changing equipment code</li> <li>Standards Compliance: Aligns with IEC 61511/61131 patterns</li> <li>Documentation: Self-documenting through sequence steps</li> <li>Safety: Enforces proper sequence execution and interlocks</li> </ol>"},{"location":"simulation/process_logic_framework/#design-considerations","title":"Design Considerations","text":""},{"location":"simulation/process_logic_framework/#thread-safety","title":"Thread Safety","text":"<ul> <li>Logic execution should be thread-safe for parallel simulations</li> <li>Use immutable conditions where possible</li> </ul>"},{"location":"simulation/process_logic_framework/#performance","title":"Performance","text":"<ul> <li>Lazy evaluation of conditions</li> <li>Cache condition results within a time step</li> <li>Efficient equipment lookup</li> </ul>"},{"location":"simulation/process_logic_framework/#error-handling","title":"Error Handling","text":"<ul> <li>Clear failure modes</li> <li>Recovery procedures</li> <li>Logging and diagnostics</li> </ul>"},{"location":"simulation/process_logic_framework/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>Existing examples continue to work</li> <li>Optional adoption of logic framework</li> <li>Gradual migration path</li> </ul>"},{"location":"simulation/process_logic_framework/#conclusion","title":"Conclusion","text":"<p>This framework provides a robust, extensible foundation for implementing complex process logic in NeqSim while maintaining the library's existing architecture and design patterns.</p>"},{"location":"simulation/process_logic_implementation_summary/","title":"Process Logic Framework Implementation Summary","text":""},{"location":"simulation/process_logic_implementation_summary/#what-was-implemented","title":"What Was Implemented","text":"<p>A comprehensive Process Logic Framework for NeqSim that enables coordinated, multi-step automation sequences for ESD, startup, shutdown, and general process control.</p>"},{"location":"simulation/process_logic_implementation_summary/#core-components-created","title":"Core Components Created","text":""},{"location":"simulation/process_logic_implementation_summary/#1-base-framework-neqsimprocesslogic","title":"1. Base Framework (<code>neqsim.process.logic</code>)","text":"<ul> <li><code>ProcessLogic.java</code> - Interface for all process logic</li> <li><code>LogicState.java</code> - Enum for logic execution states (IDLE, RUNNING, PAUSED, COMPLETED, FAILED, WAITING_PERMISSIVES)</li> <li><code>LogicAction.java</code> - Interface for actions on equipment</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#2-action-implementations-neqsimprocesslogicaction","title":"2. Action Implementations (<code>neqsim.process.logic.action</code>)","text":"<ul> <li><code>TripValveAction.java</code> - De-energize ESD valve</li> <li><code>ActivateBlowdownAction.java</code> - Open blowdown valve</li> <li><code>SetSplitterAction.java</code> - Configure splitter split factors</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#3-esd-logic-neqsimprocesslogicesd","title":"3. ESD Logic (<code>neqsim.process.logic.esd</code>)","text":"<ul> <li><code>ESDLogic.java</code> - Simplified ESD sequence executor with timed actions</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#4-enhanced-pushbutton","title":"4. Enhanced PushButton","text":"<ul> <li>Updated <code>PushButton.java</code> to support multiple logic targets via <code>linkToLogic(ProcessLogic)</code></li> <li>Maintains backward compatibility with direct BlowdownValve linking</li> <li>Single button can now trigger multiple coordinated actions</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#5-example","title":"5. Example","text":"<ul> <li><code>ESDLogicExample.java</code> - Demonstrates coordinated 3-step ESD sequence</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#key-benefits","title":"Key Benefits","text":""},{"location":"simulation/process_logic_implementation_summary/#1-single-trigger-multiple-actions","title":"1. Single Trigger, Multiple Actions","text":"<pre><code>ESDLogic esdLogic = new ESDLogic(\"ESD Level 1\");\nesdLogic.addAction(new TripValveAction(esdValve), 0.0);      // Immediate\nesdLogic.addAction(new ActivateBlowdownAction(bdValve), 0.5); // After 0.5s\nesdLogic.addAction(new SetSplitterAction(splitter, factors), 0.0);\n\nPushButton button = new PushButton(\"ESD-PB-101\");\nbutton.linkToLogic(esdLogic); // One button, three coordinated actions!\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#2-reusable-logic-sequences","title":"2. Reusable Logic Sequences","text":"<p>Define once, use across multiple simulations: <pre><code>// Create standard startup sequence\nStartupLogic standardStartup = createStandardStartup();\n\n// Use in multiple simulations\nprocessSystem1.addLogic(standardStartup);\nprocessSystem2.addLogic(standardStartup.clone());\n</code></pre></p>"},{"location":"simulation/process_logic_implementation_summary/#3-clear-separation-of-concerns","title":"3. Clear Separation of Concerns","text":"<ul> <li>Equipment: Knows how to operate (valves open/close, pumps start/stop)</li> <li>Logic: Knows when and in what order to operate equipment</li> <li>Triggers: Knows what conditions activate logic (manual, pressure, level, etc.)</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#4-configurable-timing","title":"4. Configurable Timing","text":"<pre><code>esdLogic.addAction(action1, 0.0);   // Execute immediately\nesdLogic.addAction(action2, 2.0);   // Wait 2 seconds\nesdLogic.addAction(action3, 0.5);   // Wait additional 0.5 seconds\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#5-future-extensibility","title":"5. Future Extensibility","text":"<p>Easy to add: - Startup logic with permissive checks - Shutdown sequences with ramp-down - Batch operations - Conditional branching - Parallel action execution - Voting logic (1oo2, 2oo3)</p>"},{"location":"simulation/process_logic_implementation_summary/#usage-pattern","title":"Usage Pattern","text":""},{"location":"simulation/process_logic_implementation_summary/#basic-esd-sequence","title":"Basic ESD Sequence","text":"<pre><code>// 1. Create equipment\nESDValve esdValve = new ESDValve(\"ESD-XV-101\", stream);\nBlowdownValve bdValve = new BlowdownValve(\"BD-101\", stream);\nSplitter splitter = new Splitter(\"Splitter\", stream, 2);\n\n// 2. Create logic sequence\nESDLogic esdLogic = new ESDLogic(\"ESD Level 1\");\nesdLogic.addAction(new TripValveAction(esdValve), 0.0);\nesdLogic.addAction(new ActivateBlowdownAction(bdValve), 0.5);\nesdLogic.addAction(new SetSplitterAction(splitter, new double[]{0.0, 1.0}), 0.0);\n\n// 3. Link to trigger\nPushButton esdButton = new PushButton(\"ESD-PB-101\");\nesdButton.linkToLogic(esdLogic);\n\n// 4. Execute in simulation\nesdButton.push(); // Activates logic\n\nwhile (!esdLogic.isComplete()) {\n  esdLogic.execute(timeStep);\n  equipment.runTransient(timeStep, id);\n}\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Push Button    \u2502 \u2500\u2500triggers\u2500\u2500\u2510\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502\n                                \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         ProcessLogic (ESDLogic)         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Step 1: Trip ESD Valve (delay 0s) \u2502 \u2502\u2500\u2500executes\u2500\u2500\u25b6 ESDValve.trip()\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502 Step 2: Open BD Valve (delay 0.5s) \u2502\u2502\u2500\u2500executes\u2500\u2500\u25b6 BlowdownValve.activate()\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502 Step 3: Set Splitter (delay 0.0s)  \u2502\u2502\u2500\u2500executes\u2500\u2500\u25b6 Splitter.setSplitFactors()\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#future-enhancements","title":"Future Enhancements","text":""},{"location":"simulation/process_logic_implementation_summary/#phase-1-conditions-next-priority","title":"Phase 1: Conditions (Next Priority)","text":"<pre><code>public interface LogicCondition {\n  boolean evaluate();\n  String getDescription();\n}\n\n// Example usage:\nstartupLogic.addStep(\"Open valve\")\n    .addAction(new OpenValveAction(valve))\n    .addPrecondition(new PressureCondition(separator, \"&lt;\", 5.0, \"bara\"))\n    .addCompletionCondition(new ValvePositionCondition(valve, \"&gt;\", 95.0));\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#phase-2-startupshutdown-logic","title":"Phase 2: Startup/Shutdown Logic","text":"<pre><code>StartupLogic startup = new StartupLogic(\"Separator Train Startup\");\nstartup.addStep(\"Pre-checks\").addPermissive(/* ... */);\nstartup.addStep(\"Open isolation\").addAction(/* ... */);\nstartup.addStep(\"Ramp up flow\").addAction(/* ... */);\nstartup.enableAutoProgression(); // Automatic step advancement\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#phase-3-advanced-features","title":"Phase 3: Advanced Features","text":"<ul> <li>Parallel action execution</li> <li>Conditional branching (if-then-else)</li> <li>Voting logic for redundant sensors</li> <li>Override management</li> <li>Visual logic editor</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#comparison-before-vs-after","title":"Comparison: Before vs After","text":""},{"location":"simulation/process_logic_implementation_summary/#before-manual-coordination","title":"Before (Manual Coordination)","text":"<pre><code>esdButton.push();           // Activates BD valve only\nesdValve.trip();           // Manual call\ngasSplitter.setSplitFactors(new double[]{0.0, 1.0}); // Manual call\n// Timing not coordinated, easy to forget steps\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#after-logic-framework","title":"After (Logic Framework)","text":"<pre><code>esdButton.push();  // Activates entire coordinated sequence\n// All steps executed in correct order with proper timing\n// Nothing forgotten, fully documented in logic sequence\n</code></pre>"},{"location":"simulation/process_logic_implementation_summary/#industry-standards-alignment","title":"Industry Standards Alignment","text":""},{"location":"simulation/process_logic_implementation_summary/#iec-61511-functional-safety","title":"IEC 61511 (Functional Safety)","text":"<ul> <li>Separation of logic from execution \u2713</li> <li>Clear cause-and-effect relationships \u2713</li> <li>Voting and redundancy support (future) \u2713</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#iec-61131-3-plc-programming","title":"IEC 61131-3 (PLC Programming)","text":"<ul> <li>Sequential Function Chart (SFC) patterns \u2713</li> <li>Function block structure \u2713</li> <li>Reusable logic modules \u2713</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#isa-88-batch-control","title":"ISA-88 (Batch Control)","text":"<ul> <li>Recipe-driven operations (future)</li> <li>Phase/operation/unit procedure hierarchy (future)</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#files-created","title":"Files Created","text":""},{"location":"simulation/process_logic_implementation_summary/#core-framework","title":"Core Framework","text":"<ul> <li><code>src/main/java/neqsim/process/logic/ProcessLogic.java</code></li> <li><code>src/main/java/neqsim/process/logic/LogicState.java</code></li> <li><code>src/main/java/neqsim/process/logic/LogicAction.java</code></li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#actions","title":"Actions","text":"<ul> <li><code>src/main/java/neqsim/process/logic/action/TripValveAction.java</code></li> <li><code>src/main/java/neqsim/process/logic/action/ActivateBlowdownAction.java</code></li> <li><code>src/main/java/neqsim/process/logic/action/SetSplitterAction.java</code></li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#esd-implementation","title":"ESD Implementation","text":"<ul> <li><code>src/main/java/neqsim/process/logic/esd/ESDLogic.java</code></li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#examples","title":"Examples","text":"<ul> <li><code>src/main/java/neqsim/process/util/example/ESDLogicExample.java</code></li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#documentation","title":"Documentation","text":"<ul> <li><code>docs/process_logic_framework.md</code> - Comprehensive design document</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#modified-files","title":"Modified Files","text":"<ul> <li><code>src/main/java/neqsim/process/measurementdevice/PushButton.java</code> - Added logic linking</li> </ul>"},{"location":"simulation/process_logic_implementation_summary/#testing-recommendations","title":"Testing Recommendations","text":"<ol> <li>Unit Tests for Actions</li> <li>Test each action independently</li> <li> <p>Mock equipment for isolation</p> </li> <li> <p>Integration Tests for Logic</p> </li> <li>Test complete ESD sequences</li> <li>Verify timing accuracy</li> <li> <p>Test failure modes</p> </li> <li> <p>Example Tests</p> </li> <li>Run ESDLogicExample and verify output</li> <li>Compare with manual coordination</li> <li>Performance benchmarking</li> </ol>"},{"location":"simulation/process_logic_implementation_summary/#conclusion","title":"Conclusion","text":"<p>The Process Logic Framework provides a powerful, extensible foundation for implementing complex automation in NeqSim. It:</p> <ol> <li>Simplifies complex multi-step operations</li> <li>Coordinates timing between equipment actions</li> <li>Documents operational sequences clearly</li> <li>Reuses logic across simulations</li> <li>Extends easily to new use cases (startup, batch, etc.)</li> </ol> <p>The framework follows industry standards and best practices while maintaining NeqSim's existing architecture and design patterns.</p>"},{"location":"simulation/recycle_acceleration_guide/","title":"Recycle Convergence Acceleration Guide","text":"<p>This guide explains the recycle system in NeqSim, the available convergence acceleration methods, and best practices for optimizing process simulations.</p>"},{"location":"simulation/recycle_acceleration_guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Understanding Recycles</li> <li>Acceleration Methods</li> <li>Usage Examples</li> <li>RecycleController for Multiple Recycles</li> <li>Performance Benchmarks</li> <li>Troubleshooting</li> <li>Best Practices</li> </ol>"},{"location":"simulation/recycle_acceleration_guide/#overview","title":"Overview","text":"<p>Process simulations often contain recycle loops where output streams from downstream equipment feed back into upstream units. These loops require iterative solving because the downstream conditions depend on upstream calculations, which in turn depend on the recycle stream values.</p> <p>NeqSim provides three convergence acceleration methods to speed up recycle convergence:</p> Method Best For Complexity Direct Substitution Simple, well-behaved recycles O(1) Wegstein Oscillating or slow-converging recycles O(1) Broyden Tightly coupled multi-variable systems O(n\u00b2)"},{"location":"simulation/recycle_acceleration_guide/#understanding-recycles","title":"Understanding Recycles","text":""},{"location":"simulation/recycle_acceleration_guide/#what-is-a-recycle","title":"What is a Recycle?","text":"<p>A <code>Recycle</code> unit in NeqSim connects an output stream to an input stream, creating a feedback loop. The recycle iterates until the difference between input and output falls below specified tolerances.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502  \u2502  Feed   \u2502\u2500\u2500\u2500\u25b6\u2502  Unit A \u2502\u2500\u2500\u2500\u25b6\u2502  Unit B \u2502\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502     \u2502\n\u2502       \u25b2                                       \u2502     \u2502\n\u2502       \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                   \u2502     \u2502\n\u2502       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502 Recycle \u2502\u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                         \u2502\n\u2502                                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#convergence-criteria","title":"Convergence Criteria","text":"<p>The recycle checks convergence on four properties:</p> <ol> <li>Temperature - Default tolerance: 1.0 K</li> <li>Pressure - Default tolerance: 0.01 bar</li> <li>Flow rate - Default tolerance: 1.0 kg/hr</li> <li>Composition - Default tolerance: 1e-3 (mole fraction)</li> </ol>"},{"location":"simulation/recycle_acceleration_guide/#basic-recycle-setup","title":"Basic Recycle Setup","text":"<pre><code>// Create inlet and outlet streams\nStream recycleInlet = new Stream(\"recycle inlet\", fluid);\nrecycleInlet.setFlowRate(100.0, \"kg/hr\");\n\n// ... add process equipment ...\n\n// Create recycle connecting outlet back to inlet\nRecycle recycle = new Recycle(\"main recycle\");\nrecycle.addStream(downstreamOutput);  // Output from process\nrecycle.setOutletStream(recycleInlet); // Connects to inlet\nrecycle.setTolerance(1e-2);            // Overall tolerance\n\n// Add to process system\nprocess.add(recycle);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#acceleration-methods","title":"Acceleration Methods","text":""},{"location":"simulation/recycle_acceleration_guide/#1-direct-substitution-default","title":"1. Direct Substitution (Default)","text":"<p>Algorithm: Simply uses the output values as the next input.</p> \\[x_{n+1} = g(x_n)\\] <p>Characteristics: - Simplest method - Always stable for contractive mappings - May be slow for difficult problems - No additional memory or computation</p> <p>When to Use: - Default choice for most problems - When recycles converge quickly (&lt; 10 iterations) - When stability is more important than speed</p> <pre><code>recycle.setAccelerationMethod(AccelerationMethod.DIRECT_SUBSTITUTION);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#2-wegstein-acceleration","title":"2. Wegstein Acceleration","text":"<p>Algorithm: Extrapolates based on the slope between consecutive iterations.</p> \\[x_{n+1} = q \\cdot g(x_n) + (1-q) \\cdot x_n\\] <p>where the q-factor is calculated from the slope:</p> \\[q = \\frac{s}{s-1}, \\quad s = \\frac{g(x_n) - g(x_{n-1})}{x_n - x_{n-1}}\\] <p>Bounded q-factor: NeqSim bounds q \u2208 [-5, 0] to prevent divergence: - q = 0: Pure direct substitution - q &lt; 0: Damping for oscillatory behavior - q = -5: Maximum damping</p> <p>Characteristics: - Low overhead (O(1) per variable) - Excellent for single-variable problems - Adaptive damping prevents oscillation - Each variable accelerated independently</p> <p>When to Use: - Recycles that oscillate with direct substitution - Single dominant variable controlling convergence - When you need more stability than direct substitution</p> <pre><code>recycle.setAccelerationMethod(AccelerationMethod.WEGSTEIN);\n\n// Optional: Tune the q-factor bounds\nrecycle.setWegsteinQMin(-5.0);  // More damping\nrecycle.setWegsteinQMax(0.0);   // Maximum q (direct substitution)\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#3-broydens-method","title":"3. Broyden's Method","text":"<p>Algorithm: Quasi-Newton method that builds up an approximation of the inverse Jacobian.</p> \\[x_{n+1} = x_n - B_n^{-1} \\cdot F(x_n)\\] <p>where \\(F(x) = g(x) - x\\) is the residual function and \\(B_n^{-1}\\) is updated using the Sherman-Morrison formula:</p> \\[B_{n+1}^{-1} = B_n^{-1} + \\frac{(\\Delta x - B_n^{-1} \\Delta F) \\Delta x^T B_n^{-1}}{\\Delta x^T B_n^{-1} \\Delta F}\\] <p>Characteristics: - Higher overhead (O(n\u00b2) for n variables) - Excellent for coupled multi-variable systems - Superlinear convergence near solution - Requires storing previous iteration data</p> <p>When to Use: - Multiple tightly coupled recycles - When Wegstein doesn't improve convergence - Complex processes with many interacting variables</p> <pre><code>recycle.setAccelerationMethod(AccelerationMethod.BROYDEN);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#usage-examples","title":"Usage Examples","text":""},{"location":"simulation/recycle_acceleration_guide/#example-1-simple-compression-loop","title":"Example 1: Simple Compression Loop","text":"<p>A gas compression system with intercooling and recycle:</p> <pre><code>SystemInterface gas = new SystemSrkEos(298.15, 10.0);\ngas.addComponent(\"methane\", 0.9);\ngas.addComponent(\"ethane\", 0.1);\ngas.setMixingRule(\"classic\");\n\n// Feed stream\nStream feed = new Stream(\"feed\", gas);\nfeed.setFlowRate(1000.0, \"kg/hr\");\n\n// Recycle inlet (estimate)\nStream recycleInlet = feed.clone(\"recycle inlet\");\nrecycleInlet.setFlowRate(50.0, \"kg/hr\");\n\n// Mix feed with recycle\nMixer mixer = new Mixer(\"inlet mixer\");\nmixer.addStream(feed);\nmixer.addStream(recycleInlet);\n\n// Compressor\nCompressor comp = new Compressor(\"compressor\", mixer.getOutletStream());\ncomp.setOutletPressure(50.0, \"bara\");\n\n// Cooler\nCooler cooler = new Cooler(\"intercooler\", comp.getOutletStream());\ncooler.setOutTemperature(30.0, \"C\");\n\n// Separator\nSeparator sep = new Separator(\"separator\", cooler.getOutletStream());\n\n// Recycle liquid back to inlet\nRecycle recycle = new Recycle(\"liquid recycle\");\nrecycle.addStream(sep.getLiquidOutStream());\nrecycle.setOutletStream(recycleInlet);\nrecycle.setTolerance(1e-3);\nrecycle.setAccelerationMethod(AccelerationMethod.WEGSTEIN);  // Use Wegstein\n\n// Build process\nProcessSystem process = new ProcessSystem();\nprocess.add(feed);\nprocess.add(recycleInlet);\nprocess.add(mixer);\nprocess.add(comp);\nprocess.add(cooler);\nprocess.add(sep);\nprocess.add(recycle);\n\nprocess.run();\n\nSystem.out.println(\"Converged in \" + recycle.getIterations() + \" iterations\");\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#example-2-multi-stage-separation-with-multiple-recycles","title":"Example 2: Multi-Stage Separation with Multiple Recycles","text":"<pre><code>// Create process with multiple recycles\nProcessSystem process = new ProcessSystem();\n\n// ... set up 3-stage separation train ...\n\n// HP recycle with Broyden (coupled with MP recycle)\nRecycle hpRecycle = new Recycle(\"HP recycle\");\nhpRecycle.addStream(hpSeparator.getLiquidOutStream());\nhpRecycle.setOutletStream(hpRecycleInlet);\nhpRecycle.setTolerance(1e-2);\nhpRecycle.setAccelerationMethod(AccelerationMethod.BROYDEN);\nhpRecycle.setPriority(100);  // Run first\nprocess.add(hpRecycle);\n\n// MP recycle with Broyden\nRecycle mpRecycle = new Recycle(\"MP recycle\");\nmpRecycle.addStream(mpSeparator.getLiquidOutStream());\nmpRecycle.setOutletStream(mpRecycleInlet);\nmpRecycle.setTolerance(1e-2);\nmpRecycle.setAccelerationMethod(AccelerationMethod.BROYDEN);\nmpRecycle.setPriority(200);  // Run second\nprocess.add(mpRecycle);\n\nprocess.run();\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#example-3-using-recyclecontroller","title":"Example 3: Using RecycleController","text":"<p>For coordinated control of multiple recycles:</p> <pre><code>// Create recycle controller\nRecycleController controller = new RecycleController();\n\n// Add recycles with priorities\ncontroller.addRecycle(hpRecycle, 1);  // Priority 1 (highest)\ncontroller.addRecycle(mpRecycle, 2);  // Priority 2\ncontroller.addRecycle(lpRecycle, 3);  // Priority 3\n\n// Set acceleration method for all recycles\ncontroller.setAccelerationMethod(AccelerationMethod.BROYDEN);\n\n// Configure controller\ncontroller.setMaxIterations(50);\ncontroller.setGlobalTolerance(1e-3);\n\n// Run coordinated convergence\ncontroller.converge();\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#recyclecontroller-for-multiple-recycles","title":"RecycleController for Multiple Recycles","text":"<p>The <code>RecycleController</code> class provides coordinated management of multiple recycle loops.</p>"},{"location":"simulation/recycle_acceleration_guide/#features","title":"Features","text":"<ul> <li>Priority-based sequencing: Converge recycles in order of importance</li> <li>Unified acceleration: Apply the same method to all recycles</li> <li>Global convergence tracking: Monitor overall system convergence</li> <li>Nested loop handling: Properly handle recycles within recycles</li> <li>Simultaneous modular solving: Accelerate multiple recycles together using shared Broyden updates</li> <li>Coordinated acceleration: Treat tear streams at the same priority level as a coupled system</li> </ul>"},{"location":"simulation/recycle_acceleration_guide/#simultaneous-modular-solving","title":"Simultaneous Modular Solving","text":"<p>When multiple recycles operate at the same priority level, the controller can accelerate them simultaneously using a shared Broyden accelerator. This treats all tear stream variables as a single coupled system, which can dramatically improve convergence for tightly interacting recycles.</p> <pre><code>RecycleController controller = new RecycleController();\ncontroller.addRecycle(recycle1, 100);  // Same priority\ncontroller.addRecycle(recycle2, 100);  // Same priority - will be accelerated together\n\n// Enable coordinated acceleration (default: true)\ncontroller.setUseCoordinatedAcceleration(true);\n\n// Run simultaneous acceleration for all recycles at this priority\nboolean converged = controller.runSimultaneousAcceleration(100, 1e-4, 50);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#convergence-diagnostics","title":"Convergence Diagnostics","text":"<p>The controller provides detailed diagnostics for troubleshooting:</p> <pre><code>// Get formatted diagnostic report\nSystem.out.println(controller.getConvergenceDiagnostics());\n\n// Output:\n// RecycleController Diagnostics:\n//   Total recycles: 2\n//   Current priority level: 100\n//   Using coordinated acceleration: true\n//   Recycles at current priority: 2\n//     - Recycle1 [iterations=4, solved=true, errComp=1.2e-05, errFlow=3.5e-06]\n//     - Recycle2 [iterations=9, solved=true, errComp=0.0e+00, errFlow=4.1e-06]\n\n// Query aggregate metrics\nint totalIters = controller.getTotalIterations();\ndouble maxError = controller.getMaxResidualError();\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#api-reference","title":"API Reference","text":"<pre><code>RecycleController controller = new RecycleController();\n\n// Add recycles\ncontroller.addRecycle(recycle, priority);  // Lower priority = converged first\ncontroller.removeRecycle(recycle);\n\n// Configure\ncontroller.setAccelerationMethod(AccelerationMethod.WEGSTEIN);\ncontroller.setMaxIterations(100);\ncontroller.setGlobalTolerance(1e-4);\ncontroller.setUseCoordinatedAcceleration(true);  // Enable simultaneous solving\n\n// Execute\ncontroller.converge();\n\n// Simultaneous acceleration for a specific priority level\nboolean converged = controller.runSimultaneousAcceleration(priorityLevel, tolerance, maxIter);\n\n// Query status\nboolean converged = controller.isConverged();\nint totalIterations = controller.getTotalIterations();\ndouble maxError = controller.getMaxResidualError();\nString diagnostics = controller.getConvergenceDiagnostics();\nList&lt;Recycle&gt; unconverged = controller.getUnconvergedRecycles();\n\n// Reset for re-running\ncontroller.resetAll();\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Benchmarks on a 3-stage separation train with 2 liquid recycles (~20 process units):</p> Method Average Time Iterations Speedup Direct Substitution 147 ms 6 1.00x (baseline) Wegstein 125 ms 6 1.18x Broyden 112 ms 6 1.31x"},{"location":"simulation/recycle_acceleration_guide/#observations","title":"Observations","text":"<ol> <li>All methods converge in the same iterations for well-conditioned problems</li> <li>Acceleration methods reduce error faster per iteration</li> <li>Broyden performs best for coupled multi-variable systems</li> <li>Wegstein is simpler with lower overhead</li> </ol>"},{"location":"simulation/recycle_acceleration_guide/#when-acceleration-helps-most","title":"When Acceleration Helps Most","text":"<ul> <li>Processes requiring many iterations (&gt;10)</li> <li>Oscillating or slow-converging recycles</li> <li>Tightly coupled multi-recycle systems</li> <li>Large-scale simulations where time matters</li> </ul>"},{"location":"simulation/recycle_acceleration_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"simulation/recycle_acceleration_guide/#problem-recycle-doesnt-converge","title":"Problem: Recycle doesn't converge","text":"<p>Symptoms: Maximum iterations reached, large residual errors</p> <p>Solutions: 1. Increase <code>maxIterations</code> 2. Loosen tolerance with <code>setTolerance()</code> 3. Try <code>WEGSTEIN</code> for damping 4. Check initial estimates are reasonable 5. Verify process is physically feasible</p> <pre><code>recycle.setMaxIterations(200);\nrecycle.setTolerance(1e-2);\nrecycle.setAccelerationMethod(AccelerationMethod.WEGSTEIN);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#problem-recycle-oscillates","title":"Problem: Recycle oscillates","text":"<p>Symptoms: Error bounces between values, never settles</p> <p>Solutions: 1. Use <code>WEGSTEIN</code> method (provides damping) 2. Reduce Wegstein qMax toward 0 3. Check for competing recycles</p> <pre><code>recycle.setAccelerationMethod(AccelerationMethod.WEGSTEIN);\nrecycle.setWegsteinQMin(-10.0);  // Stronger damping\nrecycle.setWegsteinQMax(-0.5);   // Never use direct substitution\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#problem-broyden-diverges","title":"Problem: Broyden diverges","text":"<p>Symptoms: Error grows exponentially with Broyden</p> <p>Solutions: 1. Fall back to <code>WEGSTEIN</code> or <code>DIRECT_SUBSTITUTION</code> 2. Improve initial estimates 3. The problem may be ill-conditioned</p>"},{"location":"simulation/recycle_acceleration_guide/#problem-slow-convergence","title":"Problem: Slow convergence","text":"<p>Symptoms: Many iterations required</p> <p>Solutions: 1. Try <code>BROYDEN</code> for coupled systems 2. Improve initial stream estimates 3. Consider process restructuring</p>"},{"location":"simulation/recycle_acceleration_guide/#best-practices","title":"Best Practices","text":""},{"location":"simulation/recycle_acceleration_guide/#1-start-simple","title":"1. Start Simple","text":"<p>Begin with <code>DIRECT_SUBSTITUTION</code> (the default). Only switch to acceleration methods if: - Convergence is too slow - Recycle oscillates - You have coupled multi-recycle systems</p>"},{"location":"simulation/recycle_acceleration_guide/#2-set-appropriate-tolerances","title":"2. Set Appropriate Tolerances","text":"<pre><code>// Tight tolerance for final design\nrecycle.setTolerance(1e-4);\nrecycle.setFlowTolerance(0.01, \"kg/hr\");\nrecycle.setTemperatureTolerance(0.1);  // K\n\n// Loose tolerance for initial exploration\nrecycle.setTolerance(1e-2);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#3-use-priorities-for-multiple-recycles","title":"3. Use Priorities for Multiple Recycles","text":"<pre><code>// Outer recycle converges first (lower number = higher priority)\nouterRecycle.setPriority(100);\n\n// Inner recycle converges second\ninnerRecycle.setPriority(200);\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#4-provide-good-initial-estimates","title":"4. Provide Good Initial Estimates","text":"<p>The closer your initial recycle stream is to the solution, the faster convergence:</p> <pre><code>// Estimate based on expected recycle ratio\nStream recycleEstimate = feed.clone(\"recycle estimate\");\nrecycleEstimate.setFlowRate(feed.getFlowRate(\"kg/hr\") * 0.1, \"kg/hr\");  // ~10% recycle\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#5-monitor-convergence","title":"5. Monitor Convergence","text":"<pre><code>process.run();\n\nfor (ProcessEquipmentInterface unit : process.getUnitOperations()) {\n    if (unit instanceof Recycle) {\n        Recycle r = (Recycle) unit;\n        System.out.println(r.getName() + \": \" + r.getIterations() + \" iterations, \" +\n                          \"converged=\" + r.solved());\n    }\n}\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#6-method-selection-guide","title":"6. Method Selection Guide","text":"<pre><code>START\n  \u2502\n  \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Does direct substitution    \u2502\n\u2502 converge in &lt; 10 iterations?\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n   YES  \u2502  NO\n        \u2502   \u2502\n        \u25bc   \u25bc\n     DONE  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502 Is the recycle oscillating? \u2502\n           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n              YES  \u2502  NO\n                   \u2502   \u2502\n                   \u25bc   \u25bc\n            WEGSTEIN  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502 Are there multiple coupled  \u2502\n                      \u2502 recycles?                   \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                         YES  \u2502  NO\n                              \u2502   \u2502\n                              \u25bc   \u25bc\n                         BROYDEN  WEGSTEIN\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#free-sensitivity-analysis-from-convergence","title":"Free Sensitivity Analysis from Convergence","text":"<p>One powerful advantage of using the Broyden method is that the inverse Jacobian computed during convergence can be reused for sensitivity analysis at no additional computational cost.</p>"},{"location":"simulation/recycle_acceleration_guide/#how-it-works","title":"How It Works","text":"<p>During Broyden convergence, the accelerator builds an approximation of the inverse Jacobian matrix \\(B^{-1}\\) where:</p> \\[B \\approx I - \\frac{\\partial g}{\\partial x}\\] <p>This matrix relates input perturbations to output changes for the tear stream variables. After convergence, you can extract this for free:</p> <pre><code>// After running process with coordinated acceleration\nRecycleController controller = process.getRecycleController();\n\nif (controller.hasSensitivityData()) {\n    // Get as SensitivityMatrix for named access\n    SensitivityMatrix sensMatrix = controller.getTearStreamSensitivityMatrix();\n\n    // Query individual sensitivities\n    double dT_dP = sensMatrix.getSensitivity(\n        \"recycle1.temperature\", \n        \"recycle1.pressure\"\n    );\n\n    // Or get raw Jacobian for matrix operations\n    double[][] jacobian = controller.getConvergenceJacobian();\n\n    // See variable names\n    List&lt;String&gt; varNames = controller.getTearStreamVariableNames();\n    // Returns: [\"recycle1.temperature\", \"recycle1.pressure\", \"recycle1.flowRate\", ...]\n}\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#comparison-with-finite-differences","title":"Comparison with Finite Differences","text":"Method Cost Accuracy Availability Broyden Jacobian Free (0 extra runs) Approximate After Broyden convergence Finite Differences 2n extra simulations Central differences Always Monte Carlo N samples \u00d7 n runs Statistical Always <p>For tear stream variables, the Broyden Jacobian provides instant sensitivity estimates without any additional simulations.</p>"},{"location":"simulation/recycle_acceleration_guide/#use-cases","title":"Use Cases","text":"<ol> <li>Uncertainty Propagation: How inlet uncertainties affect recycle convergence</li> <li>Control Analysis: Which variables most strongly affect others</li> <li>Design Sensitivity: Impact of design parameters on recycle conditions</li> <li>Model Validation: Compare against finite difference results</li> </ol>"},{"location":"simulation/recycle_acceleration_guide/#general-sensitivity-analysis","title":"General Sensitivity Analysis","text":"<p>For sensitivities beyond tear stream variables, use the <code>ProcessSensitivityAnalyzer</code>:</p> <pre><code>ProcessSensitivityAnalyzer analyzer = new ProcessSensitivityAnalyzer(process);\n\nSensitivityMatrix result = analyzer\n    .withInput(\"feed\", \"temperature\")\n    .withInput(\"feed\", \"flowRate\", \"kg/hr\")\n    .withOutput(\"product\", \"temperature\")\n    .compute();  // Uses Broyden Jacobian when possible, else FD\n\nString report = analyzer.generateReport(result);\n</code></pre> <p>See Graph-Based Process Simulation - Process Sensitivity Analysis for full documentation.</p>"},{"location":"simulation/recycle_acceleration_guide/#api-reference_1","title":"API Reference","text":""},{"location":"simulation/recycle_acceleration_guide/#recycle-class","title":"Recycle Class","text":"<pre><code>// Acceleration method\nvoid setAccelerationMethod(AccelerationMethod method)\nAccelerationMethod getAccelerationMethod()\n\n// Wegstein parameters\nvoid setWegsteinQMin(double qMin)  // Default: -5.0\nvoid setWegsteinQMax(double qMax)  // Default: 0.0\ndouble getWegsteinQMin()\ndouble getWegsteinQMax()\n\n// Tolerances\nvoid setTolerance(double tolerance)\nvoid setFlowTolerance(double tol, String unit)\nvoid setTemperatureTolerance(double tol)\nvoid setCompositionTolerance(double tol)\n\n// Iteration control\nvoid setMaxIterations(int max)\nint getIterations()\nboolean solved()\n\n// Priority for multi-recycle coordination\nvoid setPriority(int priority)\nint getPriority()\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#accelerationmethod-enum","title":"AccelerationMethod Enum","text":"<pre><code>public enum AccelerationMethod {\n    DIRECT_SUBSTITUTION,  // Simple successive substitution\n    WEGSTEIN,             // Wegstein acceleration with bounded q\n    BROYDEN               // Broyden's quasi-Newton method\n}\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#recyclecontroller-class","title":"RecycleController Class","text":"<pre><code>// Setup\nvoid addRecycle(Recycle recycle)\nvoid setUseCoordinatedAcceleration(boolean use)\nvoid init()\n\n// Running\nvoid runCurrentPriorityLevel()\nvoid runSimultaneousAcceleration()\nvoid runAllPriorityLevels()\n\n// Diagnostics\nint getRecycleCount()\nList&lt;Recycle&gt; getRecyclesAtCurrentPriority()\nString getConvergenceDiagnostics()\n\n// Sensitivity analysis (FREE from Broyden convergence)\nboolean hasSensitivityData()\nSensitivityMatrix getTearStreamSensitivityMatrix()\ndouble[][] getConvergenceJacobian()\nList&lt;String&gt; getTearStreamVariableNames()\n</code></pre>"},{"location":"simulation/recycle_acceleration_guide/#references","title":"References","text":"<ol> <li> <p>Wegstein, J.H. (1958). \"Accelerating convergence of iterative processes\". Communications of the ACM, 1(6), 9-13.</p> </li> <li> <p>Broyden, C.G. (1965). \"A class of methods for solving nonlinear simultaneous equations\". Mathematics of Computation, 19(92), 577-593.</p> </li> <li> <p>Seader, J.D., Henley, E.J., &amp; Roper, D.K. (2011). Separation Process Principles. Wiley. Chapter on sequential modular simulation.</p> </li> </ol>"},{"location":"simulation/recycle_acceleration_guide/#see-also","title":"See Also","text":"<ul> <li>Graph-Based Process Simulation - Detailed guide on graph algorithms and sensitivity analysis</li> <li>\ud83d\udcd3 GraphBasedProcessSimulation.ipynb - Interactive Jupyter notebook example</li> </ul> <p>Last updated: December 2025</p>"},{"location":"simulation/turboexpander_compressor_model/","title":"TurboExpanderCompressor Model","text":"<p>This document summarizes the mathematical basis of the coupled expander/compressor model, how reference curves are applied (and can be replaced), and provides a usage walkthrough for configuring and running the unit in a process simulation.</p>"},{"location":"simulation/turboexpander_compressor_model/#mathematical-basis","title":"Mathematical Basis","text":"<p>The expander and compressor share a shaft speed that is iteratively adjusted until the expander power balances the compressor power plus bearing losses using a Newton-Raphson iteration. The key computational steps are described below.</p>"},{"location":"simulation/turboexpander_compressor_model/#expander-calculations","title":"Expander Calculations","text":""},{"location":"simulation/turboexpander_compressor_model/#1-isentropic-enthalpy-drop","title":"1. Isentropic Enthalpy Drop","text":"<p>The isentropic enthalpy drop across the expander is calculated from an isentropic flash at the target outlet pressure:</p> \\[ \\Delta h_s = (h_{in} - h_{out,s}) \\times 1000 \\quad \\text{[J/kg]} \\] <p>where \\(h_{in}\\) is the inlet enthalpy and \\(h_{out,s}\\) is the isentropic outlet enthalpy.</p>"},{"location":"simulation/turboexpander_compressor_model/#2-velocity-ratio-calculation","title":"2. Velocity Ratio Calculation","text":"<p>The tip speed \\(U\\) and spouting (jet) velocity \\(C\\) are computed as:</p> \\[ U = \\frac{\\pi \\cdot D \\cdot N}{60} \\] \\[ C = \\sqrt{2 \\cdot \\Delta h_s} \\] <p>The velocity ratio is then:</p> \\[ u_c = \\frac{U}{C \\cdot u_{c,design}} \\] <p>An efficiency correction factor is evaluated from the UC reference curve based on this ratio.</p>"},{"location":"simulation/turboexpander_compressor_model/#3-efficiency-corrections","title":"3. Efficiency Corrections","text":"<p>The actual expander isentropic efficiency is calculated by applying correction factors:</p> \\[ \\eta_s = \\eta_{s,design} \\cdot f_{UC}(u_c) \\cdot f_{Q/N}\\left(\\frac{Q/N}{(Q/N)_{design}}\\right) \\] <p>where: - \\(f_{UC}\\) is the velocity ratio correction factor from the UC curve - \\(f_{Q/N}\\) is the optional flow coefficient correction from the Q/N efficiency spline</p>"},{"location":"simulation/turboexpander_compressor_model/#4-expander-shaft-power","title":"4. Expander Shaft Power","text":"<p>The expander shaft power is:</p> \\[ W_{expander} = \\dot{m} \\cdot \\Delta h_s \\cdot \\eta_s \\] <p>where \\(\\dot{m}\\) is the mass flow rate.</p>"},{"location":"simulation/turboexpander_compressor_model/#compressor-calculations","title":"Compressor Calculations","text":""},{"location":"simulation/turboexpander_compressor_model/#1-head-and-efficiency-corrections","title":"1. Head and Efficiency Corrections","text":"<p>The compressor polytropic head and efficiency are corrected for off-design operation:</p> \\[ H_p = H_{p,design} \\cdot f_{head}\\left(\\frac{Q/N}{(Q/N)_{design}}\\right) \\cdot \\left(\\frac{N}{N_{design}}\\right)^2 \\] \\[ \\eta_p = \\eta_{p,design} \\cdot f_{\\eta}\\left(\\frac{Q/N}{(Q/N)_{design}}\\right) \\] <p>where: - \\(f_{head}\\) is the head correction factor from the Q/N head spline - \\(f_{\\eta}\\) is the efficiency correction factor from the Q/N efficiency spline - The \\((N/N_{design})^2\\) term applies the fan law scaling for head</p>"},{"location":"simulation/turboexpander_compressor_model/#2-compressor-shaft-power","title":"2. Compressor Shaft Power","text":"<p>The compressor shaft power is:</p> \\[ W_{comp} = \\frac{\\dot{m} \\cdot H_p}{\\eta_p} \\]"},{"location":"simulation/turboexpander_compressor_model/#power-balance-and-speed-iteration","title":"Power Balance and Speed Iteration","text":"<p>The Newton-Raphson iteration solves for the shaft speed \\(N\\) that satisfies:</p> \\[ f(N) = W_{expander} - \\left(W_{comp} + W_{bearing}\\right) = 0 \\] <p>where the bearing losses are modeled as a quadratic function of speed:</p> \\[ W_{bearing} = k \\cdot N^2 \\] <p>The iteration continues until the power mismatch is negligible or iteration limits are reached. The final speed is applied to compute outlet stream properties.</p>"},{"location":"simulation/turboexpander_compressor_model/#reference-curves","title":"Reference Curves","text":"<p>Three types of reference curves tune performance away from the design point:</p>"},{"location":"simulation/turboexpander_compressor_model/#1-ucefficiency-curve","title":"1. UC/Efficiency Curve","text":"<p>A constrained parabola through the peak at \\((u_c = 1, \\eta = 1)\\):</p> \\[ f_{UC}(u_c) = a \\cdot u_c^2 + b \\cdot u_c + c \\] <p>The curve can be replaced with <code>setUCcurve(ucValues, efficiencyValues)</code> if alternate test data are available.</p>"},{"location":"simulation/turboexpander_compressor_model/#2-qn-efficiency-curve","title":"2. Q/N Efficiency Curve","text":"<p>A monotonic cubic Hermite spline built from paired Q/N and efficiency arrays via <code>setQNEfficiencycurve</code>:</p> \\[ f_{\\eta}\\left(\\frac{Q/N}{(Q/N)_{design}}\\right) = \\text{spline interpolation} \\] <p>Values are extrapolated linearly outside the provided range, allowing off-map operation while preserving trend continuity.</p>"},{"location":"simulation/turboexpander_compressor_model/#3-qn-head-curve","title":"3. Q/N Head Curve","text":"<p>A similar cubic Hermite spline created with <code>setQNHeadcurve</code> that scales polytropic head at off-design flows:</p> \\[ f_{head}\\left(\\frac{Q/N}{(Q/N)_{design}}\\right) = \\text{spline interpolation} \\] <p>Like the efficiency spline, it preserves monotonicity and extrapolates linearly beyond the data range.</p> <p>Note: Curve coefficients are stored on the equipment instance and can be replaced at runtime to test alternative reference maps or updated dynamically from external performance monitoring tools.</p>"},{"location":"simulation/turboexpander_compressor_model/#using-the-model","title":"Using the Model","text":""},{"location":"simulation/turboexpander_compressor_model/#step-1-construct-the-unit-and-streams","title":"Step 1: Construct the Unit and Streams","text":"<p>Clone feeds for the expander and compressor outputs when instantiating the equipment.</p>"},{"location":"simulation/turboexpander_compressor_model/#step-2-set-design-parameters","title":"Step 2: Set Design Parameters","text":"<p>Provide impeller diameter, design speed, efficiencies, design Q/N, and optional expander design Q/N if expander flow corrections are needed. The defaults mirror the embedded design values but can be overridden through the available setters.</p>"},{"location":"simulation/turboexpander_compressor_model/#step-3-load-reference-curves-optional","title":"Step 3: Load Reference Curves (Optional)","text":"<p>If site-specific head or efficiency curves exist, call <code>setUCcurve</code>, <code>setQNEfficiencycurve</code>, and <code>setQNHeadcurve</code> with measured points before running the unit.</p>"},{"location":"simulation/turboexpander_compressor_model/#step-4-run-the-model","title":"Step 4: Run the Model","text":"<p>Call <code>run(UUID id)</code> (or the no-argument overload) to iterate speed matching and populate result fields and outlet streams. Retrieve shaft powers with <code>getPowerExpander(unit)</code> and <code>getPowerCompressor(unit)</code> or inspect efficiencies, head, and Q/N ratios through the getters.</p>"},{"location":"simulation/turboexpander_compressor_model/#example-code","title":"Example Code","text":"<p>A realistic setup that mirrors common plant data collection and map-updating workflows:</p> <pre><code>TurboExpanderCompressor turboExpanderComp = new TurboExpanderCompressor(\n    \"TurboExpanderCompressor\", jt_tex_splitter.getSplitStream(0));\nturboExpanderComp.setUCcurve(\n    new double[] {0.9964751359624449, 0.7590835113213541, 0.984295619176559, 0.8827799803397821,\n        0.9552460269880922, 1.0},\n    new double[] {0.984090909090909, 0.796590909090909, 0.9931818181818183, 0.9363636363636364,\n        0.9943181818181818, 1.0});\nturboExpanderComp.setQNEfficiencycurve(\n    new double[] {0.5, 0.7, 0.85, 1.0, 1.2, 1.4, 1.6},\n    new double[] {0.88, 0.91, 0.95, 1.0, 0.97, 0.85, 0.6});\nturboExpanderComp.setQNHeadcurve(\n    new double[] {0.5, 0.8, 1.0, 1.2, 1.4, 1.6},\n    new double[] {1.1, 1.05, 1.0, 0.9, 0.7, 0.4});\nturboExpanderComp.setImpellerDiameter(0.424);\nturboExpanderComp.setDesignSpeed(6850.0);\nturboExpanderComp.setExpanderDesignIsentropicEfficiency(0.88);\nturboExpanderComp.setDesignUC(0.7);\nturboExpanderComp.setDesignQn(0.03328);\nturboExpanderComp.setExpanderOutPressure(inp.expander_out_pressure);\nturboExpanderComp.setCompressorDesignPolytropicEfficiency(0.81);\nturboExpanderComp.setCompressorDesignPolytropicHead(20.47);\nturboExpanderComp.setMaximumIGVArea(1.637e4);\n\n// Run the coupled model and retrieve power with unit conversion\nturboExpanderComp.run();\ndouble expanderPowerMW = turboExpanderComp.getPowerExpander(\"MW\");\ndouble compressorPowerMW = turboExpanderComp.getPowerCompressor(\"MW\");\n</code></pre>"},{"location":"simulation/turboexpander_compressor_model/#parameter-reference","title":"Parameter Reference","text":""},{"location":"simulation/turboexpander_compressor_model/#velocity-ratio-uc-curve","title":"Velocity Ratio (UC) Curve","text":"Parameter Description <code>setUCcurve(ucValues, effValues)</code> Normalizes the velocity ratio \\(u_c = \\frac{U}{C \\cdot u_{c,design}}\\) to an efficiency multiplier via a constrained parabola fitted to the supplied points"},{"location":"simulation/turboexpander_compressor_model/#qn-curves","title":"Q/N Curves","text":"Parameter Description <code>setQNEfficiencycurve(qnValues, effValues)</code> Cubic Hermite spline that scales expander and compressor efficiencies against flow coefficient deviations \\(Q/N\\) <code>setQNHeadcurve(qnValues, headValues)</code> Spline used to scale the compressor polytropic head for off-design flows before applying the \\((N/N_{design})^2\\) speed law"},{"location":"simulation/turboexpander_compressor_model/#geometry-and-design-point","title":"Geometry and Design Point","text":"Parameter Description <code>setImpellerDiameter(D)</code> Impeller diameter [m] \u2014 sets the peripheral velocity \\(U\\) at design, anchoring UC corrections <code>setDesignSpeed(N)</code> Design rotational speed [rpm] \u2014 anchor for Newton iteration speed matching <code>setExpanderDesignIsentropicEfficiency(\u03b7)</code> Base isentropic efficiency multiplied by curve correction factors <code>setCompressorDesignPolytropicEfficiency(\u03b7)</code> Base polytropic efficiency for the compressor <code>setCompressorDesignPolytropicHead(Hp)</code> Design polytropic head [kJ/kg] <code>setDesignUC(uc)</code> Design velocity ratio for the expander <code>setDesignQn(qn)</code> Reference flow coefficient \\((Q/N)_{design}\\) for the compressor <code>setDesignExpanderQn(qn)</code> Reference flow coefficient for the expander (optional)"},{"location":"simulation/turboexpander_compressor_model/#operating-conditions","title":"Operating Conditions","text":"Parameter Description <code>setExpanderOutPressure(P)</code> Target outlet pressure for the isentropic flash that produces \\(\\Delta h_s\\)"},{"location":"simulation/turboexpander_compressor_model/#igv-geometry","title":"IGV Geometry","text":"Parameter Description <code>setMaximumIGVArea(A)</code> Maximum inlet guide vane throat area [mm\u00b2] <code>setIgvAreaIncreaseFactor(f)</code> Optional factor to expand available IGV area <p>Tip: The same update paths can be invoked during runtime if monitoring identifies drift in the reference maps; supplying new curve points and re-running will propagate the new performance predictions.</p>"},{"location":"simulation/turboexpander_compressor_model/#igv-handling","title":"IGV Handling","text":"<p>The Inlet Guide Vane (IGV) opening is computed from the last stage enthalpy drop, mass flow, and volumetric flow each time <code>run()</code> completes.</p>"},{"location":"simulation/turboexpander_compressor_model/#igv-calculation-method","title":"IGV Calculation Method","text":"<p>The helper <code>evaluateIGV</code> performs the following:</p> <ol> <li>Infer density from the fluid properties</li> <li>Estimate nozzle velocity from half the stage enthalpy drop:</li> </ol> \\[ v_{nozzle} = \\sqrt{\\Delta h_{stage}} \\] <ol> <li>Derive required area to pass the flow:</li> </ol> \\[ A_{required} = \\frac{\\dot{V}}{v_{nozzle}} \\] <ol> <li>Calculate IGV opening as the area ratio:</li> </ol> \\[ \\text{IGV}_{opening} = \\min\\left(\\frac{A_{required}}{A_{throat}}, 1.0\\right) \\]"},{"location":"simulation/turboexpander_compressor_model/#igv-area-expansion","title":"IGV Area Expansion","text":"<p>If the required area exceeds the installed IGV area, an optional enlargement factor (<code>setIgvAreaIncreaseFactor</code>) increases the available area:</p> \\[ A_{available} = A_{max} \\cdot f_{increase} \\]"},{"location":"simulation/turboexpander_compressor_model/#igv-output-methods","title":"IGV Output Methods","text":"Method Description <code>calcIGVOpening()</code> Returns the calculated IGV opening fraction (0\u20131) <code>calcIGVOpenArea()</code> Returns the actual open area [mm\u00b2] <code>getCurrentIGVArea()</code> Returns the current IGV throat area [mm\u00b2]"},{"location":"simulation/well_and_choke_simulation/","title":"Well and choke simulation in NeqSim","text":""},{"location":"simulation/well_and_choke_simulation/#overview","title":"Overview","text":"<p>NeqSim combines well inflow performance relationships with hydraulic flowline models and production chokes to represent surface networks. A <code>WellFlowlineNetwork</code> assembles wells, optional chokes, and pipelines into branches that are gathered in manifolds for steady-state or transient calculations.</p>"},{"location":"simulation/well_and_choke_simulation/#well-inflow-models","title":"Well inflow models","text":"<p><code>WellFlow</code> supports several inflow performance relationships that can either solve for outlet pressure from a specified flow or compute flow from a specified outlet pressure:</p> <ul> <li>Production index (PI) \u2013 Constant PI using squared-pressure drawdown.</li> <li>Vogel \u2013 Empirical oil well relationship using a reference test to derive the productivity curve.</li> <li>Fetkovich \u2013 Gas deliverability using C and n coefficients in squared-pressure space.</li> <li>Backpressure with non-Darcy term \u2013 Deliverability equation \\(p_r^2 - p_{wf}^2 = a \\cdot q + b \\cdot q^2\\) where the quadratic term captures turbulence/non-Darcy skin. The model is solved in either direction, with guards for insufficient drawdown.</li> <li>Table-driven inflow \u2013 User-supplied pairs of bottom-hole pressure and flow rate are sorted and linearly interpolated to compute flow or back-calculate the required pressure for a requested rate.</li> </ul> <p>All models can switch between computing outlet pressure or flow via <code>solveFlowFromOutletPressure(boolean)</code>, enabling backpressure solves from downstream network pressure when desired.</p>"},{"location":"simulation/well_and_choke_simulation/#choke-representation","title":"Choke representation","text":"<p>Production chokes are modeled as <code>ThrottlingValve</code> instances using IEC 60534 sizing. Chokes can be attached per branch and run in steady-state or transient mode. Valve travel and characterization are captured through the underlying valve model, and choking conditions can be toggled and tuned at the valve level.</p>"},{"location":"simulation/well_and_choke_simulation/#network-coupling","title":"Network coupling","text":"<p><code>WellFlowlineNetwork</code> wires wells and optional chokes into <code>PipeBeggsAndBrills</code> flowlines, collects them in manifolds, and optionally sends the combined stream downstream. The network offers steady-state and transient execution modes, supports target endpoint pressure solving, and can propagate arrival pressures back to well outlets for iterative backpressure calculations.</p>"},{"location":"simulation/well_simulation_guide/","title":"NeqSim Well Simulation Guide","text":"<p>This guide covers NeqSim's well simulation capabilities, providing functionality for production system modeling including IPR models, VLP correlations, operating point calculation, lift curve generation, and multi-layer commingled production.</p>"},{"location":"simulation/well_simulation_guide/#overview","title":"Overview","text":"<p>NeqSim provides three main classes for well simulation:</p> Class Purpose Key Features <code>WellFlow</code> Inflow Performance (IPR) Vogel, Fetkovich, Backpressure, Table, Multi-layer <code>TubingPerformance</code> Vertical Lift (VLP) Beggs-Brill, Hagedorn-Brown, Gray, Hasan-Kabir, Duns-Ros <code>WellSystem</code> Integrated Well Model IPR+VLP coupling, Operating point solver, Lift curves"},{"location":"simulation/well_simulation_guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Inflow Performance Relationships (IPR)</li> <li>Vertical Lift Performance (VLP)</li> <li>Operating Point Calculation</li> <li>Lift Curve Generation</li> <li>Multi-Layer Commingled Wells</li> <li>Temperature Models</li> <li>Integration with Process Simulation</li> <li>Complete Examples</li> </ol>"},{"location":"simulation/well_simulation_guide/#inflow-performance-relationships-ipr","title":"Inflow Performance Relationships (IPR)","text":"<p>The <code>WellFlow</code> class models reservoir-to-wellbore inflow using several IPR models.</p>"},{"location":"simulation/well_simulation_guide/#available-ipr-models","title":"Available IPR Models","text":""},{"location":"simulation/well_simulation_guide/#1-production-index-darcy-flow","title":"1. Production Index (Darcy Flow)","text":"<p>For single-phase or undersaturated liquid flow:</p> <pre><code>q = PI \u00d7 (P_res\u00b2 - P_wf\u00b2)\n</code></pre> <pre><code>WellFlow well = new WellFlow(\"producer\");\nwell.setInletStream(reservoirStream);\nwell.setWellProductionIndex(1.5e-6); // Sm\u00b3/day/bar\u00b2\nwell.setOutletPressure(150.0, \"bara\");\nwell.solveFlowFromOutletPressure(true);\nwell.run();\nSystem.out.println(\"Flow rate: \" + well.getOutletStream().getFlowRate(\"MSm3/day\"));\n</code></pre>"},{"location":"simulation/well_simulation_guide/#2-vogel-equation-1968","title":"2. Vogel Equation (1968)","text":"<p>For solution-gas-drive reservoirs below bubble point:</p> <pre><code>q/q_max = 1 - 0.2(P_wf/P_res) - 0.8(P_wf/P_res)\u00b2\n</code></pre> <pre><code>// From well test data: 500 Sm\u00b3/day at 120 bara, reservoir at 200 bara\nwell.setVogelIPR(500.0, 120.0, 200.0);\nwell.setOutletPressure(100.0, \"bara\");\nwell.solveFlowFromOutletPressure(true);\nwell.run();\n</code></pre>"},{"location":"simulation/well_simulation_guide/#3-fetkovich-equation-1973","title":"3. Fetkovich Equation (1973)","text":"<p>Empirical model for gas wells:</p> <pre><code>q = C \u00d7 (P_res\u00b2 - P_wf\u00b2)^n\n</code></pre> <pre><code>well.setFetkovichIPR(0.012, 0.85);  // C and n coefficients\n</code></pre>"},{"location":"simulation/well_simulation_guide/#4-backpressure-equation","title":"4. Backpressure Equation","text":"<p>Gas wells with non-Darcy (turbulent) flow:</p> <pre><code>P_res\u00b2 - P_wf\u00b2 = A\u00d7q + B\u00d7q\u00b2\n</code></pre> <p>Where A is the Darcy term and B is the non-Darcy (rate-dependent) term.</p> <pre><code>well.setBackpressureIPR(0.5, 0.001);  // A and B coefficients\n</code></pre>"},{"location":"simulation/well_simulation_guide/#5-table-driven-ipr","title":"5. Table-Driven IPR","text":"<p>For measured IPR curves from well tests:</p> <pre><code>double[] pressures = {50, 80, 100, 120, 150, 180};  // bara\ndouble[] rates = {2.5, 2.0, 1.6, 1.2, 0.7, 0.2};    // MSm\u00b3/day\nwell.setTableIPR(pressures, rates);\n</code></pre>"},{"location":"simulation/well_simulation_guide/#6-loading-ipr-from-csv-file","title":"6. Loading IPR from CSV File","text":"<p>Load IPR curves from external files (e.g., from well test analysis software):</p> <pre><code>// Load IPR curve from CSV file\nWellFlow well = new WellFlow(\"producer\");\nwell.setInletStream(reservoirStream);\nwell.loadIPRFromFile(\"path/to/ipr_curve.csv\");\nwell.run();\n</code></pre> <p>CSV file format: <pre><code>Pwf(bara),Rate(MSm3/day)\n50,5.2\n80,4.1\n100,3.2\n120,2.4\n150,1.5\n180,0.8\n200,0.2\n</code></pre></p>"},{"location":"simulation/well_simulation_guide/#vertical-lift-performance-vlp","title":"Vertical Lift Performance (VLP)","text":"<p>The <code>TubingPerformance</code> class calculates pressure drop in tubing using multiphase correlations.</p>"},{"location":"simulation/well_simulation_guide/#available-vlp-correlations","title":"Available VLP Correlations","text":"Correlation Best For Flow Patterns Beggs-Brill All inclinations All patterns Hagedorn-Brown Vertical oil wells Slug, bubble Gray Gas wells Mist, annular Hasan-Kabir Mechanistic All patterns Duns-Ros Gas-liquid All patterns"},{"location":"simulation/well_simulation_guide/#basic-vlp-calculation","title":"Basic VLP Calculation","text":"<pre><code>import neqsim.process.equipment.pipeline.TubingPerformance;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create tubing model\nTubingPerformance tubing = new TubingPerformance(\"tubing\");\ntubing.setInletStream(feedStream);\ntubing.setDiameter(0.1);          // 100 mm ID\ntubing.setLength(3000.0);         // 3000 m TVD\ntubing.setInclination(90.0);      // Vertical\ntubing.setRoughness(0.00005);     // 50 microns\n\n// Select correlation\ntubing.setCorrelationType(TubingPerformance.CorrelationType.BEGGS_BRILL);\n\n// Run calculation\ntubing.run();\n\n// Get results\ndouble outletPressure = tubing.getOutletStream().getPressure(\"bara\");\ndouble pressureDrop = tubing.getPressureDrop();\n</code></pre>"},{"location":"simulation/well_simulation_guide/#setting-vlp-correlation","title":"Setting VLP Correlation","text":"<pre><code>// Beggs-Brill (default, all inclinations)\ntubing.setCorrelationType(TubingPerformance.CorrelationType.BEGGS_BRILL);\n\n// Hagedorn-Brown (vertical oil wells)\ntubing.setCorrelationType(TubingPerformance.CorrelationType.HAGEDORN_BROWN);\n\n// Gray (gas wells)\ntubing.setCorrelationType(TubingPerformance.CorrelationType.GRAY);\n\n// Hasan-Kabir (mechanistic)\ntubing.setCorrelationType(TubingPerformance.CorrelationType.HASAN_KABIR);\n\n// Duns-Ros (gas-liquid)\ntubing.setCorrelationType(TubingPerformance.CorrelationType.DUNS_ROS);\n</code></pre>"},{"location":"simulation/well_simulation_guide/#table-based-vlp","title":"Table-Based VLP","text":"<p>Use pre-calculated or measured VLP curves instead of correlations:</p> <pre><code>// Set VLP table programmatically\ndouble[] flowRates = {0.5, 1.0, 2.0, 3.0, 4.0, 5.0};  // MSm\u00b3/day\ndouble[] bhpValues = {85, 92, 115, 145, 182, 225};    // bara\ndouble whp = 50.0;  // Wellhead pressure (bara)\n\nTubingPerformance tubing = new TubingPerformance(\"tubing\");\ntubing.setTableVLP(flowRates, bhpValues, whp);\n\n// Interpolate BHP for a given flow rate\ndouble bhp = tubing.interpolateBHPFromTable(2.5);  // MSm\u00b3/day\n</code></pre>"},{"location":"simulation/well_simulation_guide/#loading-vlp-from-csv-file","title":"Loading VLP from CSV File","text":"<p>Load VLP curves from external files (e.g., from PROSPER, Pipesim, or other tools):</p> <pre><code>TubingPerformance tubing = new TubingPerformance(\"tubing\");\ntubing.loadVLPFromFile(\"path/to/vlp_curve.csv\", 50.0);  // WHP = 50 bara\n\n// Use interpolation\ndouble bhp = tubing.interpolateBHPFromTable(3.0);  // Get BHP at 3 MSm\u00b3/day\n</code></pre> <p>CSV file format: <pre><code>FlowRate(MSm3/day),BHP(bara)\n0.5,85\n1.0,92\n2.0,115\n3.0,145\n4.0,182\n5.0,225\n</code></pre></p>"},{"location":"simulation/well_simulation_guide/#operating-point-calculation","title":"Operating Point Calculation","text":"<p>The <code>WellSystem</code> class finds the intersection of IPR and VLP curves using an optimized bisection algorithm.</p>"},{"location":"simulation/well_simulation_guide/#using-wellsystem-for-operating-point","title":"Using WellSystem for Operating Point","text":"<pre><code>import neqsim.process.equipment.reservoir.WellSystem;\nimport neqsim.process.equipment.stream.Stream;\n\n// Create reservoir stream\nStream reservoirStream = new Stream(\"reservoir\", reservoirFluid);\nreservoirStream.setFlowRate(5000.0, \"Sm3/day\");\nreservoirStream.setTemperature(100.0, \"C\");\nreservoirStream.setPressure(280.0, \"bara\");\n\n// Create well system with inlet stream\nWellSystem well = new WellSystem(\"production_well\", reservoirStream);\n\n// Configure IPR model\nwell.setIPRModel(WellSystem.IPRModel.PRODUCTION_INDEX);\nwell.setProductionIndex(2.5e-6, \"Sm3/day/bar2\");\n\n// Configure tubing (VLP)\nwell.setWellheadPressure(60.0, \"bara\");\nwell.setTubingDiameter(4.0, \"in\");\nwell.setTubingLength(3000.0, \"m\");\nwell.setInclination(85.0);  // degrees from horizontal\n\n// Configure temperature model\nwell.setBottomHoleTemperature(100.0, \"C\");\nwell.setWellheadTemperature(50.0, \"C\");\n\n// Find operating point\nwell.run();\n\n// Results\ndouble flowRate = well.getOperatingFlowRate(\"Sm3/day\");\ndouble bhp = well.getBottomHolePressure(\"bara\");\ndouble drawdown = well.getDrawdown(\"bar\");\nSystem.out.println(\"Operating point: \" + flowRate + \" Sm\u00b3/day at \" + bhp + \" bara BHP\");\nSystem.out.println(\"Drawdown: \" + drawdown + \" bar\");\n</code></pre>"},{"location":"simulation/well_simulation_guide/#ipr-models-available","title":"IPR Models Available","text":"Model Enum Value Parameters Production Index <code>PRODUCTION_INDEX</code> <code>setProductionIndex(pi, unit)</code> Vogel (1968) <code>VOGEL</code> <code>setVogelParameters(qMax, pwfTest, pRes)</code> Fetkovich (1973) <code>FETKOVICH</code> <code>setFetkovichParameters(C, n, pRes)</code> Backpressure <code>BACKPRESSURE</code> <code>setBackpressureParameters(A, B)</code>"},{"location":"simulation/well_simulation_guide/#operating-point-methods","title":"Operating Point Methods","text":"Method Description <code>getOperatingFlowRate(unit)</code> Flow rate at IPR-VLP intersection <code>getBottomHolePressure(unit)</code> Bottom-hole pressure at operating point <code>getWellheadPressure(unit)</code> Wellhead pressure (target constraint) <code>getDrawdown(unit)</code> Reservoir pressure - BHP <code>getOutletStream()</code> Output stream for downstream connection"},{"location":"simulation/well_simulation_guide/#lift-curve-generation","title":"Lift Curve Generation","text":"<p>Generate IPR and VLP curves for nodal analysis.</p>"},{"location":"simulation/well_simulation_guide/#generating-vlp-curve-tubing-performance","title":"Generating VLP Curve (Tubing Performance)","text":"<pre><code>TubingPerformance tubing = new TubingPerformance(\"tubing\");\ntubing.setInletStream(gasStream);\ntubing.setDiameter(0.1);\ntubing.setLength(3000.0);\ntubing.setCorrelationType(TubingPerformance.CorrelationType.BEGGS_BRILL);\n\n// Generate VLP curve\ndouble[] flowRates = {0.1, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0};  // MSm\u00b3/day\ndouble[][] vlpCurve = tubing.generateVLPCurve(flowRates);\n\n// vlpCurve[0] = flow rates\n// vlpCurve[1] = required bottom-hole pressures\nfor (int i = 0; i &lt; vlpCurve[0].length; i++) {\n    System.out.printf(\"Flow: %.2f MSm\u00b3/day, BHP: %.1f bara%n\",\n        vlpCurve[0][i], vlpCurve[1][i]);\n}\n</code></pre>"},{"location":"simulation/well_simulation_guide/#generating-ipr-curve","title":"Generating IPR Curve","text":"<pre><code>WellSystem well = new WellSystem(\"producer\");\nwell.setReservoirPressure(280.0, \"bara\");\nwell.setProductivityIndex(2.5e-6);\nwell.setIprModel(WellSystem.IPRModel.PRODUCTION_INDEX);\n\n// Generate IPR curve (flowing BHP vs flow rate)\ndouble minPwf = 50.0;\ndouble maxPwf = 270.0;\nint points = 20;\ndouble[][] iprCurve = well.generateIPRCurve(minPwf, maxPwf, points);\n\n// iprCurve[0] = flowing BHP values\n// iprCurve[1] = corresponding flow rates\n</code></pre>"},{"location":"simulation/well_simulation_guide/#combined-nodal-analysis-plot-data","title":"Combined Nodal Analysis Plot Data","text":"<pre><code>WellSystem well = new WellSystem(\"nodal_analysis\");\n// ... configure well ...\n\n// Get both curves\ndouble[][] iprCurve = well.generateIPRCurve(50, 270, 20);\ndouble[][] vlpCurve = well.generateVLPCurve(new double[]{0.5, 1.0, 2.0, 3.0, 4.0, 5.0});\n\n// Operating point\nwell.run();\ndouble opFlow = well.getOperatingFlowRate(\"MSm3/day\");\ndouble opBHP = well.getOperatingBHP(\"bara\");\n\n// Export to CSV or plot\nSystem.out.println(\"IPR Curve:\");\nfor (int i = 0; i &lt; iprCurve[0].length; i++) {\n    System.out.printf(\"%.1f, %.3f%n\", iprCurve[0][i], iprCurve[1][i]);\n}\nSystem.out.println(\"\\nVLP Curve:\");\nfor (int i = 0; i &lt; vlpCurve[0].length; i++) {\n    System.out.printf(\"%.3f, %.1f%n\", vlpCurve[0][i], vlpCurve[1][i]);\n}\nSystem.out.printf(\"\\nOperating Point: %.3f MSm\u00b3/day at %.1f bara%n\", opFlow, opBHP);\n</code></pre>"},{"location":"simulation/well_simulation_guide/#multi-layer-commingled-wells","title":"Multi-Layer Commingled Wells","text":"<p>Model wells producing from multiple reservoir layers.</p>"},{"location":"simulation/well_simulation_guide/#using-wellflow-for-multi-layer","title":"Using WellFlow for Multi-Layer","text":"<pre><code>// Create fluid streams for each layer\nSystemInterface layer1Fluid = new SystemSrkEos(80, 200);\nlayer1Fluid.addComponent(\"methane\", 0.90);\nlayer1Fluid.addComponent(\"ethane\", 0.07);\nlayer1Fluid.addComponent(\"propane\", 0.03);\nlayer1Fluid.setMixingRule(\"classic\");\nStream layer1Stream = new Stream(\"layer1\", layer1Fluid);\nlayer1Stream.run();\n\nSystemInterface layer2Fluid = new SystemSrkEos(95, 220);\nlayer2Fluid.addComponent(\"methane\", 0.85);\nlayer2Fluid.addComponent(\"ethane\", 0.10);\nlayer2Fluid.addComponent(\"propane\", 0.05);\nlayer2Fluid.setMixingRule(\"classic\");\nStream layer2Stream = new Stream(\"layer2\", layer2Fluid);\nlayer2Stream.run();\n\n// Create multi-layer well\nWellFlow well = new WellFlow(\"commingled_well\");\nwell.addLayer(\"Upper Sand\", layer1Stream, 200.0, 1.0e-6);  // 200 bara, PI\nwell.addLayer(\"Lower Sand\", layer2Stream, 220.0, 1.5e-6);  // 220 bara, PI\nwell.setOutletPressure(150.0, \"bara\");  // Common BHP\nwell.run();\n\n// Get individual layer contributions\ndouble[] layerRates = well.getLayerFlowRates(\"MSm3/day\");\nSystem.out.println(\"Layer 1 flow: \" + layerRates[0] + \" MSm\u00b3/day\");\nSystem.out.println(\"Layer 2 flow: \" + layerRates[1] + \" MSm\u00b3/day\");\nSystem.out.println(\"Total flow: \" + well.getOutletStream().getFlowRate(\"MSm3/day\"));\n</code></pre>"},{"location":"simulation/well_simulation_guide/#using-wellsystem-for-multi-layer","title":"Using WellSystem for Multi-Layer","text":"<pre><code>WellSystem well = new WellSystem(\"multi_zone_producer\");\nwell.setWellheadPressure(50.0, \"bara\");\nwell.setTubingDiameter(0.1);\nwell.setTubingLength(3500.0);\n\n// Add layers with different properties\nwell.addLayer(\"Zone A\", streamA, 250.0, 1.2e-6);\nwell.addLayer(\"Zone B\", streamB, 280.0, 0.8e-6);\nwell.addLayer(\"Zone C\", streamC, 265.0, 1.5e-6);\n\n// Find operating point for commingled production\nwell.run();\n\ndouble totalFlow = well.getOperatingFlowRate(\"MSm3/day\");\ndouble bhp = well.getOperatingBHP(\"bara\");\ndouble[] zoneFlows = well.getLayerFlowRates(\"MSm3/day\");\n</code></pre>"},{"location":"simulation/well_simulation_guide/#temperature-models","title":"Temperature Models","text":"<p>Configure wellbore temperature profile for accurate property calculations.</p>"},{"location":"simulation/well_simulation_guide/#available-temperature-models","title":"Available Temperature Models","text":"Model Description Use Case ISOTHERMAL Constant temperature Quick estimates LINEAR_GRADIENT Linear geothermal Simple wells RAMEY Ramey (1962) steady-state Established production HASAN_KABIR Energy balance Transient, accurate"},{"location":"simulation/well_simulation_guide/#setting-temperature-model","title":"Setting Temperature Model","text":"<pre><code>// Isothermal (default)\ntubing.setTemperatureModel(TubingPerformance.TemperatureModel.ISOTHERMAL);\n\n// Linear gradient (specify surface and BH temperatures)\ntubing.setTemperatureModel(TubingPerformance.TemperatureModel.LINEAR_GRADIENT);\ntubing.setSurfaceTemperature(25.0);   // \u00b0C\ntubing.setBottomholeTemperature(90.0);\n\n// Ramey model (needs formation properties)\ntubing.setTemperatureModel(TubingPerformance.TemperatureModel.RAMEY);\ntubing.setFormationThermalConductivity(2.5);  // W/m\u00b7K\ntubing.setOverallHeatTransferCoefficient(25.0);\n\n// Hasan-Kabir energy balance\ntubing.setTemperatureModel(TubingPerformance.TemperatureModel.HASAN_KABIR);\n</code></pre>"},{"location":"simulation/well_simulation_guide/#ramey-temperature-model","title":"Ramey Temperature Model","text":"<p>The Ramey (1962) model accounts for:</p> <ul> <li>Geothermal gradient</li> <li>Heat transfer to formation</li> <li>Joule-Thomson effects</li> <li>Production time dependency</li> </ul> <pre><code>tubing.setTemperatureModel(TubingPerformance.TemperatureModel.RAMEY);\ntubing.setGeothermalGradient(0.03);    // \u00b0C/m\ntubing.setSurfaceTemperature(15.0);     // \u00b0C\ntubing.setFormationThermalConductivity(2.5);\ntubing.setOverallHeatTransferCoefficient(20.0);\ntubing.setProductionTime(365.0);        // days\n</code></pre>"},{"location":"simulation/well_simulation_guide/#integration-with-process-simulation","title":"Integration with Process Simulation","text":""},{"location":"simulation/well_simulation_guide/#complete-well-process-system","title":"Complete Well + Process System","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.equipment.reservoir.*;\nimport neqsim.process.equipment.pipeline.TubingPerformance;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.compressor.Compressor;\n\n// 1. Reservoir and Well\nSimpleReservoir reservoir = new SimpleReservoir(\"reservoir\");\nreservoir.setReservoirFluid(reservoirFluid);\nreservoir.setReservoirPressure(280.0, \"bara\");\nreservoir.setTemperature(85.0, \"C\");\n\nWellFlow inflow = new WellFlow(\"IPR\");\ninflow.setInletStream(reservoir.getOutletStream());\ninflow.setWellProductionIndex(2.0e-6);\n\n// 2. Tubing\nTubingPerformance tubing = new TubingPerformance(\"tubing\");\ntubing.setInletStream(inflow.getOutletStream());\ntubing.setDiameter(0.1);\ntubing.setLength(3000.0);\ntubing.setCorrelationType(TubingPerformance.CorrelationType.BEGGS_BRILL);\n\n// 3. Surface Facilities\nSeparator separator = new Separator(\"HP_sep\");\nseparator.setInletStream(tubing.getOutletStream());\n\nCompressor compressor = new Compressor(\"export_comp\");\ncompressor.setInletStream(separator.getGasOutStream());\ncompressor.setOutletPressure(150.0, \"bara\");\n\n// 4. Build Process System\nProcessSystem plant = new ProcessSystem();\nplant.add(reservoir);\nplant.add(inflow);\nplant.add(tubing);\nplant.add(separator);\nplant.add(compressor);\n\n// 5. Run\nplant.run();\n\n// 6. Results\nSystem.out.println(\"Wellhead pressure: \" + tubing.getOutletStream().getPressure(\"bara\"));\nSystem.out.println(\"Gas export rate: \" + compressor.getOutletStream().getFlowRate(\"MSm3/day\"));\n</code></pre>"},{"location":"simulation/well_simulation_guide/#coupling-with-wellflowlinenetwork","title":"Coupling with WellFlowlineNetwork","text":"<pre><code>// Multiple wells feeding a gathering network\nWellFlowlineNetwork network = new WellFlowlineNetwork(\"field_network\");\n\n// Add wells\nnetwork.addWell(well1);\nnetwork.addWell(well2);\nnetwork.addWell(well3);\n\n// Set manifold back-pressure\nnetwork.setManifoldPressure(40.0, \"bara\");\n\n// Solve network\nnetwork.run();\n\n// Get individual well rates\nfor (WellFlow well : network.getWells()) {\n    System.out.println(well.getName() + \": \" + \n        well.getOutletStream().getFlowRate(\"MSm3/day\") + \" MSm\u00b3/day\");\n}\n</code></pre>"},{"location":"simulation/well_simulation_guide/#complete-examples","title":"Complete Examples","text":""},{"location":"simulation/well_simulation_guide/#example-1-gas-well-analysis","title":"Example 1: Gas Well Analysis","text":"<pre><code>// Rich gas well with Vogel IPR and Beggs-Brill VLP\nSystemInterface gas = new SystemSrkEos(85, 250);\ngas.addComponent(\"nitrogen\", 0.02);\ngas.addComponent(\"CO2\", 0.03);\ngas.addComponent(\"methane\", 0.80);\ngas.addComponent(\"ethane\", 0.08);\ngas.addComponent(\"propane\", 0.04);\ngas.addComponent(\"n-butane\", 0.02);\ngas.addComponent(\"n-pentane\", 0.01);\ngas.setMixingRule(\"classic\");\ngas.init(0);\n\nStream reservoir = new Stream(\"reservoir\", gas);\nreservoir.setFlowRate(3.0, \"MSm3/day\");\nreservoir.run();\n\n// Well system\nWellSystem well = new WellSystem(\"gas_producer\");\nwell.setInletStream(reservoir);\nwell.setReservoirPressure(250.0, \"bara\");\nwell.setProductivityIndex(3.0e-6);\nwell.setWellheadPressure(50.0, \"bara\");\nwell.setTubingDiameter(0.088);  // 3.5\" tubing\nwell.setTubingLength(2800.0);\nwell.setVlpCorrelation(WellSystem.VLPCorrelation.GRAY);\nwell.run();\n\nSystem.out.println(\"=== Gas Well Operating Point ===\");\nSystem.out.println(\"Flow rate: \" + well.getOperatingFlowRate(\"MSm3/day\") + \" MSm\u00b3/day\");\nSystem.out.println(\"BHP: \" + well.getOperatingBHP(\"bara\") + \" bara\");\nSystem.out.println(\"Drawdown: \" + well.getDrawdown() + \" bar\");\n</code></pre>"},{"location":"simulation/well_simulation_guide/#example-2-oil-well-with-artificial-lift-comparison","title":"Example 2: Oil Well with Artificial Lift Comparison","text":"<pre><code>// Compare production with different wellhead pressures (simulating lift)\nWellSystem well = new WellSystem(\"oil_producer\");\nwell.setReservoirPressure(180.0, \"bara\");\nwell.setProductivityIndex(5.0e-6);\nwell.setTubingDiameter(0.076);  // 3\" tubing\nwell.setTubingLength(2000.0);\nwell.setVlpCorrelation(WellSystem.VLPCorrelation.HAGEDORN_BROWN);\n\nSystem.out.println(\"Wellhead Pressure | Flow Rate | BHP\");\nfor (double whp = 10; whp &lt;= 50; whp += 10) {\n    well.setWellheadPressure(whp, \"bara\");\n    well.run();\n    System.out.printf(\"%17.0f | %9.2f | %6.1f%n\",\n        whp, well.getOperatingFlowRate(\"Sm3/day\"), well.getOperatingBHP(\"bara\"));\n}\n</code></pre>"},{"location":"simulation/well_simulation_guide/#example-3-multi-zone-completion","title":"Example 3: Multi-Zone Completion","text":"<pre><code>// Three-zone commingled gas well\nWellSystem well = new WellSystem(\"multizone_gas\");\nwell.setWellheadPressure(45.0, \"bara\");\nwell.setTubingDiameter(0.1);\nwell.setTubingLength(3200.0);\n\n// Zone A: Shallow gas, high perm\nwell.addLayer(\"Zone_A\", shallowStream, 180.0, 4.0e-6);\n// Zone B: Middle, moderate perm\nwell.addLayer(\"Zone_B\", middleStream, 220.0, 2.0e-6);\n// Zone C: Deep, low perm but high pressure\nwell.addLayer(\"Zone_C\", deepStream, 280.0, 0.8e-6);\n\nwell.run();\n\nSystem.out.println(\"=== Multi-Zone Production ===\");\nSystem.out.println(\"Total rate: \" + well.getOperatingFlowRate(\"MSm3/day\") + \" MSm\u00b3/day\");\ndouble[] zoneFlows = well.getLayerFlowRates(\"MSm3/day\");\nSystem.out.println(\"Zone A: \" + zoneFlows[0] + \" MSm\u00b3/day\");\nSystem.out.println(\"Zone B: \" + zoneFlows[1] + \" MSm\u00b3/day\");\nSystem.out.println(\"Zone C: \" + zoneFlows[2] + \" MSm\u00b3/day\");\n</code></pre>"},{"location":"simulation/well_simulation_guide/#api-reference-summary","title":"API Reference Summary","text":""},{"location":"simulation/well_simulation_guide/#wellflow-ipr","title":"WellFlow (IPR)","text":"Method Description <code>setWellProductionIndex(pi)</code> Set productivity index <code>setVogelIPR(qTest, pwfTest, pRes)</code> Configure Vogel IPR <code>setFetkovichIPR(c, n)</code> Configure Fetkovich IPR <code>setBackpressureIPR(a, b)</code> Configure Backpressure IPR <code>setTableIPR(pwf[], rate[])</code> Set table-driven IPR <code>addLayer(name, stream, pRes, pi)</code> Add reservoir layer <code>getLayerFlowRates(unit)</code> Get layer flow contributions"},{"location":"simulation/well_simulation_guide/#tubingperformance-vlp","title":"TubingPerformance (VLP)","text":"Method Description <code>setDiameter(d)</code> Set tubing ID (meters) <code>setLength(L)</code> Set tubing length (meters) <code>setInclination(angle)</code> Set inclination (degrees from horizontal) <code>setRoughness(eps)</code> Set pipe roughness (meters) <code>setCorrelationType(type)</code> Select VLP correlation <code>setTemperatureModel(model)</code> Select temperature model <code>generateVLPCurve(rates)</code> Generate lift curve <code>getPressureDrop()</code> Get calculated pressure drop"},{"location":"simulation/well_simulation_guide/#wellsystem-integrated","title":"WellSystem (Integrated)","text":"Method Description <code>setReservoirPressure(p, unit)</code> Set reservoir pressure <code>setProductivityIndex(pi)</code> Set well PI <code>setWellheadPressure(p, unit)</code> Set tubing outlet pressure <code>setIprModel(model)</code> Select IPR model <code>setVlpCorrelation(corr)</code> Select VLP correlation <code>getOperatingFlowRate(unit)</code> Get operating flow rate <code>getOperatingBHP(unit)</code> Get operating BHP <code>generateIPRCurve(min, max, n)</code> Generate IPR curve <code>generateVLPCurve(rates)</code> Generate VLP curve"},{"location":"simulation/well_simulation_guide/#complete-production-system-example","title":"Complete Production System Example","text":"<p>For a comprehensive example demonstrating the full integration of well simulation with downstream processing, see WellToOilStabilizationExample.java.</p> <p>This example includes: - Reservoir: SimpleReservoir with oil, gas, and water phases - Integrated Well System: WellSystem with Vogel IPR model and optimized VLP solver - Flowline: 5 km pipeline with PipeBeggsAndBrills multiphase flow - Choke Valve: ThrottlingValve with outlet pressure control - Oil Stabilization: Three-stage separation train (HP/MP/LP) - Gas Compression: Multi-stage compression with intercooling - Process System: Complete flowsheet integration</p>"},{"location":"simulation/well_simulation_guide/#using-wellsystem-in-processsystem","title":"Using WellSystem in ProcessSystem","text":"<p>The <code>WellSystem</code> class integrates seamlessly with <code>ProcessSystem</code> for building complete production flowsheets. It uses an optimized IPR+VLP solver with:</p> <ul> <li>Bisection algorithm for robust convergence</li> <li>Simplified VLP correlation for fast pressure drop calculation</li> <li>Direct outlet stream access via <code>getOutletStream()</code></li> </ul> <pre><code>// Create reservoir and reservoir stream\nSimpleReservoir reservoir = new SimpleReservoir(\"Main Reservoir\");\nreservoir.setReservoirFluid(reservoirFluid, 1e6, 10.0, 10.0);\n\nStream reservoirStream = new Stream(\"Reservoir Stream\", reservoir.getReservoirFluid());\nreservoirStream.setFlowRate(5000.0, \"Sm3/day\");\nreservoirStream.setTemperature(100.0, \"C\");\nreservoirStream.setPressure(250.0, \"bara\");\n\n// Create WellSystem with integrated IPR and VLP\nWellSystem well = new WellSystem(\"Producer-1\", reservoirStream);\n\n// Configure IPR model (Vogel for solution gas drive)\nwell.setIPRModel(WellSystem.IPRModel.VOGEL);\nwell.setVogelParameters(8000.0, 180.0, 250.0); // qMax, testPwf, Pr\n\n// Configure VLP (tubing)\nwell.setTubingLength(2500.0, \"m\");\nwell.setTubingDiameter(4.0, \"in\");\nwell.setWellheadPressure(80.0, \"bara\");\nwell.setBottomHoleTemperature(100.0, \"C\");\nwell.setWellheadTemperature(65.0, \"C\");\n\n// Connect downstream equipment\nPipeBeggsAndBrills flowline = new PipeBeggsAndBrills(\"Flowline\");\nflowline.setInletStream(well.getOutletStream());\nflowline.setLength(5000.0);\nflowline.setDiameter(0.2);\n\n// Build complete ProcessSystem\nProcessSystem process = new ProcessSystem();\nprocess.add(well);          // WellSystem as first equipment\nprocess.add(flowline);\nprocess.add(inletChoke);\nprocess.add(hpSeparator);\n// ... add remaining equipment\n\n// Run complete simulation\nprocess.run();\n\n// Access well operating point results\ndouble opRate = well.getOperatingFlowRate(\"Sm3/day\");\ndouble bhp = well.getBottomHolePressure(\"bara\");\ndouble drawdown = well.getDrawdown(\"bar\");\n</code></pre>"},{"location":"simulation/well_simulation_guide/#performance-considerations","title":"Performance Considerations","text":"<p>The <code>WellSystem</code> solver is optimized for speed:</p> Feature Description Simplified VLP Uses hydrostatic + friction correlation instead of full TubingPerformance iteration Bisection solver Robust convergence in ~15-20 iterations Single flash per iteration Minimizes thermodynamic calculations Typical solve time &lt; 1 second for complex fluids <p>For detailed VLP calculations with full correlation support, use <code>TubingPerformance</code> directly.</p>"},{"location":"simulation/well_simulation_guide/#vlp-solver-modes","title":"VLP Solver Modes","text":"<p><code>WellSystem</code> supports multiple VLP solver modes for different accuracy/speed tradeoffs:</p> <pre><code>import neqsim.process.equipment.reservoir.WellSystem.VLPSolverMode;\n\n// Default: Fast simplified solver (hydrostatic + friction)\nwell.setVLPSolverMode(VLPSolverMode.SIMPLIFIED);\n\n// Traditional correlations (via TubingPerformance)\nwell.setVLPSolverMode(VLPSolverMode.BEGGS_BRILL);\nwell.setVLPSolverMode(VLPSolverMode.HAGEDORN_BROWN);\nwell.setVLPSolverMode(VLPSolverMode.GRAY);\nwell.setVLPSolverMode(VLPSolverMode.HASAN_KABIR);\nwell.setVLPSolverMode(VLPSolverMode.DUNS_ROS);\n\n// Advanced multiphase models\nwell.setVLPSolverMode(VLPSolverMode.DRIFT_FLUX);  // Drift-flux with slip\nwell.setVLPSolverMode(VLPSolverMode.TWO_FLUID);   // Separate momentum equations\n</code></pre> VLP Solver Mode Description Speed Accuracy SIMPLIFIED Hydrostatic + friction correlation Fastest Approximate BEGGS_BRILL Beggs &amp; Brill empirical correlation Medium Good for general use HAGEDORN_BROWN Hagedorn-Brown for vertical wells Medium Good for oil wells GRAY Gray correlation for gas wells Medium Good for gas wells HASAN_KABIR Mechanistic model Slow High accuracy DUNS_ROS Duns &amp; Ros correlation Medium Good for gas-liquid DRIFT_FLUX Accounts for phase slip velocity Medium Better for high GOR TWO_FLUID Separate gas/liquid momentum Slowest Highest accuracy"},{"location":"simulation/well_simulation_guide/#see-also","title":"See Also","text":"<ul> <li>Reservoir Simulation - SimpleReservoir class</li> <li>Pipeline Modeling - PipeBeggsAndBrills, TwoFluidPipe</li> <li>Process System - ProcessSystem class</li> </ul>"},{"location":"simulation/well_simulation_guide/#references","title":"References","text":"<ol> <li>Vogel, J.V. (1968). \"Inflow Performance Relationships for Solution-Gas Drive Wells\"</li> <li>Fetkovich, M.J. (1973). \"The Isochronal Testing of Oil Wells\"</li> <li>Beggs, H.D. and Brill, J.P. (1973). \"A Study of Two-Phase Flow in Inclined Pipes\"</li> <li>Hagedorn, A.R. and Brown, K.E. (1965). \"Experimental Study of Pressure Gradients...\"</li> <li>Gray, H.E. (1974). \"Vertical Flow Correlation in Gas Wells\"</li> <li>Hasan, A.R. and Kabir, C.S. (2002). \"Fluid Flow and Heat Transfer in Wellbores\"</li> <li>Ramey, H.J. (1962). \"Wellbore Heat Transmission\"</li> </ol>"},{"location":"standards/","title":"Standards Package","text":"<p>The NeqSim standards package implements international standards for gas and oil quality calculations, enabling compliance verification and sales contract management.</p>"},{"location":"standards/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Sub-Documentation</li> <li>Core Concepts</li> <li>Quick Start</li> <li>Sales Contracts</li> </ul>"},{"location":"standards/#overview","title":"Overview","text":"<p>Location: <code>neqsim.standards</code></p> <p>The standards package provides implementations of:</p> <ol> <li>Gas Quality Standards - ISO 6976, ISO 6974, ISO 6578, ISO 15403, ISO 18453</li> <li>Oil Quality Standards - ASTM D6377 for vapor pressure</li> <li>Sales Contracts - Specification verification against contractual limits</li> </ol> <p>Key Applications: - Calculating calorific values (GCV/LCV) and Wobbe index per ISO 6976 - LNG density calculations per ISO 6578 - Water and hydrocarbon dew point determination - Reid vapor pressure (RVP) calculations - Contractual compliance checking</p>"},{"location":"standards/#package-structure","title":"Package Structure","text":"<pre><code>standards/\n\u251c\u2500\u2500 Standard.java                    # Abstract base class\n\u251c\u2500\u2500 StandardInterface.java           # Interface definition\n\u2502\n\u251c\u2500\u2500 gasquality/                      # Gas quality standards\n\u2502   \u251c\u2500\u2500 Standard_ISO6976.java        # Calorific values &amp; Wobbe index\n\u2502   \u251c\u2500\u2500 Standard_ISO6976_2016.java   # ISO 6976:2016 edition\n\u2502   \u251c\u2500\u2500 Standard_ISO6974.java        # Gas chromatography composition\n\u2502   \u251c\u2500\u2500 Standard_ISO6578.java        # LNG density calculation\n\u2502   \u251c\u2500\u2500 Standard_ISO15403.java       # CNG fuel quality (MON, methane number)\n\u2502   \u251c\u2500\u2500 Draft_ISO18453.java          # Water dew point (GERG-water)\n\u2502   \u251c\u2500\u2500 Draft_GERG2004.java          # GERG-2004 EoS properties\n\u2502   \u251c\u2500\u2500 BestPracticeHydrocarbonDewPoint.java  # HC dew point\n\u2502   \u251c\u2500\u2500 GasChromotograpyhBase.java   # Gas composition base class\n\u2502   \u251c\u2500\u2500 SulfurSpecificationMethod.java  # H2S and sulfur content\n\u2502   \u2514\u2500\u2500 UKspecifications_ICF_SI.java # UK ICF/SI specifications\n\u2502\n\u251c\u2500\u2500 oilquality/                      # Oil quality standards\n\u2502   \u2514\u2500\u2500 Standard_ASTM_D6377.java     # Reid vapor pressure (RVP)\n\u2502\n\u2514\u2500\u2500 salescontract/                   # Contract management\n    \u251c\u2500\u2500 BaseContract.java            # Contract implementation\n    \u251c\u2500\u2500 ContractInterface.java       # Contract interface\n    \u2514\u2500\u2500 ContractSpecification.java   # Individual specifications\n</code></pre>"},{"location":"standards/#sub-documentation","title":"Sub-Documentation","text":"<p>Detailed guides for each major standard:</p> Guide Description ISO 6976 - Calorific Values GCV, LCV, Wobbe index, density from composition ISO 6578 - LNG Density LNG density calculation method ISO 15403 - CNG Quality Methane number and MON for vehicle fuel Dew Point Standards Water and hydrocarbon dew point methods ASTM D6377 - RVP Reid vapor pressure for crude and condensate Sales Contracts Contract specification and compliance checking"},{"location":"standards/#core-concepts","title":"Core Concepts","text":""},{"location":"standards/#standardinterface","title":"StandardInterface","text":"<p>All standards implement <code>StandardInterface</code>:</p> <pre><code>public interface StandardInterface {\n    void calculate();                              // Run calculation\n    double getValue(String parameter);             // Get result\n    double getValue(String parameter, String unit); // Get result with unit\n    String getUnit(String parameter);              // Get unit string\n    boolean isOnSpec();                            // Check compliance\n\n    ContractInterface getSalesContract();          // Get attached contract\n    void setSalesContract(ContractInterface contract);\n    SystemInterface getThermoSystem();             // Get fluid\n}\n</code></pre>"},{"location":"standards/#standard-base-class","title":"Standard Base Class","text":"<p>Standards extend <code>Standard</code>:</p> <pre><code>public abstract class Standard extends NamedBaseClass implements StandardInterface {\n    protected SystemInterface thermoSystem;\n    protected ThermodynamicOperations thermoOps;\n    protected ContractInterface salesContract;\n    protected String standardDescription;\n    private String referenceState = \"real\";  // or \"ideal\"\n    private double referencePressure = 70.0;\n}\n</code></pre>"},{"location":"standards/#reference-states","title":"Reference States","text":"<p>Most gas quality standards support: - Real gas - Accounts for compressibility - Ideal gas - Assumes Z = 1</p> <pre><code>standard.setReferenceState(\"real\");   // Default\nstandard.setReferenceState(\"ideal\");  // Ideal gas assumption\n</code></pre>"},{"location":"standards/#quick-start","title":"Quick Start","text":""},{"location":"standards/#iso-6976-calorific-values","title":"ISO 6976 - Calorific Values","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.standards.gasquality.Standard_ISO6976;\n\n// Create gas composition\nSystemInterface gas = new SystemSrkEos(273.15 + 15, 1.01325);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"propane\", 0.02);\ngas.addComponent(\"nitrogen\", 0.02);\ngas.addComponent(\"CO2\", 0.01);\ngas.setMixingRule(\"classic\");\n\n// Create standard\n// Parameters: system, volumeRefT(\u00b0C), energyRefT(\u00b0C), referenceType\nStandard_ISO6976 iso6976 = new Standard_ISO6976(gas, 15, 15, \"volume\");\niso6976.setReferenceState(\"real\");\n\n// Calculate\niso6976.calculate();\n\n// Get results\ndouble gcv = iso6976.getValue(\"GCV\");           // Gross calorific value [kJ/m\u00b3]\ndouble lcv = iso6976.getValue(\"LCV\");           // Net calorific value [kJ/m\u00b3]\ndouble wobbe = iso6976.getValue(\"SuperiorWobbeIndex\");  // Wobbe index [kJ/m\u00b3]\ndouble relDens = iso6976.getValue(\"RelativeDensity\");   // Relative density [-]\ndouble Z = iso6976.getValue(\"CompressionFactor\");       // Compressibility [-]\ndouble molarMass = iso6976.getValue(\"MolarMass\");       // g/mol\n\nSystem.out.printf(\"GCV = %.2f kJ/m\u00b3%n\", gcv);\nSystem.out.printf(\"Wobbe Index = %.2f kJ/m\u00b3%n\", wobbe);\nSystem.out.printf(\"Relative Density = %.4f%n\", relDens);\n</code></pre>"},{"location":"standards/#lng-density-iso-6578","title":"LNG Density (ISO 6578)","text":"<pre><code>import neqsim.standards.gasquality.Standard_ISO6578;\n\n// LNG composition\nSystemInterface lng = new SystemSrkEos(110, 1.01325);  // -163\u00b0C\nlng.addComponent(\"methane\", 0.92);\nlng.addComponent(\"ethane\", 0.05);\nlng.addComponent(\"propane\", 0.02);\nlng.addComponent(\"nitrogen\", 0.01);\nlng.setMixingRule(\"classic\");\n\n// Calculate density\nStandard_ISO6578 iso6578 = new Standard_ISO6578(lng);\niso6578.calculate();\n\ndouble density = iso6578.getValue(\"density\", \"kg/m3\");\nSystem.out.printf(\"LNG Density = %.2f kg/m\u00b3%n\", density);\n</code></pre>"},{"location":"standards/#water-dew-point-iso-18453","title":"Water Dew Point (ISO 18453)","text":"<pre><code>import neqsim.standards.gasquality.Draft_ISO18453;\n\n// Natural gas with water\nSystemInterface wetGas = new SystemSrkCPA(273.15 + 20, 70.0);\nwetGas.addComponent(\"methane\", 0.95);\nwetGas.addComponent(\"water\", 50e-6);  // 50 ppm water\nwetGas.setMixingRule(\"CPA-EoS\");\n\n// Calculate water dew point\nDraft_ISO18453 waterDewPoint = new Draft_ISO18453(wetGas);\nwaterDewPoint.calculate();\n\ndouble wdp = waterDewPoint.getValue(\"dewPointTemperature\");\nSystem.out.printf(\"Water Dew Point = %.1f \u00b0C%n\", wdp);\n</code></pre>"},{"location":"standards/#reid-vapor-pressure-astm-d6377","title":"Reid Vapor Pressure (ASTM D6377)","text":"<pre><code>import neqsim.standards.oilquality.Standard_ASTM_D6377;\n\n// Crude oil / condensate\nSystemInterface crude = new SystemSrkEos(273.15 + 15, 1.0);\ncrude.addComponent(\"methane\", 0.02);\ncrude.addComponent(\"ethane\", 0.03);\ncrude.addComponent(\"propane\", 0.05);\ncrude.addComponent(\"n-butane\", 0.08);\ncrude.addComponent(\"n-pentane\", 0.10);\ncrude.addTBPfraction(\"C6\", 0.15, 86/1000.0, 0.66);\ncrude.addTBPfraction(\"C10\", 0.30, 142/1000.0, 0.78);\ncrude.addTBPfraction(\"C20\", 0.27, 282/1000.0, 0.85);\ncrude.setMixingRule(\"classic\");\n\n// Calculate RVP\nStandard_ASTM_D6377 rvpStandard = new Standard_ASTM_D6377(crude);\nrvpStandard.setMethodRVP(\"VPCR4\");  // Options: VPCR4, RVP_ASTM_D6377, RVP_ASTM_D323_82\nrvpStandard.calculate();\n\ndouble rvp = rvpStandard.getValue(\"RVP\", \"bara\");\ndouble tvp = rvpStandard.getValue(\"TVP\", \"bara\");\nSystem.out.printf(\"RVP = %.3f bara%n\", rvp);\nSystem.out.printf(\"TVP = %.3f bara%n\", tvp);\n</code></pre>"},{"location":"standards/#sales-contracts","title":"Sales Contracts","text":""},{"location":"standards/#creating-a-contract","title":"Creating a Contract","text":"<pre><code>import neqsim.standards.salescontract.BaseContract;\nimport neqsim.standards.salescontract.ContractInterface;\n\n// Create contract from database\nContractInterface contract = new BaseContract(gas, \"Kaarstoe\", \"Norway\");\n\n// Run compliance check\ncontract.runCheck();\n\n// Get results\nString[][] results = contract.getResultTable();\nint numSpecs = contract.getSpecificationsNumber();\n\n// Display results\ncontract.display();\n</code></pre>"},{"location":"standards/#attaching-contract-to-standard","title":"Attaching Contract to Standard","text":"<pre><code>Standard_ISO6976 standard = new Standard_ISO6976(gas);\nstandard.setSalesContract(contract);\nstandard.calculate();\n\n// Check if on specification\nboolean onSpec = standard.isOnSpec();\n</code></pre>"},{"location":"standards/#custom-contract-specifications","title":"Custom Contract Specifications","text":"<pre><code>import neqsim.standards.salescontract.ContractSpecification;\n\n// Create custom specification\nContractSpecification spec = new ContractSpecification(\n    \"Water Dew Point\",           // Name\n    \"Maximum water dew point\",   // Description\n    \"Norway\",                    // Country\n    \"Kaarstoe\",                  // Terminal\n    waterDewPointStandard,       // Standard method\n    -20.0,                       // Min value\n    -8.0,                        // Max value\n    \"\u00b0C\",                        // Unit\n    15.0,                        // Reference T measurement\n    15.0,                        // Reference T combustion\n    70.0,                        // Reference pressure\n    \"At 70 bar\"                  // Comments\n);\n</code></pre>"},{"location":"standards/#available-return-parameters","title":"Available Return Parameters","text":""},{"location":"standards/#iso-6976","title":"ISO 6976","text":"Parameter Description Unit <code>GCV</code> / <code>SuperiorCalorificValue</code> Gross calorific value kJ/m\u00b3 <code>LCV</code> / <code>InferiorCalorificValue</code> Net calorific value kJ/m\u00b3 <code>SuperiorWobbeIndex</code> Superior Wobbe index kJ/m\u00b3 <code>InferiorWobbeIndex</code> Inferior Wobbe index kJ/m\u00b3 <code>WI</code> Wobbe index (alias) kJ/m\u00b3 <code>RelativeDensity</code> Relative density (air=1) - <code>CompressionFactor</code> Compressibility factor Z - <code>MolarMass</code> Average molar mass g/mol <code>DensityIdeal</code> Ideal gas density kg/m\u00b3 <code>DensityReal</code> Real gas density kg/m\u00b3"},{"location":"standards/#iso-6578","title":"ISO 6578","text":"Parameter Description Unit <code>density</code> LNG density kg/m\u00b3"},{"location":"standards/#astm-d6377","title":"ASTM D6377","text":"Parameter Description Unit <code>RVP</code> Reid vapor pressure bara <code>TVP</code> True vapor pressure bara <code>VPCR4</code> Vapor pressure at V/L=4 bara"},{"location":"standards/#reference-conditions","title":"Reference Conditions","text":""},{"location":"standards/#standard-temperaturepressure","title":"Standard Temperature/Pressure","text":"Standard Volume Ref T Energy Ref T Pressure ISO 6976 0, 15, 20\u00b0C 0, 15, 20, 25\u00b0C, 60\u00b0F 1.01325 bar ISO 6578 -160 to -140\u00b0C - 1.01325 bar ASTM D6377 37.8\u00b0C (100\u00b0F) - -"},{"location":"standards/#setting-reference-conditions","title":"Setting Reference Conditions","text":"<pre><code>// ISO 6976 with specific reference conditions\nStandard_ISO6976 standard = new Standard_ISO6976(\n    gas,\n    15.0,      // Volume reference temperature (\u00b0C)\n    25.0,      // Energy reference temperature (\u00b0C)  \n    \"volume\"   // Reference type: \"volume\", \"mass\", or \"molar\"\n);\n\n// Modify reference conditions after creation\nstandard.setVolRefT(0.0);      // Volume at 0\u00b0C\nstandard.setEnergyRefT(15.0);  // Combustion at 15\u00b0C\n</code></pre>"},{"location":"standards/#best-practices","title":"Best Practices","text":""},{"location":"standards/#composition-normalization","title":"Composition Normalization","text":"<ul> <li>Ensure compositions sum to 1.0 before calculation</li> <li>Standards internally use mole fractions</li> </ul>"},{"location":"standards/#component-coverage","title":"Component Coverage","text":"<ul> <li>ISO 6976 has data for common natural gas components</li> <li>Unknown components are approximated (HC \u2192 n-heptane, alcohols \u2192 methanol)</li> <li>Check <code>componentsNotDefinedByStandard</code> for warnings</li> </ul>"},{"location":"standards/#reference-state-selection","title":"Reference State Selection","text":"<ul> <li>Use \"real\" for custody transfer calculations</li> <li>Use \"ideal\" for simplified comparisons</li> <li>Document the reference state used</li> </ul>"},{"location":"standards/#contract-database","title":"Contract Database","text":"<ul> <li>Contract specifications are stored in database table <code>gascontractspecifications</code></li> <li>Query by terminal and country</li> </ul>"},{"location":"standards/#references","title":"References","text":"<ol> <li>ISO 6976:2016 - Natural gas \u2014 Calculation of calorific values, density, relative density and Wobbe indices from composition</li> <li>ISO 6578:2017 - Refrigerated hydrocarbon liquids \u2014 Static measurement \u2014 Calculation procedure</li> <li>ISO 15403-1:2006 - Natural gas \u2014 Natural gas for use as a compressed fuel for vehicles</li> <li>ISO 18453:2004 - Natural gas \u2014 Correlation between water content and water dew point</li> <li>ASTM D6377 - Standard Test Method for Determination of Vapor Pressure of Crude Oil</li> <li>GERG-2004 - The GERG-2004 Wide-Range Equation of State for Natural Gases and Other Mixtures</li> </ol>"},{"location":"standards/astm_d6377_rvp/","title":"ASTM D6377 - Reid Vapor Pressure","text":"<p>ASTM D6377 provides methods for determining vapor pressure of crude oil and petroleum products.</p>"},{"location":"standards/astm_d6377_rvp/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Vapor Pressure Definitions</li> <li>Implementation</li> <li>Usage Examples</li> <li>Method Selection</li> <li>Correlations</li> </ul>"},{"location":"standards/astm_d6377_rvp/#overview","title":"Overview","text":"<p>Standard: ASTM D6377 - Standard Test Method for Determination of Vapor Pressure of Crude Oil: VPCRx (Expansion Method)</p> <p>Purpose: Determine the vapor pressure of crude oil and condensates for: - Safety in storage and transport - Product specifications - Blending calculations - Regulatory compliance</p> <p>Class: <code>Standard_ASTM_D6377</code></p>"},{"location":"standards/astm_d6377_rvp/#vapor-pressure-definitions","title":"Vapor Pressure Definitions","text":""},{"location":"standards/astm_d6377_rvp/#true-vapor-pressure-tvp","title":"True Vapor Pressure (TVP)","text":"<p>The equilibrium pressure of vapor above a liquid at a specified temperature when vapor/liquid ratio approaches zero.</p> \\[TVP = P_{bubble}(T)\\]"},{"location":"standards/astm_d6377_rvp/#reid-vapor-pressure-rvp","title":"Reid Vapor Pressure (RVP)","text":"<p>The vapor pressure measured at 100\u00b0F (37.8\u00b0C) in a standardized apparatus with vapor/liquid volume ratio of 4:1.</p>"},{"location":"standards/astm_d6377_rvp/#vpcr4-vapor-pressure-at-vl-4","title":"VPCR4 (Vapor Pressure at V/L = 4)","text":"<p>The pressure at which 80% by volume is vapor at 37.8\u00b0C (100\u00b0F).</p>"},{"location":"standards/astm_d6377_rvp/#vpcr-relationship","title":"VPCR Relationship","text":"<p>Different VPCR ratios are used in various standards: - VPCR4: 80% vapor (ASTM D6377) - VPCR1: 50% vapor - VPCR0.02: ~2% vapor (approximates TVP)</p>"},{"location":"standards/astm_d6377_rvp/#implementation","title":"Implementation","text":""},{"location":"standards/astm_d6377_rvp/#constructor","title":"Constructor","text":"<pre><code>import neqsim.standards.oilquality.Standard_ASTM_D6377;\n\n// Create standard from fluid\nStandard_ASTM_D6377 rvpStandard = new Standard_ASTM_D6377(thermoSystem);\n</code></pre>"},{"location":"standards/astm_d6377_rvp/#available-methods","title":"Available Methods","text":"Method Name Description <code>VPCR4</code> Vapor pressure at V/L = 4 (default) <code>VPCR4_no_water</code> VPCR4 excluding water <code>RVP_ASTM_D6377</code> RVP correlation from D6377 <code>RVP_ASTM_D323_73_79</code> RVP per D323 (1973/1979) <code>RVP_ASTM_D323_82</code> RVP per D323 (1982)"},{"location":"standards/astm_d6377_rvp/#key-methods","title":"Key Methods","text":"Method Description <code>calculate()</code> Perform vapor pressure calculations <code>getValue(\"RVP\", \"bara\")</code> Get Reid vapor pressure <code>getValue(\"TVP\", \"bara\")</code> Get true vapor pressure <code>getValue(\"VPCR4\", \"bara\")</code> Get VPCR4 <code>setMethodRVP(method)</code> Select RVP calculation method <code>getMethodRVP()</code> Get current method"},{"location":"standards/astm_d6377_rvp/#usage-examples","title":"Usage Examples","text":""},{"location":"standards/astm_d6377_rvp/#basic-rvp-calculation","title":"Basic RVP Calculation","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.standards.oilquality.Standard_ASTM_D6377;\n\n// Create condensate/crude composition\nSystemInterface crude = new SystemSrkEos(273.15 + 15, 1.01325);\ncrude.addComponent(\"methane\", 0.01);\ncrude.addComponent(\"ethane\", 0.02);\ncrude.addComponent(\"propane\", 0.04);\ncrude.addComponent(\"n-butane\", 0.06);\ncrude.addComponent(\"i-butane\", 0.03);\ncrude.addComponent(\"n-pentane\", 0.08);\ncrude.addComponent(\"i-pentane\", 0.05);\ncrude.addComponent(\"n-hexane\", 0.10);\ncrude.addTBPfraction(\"C7\", 0.15, 100.0/1000.0, 0.72);\ncrude.addTBPfraction(\"C10\", 0.20, 142.0/1000.0, 0.78);\ncrude.addTBPfraction(\"C20\", 0.26, 282.0/1000.0, 0.85);\ncrude.setMixingRule(\"classic\");\n\n// Calculate RVP\nStandard_ASTM_D6377 rvpStandard = new Standard_ASTM_D6377(crude);\nrvpStandard.setMethodRVP(\"VPCR4\");\nrvpStandard.calculate();\n\n// Get results\ndouble tvp = rvpStandard.getValue(\"TVP\", \"bara\");\ndouble rvp = rvpStandard.getValue(\"RVP\", \"bara\");\ndouble vpcr4 = rvpStandard.getValue(\"VPCR4\", \"bara\");\n\nSystem.out.println(\"=== Vapor Pressure Results ===\");\nSystem.out.printf(\"True Vapor Pressure (TVP) = %.4f bara%n\", tvp);\nSystem.out.printf(\"Reid Vapor Pressure (RVP) = %.4f bara%n\", rvp);\nSystem.out.printf(\"VPCR4 = %.4f bara%n\", vpcr4);\n</code></pre>"},{"location":"standards/astm_d6377_rvp/#comparing-different-rvp-methods","title":"Comparing Different RVP Methods","text":"<pre><code>// Calculate using all available methods\nString[] methods = {\"VPCR4\", \"RVP_ASTM_D6377\", \"RVP_ASTM_D323_73_79\", \"RVP_ASTM_D323_82\"};\n\nSystem.out.println(\"Method                | RVP (bara)\");\nSystem.out.println(\"----------------------|----------\");\n\nfor (String method : methods) {\n    Standard_ASTM_D6377 std = new Standard_ASTM_D6377(crude);\n    std.setMethodRVP(method);\n    std.calculate();\n    double rvp = std.getValue(\"RVP\", \"bara\");\n    System.out.printf(\"%-21s | %.4f%n\", method, rvp);\n}\n</code></pre>"},{"location":"standards/astm_d6377_rvp/#effect-of-light-ends-on-rvp","title":"Effect of Light Ends on RVP","text":"<pre><code>// Analyze RVP sensitivity to light ends\ndouble[] methaneContent = {0.0, 0.005, 0.01, 0.02, 0.05};\n\nSystem.out.println(\"Methane (mol%) | RVP (bara)\");\nSystem.out.println(\"---------------|----------\");\n\nfor (double ch4 : methaneContent) {\n    SystemInterface fluid = new SystemSrkEos(273.15 + 15, 1.0);\n    fluid.addComponent(\"methane\", ch4);\n    fluid.addComponent(\"ethane\", 0.02);\n    fluid.addComponent(\"propane\", 0.04);\n    fluid.addComponent(\"n-butane\", 0.08);\n    fluid.addComponent(\"n-pentane\", 0.10);\n    fluid.addTBPfraction(\"C7\", 0.20, 100/1000.0, 0.72);\n    fluid.addTBPfraction(\"C15\", 0.56 - ch4, 200/1000.0, 0.80);\n    fluid.setMixingRule(\"classic\");\n\n    Standard_ASTM_D6377 std = new Standard_ASTM_D6377(fluid);\n    std.calculate();\n    double rvp = std.getValue(\"RVP\", \"bara\");\n\n    System.out.printf(\"%14.1f | %.4f%n\", ch4 * 100, rvp);\n}\n</code></pre>"},{"location":"standards/astm_d6377_rvp/#wet-vs-dry-rvp","title":"Wet vs Dry RVP","text":"<pre><code>// Calculate with and without water\nSystemInterface wetCrude = crude.clone();\nwetCrude.addComponent(\"water\", 0.01);  // 1% water\n\nStandard_ASTM_D6377 wetStd = new Standard_ASTM_D6377(wetCrude);\nwetStd.calculate();\n\ndouble vpcr4Wet = wetStd.getValue(\"VPCR4\", \"bara\");\ndouble vpcr4Dry = wetStd.getValue(\"VPCR4_no_water\", \"bara\");\n\nSystem.out.printf(\"VPCR4 (with water) = %.4f bara%n\", vpcr4Wet);\nSystem.out.printf(\"VPCR4 (dry basis) = %.4f bara%n\", vpcr4Dry);\n</code></pre>"},{"location":"standards/astm_d6377_rvp/#method-selection","title":"Method Selection","text":""},{"location":"standards/astm_d6377_rvp/#vpcr4-default","title":"VPCR4 (Default)","text":"<p>Best for: - General crude oil characterization - Comparison with standard lab measurements - Regulatory compliance</p>"},{"location":"standards/astm_d6377_rvp/#rvp_astm_d6377","title":"RVP_ASTM_D6377","text":"<p>Correlation from ASTM D6377: $\\(RVP = 0.834 \\times VPCR4\\)$</p>"},{"location":"standards/astm_d6377_rvp/#rvp_astm_d323_82","title":"RVP_ASTM_D323_82","text":"<p>Correlation from ASTM D323 (1982 edition): $\\(RVP = \\frac{0.752 \\times (100 \\times VPCR4) + 6.07}{100}\\)$</p>"},{"location":"standards/astm_d6377_rvp/#rvp_astm_d323_73_79","title":"RVP_ASTM_D323_73_79","text":"<p>For comparison with historical data using D323 (1973/1979 editions). Uses VPCR4 without water contribution.</p>"},{"location":"standards/astm_d6377_rvp/#correlations","title":"Correlations","text":""},{"location":"standards/astm_d6377_rvp/#tvp-to-rvp","title":"TVP to RVP","text":"<p>Approximate relationship: $\\(RVP \\approx 0.75 \\times TVP + constant\\)$</p> <p>The constant depends on crude composition.</p>"},{"location":"standards/astm_d6377_rvp/#temperature-dependence","title":"Temperature Dependence","text":"<p>For estimation at temperatures other than 37.8\u00b0C:</p> \\[\\log_{10}(P_{vap}) = A - \\frac{B}{T + C}\\] <p>Antoine-type equation where A, B, C are crude-specific.</p>"},{"location":"standards/astm_d6377_rvp/#rvp-specifications","title":"RVP Specifications","text":"Product Typical RVP Limit Crude oil (export) &lt; 0.7 bara (10 psia) Stabilized condensate &lt; 0.5 bara (7 psia) Gasoline (summer) &lt; 0.62 bara (9 psi) Gasoline (winter) &lt; 0.90 bara (13 psi)"},{"location":"standards/astm_d6377_rvp/#technical-details","title":"Technical Details","text":""},{"location":"standards/astm_d6377_rvp/#calculation-procedure","title":"Calculation Procedure","text":"<ol> <li>Set temperature to 37.8\u00b0C (100\u00b0F)</li> <li>Perform bubble point flash to get TVP</li> <li>Perform flash at vapor/liquid volume ratio = 4</li> <li>Apply correlation for RVP estimation</li> </ol>"},{"location":"standards/astm_d6377_rvp/#reference-conditions","title":"Reference Conditions","text":"Parameter Value Temperature 37.8\u00b0C (100\u00b0F) V/L ratio 4:1 (80% vapor by volume) Pressure Equilibrium"},{"location":"standards/astm_d6377_rvp/#equation-of-state","title":"Equation of State","text":"<p>Uses SRK-EoS for phase equilibrium calculations.</p>"},{"location":"standards/astm_d6377_rvp/#accuracy-considerations","title":"Accuracy Considerations","text":""},{"location":"standards/astm_d6377_rvp/#factors-affecting-accuracy","title":"Factors Affecting Accuracy","text":"<ol> <li>Light end characterization - Accurate C1-C4 composition critical</li> <li>Heavy end representation - TBP fractions affect liquid volume</li> <li>Water content - Can significantly affect measured RVP</li> <li>Sample handling - Light end loss during sampling</li> </ol>"},{"location":"standards/astm_d6377_rvp/#typical-uncertainty","title":"Typical Uncertainty","text":"Method Uncertainty VPCR4 calculation \u00b10.02 bara RVP correlation \u00b10.03-0.05 bara"},{"location":"standards/astm_d6377_rvp/#recommendations","title":"Recommendations","text":"<ol> <li>Ensure accurate light ends (C1-C5) analysis</li> <li>Use consistent method for comparison</li> <li>Report method used with results</li> <li>Consider water content effects</li> </ol>"},{"location":"standards/astm_d6377_rvp/#references","title":"References","text":"<ol> <li>ASTM D6377 - Standard Test Method for Determination of Vapor Pressure of Crude Oil: VPCRx (Expansion Method)</li> <li>ASTM D323 - Standard Test Method for Vapor Pressure of Petroleum Products (Reid Method)</li> <li>ASTM D5191 - Standard Test Method for Vapor Pressure of Petroleum Products and Liquid Fuels (Mini Method)</li> <li>API MPMS Chapter 8 - Sampling</li> </ol>"},{"location":"standards/dew_point_standards/","title":"Dew Point Standards","text":"<p>Standards for calculating water and hydrocarbon dew points of natural gas.</p>"},{"location":"standards/dew_point_standards/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Water Dew Point (ISO 18453)</li> <li>Hydrocarbon Dew Point</li> <li>Usage Examples</li> <li>Comparison of Methods</li> </ul>"},{"location":"standards/dew_point_standards/#overview","title":"Overview","text":"<p>Dew point specifications are critical for: - Pipeline transport (preventing liquid dropout) - Custody transfer specifications - Processing plant design - Sales contract compliance</p> <p>Available Implementations: - <code>Draft_ISO18453</code> - Water dew point using GERG-water equation - <code>BestPracticeHydrocarbonDewPoint</code> - Hydrocarbon dew point using SRK-EoS</p>"},{"location":"standards/dew_point_standards/#water-dew-point-iso-18453","title":"Water Dew Point (ISO 18453)","text":""},{"location":"standards/dew_point_standards/#standard","title":"Standard","text":"<p>ISO 18453:2004 - Natural gas \u2014 Correlation between water content and water dew point</p>"},{"location":"standards/dew_point_standards/#purpose","title":"Purpose","text":"<p>Calculate the temperature at which water vapor in natural gas begins to condense at a given pressure.</p>"},{"location":"standards/dew_point_standards/#implementation","title":"Implementation","text":"<p>Class: <code>Draft_ISO18453</code></p> <p>Uses the GERG-water equation of state which is specifically designed for water in natural gas systems.</p>"},{"location":"standards/dew_point_standards/#constructor","title":"Constructor","text":"<pre><code>import neqsim.standards.gasquality.Draft_ISO18453;\n\n// Create standard from any fluid\nDraft_ISO18453 waterDewPoint = new Draft_ISO18453(thermoSystem);\n</code></pre>"},{"location":"standards/dew_point_standards/#how-it-works","title":"How It Works","text":"<ol> <li>Converts input fluid to GERG-water EoS if not already</li> <li>Sets pressure to reference pressure (default 70 bar)</li> <li>Performs water dew point temperature flash</li> <li>Returns temperature where water just begins to condense</li> </ol>"},{"location":"standards/dew_point_standards/#key-methods","title":"Key Methods","text":"Method Description <code>calculate()</code> Perform dew point calculation <code>getValue(\"dewPointTemperature\")</code> Get dew point in \u00b0C <code>getValue(\"pressure\")</code> Get reference pressure in bar <code>setReferencePressure(P)</code> Set reference pressure <code>isOnSpec()</code> Check against sales contract specification"},{"location":"standards/dew_point_standards/#example","title":"Example","text":"<pre><code>import neqsim.thermo.system.SystemSrkCPAstatoil;\nimport neqsim.standards.gasquality.Draft_ISO18453;\n\n// Natural gas with water\nSystemInterface wetGas = new SystemSrkCPAstatoil(273.15 + 20, 50.0);\nwetGas.addComponent(\"methane\", 0.90);\nwetGas.addComponent(\"ethane\", 0.05);\nwetGas.addComponent(\"propane\", 0.02);\nwetGas.addComponent(\"CO2\", 0.02);\nwetGas.addComponent(\"water\", 100e-6);  // 100 ppm water\nwetGas.setMixingRule(\"CPA_Statoil\");\n\n// Calculate water dew point\nDraft_ISO18453 iso18453 = new Draft_ISO18453(wetGas);\niso18453.setReferencePressure(70.0);  // 70 bar reference\niso18453.calculate();\n\ndouble wdp = iso18453.getValue(\"dewPointTemperature\");\nSystem.out.printf(\"Water Dew Point at 70 bar = %.1f \u00b0C%n\", wdp);\n</code></pre>"},{"location":"standards/dew_point_standards/#specification-checking","title":"Specification Checking","text":"<pre><code>// Check against contract specification\niso18453.getSalesContract().setWaterDewPointTemperature(-8.0);  // Max -8\u00b0C\n\nif (iso18453.isOnSpec()) {\n    System.out.println(\"Gas meets water dew point specification\");\n} else {\n    System.out.println(\"Gas FAILS water dew point specification\");\n}\n</code></pre>"},{"location":"standards/dew_point_standards/#hydrocarbon-dew-point","title":"Hydrocarbon Dew Point","text":""},{"location":"standards/dew_point_standards/#purpose_1","title":"Purpose","text":"<p>Calculate the temperature at which hydrocarbon liquids begin to condense from natural gas (cricondentherm).</p>"},{"location":"standards/dew_point_standards/#implementation_1","title":"Implementation","text":"<p>Class: <code>BestPracticeHydrocarbonDewPoint</code></p> <p>Uses SRK equation of state with Peneloux volume correction (mixing rule 2) for hydrocarbon phase behavior.</p>"},{"location":"standards/dew_point_standards/#constructor_1","title":"Constructor","text":"<pre><code>import neqsim.standards.gasquality.BestPracticeHydrocarbonDewPoint;\n\n// Create from any fluid (water is automatically removed)\nBestPracticeHydrocarbonDewPoint hcDewPoint = \n    new BestPracticeHydrocarbonDewPoint(thermoSystem);\n</code></pre>"},{"location":"standards/dew_point_standards/#how-it-works_1","title":"How It Works","text":"<ol> <li>Creates new SRK-EoS system from input (excludes water)</li> <li>Sets reference pressure (default 50 bar)</li> <li>Performs dew point temperature flash</li> <li>Returns hydrocarbon dew point temperature</li> </ol>"},{"location":"standards/dew_point_standards/#key-methods_1","title":"Key Methods","text":"Method Description <code>calculate()</code> Perform dew point calculation <code>getValue(\"hydrocarbondewpointTemperature\")</code> Get dew point in \u00b0C <code>getValue(\"pressure\")</code> Get reference pressure in bar <code>isOnSpec()</code> Check against specification"},{"location":"standards/dew_point_standards/#example_1","title":"Example","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.standards.gasquality.BestPracticeHydrocarbonDewPoint;\n\n// Rich natural gas\nSystemInterface richGas = new SystemSrkEos(273.15 + 20, 50.0);\nrichGas.addComponent(\"methane\", 0.85);\nrichGas.addComponent(\"ethane\", 0.06);\nrichGas.addComponent(\"propane\", 0.03);\nrichGas.addComponent(\"n-butane\", 0.02);\nrichGas.addComponent(\"n-pentane\", 0.01);\nrichGas.addComponent(\"n-hexane\", 0.005);\nrichGas.addComponent(\"n-heptane\", 0.003);\nrichGas.addComponent(\"n-octane\", 0.002);\nrichGas.addComponent(\"nitrogen\", 0.02);\nrichGas.setMixingRule(\"classic\");\n\n// Calculate hydrocarbon dew point\nBestPracticeHydrocarbonDewPoint hcDP = new BestPracticeHydrocarbonDewPoint(richGas);\nhcDP.calculate();\n\ndouble hcdp = hcDP.getValue(\"hydrocarbondewpointTemperature\");\nSystem.out.printf(\"Hydrocarbon Dew Point at 50 bar = %.1f \u00b0C%n\", hcdp);\n</code></pre>"},{"location":"standards/dew_point_standards/#multiple-pressures","title":"Multiple Pressures","text":"<pre><code>// Calculate HCDP curve at multiple pressures\ndouble[] pressures = {20, 30, 40, 50, 60, 70, 80};\n\nSystem.out.println(\"Pressure (bar) | HC Dew Point (\u00b0C)\");\nSystem.out.println(\"---------------|-----------------\");\n\nfor (double P : pressures) {\n    richGas.setPressure(P);\n    BestPracticeHydrocarbonDewPoint hcDP = new BestPracticeHydrocarbonDewPoint(richGas);\n    hcDP.calculate();\n    double hcdp = hcDP.getValue(\"hydrocarbondewpointTemperature\");\n    System.out.printf(\"%14.0f | %16.1f%n\", P, hcdp);\n}\n</code></pre>"},{"location":"standards/dew_point_standards/#usage-examples","title":"Usage Examples","text":""},{"location":"standards/dew_point_standards/#combined-water-and-hc-dew-points","title":"Combined Water and HC Dew Points","text":"<pre><code>import neqsim.thermo.system.SystemSrkCPAstatoil;\nimport neqsim.standards.gasquality.Draft_ISO18453;\nimport neqsim.standards.gasquality.BestPracticeHydrocarbonDewPoint;\n\n// Create wet gas with heavy ends\nSystemInterface gas = new SystemSrkCPAstatoil(273.15 + 20, 70.0);\ngas.addComponent(\"methane\", 0.88);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"propane\", 0.02);\ngas.addComponent(\"n-butane\", 0.01);\ngas.addComponent(\"n-pentane\", 0.005);\ngas.addComponent(\"n-hexane\", 0.002);\ngas.addComponent(\"CO2\", 0.02);\ngas.addComponent(\"water\", 50e-6);\ngas.setMixingRule(\"CPA_Statoil\");\n\n// Water dew point\nDraft_ISO18453 waterDP = new Draft_ISO18453(gas);\nwaterDP.setReferencePressure(70.0);\nwaterDP.calculate();\ndouble wdp = waterDP.getValue(\"dewPointTemperature\");\n\n// Hydrocarbon dew point\nBestPracticeHydrocarbonDewPoint hcDP = new BestPracticeHydrocarbonDewPoint(gas);\nhcDP.calculate();\ndouble hcdp = hcDP.getValue(\"hydrocarbondewpointTemperature\");\n\nSystem.out.println(\"=== Dew Point Analysis ===\");\nSystem.out.printf(\"Water Dew Point (at 70 bar): %.1f \u00b0C%n\", wdp);\nSystem.out.printf(\"Hydrocarbon Dew Point (at 50 bar): %.1f \u00b0C%n\", hcdp);\n</code></pre>"},{"location":"standards/dew_point_standards/#effect-of-water-content-on-wdp","title":"Effect of Water Content on WDP","text":"<pre><code>// Analyze water dew point vs water content\ndouble[] waterContents = {10, 20, 50, 100, 200, 500};  // ppm\n\nSystem.out.println(\"Water Content (ppm) | Water Dew Point (\u00b0C)\");\nSystem.out.println(\"--------------------|--------------------\");\n\nfor (double ppm : waterContents) {\n    SystemInterface gas = new SystemSrkCPAstatoil(273.15 + 20, 70.0);\n    gas.addComponent(\"methane\", 0.95);\n    gas.addComponent(\"ethane\", 0.03);\n    gas.addComponent(\"CO2\", 0.01);\n    gas.addComponent(\"water\", ppm * 1e-6);\n    gas.setMixingRule(\"CPA_Statoil\");\n\n    Draft_ISO18453 waterDP = new Draft_ISO18453(gas);\n    waterDP.setReferencePressure(70.0);\n    waterDP.calculate();\n    double wdp = waterDP.getValue(\"dewPointTemperature\");\n\n    System.out.printf(\"%19.0f | %19.1f%n\", ppm, wdp);\n}\n</code></pre>"},{"location":"standards/dew_point_standards/#comparison-of-methods","title":"Comparison of Methods","text":""},{"location":"standards/dew_point_standards/#water-dew-point-approaches","title":"Water Dew Point Approaches","text":"Aspect ISO 18453 (GERG-water) CPA-EoS Model GERG-water specific General CPA Accuracy Optimized for NG Good general accuracy Speed Fast Moderate Water association Empirical Explicit"},{"location":"standards/dew_point_standards/#hydrocarbon-dew-point-approaches","title":"Hydrocarbon Dew Point Approaches","text":"Aspect Best Practice (SRK) PR-EoS GERG-2004 Heavy ends Good Good Limited Accuracy Typical \u00b12-3\u00b0C Typical \u00b12-3\u00b0C Best for lean gas Speed Fast Fast Moderate"},{"location":"standards/dew_point_standards/#typical-specifications","title":"Typical Specifications","text":""},{"location":"standards/dew_point_standards/#european-gas-specifications","title":"European Gas Specifications","text":"Parameter Typical Limit Water dew point &lt; -8\u00b0C at 70 bar HC dew point &lt; -2\u00b0C at 1-70 bar"},{"location":"standards/dew_point_standards/#us-pipeline-specifications","title":"US Pipeline Specifications","text":"Parameter Typical Limit Water dew point &lt; -7\u00b0C (20\u00b0F) at max operating P HC dew point &lt; -4\u00b0C (25\u00b0F) at cricondenbar"},{"location":"standards/dew_point_standards/#accuracy-considerations","title":"Accuracy Considerations","text":""},{"location":"standards/dew_point_standards/#factors-affecting-water-dew-point","title":"Factors Affecting Water Dew Point","text":"<ul> <li>Water content measurement uncertainty</li> <li>Pressure accuracy</li> <li>EoS model selection</li> <li>Presence of glycols or methanol</li> </ul>"},{"location":"standards/dew_point_standards/#factors-affecting-hc-dew-point","title":"Factors Affecting HC Dew Point","text":"<ul> <li>Heavy end characterization (C6+ components)</li> <li>Retrograde behavior near cricondentherm</li> <li>EoS binary interaction parameters</li> <li>Pressure at measurement</li> </ul>"},{"location":"standards/dew_point_standards/#recommendations","title":"Recommendations","text":"<ol> <li>Use CPA or GERG-water for water dew point</li> <li>Characterize C6+ fraction carefully for HC dew point</li> <li>Report dew point with reference pressure</li> <li>Consider measurement at multiple pressures for HC dew point curve</li> </ol>"},{"location":"standards/dew_point_standards/#references","title":"References","text":"<ol> <li>ISO 18453:2004 - Natural gas \u2014 Correlation between water content and water dew point</li> <li>Folas, G.K., et al. (2007). High-pressure vapor-liquid equilibria of systems containing ethylene glycol, water and methane. Fluid Phase Equilibria.</li> <li>ISO 23874:2006 - Natural gas \u2014 Gas chromatographic requirements for hydrocarbon dewpoint calculation</li> <li>GERG Technical Monograph TM14 (2007) - The GERG-2004 Wide-Range Equation of State for Natural Gases</li> </ol>"},{"location":"standards/iso15403_cng_quality/","title":"ISO 15403 - CNG Quality","text":"<p>ISO 15403 specifies requirements for natural gas used as compressed fuel for vehicles (CNG).</p>"},{"location":"standards/iso15403_cng_quality/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Calculated Parameters</li> <li>Implementation</li> <li>Usage Examples</li> <li>Methane Number Concepts</li> </ul>"},{"location":"standards/iso15403_cng_quality/#overview","title":"Overview","text":"<p>Standard: ISO 15403-1:2006 - Natural gas \u2014 Natural gas for use as a compressed fuel for vehicles</p> <p>Purpose: Assess natural gas quality for use in vehicle engines by calculating: - Motor Octane Number (MON) - Methane Number (MN)</p> <p>Class: <code>Standard_ISO15403</code></p>"},{"location":"standards/iso15403_cng_quality/#calculated-parameters","title":"Calculated Parameters","text":""},{"location":"standards/iso15403_cng_quality/#motor-octane-number-mon","title":"Motor Octane Number (MON)","text":"<p>MON indicates knock resistance. Calculated from gas composition:</p> \\[MON = 137.78 \\cdot x_{CH_4} + 29.948 \\cdot x_{C_2H_6} - 18.193 \\cdot x_{C_3H_8} - 167.062 \\cdot (x_{nC_4} + x_{iC_4}) + 181.233 \\cdot x_{CO_2} + 26.944 \\cdot x_{N_2}\\] <p>where \\(x_i\\) is the mole fraction of component i.</p>"},{"location":"standards/iso15403_cng_quality/#methane-number-mn","title":"Methane Number (MN)","text":"<p>MN is derived from MON:</p> \\[MN = 1.445 \\cdot MON - 103.42\\] <p>Interpretation: - MN = 100: Pure methane - MN = 0: Pure hydrogen - Higher MN = better knock resistance</p>"},{"location":"standards/iso15403_cng_quality/#implementation","title":"Implementation","text":""},{"location":"standards/iso15403_cng_quality/#constructor","title":"Constructor","text":"<pre><code>import neqsim.standards.gasquality.Standard_ISO15403;\n\n// Create from gas composition\nStandard_ISO15403 iso15403 = new Standard_ISO15403(thermoSystem);\n</code></pre>"},{"location":"standards/iso15403_cng_quality/#key-methods","title":"Key Methods","text":"Method Description <code>calculate()</code> Calculate MON and MN <code>getValue(\"MON\")</code> Get Motor Octane Number <code>getValue(\"MN\")</code> Get Methane Number"},{"location":"standards/iso15403_cng_quality/#usage-examples","title":"Usage Examples","text":""},{"location":"standards/iso15403_cng_quality/#basic-calculation","title":"Basic Calculation","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.standards.gasquality.Standard_ISO15403;\n\n// CNG composition\nSystemInterface cng = new SystemSrkEos(273.15 + 15, 200.0);\ncng.addComponent(\"methane\", 0.92);\ncng.addComponent(\"ethane\", 0.04);\ncng.addComponent(\"propane\", 0.01);\ncng.addComponent(\"n-butane\", 0.002);\ncng.addComponent(\"i-butane\", 0.003);\ncng.addComponent(\"CO2\", 0.015);\ncng.addComponent(\"nitrogen\", 0.01);\ncng.setMixingRule(\"classic\");\n\n// Calculate methane number\nStandard_ISO15403 iso15403 = new Standard_ISO15403(cng);\niso15403.calculate();\n\ndouble mon = iso15403.getValue(\"MON\");\ndouble mn = iso15403.getValue(\"MN\");\n\nSystem.out.printf(\"Motor Octane Number (MON) = %.1f%n\", mon);\nSystem.out.printf(\"Methane Number (MN) = %.1f%n\", mn);\n</code></pre>"},{"location":"standards/iso15403_cng_quality/#effect-of-composition-on-methane-number","title":"Effect of Composition on Methane Number","text":"<pre><code>// Analyze MN sensitivity to C2+ content\ndouble[] ethaneContents = {0.01, 0.03, 0.05, 0.08, 0.10};\n\nSystem.out.println(\"Ethane (mol%) | MON   | MN\");\nSystem.out.println(\"--------------|-------|------\");\n\nfor (double c2 : ethaneContents) {\n    SystemInterface gas = new SystemSrkEos(273.15 + 15, 200.0);\n    gas.addComponent(\"methane\", 0.97 - c2);\n    gas.addComponent(\"ethane\", c2);\n    gas.addComponent(\"CO2\", 0.02);\n    gas.addComponent(\"nitrogen\", 0.01);\n    gas.setMixingRule(\"classic\");\n\n    Standard_ISO15403 std = new Standard_ISO15403(gas);\n    std.calculate();\n\n    System.out.printf(\"%13.0f | %.1f | %.1f%n\", \n        c2 * 100, \n        std.getValue(\"MON\"), \n        std.getValue(\"MN\"));\n}\n</code></pre>"},{"location":"standards/iso15403_cng_quality/#co2-and-n2-effects","title":"CO2 and N2 Effects","text":"<pre><code>// CO2 and N2 improve methane number\nSystemInterface leanGas = new SystemSrkEos(273.15 + 15, 200.0);\nleanGas.addComponent(\"methane\", 0.85);\nleanGas.addComponent(\"ethane\", 0.05);\nleanGas.addComponent(\"propane\", 0.02);\n\n// Base case - no inerts\nleanGas.addComponent(\"CO2\", 0.0);\nleanGas.addComponent(\"nitrogen\", 0.0);\nleanGas.setMixingRule(\"classic\");\n\nStandard_ISO15403 baseStd = new Standard_ISO15403(leanGas);\nbaseStd.calculate();\nSystem.out.printf(\"Base case MN: %.1f%n\", baseStd.getValue(\"MN\"));\n\n// With 5% CO2\nSystemInterface withCO2 = leanGas.clone();\nwithCO2.addComponent(\"CO2\", 0.05);\nStandard_ISO15403 co2Std = new Standard_ISO15403(withCO2);\nco2Std.calculate();\nSystem.out.printf(\"With 5%% CO2 MN: %.1f%n\", co2Std.getValue(\"MN\"));\n\n// With 5% N2\nSystemInterface withN2 = leanGas.clone();\nwithN2.addComponent(\"nitrogen\", 0.05);\nStandard_ISO15403 n2Std = new Standard_ISO15403(withN2);\nn2Std.calculate();\nSystem.out.printf(\"With 5%% N2 MN: %.1f%n\", n2Std.getValue(\"MN\"));\n</code></pre>"},{"location":"standards/iso15403_cng_quality/#methane-number-concepts","title":"Methane Number Concepts","text":""},{"location":"standards/iso15403_cng_quality/#component-effects","title":"Component Effects","text":"Component Effect on MN Methane Increases MN Ethane Slight decrease Propane Moderate decrease Butanes Strong decrease CO\u2082 Increases MN N\u2082 Increases MN H\u2082 Decreases MN"},{"location":"standards/iso15403_cng_quality/#typical-values","title":"Typical Values","text":"Gas Type Typical MN Pure methane 100 Lean natural gas 85-95 Associated gas 70-85 Biogas 130-140 LNG regasified 75-90"},{"location":"standards/iso15403_cng_quality/#specifications","title":"Specifications","text":"Region Minimum MN Europe (typical) 65-70 Germany (DIN 51624) 70 California 80"},{"location":"standards/iso15403_cng_quality/#technical-notes","title":"Technical Notes","text":""},{"location":"standards/iso15403_cng_quality/#correlation-validity","title":"Correlation Validity","text":"<p>The correlation is valid for: - Methane content &gt; 70% - Limited C4+ content - Typical natural gas compositions</p>"},{"location":"standards/iso15403_cng_quality/#limitations","title":"Limitations","text":"<ol> <li>Does not account for C5+ hydrocarbons</li> <li>Hydrogen effects not included in correlation</li> <li>Best for pipeline-quality natural gas</li> </ol>"},{"location":"standards/iso15403_cng_quality/#alternative-methods","title":"Alternative Methods","text":"<p>For more complex gases, consider: - AVL Methane Number calculation - W\u00e4rtsil\u00e4 MN method - GRI/MWM correlations</p>"},{"location":"standards/iso15403_cng_quality/#references","title":"References","text":"<ol> <li>ISO 15403-1:2006 - Natural gas \u2014 Natural gas for use as a compressed fuel for vehicles \u2014 Part 1: Designation of the quality</li> <li>DIN 51624 - Automotive fuels - Compressed natural gas - Requirements and test methods</li> <li>SAE J1616 - Recommended Practice for Compressed Natural Gas Vehicle Fuel</li> </ol>"},{"location":"standards/iso6578_lng_density/","title":"ISO 6578 - LNG Density Calculation","text":"<p>ISO 6578 provides methods for calculating the density of liquefied natural gas (LNG) from composition and temperature.</p>"},{"location":"standards/iso6578_lng_density/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Calculation Method</li> <li>Implementation</li> <li>Usage Examples</li> <li>Correction Factors</li> <li>Component Data</li> </ul>"},{"location":"standards/iso6578_lng_density/#overview","title":"Overview","text":"<p>Standard: ISO 6578:2017 - Refrigerated hydrocarbon liquids \u2014 Static measurement \u2014 Calculation procedure</p> <p>Purpose: Calculate LNG density for custody transfer and inventory management.</p> <p>Scope: - Temperature range: -195\u00b0C to -100\u00b0C (78 K to 173 K) - Applicable to typical LNG compositions - Based on corresponding states principle with correction factors</p> <p>Class: <code>Standard_ISO6578</code></p>"},{"location":"standards/iso6578_lng_density/#calculation-method","title":"Calculation Method","text":""},{"location":"standards/iso6578_lng_density/#principle","title":"Principle","text":"<p>LNG density is calculated from:</p> <ol> <li>Ideal mixing - Pure component molar volumes</li> <li>Excess volume correction - Klosek-McKinley correction factors</li> </ol>"},{"location":"standards/iso6578_lng_density/#density-equation","title":"Density Equation","text":"\\[\\rho = \\frac{M_{mix}}{V_{mix}}\\] <p>where: $\\(V_{mix} = \\sum_i x_i V_i + \\Delta V_{correction}\\)$</p> <ul> <li>\\(V_i\\) = molar volume of pure component i at temperature T</li> <li>\\(\\Delta V_{correction}\\) = Klosek-McKinley correction for non-ideal mixing</li> </ul>"},{"location":"standards/iso6578_lng_density/#klosek-mckinley-correction","title":"Klosek-McKinley Correction","text":"\\[V_{mix} = \\sum_i x_i V_i - k_1 x_{N_2} - k_2 x_{CH_4}\\] <p>where: - \\(k_1\\) = correction factor 1 (function of T and molar mass) - \\(k_2\\) = correction factor 2 (function of T and molar mass) - \\(x_{N_2}\\) = nitrogen mole fraction - \\(x_{CH_4}\\) = methane mole fraction</p>"},{"location":"standards/iso6578_lng_density/#implementation","title":"Implementation","text":""},{"location":"standards/iso6578_lng_density/#constructor","title":"Constructor","text":"<pre><code>import neqsim.standards.gasquality.Standard_ISO6578;\n\n// Create standard\nStandard_ISO6578 iso6578 = new Standard_ISO6578(thermoSystem);\n</code></pre>"},{"location":"standards/iso6578_lng_density/#key-methods","title":"Key Methods","text":"Method Description <code>calculate()</code> Perform density calculation <code>getValue(\"density\", \"kg/m3\")</code> Get density in kg/m\u00b3 <code>useISO6578VolumeCorrectionFacotrs(boolean)</code> Toggle ISO 6578 vs alternative factors"},{"location":"standards/iso6578_lng_density/#internal-data","title":"Internal Data","text":"<p>The class includes tabulated data for: - Pure component molar volumes vs temperature - \\(k_1\\) and \\(k_2\\) correction factor matrices - Interpolation functions for intermediate temperatures</p>"},{"location":"standards/iso6578_lng_density/#usage-examples","title":"Usage Examples","text":""},{"location":"standards/iso6578_lng_density/#basic-lng-density-calculation","title":"Basic LNG Density Calculation","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.standards.gasquality.Standard_ISO6578;\n\n// Create LNG composition at storage temperature\nSystemInterface lng = new SystemSrkEos(273.15 - 162, 1.01325);  // -162\u00b0C\nlng.addComponent(\"methane\", 0.9200);\nlng.addComponent(\"ethane\", 0.0500);\nlng.addComponent(\"propane\", 0.0180);\nlng.addComponent(\"n-butane\", 0.0040);\nlng.addComponent(\"i-butane\", 0.0030);\nlng.addComponent(\"nitrogen\", 0.0050);\nlng.setMixingRule(\"classic\");\n\n// Calculate density\nStandard_ISO6578 iso6578 = new Standard_ISO6578(lng);\niso6578.calculate();\n\ndouble density = iso6578.getValue(\"density\", \"kg/m3\");\nSystem.out.printf(\"LNG Density at %.1f\u00b0C = %.2f kg/m\u00b3%n\", \n    lng.getTemperature() - 273.15, density);\n</code></pre>"},{"location":"standards/iso6578_lng_density/#density-at-different-temperatures","title":"Density at Different Temperatures","text":"<pre><code>// Temperature sweep\ndouble[] temperatures = {-165, -162, -160, -155, -150};  // \u00b0C\n\nfor (double T : temperatures) {\n    lng.setTemperature(T + 273.15);\n    iso6578.calculate();\n    double rho = iso6578.getValue(\"density\", \"kg/m3\");\n    System.out.printf(\"T = %.0f\u00b0C: \u03c1 = %.2f kg/m\u00b3%n\", T, rho);\n}\n</code></pre>"},{"location":"standards/iso6578_lng_density/#rich-lng-high-ethanepropane","title":"Rich LNG (High Ethane/Propane)","text":"<pre><code>// Rich LNG composition\nSystemInterface richLNG = new SystemSrkEos(273.15 - 162, 1.01325);\nrichLNG.addComponent(\"methane\", 0.8500);\nrichLNG.addComponent(\"ethane\", 0.0900);\nrichLNG.addComponent(\"propane\", 0.0400);\nrichLNG.addComponent(\"n-butane\", 0.0100);\nrichLNG.addComponent(\"nitrogen\", 0.0100);\nrichLNG.setMixingRule(\"classic\");\n\nStandard_ISO6578 standard = new Standard_ISO6578(richLNG);\nstandard.calculate();\n\ndouble density = standard.getValue(\"density\", \"kg/m3\");\nSystem.out.printf(\"Rich LNG Density = %.2f kg/m\u00b3%n\", density);\n\n// Rich LNG has higher density due to heavier components\n</code></pre>"},{"location":"standards/iso6578_lng_density/#comparing-correction-factor-options","title":"Comparing Correction Factor Options","text":"<pre><code>// Using ISO 6578 correction factors (default)\nStandard_ISO6578 iso_factors = new Standard_ISO6578(lng);\niso_factors.useISO6578VolumeCorrectionFacotrs(true);\niso_factors.calculate();\ndouble rho_iso = iso_factors.getValue(\"density\", \"kg/m3\");\n\n// Using alternative correction factors\nStandard_ISO6578 alt_factors = new Standard_ISO6578(lng);\nalt_factors.useISO6578VolumeCorrectionFacotrs(false);\nalt_factors.calculate();\ndouble rho_alt = alt_factors.getValue(\"density\", \"kg/m3\");\n\nSystem.out.printf(\"ISO 6578 factors: %.2f kg/m\u00b3%n\", rho_iso);\nSystem.out.printf(\"Alternative factors: %.2f kg/m\u00b3%n\", rho_alt);\n</code></pre>"},{"location":"standards/iso6578_lng_density/#correction-factors","title":"Correction Factors","text":""},{"location":"standards/iso6578_lng_density/#klosek-mckinley-correction-factor-tables","title":"Klosek-McKinley Correction Factor Tables","text":"<p>The implementation includes two sets of correction factors:</p>"},{"location":"standards/iso6578_lng_density/#iso-6578-factors","title":"ISO 6578 Factors","text":"<p>Temperature range: 93.15 K to 133.15 K (-180\u00b0C to -140\u00b0C) Molar mass range: 16 to 30 g/mol</p> <pre><code>Temperatures: {93.15, 98.15, 103.15, 108.15, 113.15, 118.15, 123.15, 128.15, 133.15} K\nMolar Masses: {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30} g/mol\n</code></pre>"},{"location":"standards/iso6578_lng_density/#alternative-factors","title":"Alternative Factors","text":"<p>Temperature range: 105 K to 135 K Molar mass range: 16 to 25 g/mol</p>"},{"location":"standards/iso6578_lng_density/#interpolation","title":"Interpolation","text":"<p>Bicubic interpolation is used for: - \\(k_1\\) correction factor (nitrogen effect) - \\(k_2\\) correction factor (methane effect)</p> <p>Linear interpolation for pure component molar volumes.</p>"},{"location":"standards/iso6578_lng_density/#component-data","title":"Component Data","text":""},{"location":"standards/iso6578_lng_density/#supported-components","title":"Supported Components","text":"Component Formula Molar Volume Data Methane CH\u2084 Yes Ethane C\u2082H\u2086 Yes Propane C\u2083H\u2088 Yes n-Butane C\u2084H\u2081\u2080 Yes i-Butane C\u2084H\u2081\u2080 Yes n-Pentane C\u2085H\u2081\u2082 Yes i-Pentane C\u2085H\u2081\u2082 Yes n-Hexane C\u2086H\u2081\u2084 Yes Nitrogen N\u2082 Yes"},{"location":"standards/iso6578_lng_density/#molar-volume-data","title":"Molar Volume Data","text":"<p>Pure component molar volumes at reference temperatures:</p> <pre><code>Temperatures: {93.15, 98.15, 103.15, 108.15, 113.15, 118.15, 123.15, 128.15, 133.15} K\n\nExample - Methane (dm\u00b3/mol):\n{0.035771, 0.036315, 0.036891, 0.037500, 0.038149, 0.038839, 0.039580, 0.040375, 0.041237}\n</code></pre>"},{"location":"standards/iso6578_lng_density/#typical-results","title":"Typical Results","text":""},{"location":"standards/iso6578_lng_density/#lean-lng-high-methane","title":"Lean LNG (High Methane)","text":"Composition Value Methane 95% Ethane 3% Others 2% Density at -162\u00b0C 425-435 kg/m\u00b3"},{"location":"standards/iso6578_lng_density/#standard-lng","title":"Standard LNG","text":"Composition Value Methane 90-92% Ethane 5-6% Propane 2% Others 1-2% Density at -162\u00b0C 440-460 kg/m\u00b3"},{"location":"standards/iso6578_lng_density/#rich-lng-high-c2","title":"Rich LNG (High C2+)","text":"Composition Value Methane 85% Ethane 9% Propane 4% Others 2% Density at -162\u00b0C 470-490 kg/m\u00b3"},{"location":"standards/iso6578_lng_density/#accuracy-considerations","title":"Accuracy Considerations","text":""},{"location":"standards/iso6578_lng_density/#temperature-sensitivity","title":"Temperature Sensitivity","text":"<p>LNG density is strongly temperature dependent: - Approximately -1 to -2 kg/m\u00b3 per \u00b0C increase</p>"},{"location":"standards/iso6578_lng_density/#composition-sensitivity","title":"Composition Sensitivity","text":"<ul> <li>Higher C2+ content \u2192 higher density</li> <li>Higher nitrogen content \u2192 lower density</li> </ul>"},{"location":"standards/iso6578_lng_density/#uncertainty","title":"Uncertainty","text":"<p>Typical uncertainty: \u00b10.1% for well-characterized LNG</p>"},{"location":"standards/iso6578_lng_density/#references","title":"References","text":"<ol> <li>ISO 6578:2017 - Refrigerated hydrocarbon liquids \u2014 Static measurement \u2014 Calculation procedure</li> <li>Klosek, J., McKinley, C. (1968). Densities of Liquefied Natural Gas and of Low Molecular Weight Hydrocarbons. Proceedings of the First International Conference on LNG.</li> <li>GIIGNL Custody Transfer Handbook (5<sup>th</sup> Edition)</li> </ol>"},{"location":"standards/iso6976_calorific_values/","title":"ISO 6976 - Calorific Values from Composition","text":"<p>ISO 6976 provides methods for calculating calorific values, density, relative density, and Wobbe indices from natural gas composition.</p>"},{"location":"standards/iso6976_calorific_values/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Calculated Properties</li> <li>Reference Conditions</li> <li>Implementation</li> <li>Usage Examples</li> <li>Return Parameters</li> <li>Component Data</li> <li>Versions</li> </ul>"},{"location":"standards/iso6976_calorific_values/#overview","title":"Overview","text":"<p>Standard: ISO 6976:2016 (and earlier editions)</p> <p>Purpose: Calculate physical properties of natural gas from composition analysis without direct measurement.</p> <p>Scope: - Gross and net calorific values (GCV/LCV) - Wobbe indices (superior/inferior) - Relative density - Compressibility factor - Gas density</p> <p>Classes: - <code>Standard_ISO6976</code> - ISO 6976:1995 edition - <code>Standard_ISO6976_2016</code> - ISO 6976:2016 edition</p>"},{"location":"standards/iso6976_calorific_values/#calculated-properties","title":"Calculated Properties","text":""},{"location":"standards/iso6976_calorific_values/#calorific-values","title":"Calorific Values","text":"<p>Gross Calorific Value (GCV) - Also called Higher Heating Value (HHV): $\\(H_s = \\sum_i x_i \\cdot H_{s,i}^{id}\\)$</p> <p>Net Calorific Value (LCV) - Also called Lower Heating Value (LHV): $\\(H_i = \\sum_i x_i \\cdot H_{i,i}^{id}\\)$</p> <p>where: - \\(x_i\\) = mole fraction of component i - \\(H_{s,i}^{id}\\) = ideal molar superior calorific value of component i - \\(H_{i,i}^{id}\\) = ideal molar inferior calorific value of component i</p>"},{"location":"standards/iso6976_calorific_values/#wobbe-index","title":"Wobbe Index","text":"<p>The Wobbe index indicates interchangeability of fuel gases:</p> \\[W_s = \\frac{H_s}{\\sqrt{d}}\\] <p>where \\(d\\) is the relative density.</p>"},{"location":"standards/iso6976_calorific_values/#compressibility-factor","title":"Compressibility Factor","text":"<p>Mixture compressibility at reference conditions:</p> \\[Z_{mix} = 1 - \\left(\\sum_i x_i \\sqrt{b_i}\\right)^2\\] <p>where \\(b_i\\) is the summation factor for component i.</p>"},{"location":"standards/iso6976_calorific_values/#relative-density","title":"Relative Density","text":"\\[d = \\frac{\\rho_{gas}}{\\rho_{air}} = \\frac{M_{gas}}{M_{air}} \\cdot \\frac{Z_{air}}{Z_{gas}}\\]"},{"location":"standards/iso6976_calorific_values/#reference-conditions","title":"Reference Conditions","text":""},{"location":"standards/iso6976_calorific_values/#temperature-options","title":"Temperature Options","text":"Reference T Description 0\u00b0C (273.15 K) European standard 15\u00b0C (288.15 K) ISO standard / metric 15.55\u00b0C (60\u00b0F) US/UK standard 20\u00b0C (293.15 K) Engineering standard 25\u00b0C (298.15 K) Thermochemical standard"},{"location":"standards/iso6976_calorific_values/#reference-state","title":"Reference State","text":"<ul> <li>Real gas: Uses compressibility factor \\(Z\\) from ISO 6976 correlation</li> <li>Ideal gas: Assumes \\(Z = 1\\)</li> </ul>"},{"location":"standards/iso6976_calorific_values/#reference-type","title":"Reference Type","text":"<ul> <li>Volume (<code>\"volume\"</code>): kJ/m\u00b3 - Standard for gas sales</li> <li>Mass (<code>\"mass\"</code>): kJ/kg - Useful for comparisons</li> <li>Molar (<code>\"molar\"</code>): kJ/mol - Thermodynamic basis</li> </ul>"},{"location":"standards/iso6976_calorific_values/#implementation","title":"Implementation","text":""},{"location":"standards/iso6976_calorific_values/#constructor","title":"Constructor","text":"<pre><code>// Basic constructor (uses default reference conditions)\nStandard_ISO6976 standard = new Standard_ISO6976(thermoSystem);\n\n// Full constructor with reference conditions\nStandard_ISO6976 standard = new Standard_ISO6976(\n    thermoSystem,                    // SystemInterface\n    volumeRefT,                      // Volume reference T [\u00b0C]\n    energyRefT,                      // Energy reference T [\u00b0C]\n    calculationType                  // \"volume\", \"mass\", or \"molar\"\n);\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#key-methods","title":"Key Methods","text":"Method Description <code>calculate()</code> Perform calculations <code>getValue(param)</code> Get calculated value <code>getValue(param, unit)</code> Get value with unit conversion <code>setReferenceState(state)</code> Set \"real\" or \"ideal\" <code>setReferenceType(type)</code> Set \"volume\", \"mass\", or \"molar\" <code>setVolRefT(T)</code> Set volume reference temperature <code>setEnergyRefT(T)</code> Set energy reference temperature <code>getAverageCarbonNumber()</code> Average C number of mixture"},{"location":"standards/iso6976_calorific_values/#internal-data","title":"Internal Data","text":"<p>Component properties are loaded from database table <code>ISO6976constants</code>: - Molar mass - Compressibility factors at 0, 15, 20\u00b0C - Summation factors for Z calculation - Superior/inferior calorific values at reference temperatures</p>"},{"location":"standards/iso6976_calorific_values/#usage-examples","title":"Usage Examples","text":""},{"location":"standards/iso6976_calorific_values/#basic-calculation","title":"Basic Calculation","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.standards.gasquality.Standard_ISO6976;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// Create natural gas composition\nSystemInterface gas = new SystemSrkEos(273.15 + 15, 1.01325);\ngas.addComponent(\"methane\", 0.9248);\ngas.addComponent(\"ethane\", 0.0350);\ngas.addComponent(\"propane\", 0.0098);\ngas.addComponent(\"n-butane\", 0.0022);\ngas.addComponent(\"i-butane\", 0.0034);\ngas.addComponent(\"n-pentane\", 0.0006);\ngas.addComponent(\"i-pentane\", 0.0005);\ngas.addComponent(\"nitrogen\", 0.0107);\ngas.addComponent(\"CO2\", 0.0130);\ngas.setMixingRule(\"classic\");\n\n// Flash to ensure single phase\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\nops.TPflash();\n\n// Create ISO 6976 standard\nStandard_ISO6976 iso6976 = new Standard_ISO6976(gas, 15, 15, \"volume\");\niso6976.setReferenceState(\"real\");\n\n// Calculate\niso6976.calculate();\n\n// Get results\nSystem.out.println(\"=== ISO 6976 Results (15\u00b0C/15\u00b0C, real gas) ===\");\nSystem.out.printf(\"GCV = %.2f kJ/m\u00b3%n\", iso6976.getValue(\"GCV\"));\nSystem.out.printf(\"LCV = %.2f kJ/m\u00b3%n\", iso6976.getValue(\"LCV\"));\nSystem.out.printf(\"Wobbe Index = %.2f kJ/m\u00b3%n\", iso6976.getValue(\"SuperiorWobbeIndex\"));\nSystem.out.printf(\"Relative Density = %.5f%n\", iso6976.getValue(\"RelativeDensity\"));\nSystem.out.printf(\"Z (compressibility) = %.6f%n\", iso6976.getValue(\"CompressionFactor\"));\nSystem.out.printf(\"Molar Mass = %.4f g/mol%n\", iso6976.getValue(\"MolarMass\"));\nSystem.out.printf(\"Density (real) = %.4f kg/m\u00b3%n\", iso6976.getValue(\"DensityReal\"));\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#different-reference-conditions","title":"Different Reference Conditions","text":"<pre><code>// Standard conditions for US market (60\u00b0F)\nStandard_ISO6976 us_standard = new Standard_ISO6976(gas, 15.55, 15.55, \"volume\");\nus_standard.setReferenceState(\"real\");\nus_standard.calculate();\nSystem.out.printf(\"GCV (60\u00b0F) = %.2f kJ/m\u00b3%n\", us_standard.getValue(\"GCV\"));\n\n// European conditions (0\u00b0C metering, 25\u00b0C combustion)\nStandard_ISO6976 eu_standard = new Standard_ISO6976(gas, 0, 25, \"volume\");\neu_standard.setReferenceState(\"real\");\neu_standard.calculate();\nSystem.out.printf(\"GCV (0\u00b0C/25\u00b0C) = %.2f kJ/m\u00b3%n\", eu_standard.getValue(\"GCV\"));\n\n// Mass-based calorific value\nStandard_ISO6976 mass_standard = new Standard_ISO6976(gas, 15, 25, \"mass\");\nmass_standard.calculate();\nSystem.out.printf(\"GCV (mass) = %.2f kJ/kg%n\", mass_standard.getValue(\"GCV\"));\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#using-in-kwh","title":"Using in kWh","text":"<pre><code>// Get Wobbe index in kWh/m\u00b3\ndouble wobbeKWh = iso6976.getValue(\"SuperiorWobbeIndex\", \"kWh\");\nSystem.out.printf(\"Wobbe Index = %.4f kWh/m\u00b3%n\", wobbeKWh);\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#with-pseudo-components-tbp-fractions","title":"With Pseudo-Components (TBP Fractions)","text":"<pre><code>// Gas with heavy ends characterized as TBP fraction\nSystemInterface richGas = new SystemSrkEos(273.15 + 15, 1.01325);\nrichGas.addComponent(\"methane\", 0.85);\nrichGas.addComponent(\"ethane\", 0.05);\nrichGas.addComponent(\"propane\", 0.03);\nrichGas.addTBPfraction(\"C7+\", 0.02, 100.0/1000.0, 0.75);  // MW=100, SG=0.75\nrichGas.addComponent(\"CO2\", 0.03);\nrichGas.addComponent(\"nitrogen\", 0.02);\nrichGas.setMixingRule(\"classic\");\n\nStandard_ISO6976 standard = new Standard_ISO6976(richGas, 15, 15, \"volume\");\nstandard.calculate();\n\n// Note: TBP fractions are approximated using n-heptane properties\ndouble gcv = standard.getValue(\"GCV\");\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#display-results-table","title":"Display Results Table","text":"<pre><code>// Create formatted table\nString[][] table = iso6976.createTable(\"ISO 6976 Results\");\n\n// Or display in GUI\niso6976.display();\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#return-parameters","title":"Return Parameters","text":"Parameter Aliases Description <code>SuperiorCalorificValue</code> <code>GCV</code> Gross calorific value <code>InferiorCalorificValue</code> <code>LCV</code> Net calorific value <code>SuperiorWobbeIndex</code> <code>WI</code> Superior Wobbe index <code>InferiorWobbeIndex</code> - Inferior Wobbe index <code>RelativeDensity</code> - Relative density (air=1) <code>CompressionFactor</code> - Compressibility factor Z <code>MolarMass</code> - Average molar mass [g/mol] <code>DensityIdeal</code> - Ideal gas density [kg/m\u00b3] <code>DensityReal</code> - Real gas density [kg/m\u00b3]"},{"location":"standards/iso6976_calorific_values/#unit-options","title":"Unit Options","text":"<p>For calorific values and Wobbe index: - Default: kJ per reference unit (m\u00b3, kg, or mol) - <code>\"kWh\"</code>: Converts kJ to kWh (divides by 3600)</p>"},{"location":"standards/iso6976_calorific_values/#component-data","title":"Component Data","text":""},{"location":"standards/iso6976_calorific_values/#supported-components","title":"Supported Components","text":"<p>The standard includes data for: - Alkanes: methane through n-decane, iso-butane, iso-pentane, neopentane - Other hydrocarbons: ethene, propene, benzene - Inerts: nitrogen, carbon dioxide, hydrogen sulfide, helium, argon - Other: hydrogen, carbon monoxide, water</p>"},{"location":"standards/iso6976_calorific_values/#handling-unknown-components","title":"Handling Unknown Components","text":"<p>Components not in the ISO 6976 database are approximated:</p> Component Type Approximated As HC, TBP, plus n-heptane alcohol, glycol methanol Other inert (N\u2082) <p>Check for approximations: <pre><code>ArrayList&lt;String&gt; unknowns = standard.getComponentsNotDefinedByStandard();\nif (!unknowns.isEmpty()) {\n    System.out.println(\"Warning: Components approximated: \" + unknowns);\n}\n</code></pre></p>"},{"location":"standards/iso6976_calorific_values/#versions","title":"Versions","text":""},{"location":"standards/iso6976_calorific_values/#standard_iso6976-1995-edition","title":"Standard_ISO6976 (1995 Edition)","text":"<p>Original implementation based on ISO 6976:1995.</p>"},{"location":"standards/iso6976_calorific_values/#standard_iso6976_2016-2016-edition","title":"Standard_ISO6976_2016 (2016 Edition)","text":"<p>Updated implementation with: - Revised component data - Additional temperature point (60\u00b0F / 15.55\u00b0C) - Updated air compressibility values - Uses database table <code>iso6976constants2016</code></p> <pre><code>import neqsim.standards.gasquality.Standard_ISO6976_2016;\n\nStandard_ISO6976_2016 iso2016 = new Standard_ISO6976_2016(gas, 15, 25, \"volume\");\niso2016.calculate();\ndouble gcv = iso2016.getValue(\"GCV\");\n</code></pre>"},{"location":"standards/iso6976_calorific_values/#validation","title":"Validation","text":""},{"location":"standards/iso6976_calorific_values/#reference-air-properties","title":"Reference Air Properties","text":"Temperature Z_air (1995) Z_air (2016) 0\u00b0C 0.99941 0.999419 15\u00b0C 0.99958 0.999595 20\u00b0C 0.99963 0.999645 60\u00b0F - 0.999601"},{"location":"standards/iso6976_calorific_values/#typical-results-for-dry-gas","title":"Typical Results for Dry Gas","text":"<p>For a typical North Sea gas (mostly methane): - GCV: ~37,000-40,000 kJ/m\u00b3 - Wobbe Index: ~48,000-52,000 kJ/m\u00b3 - Relative Density: ~0.58-0.62</p>"},{"location":"standards/iso6976_calorific_values/#references","title":"References","text":"<ol> <li>ISO 6976:2016 - Natural gas \u2014 Calculation of calorific values, density, relative density and Wobbe indices from composition</li> <li>ISO 6976:1995 - Natural gas \u2014 Calculation of calorific values, density and Wobbe index from composition</li> <li>GPA 2172 - Calculation of Gross Heating Value, Relative Density and Compressibility Factor for Natural Gas Mixtures from Compositional Analysis</li> </ol>"},{"location":"standards/sales_contracts/","title":"Sales Contracts","text":"<p>The sales contract system enables specification verification and compliance checking for natural gas quality.</p>"},{"location":"standards/sales_contracts/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Architecture</li> <li>Creating Contracts</li> <li>Contract Specifications</li> <li>Usage Examples</li> <li>Database Integration</li> </ul>"},{"location":"standards/sales_contracts/#overview","title":"Overview","text":"<p>Location: <code>neqsim.standards.salescontract</code></p> <p>Purpose: - Define quality specifications for gas sales points - Verify gas quality against contractual limits - Generate compliance reports - Support multi-specification contracts</p> <p>Classes: - <code>BaseContract</code> - Main contract implementation - <code>ContractInterface</code> - Contract interface - <code>ContractSpecification</code> - Individual specification</p>"},{"location":"standards/sales_contracts/#architecture","title":"Architecture","text":""},{"location":"standards/sales_contracts/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>ContractInterface\n    \u2502\n    \u2514\u2500\u2500 BaseContract\n            \u2502\n            \u251c\u2500\u2500 ArrayList&lt;ContractSpecification&gt;\n            \u2502       \u2502\n            \u2502       \u2514\u2500\u2500 StandardInterface (method)\n            \u2502\n            \u2514\u2500\u2500 Database connection (gascontractspecifications)\n</code></pre>"},{"location":"standards/sales_contracts/#workflow","title":"Workflow","text":"<pre><code>1. Create Contract (from database or manually)\n        \u2193\n2. Add Specifications (linked to standards)\n        \u2193\n3. Run Compliance Check\n        \u2193\n4. Generate Results Table\n        \u2193\n5. Display/Export Results\n</code></pre>"},{"location":"standards/sales_contracts/#creating-contracts","title":"Creating Contracts","text":""},{"location":"standards/sales_contracts/#from-database","title":"From Database","text":"<pre><code>import neqsim.standards.salescontract.BaseContract;\nimport neqsim.standards.salescontract.ContractInterface;\n\n// Load contract from database by terminal and country\nContractInterface contract = new BaseContract(\n    thermoSystem,    // Gas composition\n    \"Kaarstoe\",      // Terminal name\n    \"Norway\"         // Country\n);\n</code></pre>"},{"location":"standards/sales_contracts/#programmatic-creation","title":"Programmatic Creation","text":"<pre><code>// Create empty contract\nContractInterface contract = new BaseContract();\n\n// Or with basic water dew point spec\nContractInterface contract = new BaseContract(thermoSystem);\n</code></pre>"},{"location":"standards/sales_contracts/#contract-specifications","title":"Contract Specifications","text":""},{"location":"standards/sales_contracts/#contractspecification-class","title":"ContractSpecification Class","text":"<p>Each specification contains:</p> Field Description <code>name</code> Specification name <code>specification</code> Description <code>country</code> Country code <code>terminal</code> Terminal/delivery point <code>standard</code> StandardInterface method <code>minValue</code> Minimum acceptable value <code>maxValue</code> Maximum acceptable value <code>unit</code> Unit of measurement <code>referenceTemperatureMeasurement</code> Reference T for measurement <code>referenceTemperatureCombustion</code> Reference T for combustion <code>referencePressure</code> Reference pressure <code>comments</code> Additional notes"},{"location":"standards/sales_contracts/#creating-specifications","title":"Creating Specifications","text":"<pre><code>import neqsim.standards.salescontract.ContractSpecification;\nimport neqsim.standards.gasquality.Draft_ISO18453;\n\n// Create water dew point specification\nStandardInterface waterDPMethod = new Draft_ISO18453(thermoSystem);\n\nContractSpecification waterSpec = new ContractSpecification(\n    \"Water Dew Point\",           // Name\n    \"Maximum water dew point\",   // Specification description\n    \"Norway\",                    // Country\n    \"Kaarstoe\",                  // Terminal\n    waterDPMethod,               // Calculation method\n    -20.0,                       // Minimum value\n    -8.0,                        // Maximum value\n    \"\u00b0C\",                        // Unit\n    15.0,                        // Reference T measurement\n    15.0,                        // Reference T combustion\n    70.0,                        // Reference pressure (bar)\n    \"At 70 bar\"                  // Comments\n);\n</code></pre>"},{"location":"standards/sales_contracts/#available-standard-methods","title":"Available Standard Methods","text":"Method Name Class Purpose <code>ISO18453</code> <code>Draft_ISO18453</code> Water dew point <code>ISO6974</code> <code>Standard_ISO6974</code> Gas composition <code>ISO6976</code> <code>Standard_ISO6976</code> Calorific values, Wobbe <code>BestPracticeHydrocarbonDewPoint</code> <code>BestPracticeHydrocarbonDewPoint</code> HC dew point <code>SulfurSpecificationMethod</code> <code>SulfurSpecificationMethod</code> H2S and sulfur <code>UKspecifications</code> <code>UKspecifications_ICF_SI</code> UK ICF/SI specs"},{"location":"standards/sales_contracts/#usage-examples","title":"Usage Examples","text":""},{"location":"standards/sales_contracts/#basic-contract-check","title":"Basic Contract Check","text":"<pre><code>import neqsim.thermo.system.SystemSrkCPAstatoil;\nimport neqsim.standards.salescontract.BaseContract;\n\n// Create gas composition\nSystemInterface gas = new SystemSrkCPAstatoil(273.15 + 15, 70.0);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"propane\", 0.02);\ngas.addComponent(\"CO2\", 0.02);\ngas.addComponent(\"nitrogen\", 0.005);\ngas.addComponent(\"water\", 30e-6);  // 30 ppm water\ngas.setMixingRule(\"CPA_Statoil\");\n\n// Load contract from database\nBaseContract contract = new BaseContract(gas, \"Kaarstoe\", \"Norway\");\n\n// Run compliance check\ncontract.runCheck();\n\n// Get results\nString[][] results = contract.getResultTable();\nint numSpecs = contract.getSpecificationsNumber();\n\nSystem.out.printf(\"Checked %d specifications%n\", numSpecs);\n\n// Display results\ncontract.display();\n</code></pre>"},{"location":"standards/sales_contracts/#custom-contract","title":"Custom Contract","text":"<pre><code>import neqsim.standards.salescontract.*;\nimport neqsim.standards.gasquality.*;\n\n// Create empty contract\nBaseContract contract = new BaseContract();\n\n// Add water dew point specification\nDraft_ISO18453 waterMethod = new Draft_ISO18453(gas);\nwaterMethod.setReferencePressure(70.0);\nContractSpecification waterSpec = new ContractSpecification(\n    \"Water DP\", \"Water dew point max\", \"Export\", \"Platform\",\n    waterMethod, -100, -8, \"\u00b0C\", 15, 15, 70, \"\"\n);\ncontract.addSpecification(waterSpec);\n\n// Add Wobbe index specification\nStandard_ISO6976 wobbeMethod = new Standard_ISO6976(gas, 15, 25, \"volume\");\nContractSpecification wobbeSpec = new ContractSpecification(\n    \"Wobbe Index\", \"Wobbe index range\", \"Export\", \"Platform\",\n    wobbeMethod, 47300, 51500, \"kJ/m\u00b3\", 15, 25, 1.01325, \"\"\n);\ncontract.addSpecification(wobbeSpec);\n\n// Add GCV specification\nContractSpecification gcvSpec = new ContractSpecification(\n    \"GCV\", \"Gross calorific value\", \"Export\", \"Platform\",\n    wobbeMethod, 37500, 43000, \"kJ/m\u00b3\", 15, 25, 1.01325, \"\"\n);\ncontract.addSpecification(gcvSpec);\n\n// Run check\ncontract.runCheck();\n</code></pre>"},{"location":"standards/sales_contracts/#attaching-contract-to-standard","title":"Attaching Contract to Standard","text":"<pre><code>import neqsim.standards.gasquality.Draft_ISO18453;\n\n// Create standard with contract\nDraft_ISO18453 waterDP = new Draft_ISO18453(gas);\nwaterDP.setSalesContract(contract);\n\n// Calculate\nwaterDP.calculate();\n\n// Check specification compliance\nif (waterDP.isOnSpec()) {\n    System.out.println(\"PASS: Water dew point within specification\");\n} else {\n    System.out.println(\"FAIL: Water dew point out of specification\");\n}\n</code></pre>"},{"location":"standards/sales_contracts/#contract-results-table","title":"Contract Results Table","text":"<pre><code>// After running check\nString[][] results = contract.getResultTable();\n\n// Results table structure:\n// [row][0] = Specification name\n// [row][1] = Measured value\n// [row][2] = Min specification\n// [row][3] = Max specification\n// [row][4] = Unit\n// [row][5] = Pass/Fail status\n\nSystem.out.println(\"Specification | Value | Min | Max | Unit | Status\");\nSystem.out.println(\"--------------|-------|-----|-----|------|-------\");\n\nfor (int i = 0; i &lt; contract.getSpecificationsNumber(); i++) {\n    System.out.printf(\"%13s | %5s | %3s | %3s | %4s | %6s%n\",\n        results[i][0], results[i][1], results[i][2],\n        results[i][3], results[i][4], results[i][5]);\n}\n</code></pre>"},{"location":"standards/sales_contracts/#database-integration","title":"Database Integration","text":""},{"location":"standards/sales_contracts/#database-table-structure","title":"Database Table Structure","text":"<p>Table: <code>gascontractspecifications</code></p> Column Description <code>NAME</code> Specification name <code>SPECIFICATION</code> Description <code>COUNTRY</code> Country code <code>TERMINAL</code> Delivery point <code>METHOD</code> Calculation method name <code>MINVALUE</code> Minimum value <code>MAXVALUE</code> Maximum value <code>UNIT</code> Unit string <code>ReferenceTdegC</code> Reference temperature <code>ReferencePbar</code> Reference pressure <code>Comments</code> Additional notes"},{"location":"standards/sales_contracts/#method-name-mapping","title":"Method Name Mapping","text":"Database Method Class <code>ISO18453</code> <code>Draft_ISO18453</code> <code>ISO6974</code> <code>Standard_ISO6974</code> <code>ISO6976</code> <code>Standard_ISO6976</code> <code>BestPracticeHydrocarbonDewPoint</code> <code>BestPracticeHydrocarbonDewPoint</code> <code>SulfurSpecificationMethod</code> <code>SulfurSpecificationMethod</code> <code>UKspecifications</code> <code>UKspecifications_ICF_SI</code>"},{"location":"standards/sales_contracts/#querying-contracts","title":"Querying Contracts","text":"<pre><code>// Contracts are loaded by terminal and country\nBaseContract norwegianContract = new BaseContract(gas, \"Kaarstoe\", \"Norway\");\nBaseContract ukContract = new BaseContract(gas, \"StFergus\", \"UK\");\nBaseContract belgianContract = new BaseContract(gas, \"Zeebrugge\", \"Belgium\");\n</code></pre>"},{"location":"standards/sales_contracts/#typical-specifications","title":"Typical Specifications","text":""},{"location":"standards/sales_contracts/#norwegian-pipeline-gas","title":"Norwegian Pipeline Gas","text":"Parameter Min Max Unit Reference Water dew point - -8 \u00b0C 70 bar HC dew point - -2 \u00b0C cricondentherm GCV 36.5 44.0 MJ/Sm\u00b3 15\u00b0C/15\u00b0C Wobbe index 47.0 52.0 MJ/Sm\u00b3 15\u00b0C/15\u00b0C CO\u2082 - 2.5 mol% - H\u2082S - 5 mg/Sm\u00b3 -"},{"location":"standards/sales_contracts/#uk-nts-gas","title":"UK NTS Gas","text":"Parameter Min Max Unit Reference GCV 36.9 42.3 MJ/m\u00b3 15\u00b0C/15\u00b0C Wobbe index 47.2 51.41 MJ/m\u00b3 15\u00b0C/15\u00b0C ICF - 0.48 - - SI - 0.60 - -"},{"location":"standards/sales_contracts/#best-practices","title":"Best Practices","text":""},{"location":"standards/sales_contracts/#contract-management","title":"Contract Management","text":"<ol> <li>Store specifications in database for consistency</li> <li>Version control specification changes</li> <li>Document reference conditions clearly</li> <li>Include measurement uncertainty allowances</li> </ol>"},{"location":"standards/sales_contracts/#compliance-checking","title":"Compliance Checking","text":"<ol> <li>Run checks before custody transfer</li> <li>Log all specification results</li> <li>Alert on near-limit values</li> <li>Track specification trends over time</li> </ol>"},{"location":"standards/sales_contracts/#integration","title":"Integration","text":"<ol> <li>Link to online analyzers for real-time checking</li> <li>Interface with SCADA systems</li> <li>Generate automatic compliance reports</li> <li>Archive historical compliance data</li> </ol>"},{"location":"standards/sales_contracts/#references","title":"References","text":"<ol> <li>EASEE-gas Common Business Practice 2005-001 - Harmonisation of Natural Gas Quality</li> <li>EN 16726 - Gas infrastructure - Quality of gas - Group H</li> <li>ISO 13686 - Natural gas \u2014 Quality designation</li> <li>GTS (Dutch) - Gas quality specifications</li> <li>National Grid (UK) - Gas Ten Year Statement</li> </ol>"},{"location":"statistics/","title":"Statistics Package","text":"<p>The NeqSim statistics package provides tools for parameter fitting, uncertainty quantification, and data analysis for thermodynamic model development and validation.</p>"},{"location":"statistics/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Sub-Documentation</li> <li>Core Concepts</li> <li>Quick Start</li> <li>Integration with Thermodynamic Models</li> </ul>"},{"location":"statistics/#overview","title":"Overview","text":"<p>The statistics package supports:</p> <ol> <li>Parameter Fitting - Nonlinear regression using Levenberg-Marquardt algorithm</li> <li>Monte Carlo Simulation - Uncertainty propagation and confidence intervals</li> <li>Data Analysis - Smoothing, filtering, and statistical analysis</li> <li>Experimental Data Management - Sample sets and experimental equipment modeling</li> </ol> <p>Location: <code>neqsim.statistics</code></p> <p>Key Applications: - Fitting binary interaction parameters (\\(k_{ij}\\)) to experimental VLE data - Tuning EoS parameters for custom components - Uncertainty analysis for thermodynamic predictions - Regression of transport property correlations</p>"},{"location":"statistics/#package-structure","title":"Package Structure","text":"<pre><code>statistics/\n\u251c\u2500\u2500 parameterfitting/                    # Core parameter fitting framework\n\u2502   \u251c\u2500\u2500 StatisticsBaseClass.java        # Abstract base for all fitting\n\u2502   \u251c\u2500\u2500 StatisticsInterface.java        # Interface definition\n\u2502   \u251c\u2500\u2500 SampleSet.java                  # Collection of experimental points\n\u2502   \u251c\u2500\u2500 SampleValue.java                # Single experimental data point\n\u2502   \u251c\u2500\u2500 BaseFunction.java               # Abstract objective function\n\u2502   \u251c\u2500\u2500 FunctionInterface.java          # Function interface\n\u2502   \u251c\u2500\u2500 NumericalDerivative.java        # Numerical differentiation\n\u2502   \u2514\u2500\u2500 nonlinearparameterfitting/      # Nonlinear optimization\n\u2502       \u251c\u2500\u2500 LevenbergMarquardt.java     # L-M optimizer (least squares)\n\u2502       \u251c\u2500\u2500 LevenbergMarquardtAbsDev.java   # Absolute deviation\n\u2502       \u251c\u2500\u2500 LevenbergMarquardtBiasDev.java  # Bias deviation\n\u2502       \u2514\u2500\u2500 LevenbergMarquardtFunction.java # Example function\n\u2502\n\u251c\u2500\u2500 montecarlosimulation/               # Uncertainty quantification\n\u2502   \u2514\u2500\u2500 MonteCarloSimulation.java       # MC simulation runner\n\u2502\n\u251c\u2500\u2500 dataanalysis/                       # Data processing\n\u2502   \u2514\u2500\u2500 datasmoothing/\n\u2502       \u2514\u2500\u2500 DataSmoother.java           # Savitzky-Golay smoothing\n\u2502\n\u251c\u2500\u2500 experimentalsamplecreation/         # Sample generation\n\u2502   \u251c\u2500\u2500 readdatafromfile/               # File I/O for experimental data\n\u2502   \u2514\u2500\u2500 samplecreator/\n\u2502       \u251c\u2500\u2500 SampleCreator.java          # Base sample creator\n\u2502       \u2514\u2500\u2500 wettedwallcolumnsamplecreator/  # Specialized creator\n\u2502\n\u2514\u2500\u2500 experimentalequipmentdata/          # Equipment modeling\n    \u251c\u2500\u2500 ExperimentalEquipmentData.java\n    \u2514\u2500\u2500 wettedwallcolumndata/           # Wetted wall column\n</code></pre>"},{"location":"statistics/#sub-documentation","title":"Sub-Documentation","text":"<p>Detailed guides for each major subsystem:</p> Guide Description Parameter Fitting Levenberg-Marquardt optimization, creating objective functions, bounds Monte Carlo Simulation Uncertainty propagation, confidence intervals, distribution sampling Data Analysis Data smoothing, filtering, statistical measures"},{"location":"statistics/#core-concepts","title":"Core Concepts","text":""},{"location":"statistics/#sample-values","title":"Sample Values","text":"<p>A <code>SampleValue</code> represents one experimental data point:</p> <pre><code>// Experimental value with uncertainty\ndouble experimentalValue = 0.5;    // Measured value (e.g., pressure)\ndouble standardDeviation = 0.05;  // Experimental uncertainty\ndouble[] independentVariables = {300.0, 0.1};  // e.g., temperature, composition\n\nSampleValue sample = new SampleValue(\n    experimentalValue, \n    standardDeviation, \n    independentVariables\n);\n</code></pre>"},{"location":"statistics/#sample-sets","title":"Sample Sets","text":"<p>A <code>SampleSet</code> is a collection of experimental points:</p> <pre><code>SampleSet sampleSet = new SampleSet();\nsampleSet.add(sample1);\nsampleSet.add(sample2);\nsampleSet.add(sample3);\n\n// Or from array\nSampleValue[] samples = {sample1, sample2, sample3};\nSampleSet sampleSet = new SampleSet(samples);\n</code></pre>"},{"location":"statistics/#objective-functions","title":"Objective Functions","text":"<p>Functions extend <code>BaseFunction</code> or <code>LevenbergMarquardtFunction</code>:</p> <pre><code>public class MyObjectiveFunction extends LevenbergMarquardtFunction {\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        // params[0], params[1], ... are the fitting parameters\n        // dependentValues are the independent variables (T, P, x, ...)\n\n        double T = dependentValues[0];\n        double x = dependentValues[1];\n\n        // Calculate model prediction\n        double predicted = params[0] * Math.exp(-params[1] / T) * x;\n\n        return predicted;\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n</code></pre>"},{"location":"statistics/#quick-start","title":"Quick Start","text":""},{"location":"statistics/#basic-parameter-fitting","title":"Basic Parameter Fitting","text":"<pre><code>import neqsim.statistics.parameterfitting.*;\nimport neqsim.statistics.parameterfitting.nonlinearparameterfitting.*;\nimport java.util.ArrayList;\n\n// 1. Create objective function\nMyObjectiveFunction function = new MyObjectiveFunction();\n\n// 2. Set initial parameter guess\ndouble[] initialGuess = {1.0, 500.0};  // Two parameters to fit\nfunction.setInitialGuess(initialGuess);\n\n// 3. Create experimental samples\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\n\ndouble[] x1 = {300.0, 0.1};  // T=300K, x=0.1\nSampleValue s1 = new SampleValue(0.05, 0.005, x1);  // exp=0.05 \u00b1 0.005\ns1.setFunction(function);\nsamples.add(s1);\n\ndouble[] x2 = {350.0, 0.2};\nSampleValue s2 = new SampleValue(0.12, 0.01, x2);\ns2.setFunction(function);\nsamples.add(s2);\n\n// Add more samples...\n\n// 4. Create sample set and optimizer\nSampleSet sampleSet = new SampleSet(samples);\nLevenbergMarquardt optimizer = new LevenbergMarquardt();\noptimizer.setSampleSet(sampleSet);\n\n// 5. Solve\noptimizer.solve();\n\n// 6. Get results\ndouble[] fittedParams = sampleSet.getSample(0).getFunction().getFittingParams();\nSystem.out.println(\"Fitted parameters: \" + Arrays.toString(fittedParams));\n\n// 7. Display results\noptimizer.displayCurveFit();\noptimizer.displayResult();\n</code></pre>"},{"location":"statistics/#with-monte-carlo-uncertainty","title":"With Monte Carlo Uncertainty","text":"<pre><code>// After solving...\noptimizer.runMonteCarloSimulation(100);  // 100 Monte Carlo runs\n\n// This generates samples with normally distributed perturbations\n// around experimental values and re-fits, providing parameter distributions\n</code></pre>"},{"location":"statistics/#integration-with-thermodynamic-models","title":"Integration with Thermodynamic Models","text":""},{"location":"statistics/#fitting-binary-interaction-parameters","title":"Fitting Binary Interaction Parameters","text":"<pre><code>public class KijFittingFunction extends LevenbergMarquardtFunction {\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        double temperature = dependentValues[0];\n        double pressure = dependentValues[1];\n        double x_exp = dependentValues[2];  // Experimental composition\n\n        // Set up thermodynamic system\n        system.setTemperature(temperature);\n        system.setPressure(pressure);\n\n        // Set kij from fitting parameters\n        ((PhaseEos) system.getPhase(0)).getMixingRule()\n            .setBinaryInteractionParameter(0, 1, params[0]);\n        ((PhaseEos) system.getPhase(1)).getMixingRule()\n            .setBinaryInteractionParameter(0, 1, params[0]);\n\n        // Flash calculation\n        thermoOps.TPflash();\n\n        // Return calculated liquid composition\n        return system.getPhase(1).getComponent(0).getx();\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n</code></pre>"},{"location":"statistics/#fitting-cpa-association-parameters","title":"Fitting CPA Association Parameters","text":"<pre><code>public class CPAFittingFunction extends LevenbergMarquardtFunction {\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        double T = dependentValues[0];\n        double P = dependentValues[1];\n\n        // params[0] = epsilon (association energy)\n        // params[1] = beta (association volume)\n\n        system.getComponent(\"water\").setAssociationEnergy(params[0]);\n        system.getComponent(\"water\").setAssociationVolume(params[1]);\n\n        thermoOps.TPflash();\n\n        return system.getPhase(1).getDensity(\"kg/m3\");\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n</code></pre>"},{"location":"statistics/#statistical-measures","title":"Statistical Measures","text":"<p>After fitting, several statistics are available:</p> <pre><code>// Solve first\noptimizer.solve();\n\n// Chi-square statistic\ndouble chiSquare = optimizer.calcChiSquare();\n\n// Absolute deviation statistics\noptimizer.calcAbsDev();\n\n// Covariance matrix\noptimizer.calcCoVarianceMatrix();\n\n// Parameter standard deviations\noptimizer.calcParameterStandardDeviation();\n\n// Parameter correlation matrix\noptimizer.calcCorrelationMatrix();\n\n// 95% confidence intervals\noptimizer.calcParameterUncertainty();\n</code></pre>"},{"location":"statistics/#best-practices","title":"Best Practices","text":""},{"location":"statistics/#initial-guess-selection","title":"Initial Guess Selection","text":"<p>Good initial guesses are critical for convergence: - Use physical reasoning to estimate parameter magnitude - Start with literature values when available - Try multiple starting points if convergence fails</p>"},{"location":"statistics/#experimental-uncertainties","title":"Experimental Uncertainties","text":"<p>Proper uncertainty specification affects: - Weighting of data points in regression - Confidence intervals on fitted parameters - Chi-square goodness-of-fit</p>"},{"location":"statistics/#parameter-bounds","title":"Parameter Bounds","text":"<p>Set physical bounds to prevent unphysical solutions:</p> <pre><code>double[][] bounds = {\n    {0.0, 1.0},     // Parameter 0: between 0 and 1\n    {100.0, 1000.0} // Parameter 1: between 100 and 1000\n};\nfunction.setBounds(bounds);\n</code></pre>"},{"location":"statistics/#convergence-criteria","title":"Convergence Criteria","text":"<pre><code>optimizer.setMaxNumberOfIterations(100);  // Increase if needed\n</code></pre>"},{"location":"statistics/#references","title":"References","text":"<ol> <li>Press, W.H., et al. (2007). Numerical Recipes: The Art of Scientific Computing. Cambridge University Press.</li> <li>Marquardt, D.W. (1963). An Algorithm for Least-Squares Estimation of Nonlinear Parameters. SIAM J. Appl. Math.</li> <li>Savitzky, A., Golay, M.J.E. (1964). Smoothing and Differentiation of Data by Simplified Least Squares Procedures. Anal. Chem.</li> </ol>"},{"location":"statistics/data_analysis/","title":"Data Analysis","text":"<p>The data analysis subsystem provides tools for preprocessing, smoothing, and statistical analysis of experimental data.</p>"},{"location":"statistics/data_analysis/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Data Smoothing</li> <li>Sample Creation</li> <li>Experimental Equipment Data</li> <li>Statistical Measures</li> <li>Examples</li> </ul>"},{"location":"statistics/data_analysis/#overview","title":"Overview","text":"<p>Location: <code>neqsim.statistics.dataanalysis</code></p> <p>The data analysis package provides:</p> Component Purpose <code>DataSmoother</code> Savitzky-Golay smoothing filter <code>SampleCreator</code> Generate samples from equipment data <code>ExperimentalEquipmentData</code> Interface for equipment measurements"},{"location":"statistics/data_analysis/#data-smoothing","title":"Data Smoothing","text":""},{"location":"statistics/data_analysis/#savitzky-golay-filter","title":"Savitzky-Golay Filter","text":"<p>Location: <code>neqsim.statistics.dataanalysis.datasmoothing.DataSmoother</code></p> <p>The Savitzky-Golay filter smooths data by fitting local polynomials, preserving signal shape better than simple moving averages.</p>"},{"location":"statistics/data_analysis/#algorithm","title":"Algorithm","text":"<p>For each data point, fit a polynomial of degree \\(m\\) to a window of \\(n_L\\) points left and \\(n_R\\) points right:</p> \\[y_{smooth}(i) = \\sum_{j=-n_L}^{n_R} c_j \\cdot y(i+j)\\] <p>where coefficients \\(c_j\\) are computed from the polynomial fit.</p>"},{"location":"statistics/data_analysis/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.statistics.dataanalysis.datasmoothing.DataSmoother;\n\n// Create smoother with window size and polynomial order\nint nl = 3;  // Points to the left\nint nr = 3;  // Points to the right\nint m = 2;   // Polynomial order (quadratic)\nint ld = 0;  // Derivative order (0 = smooth, 1 = first derivative)\n\nDataSmoother smoother = new DataSmoother(nl, nr, m, ld);\n</code></pre>"},{"location":"statistics/data_analysis/#complete-example","title":"Complete Example","text":"<pre><code>// Raw noisy data\ndouble[] rawData = {1.2, 2.1, 2.8, 4.2, 4.9, 6.1, 6.8, 8.2, 8.9, 10.1};\n\n// Create smoother\nDataSmoother smoother = new DataSmoother(2, 2, 2, 0);\n\n// Set input data\nsmoother.setInputNumbers(rawData);\n\n// Run smoothing\nsmoother.runSmoothing();\n\n// Get smoothed output\ndouble[] smoothedData = smoother.getSmoothedNumbers();\n\n// Print results\nfor (int i = 0; i &lt; rawData.length; i++) {\n    System.out.printf(\"Raw: %.2f -&gt; Smoothed: %.2f%n\", \n        rawData[i], smoothedData[i]);\n}\n</code></pre>"},{"location":"statistics/data_analysis/#parameters","title":"Parameters","text":"Parameter Symbol Description <code>nl</code> \\(n_L\\) Number of points to the left of center <code>nr</code> \\(n_R\\) Number of points to the right of center <code>m</code> \\(m\\) Polynomial order (typically 2-4) <code>ld</code> \\(l_d\\) Derivative order (0=smooth, 1=1<sup>st</sup> deriv, etc.)"},{"location":"statistics/data_analysis/#coefficient-calculation","title":"Coefficient Calculation","text":"<p>The <code>findCoefs()</code> method computes Savitzky-Golay coefficients:</p> <pre><code>// Internal coefficient calculation\nprivate void findCoefs() {\n    // Uses least-squares polynomial fitting\n    // Coefficients stored in coefs[] array\n\n    int np = nl + nr + 1;  // Total points in window\n\n    // Solve normal equations for polynomial coefficients\n    // Returns convolution weights for smoothing\n}\n</code></pre>"},{"location":"statistics/data_analysis/#derivative-estimation","title":"Derivative Estimation","text":"<p>Set <code>ld &gt; 0</code> to compute derivatives while smoothing:</p> <pre><code>// Compute first derivative (slope)\nDataSmoother derivSmoother = new DataSmoother(3, 3, 3, 1);\nderivSmoother.setInputNumbers(data);\nderivSmoother.runSmoothing();\ndouble[] derivatives = derivSmoother.getSmoothedNumbers();\n\n// Compute second derivative (curvature)\nDataSmoother deriv2Smoother = new DataSmoother(4, 4, 4, 2);\nderiv2Smoother.setInputNumbers(data);\nderiv2Smoother.runSmoothing();\ndouble[] secondDerivatives = deriv2Smoother.getSmoothedNumbers();\n</code></pre>"},{"location":"statistics/data_analysis/#window-size-guidelines","title":"Window Size Guidelines","text":"Data Characteristic Recommended Window Polynomial Order Low noise nl=2, nr=2 2 Moderate noise nl=4, nr=4 2-3 High noise nl=6, nr=6 3-4 Preserving peaks nl=2, nr=2 2 Smooth trends nl=5, nr=5 4 <p>Important: Window size (\\(n_L + n_R + 1\\)) must be greater than polynomial order (\\(m\\)).</p>"},{"location":"statistics/data_analysis/#edge-handling","title":"Edge Handling","text":"<p>Edge points cannot use the full window. The implementation handles boundaries by: - Using asymmetric windows near edges - Maintaining coefficient recalculation for reduced windows</p>"},{"location":"statistics/data_analysis/#sample-creation","title":"Sample Creation","text":""},{"location":"statistics/data_analysis/#samplecreator-class","title":"SampleCreator Class","text":"<p>Location: <code>neqsim.statistics.experimentalsamplecreation.samplecreator.SampleCreator</code></p> <p>Creates <code>SampleValue</code> objects from experimental equipment data for use in parameter fitting.</p> <pre><code>import neqsim.statistics.experimentalsamplecreation.samplecreator.SampleCreator;\nimport neqsim.thermo.system.SystemInterface;\n\n// Link thermodynamic system with equipment data\nSampleCreator creator = new SampleCreator();\ncreator.setThermoSystem(system);\ncreator.setEquipmentData(equipmentData);\n\n// Create samples\ncreator.createSamples();\n</code></pre>"},{"location":"statistics/data_analysis/#wetted-wall-column-sample-creator","title":"Wetted Wall Column Sample Creator","text":"<p>Location: <code>neqsim.statistics.experimentalsamplecreation.samplecreator.wettedwallcolumnsamplecreator</code></p> <p>Specialized creator for mass transfer experiments:</p> <pre><code>import neqsim.statistics.experimentalsamplecreation.samplecreator\n    .wettedwallcolumnsamplecreator.WettedWallColumnSampleCreator;\n\nWettedWallColumnSampleCreator creator = new WettedWallColumnSampleCreator();\ncreator.setThermoSystem(system);\ncreator.setWettedWallColumnData(columnData);\ncreator.createSamples();\n\nArrayList&lt;SampleValue&gt; samples = creator.getSamples();\n</code></pre>"},{"location":"statistics/data_analysis/#experimental-equipment-data","title":"Experimental Equipment Data","text":""},{"location":"statistics/data_analysis/#experimentalequipmentdata-interface","title":"ExperimentalEquipmentData Interface","text":"<p>Location: <code>neqsim.statistics.experimentalequipmentdata</code></p> <p>Base interface for experimental equipment measurements:</p> <pre><code>public interface ExperimentalEquipmentData {\n    double[] getMeasuredValues();\n    double[] getUncertainties();\n    double[] getOperatingConditions();\n    String getEquipmentType();\n}\n</code></pre>"},{"location":"statistics/data_analysis/#wetted-wall-column-data","title":"Wetted Wall Column Data","text":"<p>Location: <code>neqsim.statistics.experimentalequipmentdata.wettedwallcolumndata</code></p> <p>For mass transfer coefficient measurements:</p> <pre><code>import neqsim.statistics.experimentalequipmentdata\n    .wettedwallcolumndata.WettedWallColumnData;\n\nWettedWallColumnData data = new WettedWallColumnData();\ndata.setGasFlowRate(0.5);        // [m\u00b3/h]\ndata.setLiquidFlowRate(0.1);     // [L/min]\ndata.setColumnHeight(0.5);       // [m]\ndata.setColumnDiameter(0.02);    // [m]\ndata.setTemperature(298.15);     // [K]\ndata.setPressure(1.0);           // [bar]\ndata.setMeasuredKla(0.05);       // Mass transfer coefficient\ndata.setKlaUncertainty(0.005);   // Uncertainty\n</code></pre>"},{"location":"statistics/data_analysis/#statistical-measures","title":"Statistical Measures","text":""},{"location":"statistics/data_analysis/#chi-square-statistic","title":"Chi-Square Statistic","text":"<p>Calculated in <code>StatisticsBaseClass</code>:</p> <pre><code>public double calcChiSquare() {\n    double chiSq = 0.0;\n    for (int i = 0; i &lt; sampleSet.getLength(); i++) {\n        SampleValue sample = sampleSet.getSample(i);\n        double exp = sample.getSampleValue();\n        double calc = sample.getFunction().calcValue(sample.getDependentValues());\n        double sigma = sample.getStandardDeviation();\n\n        chiSq += Math.pow((exp - calc) / sigma, 2);\n    }\n    return chiSq;\n}\n</code></pre>"},{"location":"statistics/data_analysis/#absolute-deviation","title":"Absolute Deviation","text":"<pre><code>public void calcAbsDev() {\n    absdev = 0.0;\n    for (int i = 0; i &lt; sampleSet.getLength(); i++) {\n        SampleValue sample = sampleSet.getSample(i);\n        double exp = sample.getSampleValue();\n        double calc = sample.getFunction().calcValue(sample.getDependentValues());\n\n        absdev += Math.abs(exp - calc);\n    }\n    absdev /= sampleSet.getLength();\n}\n</code></pre>"},{"location":"statistics/data_analysis/#bias-deviation","title":"Bias Deviation","text":"<pre><code>public void calcBiasDev() {\n    biasdev = 0.0;\n    for (int i = 0; i &lt; sampleSet.getLength(); i++) {\n        SampleValue sample = sampleSet.getSample(i);\n        double exp = sample.getSampleValue();\n        double calc = sample.getFunction().calcValue(sample.getDependentValues());\n\n        biasdev += (exp - calc);\n    }\n    biasdev /= sampleSet.getLength();\n}\n</code></pre>"},{"location":"statistics/data_analysis/#relative-deviations","title":"Relative Deviations","text":"<p>Average Absolute Relative Deviation (AARD):</p> \\[AARD = \\frac{1}{N}\\sum_{i=1}^{N}\\left|\\frac{y_i^{exp} - y_i^{calc}}{y_i^{exp}}\\right| \\times 100\\%\\] <pre><code>public double calcAARD() {\n    double aard = 0.0;\n    for (int i = 0; i &lt; sampleSet.getLength(); i++) {\n        SampleValue sample = sampleSet.getSample(i);\n        double exp = sample.getSampleValue();\n        double calc = sample.getFunction().calcValue(sample.getDependentValues());\n\n        if (Math.abs(exp) &gt; 1e-10) {\n            aard += Math.abs((exp - calc) / exp);\n        }\n    }\n    return 100.0 * aard / sampleSet.getLength();\n}\n</code></pre>"},{"location":"statistics/data_analysis/#covariance-matrix","title":"Covariance Matrix","text":"<p>The covariance matrix \\(\\mathbf{C}\\) is computed from the Hessian approximation:</p> \\[\\mathbf{C} = (\\mathbf{J}^T \\mathbf{W} \\mathbf{J})^{-1}\\] <pre><code>public void calcCoVarianceMatrix() {\n    // Build alpha matrix (J'WJ)\n    calcAlphaMatrix();\n\n    // Invert to get covariance\n    Matrix alphaMatrix = new Matrix(alpha);\n    Matrix covariance = alphaMatrix.inverse();\n    coVarianceMatrix = covariance.getArray();\n}\n</code></pre>"},{"location":"statistics/data_analysis/#correlation-matrix","title":"Correlation Matrix","text":"<p>Parameter correlation from covariance:</p> \\[\\rho_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii}C_{jj}}}\\] <pre><code>public void calcCorrelationMatrix() {\n    calcCoVarianceMatrix();\n\n    int n = coVarianceMatrix.length;\n    parameterCorrelationMatrix = new double[n][n];\n\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            parameterCorrelationMatrix[i][j] = coVarianceMatrix[i][j] /\n                Math.sqrt(coVarianceMatrix[i][i] * coVarianceMatrix[j][j]);\n        }\n    }\n}\n</code></pre>"},{"location":"statistics/data_analysis/#examples","title":"Examples","text":""},{"location":"statistics/data_analysis/#example-1-smoothing-noisy-thermodynamic-data","title":"Example 1: Smoothing Noisy Thermodynamic Data","text":"<pre><code>import neqsim.statistics.dataanalysis.datasmoothing.DataSmoother;\n\n// Noisy vapor pressure data\ndouble[] temperatures = {300, 310, 320, 330, 340, 350, 360, 370, 380, 390};\ndouble[] pressures = {0.52, 0.88, 1.45, 2.32, 3.58, 5.45, 7.89, 11.2, 15.4, 21.1};\n\n// Add simulated noise\njava.util.Random rng = new java.util.Random(42);\ndouble[] noisyPressures = new double[pressures.length];\nfor (int i = 0; i &lt; pressures.length; i++) {\n    noisyPressures[i] = pressures[i] * (1 + 0.05 * rng.nextGaussian());\n}\n\n// Smooth the data\nDataSmoother smoother = new DataSmoother(2, 2, 2, 0);\nsmoother.setInputNumbers(noisyPressures);\nsmoother.runSmoothing();\ndouble[] smoothed = smoother.getSmoothedNumbers();\n\n// Compare\nSystem.out.println(\"T(K)\\tNoisy P\\tSmoothed P\\tTrue P\");\nfor (int i = 0; i &lt; temperatures.length; i++) {\n    System.out.printf(\"%.0f\\t%.3f\\t%.3f\\t\\t%.3f%n\",\n        temperatures[i], noisyPressures[i], smoothed[i], pressures[i]);\n}\n</code></pre>"},{"location":"statistics/data_analysis/#example-2-computing-data-quality-metrics","title":"Example 2: Computing Data Quality Metrics","text":"<pre><code>import neqsim.statistics.parameterfitting.*;\nimport neqsim.statistics.parameterfitting.nonlinearparameterfitting.*;\n\n// After fitting...\noptimizer.solve();\n\n// Calculate all statistics\ndouble chiSq = optimizer.calcChiSquare();\noptimizer.calcAbsDev();\noptimizer.calcCoVarianceMatrix();\noptimizer.calcCorrelationMatrix();\noptimizer.calcParameterStandardDeviation();\n\n// Report\nSystem.out.println(\"=== Fitting Statistics ===\");\nSystem.out.printf(\"Chi-square: %.4f%n\", chiSq);\nSystem.out.printf(\"Reduced chi-square: %.4f%n\", \n    chiSq / (sampleSet.getLength() - numParams));\nSystem.out.printf(\"Absolute deviation: %.4f%n\", optimizer.absdev);\n\nSystem.out.println(\"\\nParameter values and uncertainties:\");\ndouble[] params = function.getFittingParams();\nfor (int i = 0; i &lt; params.length; i++) {\n    System.out.printf(\"  p[%d] = %.6f \u00b1 %.6f%n\", \n        i, params[i], optimizer.parameterStandardDeviation[i]);\n}\n\nSystem.out.println(\"\\nParameter correlations:\");\nfor (int i = 0; i &lt; params.length; i++) {\n    for (int j = 0; j &lt; params.length; j++) {\n        System.out.printf(\"%.3f \", optimizer.parameterCorrelationMatrix[i][j]);\n    }\n    System.out.println();\n}\n</code></pre>"},{"location":"statistics/data_analysis/#example-3-preprocessing-experimental-data","title":"Example 3: Preprocessing Experimental Data","text":"<pre><code>import neqsim.statistics.dataanalysis.datasmoothing.DataSmoother;\nimport neqsim.statistics.parameterfitting.*;\n\n// Raw experimental data with noise\ndouble[][] rawData = {\n    {300.0, 0.52, 0.03},  // T, P_measured, P_uncertainty\n    {310.0, 0.91, 0.05},\n    {320.0, 1.38, 0.07},\n    // ... more data\n};\n\n// Extract pressure values\ndouble[] pressures = new double[rawData.length];\nfor (int i = 0; i &lt; rawData.length; i++) {\n    pressures[i] = rawData[i][1];\n}\n\n// Smooth pressures\nDataSmoother smoother = new DataSmoother(2, 2, 2, 0);\nsmoother.setInputNumbers(pressures);\nsmoother.runSmoothing();\ndouble[] smoothedPressures = smoother.getSmoothedNumbers();\n\n// Create samples with smoothed values\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; rawData.length; i++) {\n    double[] dep = {rawData[i][0]};  // Temperature\n    double value = smoothedPressures[i];  // Smoothed pressure\n    double sigma = rawData[i][2];  // Original uncertainty\n\n    SampleValue s = new SampleValue(value, sigma, dep);\n    s.setFunction(myFunction);\n    samples.add(s);\n}\n\n// Proceed with fitting...\n</code></pre>"},{"location":"statistics/data_analysis/#example-4-derivative-estimation","title":"Example 4: Derivative Estimation","text":"<pre><code>// Estimate heat capacity from enthalpy vs temperature\ndouble[] temperatures = {300, 320, 340, 360, 380, 400};  // K\ndouble[] enthalpies = {2000, 2200, 2420, 2660, 2920, 3200};  // J/mol\n\n// Compute dH/dT using Savitzky-Golay derivative\nDataSmoother derivSmoother = new DataSmoother(1, 1, 2, 1);\nderivSmoother.setInputNumbers(enthalpies);\nderivSmoother.runSmoothing();\ndouble[] rawDerivatives = derivSmoother.getSmoothedNumbers();\n\n// Scale by temperature spacing\ndouble dT = temperatures[1] - temperatures[0];  // Assuming uniform spacing\ndouble[] heatCapacity = new double[rawDerivatives.length];\nfor (int i = 0; i &lt; rawDerivatives.length; i++) {\n    heatCapacity[i] = rawDerivatives[i] / dT;\n}\n\nSystem.out.println(\"T(K)\\tCp (J/mol/K)\");\nfor (int i = 0; i &lt; temperatures.length; i++) {\n    System.out.printf(\"%.0f\\t%.2f%n\", temperatures[i], heatCapacity[i]);\n}\n</code></pre>"},{"location":"statistics/data_analysis/#best-practices","title":"Best Practices","text":""},{"location":"statistics/data_analysis/#data-preprocessing","title":"Data Preprocessing","text":"<ol> <li>Outlier detection - Remove or down-weight outliers before fitting</li> <li>Smoothing choice - Use S-G for preserving peak shapes</li> <li>Uncertainty estimation - Propagate smoothing effects to uncertainties</li> </ol>"},{"location":"statistics/data_analysis/#window-selection","title":"Window Selection","text":"<ul> <li>Larger windows \u2192 more smoothing, potential signal distortion</li> <li>Smaller windows \u2192 less smoothing, more noise passes through</li> <li>Always test visually before final analysis</li> </ul>"},{"location":"statistics/data_analysis/#derivative-estimation_1","title":"Derivative Estimation","text":"<ul> <li>Use S-G derivatives instead of finite differences</li> <li>Higher polynomial order for smoother derivatives</li> <li>Validate against known analytical derivatives</li> </ul>"},{"location":"statistics/data_analysis/#references","title":"References","text":"<ol> <li>Savitzky, A., Golay, M.J.E. (1964). Smoothing and Differentiation of Data by Simplified Least Squares Procedures. Analytical Chemistry, 36(8), 1627-1639.</li> <li>Press, W.H., et al. (2007). Numerical Recipes: The Art of Scientific Computing. Chapter 14: Interpolation and Extrapolation.</li> <li>Orfanidis, S.J. (1996). Introduction to Signal Processing. Prentice Hall.</li> </ol>"},{"location":"statistics/monte_carlo_simulation/","title":"Monte Carlo Simulation","text":"<p>Monte Carlo simulation provides uncertainty quantification for fitted parameters by propagating experimental uncertainties through the fitting process.</p>"},{"location":"statistics/monte_carlo_simulation/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Theory</li> <li>Implementation</li> <li>Running Simulations</li> <li>Interpreting Results</li> <li>Integration with Parameter Fitting</li> <li>Examples</li> <li>Best Practices</li> </ul>"},{"location":"statistics/monte_carlo_simulation/#overview","title":"Overview","text":"<p>Location: <code>neqsim.statistics.montecarlosimulation</code></p> <p>Monte Carlo simulation addresses the question: Given experimental uncertainties, what is the uncertainty in fitted parameters?</p> <p>Key Concept: Run many parameter fits with randomly perturbed experimental data to build a distribution of fitted parameter values.</p> <pre><code>Experimental Data \u00b1 \u03c3\n        \u2193\n    Random Perturbation (N times)\n        \u2193\n    N Parameter Fits\n        \u2193\n    Parameter Distribution\n        \u2193\n    Mean, StdDev, Confidence Intervals\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#theory","title":"Theory","text":""},{"location":"statistics/monte_carlo_simulation/#uncertainty-propagation","title":"Uncertainty Propagation","text":"<p>Given experimental measurements \\(y_i \\pm \\sigma_i\\), Monte Carlo simulation:</p> <ol> <li> <p>Generates \\(N\\) synthetic datasets where each measurement is replaced by:    $\\(y_i^{(k)} = y_i + \\epsilon_i^{(k)}\\)$    where \\(\\epsilon_i^{(k)} \\sim \\mathcal{N}(0, \\sigma_i^2)\\)</p> </li> <li> <p>Fits parameters \\(\\vec{p}^{(k)}\\) to each synthetic dataset</p> </li> <li> <p>Computes statistics from the parameter ensemble:</p> </li> <li>Mean: \\(\\bar{p}_j = \\frac{1}{N}\\sum_{k=1}^{N} p_j^{(k)}\\)</li> <li>Standard deviation: \\(s_j = \\sqrt{\\frac{1}{N-1}\\sum_{k=1}^{N}(p_j^{(k)} - \\bar{p}_j)^2}\\)</li> </ol>"},{"location":"statistics/monte_carlo_simulation/#advantages","title":"Advantages","text":"<ul> <li>Model-independent - Works for any objective function</li> <li>No linearity assumptions - Valid for highly nonlinear models</li> <li>Handles correlations - Captures parameter covariance naturally</li> <li>Distribution shape - Reveals non-Gaussian parameter distributions</li> </ul>"},{"location":"statistics/monte_carlo_simulation/#when-to-use","title":"When to Use","text":"Situation Recommendation Linear or mildly nonlinear models Covariance matrix from Levenberg-Marquardt Highly nonlinear models Monte Carlo simulation Non-Gaussian errors Monte Carlo simulation Correlated experimental errors Monte Carlo with correlated sampling Publication-quality uncertainties Monte Carlo simulation"},{"location":"statistics/monte_carlo_simulation/#implementation","title":"Implementation","text":""},{"location":"statistics/monte_carlo_simulation/#montecarlosimulation-class","title":"MonteCarloSimulation Class","text":"<pre><code>import neqsim.statistics.montecarlosimulation.MonteCarloSimulation;\nimport neqsim.statistics.parameterfitting.StatisticsInterface;\n\npublic class MonteCarloSimulation {\n    private StatisticsInterface baseCase;\n    private int numberOfRuns = 50;\n\n    // Creates randomized sample sets and re-fits\n    public void runSimulation() {\n        for (int i = 0; i &lt; numberOfRuns; i++) {\n            StatisticsInterface runCase = baseCase.clone();\n            runCase.setSampleSet(\n                baseCase.getSampleSet().createNewNormalDistributedSet()\n            );\n            runCase.init();\n            runCase.solve();\n        }\n    }\n\n    // Collects fitted parameters from all runs\n    public double[][] createReportMatrix() { ... }\n}\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#sample-randomization","title":"Sample Randomization","text":"<p>The <code>SampleSet.createNewNormalDistributedSet()</code> method:</p> <pre><code>public SampleSet createNewNormalDistributedSet() {\n    SampleSet newSet = new SampleSet();\n    Normal normalDist = new Normal(0, 1, new MersenneTwister());\n\n    for (SampleValue sample : samples) {\n        // Perturb experimental value by its uncertainty\n        double perturbedValue = sample.getSampleValue() \n            + normalDist.nextDouble() * sample.getStandardDeviation();\n\n        SampleValue newSample = new SampleValue(\n            perturbedValue,\n            sample.getStandardDeviation(),\n            sample.getDependentValues()\n        );\n        newSample.setFunction(sample.getFunction().clone());\n        newSet.add(newSample);\n    }\n    return newSet;\n}\n</code></pre> <p>Uses the Colt library's Normal distribution with Mersenne Twister RNG.</p>"},{"location":"statistics/monte_carlo_simulation/#running-simulations","title":"Running Simulations","text":""},{"location":"statistics/monte_carlo_simulation/#method-1-via-statisticsbaseclass","title":"Method 1: Via StatisticsBaseClass","text":"<p>The simplest approach uses the built-in method:</p> <pre><code>import neqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardt;\n\n// Create and set up optimizer\nLevenbergMarquardt optimizer = new LevenbergMarquardt();\noptimizer.setSampleSet(sampleSet);\n\n// Fit once to get best-fit parameters\noptimizer.solve();\nSystem.out.println(\"Best fit chi-square: \" + optimizer.calcChiSquare());\n\n// Run Monte Carlo simulation\nint numberOfRuns = 100;\noptimizer.runMonteCarloSimulation(numberOfRuns);\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#method-2-direct-montecarlosimulation","title":"Method 2: Direct MonteCarloSimulation","text":"<p>For more control:</p> <pre><code>import neqsim.statistics.montecarlosimulation.MonteCarloSimulation;\n\n// Create Monte Carlo simulation\nMonteCarloSimulation mc = new MonteCarloSimulation(optimizer);\nmc.setNumberOfRuns(100);\n\n// Run simulation\nmc.runSimulation();\n\n// Get results matrix\ndouble[][] results = mc.createReportMatrix();\n// results[runIndex][parameterIndex]\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#configuring-number-of-runs","title":"Configuring Number of Runs","text":"Purpose Recommended Runs Quick estimate 50-100 Standard analysis 500-1000 Publication quality 5000-10000 Parameter distribution shape 10000+ <p>More runs provide: - More stable statistics - Better distribution characterization - Slower computation</p>"},{"location":"statistics/monte_carlo_simulation/#interpreting-results","title":"Interpreting Results","text":""},{"location":"statistics/monte_carlo_simulation/#report-matrix-structure","title":"Report Matrix Structure","text":"<pre><code>double[][] results = mc.createReportMatrix();\n\n// results[i][j] = value of parameter j in run i\nint numRuns = results.length;\nint numParams = results[0].length;\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#computing-statistics","title":"Computing Statistics","text":"<pre><code>// Calculate mean and standard deviation\ndouble[] means = new double[numParams];\ndouble[] stds = new double[numParams];\n\nfor (int j = 0; j &lt; numParams; j++) {\n    double sum = 0, sumSq = 0;\n    for (int i = 0; i &lt; numRuns; i++) {\n        sum += results[i][j];\n        sumSq += results[i][j] * results[i][j];\n    }\n    means[j] = sum / numRuns;\n    stds[j] = Math.sqrt(sumSq/numRuns - means[j]*means[j]);\n}\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#confidence-intervals","title":"Confidence Intervals","text":"<p>For 95% confidence interval (assuming normal distribution):</p> \\[p_j \\pm 1.96 \\times s_j\\] <p>For small sample sizes, use t-distribution:</p> \\[p_j \\pm t_{0.975, N-1} \\times s_j\\]"},{"location":"statistics/monte_carlo_simulation/#percentile-based-intervals","title":"Percentile-Based Intervals","text":"<p>More robust for non-Gaussian distributions:</p> <pre><code>import java.util.Arrays;\n\n// Sort parameter values\ndouble[] paramJ = new double[numRuns];\nfor (int i = 0; i &lt; numRuns; i++) {\n    paramJ[i] = results[i][j];\n}\nArrays.sort(paramJ);\n\n// 95% confidence interval\ndouble lower = paramJ[(int)(0.025 * numRuns)];\ndouble upper = paramJ[(int)(0.975 * numRuns)];\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#parameter-correlation","title":"Parameter Correlation","text":"<pre><code>// Calculate correlation between parameters i and j\ndouble sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;\nfor (int k = 0; k &lt; numRuns; k++) {\n    sumX += results[k][i];\n    sumY += results[k][j];\n    sumXY += results[k][i] * results[k][j];\n    sumX2 += results[k][i] * results[k][i];\n    sumY2 += results[k][j] * results[k][j];\n}\n\ndouble correlation = (numRuns*sumXY - sumX*sumY) /\n    Math.sqrt((numRuns*sumX2 - sumX*sumX) * (numRuns*sumY2 - sumY*sumY));\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#integration-with-parameter-fitting","title":"Integration with Parameter Fitting","text":""},{"location":"statistics/monte_carlo_simulation/#complete-workflow","title":"Complete Workflow","text":"<pre><code>import neqsim.statistics.parameterfitting.*;\nimport neqsim.statistics.parameterfitting.nonlinearparameterfitting.*;\nimport java.util.ArrayList;\n\n// 1. Create objective function\nMyFittingFunction function = new MyFittingFunction();\nfunction.setInitialGuess(new double[]{1.0, 100.0});\n\n// 2. Load experimental data with uncertainties\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; data.length; i++) {\n    double[] indepVars = {data[i][0]};          // x\n    double expValue = data[i][1];               // y\n    double uncertainty = data[i][2];            // \u03c3y\n\n    SampleValue s = new SampleValue(expValue, uncertainty, indepVars);\n    s.setFunction(function.clone());\n    samples.add(s);\n}\n\n// 3. Create sample set and optimizer\nSampleSet sampleSet = new SampleSet(samples);\nLevenbergMarquardt optimizer = new LevenbergMarquardt();\noptimizer.setSampleSet(sampleSet);\n\n// 4. Solve for best-fit parameters\noptimizer.solve();\ndouble[] bestFit = function.getFittingParams();\nSystem.out.printf(\"Best fit: a=%.4f, b=%.4f%n\", bestFit[0], bestFit[1]);\n\n// 5. Calculate analytical uncertainties\noptimizer.calcCoVarianceMatrix();\noptimizer.calcParameterStandardDeviation();\ndouble[] analyticStd = optimizer.parameterStandardDeviation;\nSystem.out.printf(\"Analytic \u03c3: \u03c3a=%.4f, \u03c3b=%.4f%n\", \n    analyticStd[0], analyticStd[1]);\n\n// 6. Run Monte Carlo simulation\noptimizer.runMonteCarloSimulation(500);\n\n// 7. Get Monte Carlo statistics\n// (Access via the internal arrays populated by runMonteCarloSimulation)\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#comparing-analytical-and-monte-carlo-uncertainties","title":"Comparing Analytical and Monte Carlo Uncertainties","text":"<p>The covariance matrix from Levenberg-Marquardt provides analytical uncertainties:</p> <pre><code>optimizer.calcCoVarianceMatrix();\noptimizer.calcParameterStandardDeviation();\n</code></pre> <p>Monte Carlo provides empirical uncertainties from the parameter distribution.</p> <p>Agreement indicates the model behaves approximately linearly near the optimum.</p> <p>Disagreement may indicate: - Strong nonlinearity - Parameter boundaries affecting results - Non-Gaussian experimental errors</p>"},{"location":"statistics/monte_carlo_simulation/#examples","title":"Examples","text":""},{"location":"statistics/monte_carlo_simulation/#example-1-basic-monte-carlo","title":"Example 1: Basic Monte Carlo","text":"<pre><code>import neqsim.statistics.parameterfitting.*;\nimport neqsim.statistics.parameterfitting.nonlinearparameterfitting.*;\n\n// Simple linear function: y = a*x + b\npublic class LinearFunction extends LevenbergMarquardtFunction {\n    public LinearFunction() { params = new double[2]; }\n\n    @Override\n    public double calcValue(double[] dep) {\n        return params[0] * dep[0] + params[1];\n    }\n\n    @Override\n    public void setFittingParams(int i, double val) { params[i] = val; }\n}\n\n// Main code\nLinearFunction func = new LinearFunction();\nfunc.setInitialGuess(new double[]{1.0, 0.0});\n\n// Data with 5% uncertainty\ndouble[][] data = {\n    {1.0, 2.1, 0.1},\n    {2.0, 4.0, 0.2},\n    {3.0, 6.2, 0.3},\n    {4.0, 8.1, 0.4},\n    {5.0, 9.8, 0.5}\n};\n\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\nfor (double[] row : data) {\n    SampleValue s = new SampleValue(row[1], row[2], new double[]{row[0]});\n    s.setFunction(func);\n    samples.add(s);\n}\n\nSampleSet set = new SampleSet(samples);\nLevenbergMarquardt opt = new LevenbergMarquardt();\nopt.setSampleSet(set);\nopt.solve();\n\nSystem.out.println(\"Best fit: a=\" + func.params[0] + \", b=\" + func.params[1]);\n\n// Run Monte Carlo\nopt.runMonteCarloSimulation(1000);\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#example-2-thermodynamic-parameter-uncertainty","title":"Example 2: Thermodynamic Parameter Uncertainty","text":"<pre><code>// Fitting kij for methane-CO2 with uncertainty estimation\n\npublic class KijFunction extends LevenbergMarquardtFunction {\n    private SystemInterface system;\n    private ThermodynamicOperations thermoOps;\n\n    public KijFunction(SystemInterface sys) {\n        this.system = sys;\n        this.thermoOps = new ThermodynamicOperations(sys);\n        params = new double[1];\n    }\n\n    @Override\n    public double calcValue(double[] dep) {\n        double T = dep[0];\n        double P = dep[1];\n\n        // Set kij\n        system.getPhase(0).getMixingRule()\n            .setBinaryInteractionParameter(0, 1, params[0]);\n        system.getPhase(1).getMixingRule()\n            .setBinaryInteractionParameter(0, 1, params[0]);\n\n        system.setTemperature(T);\n        system.setPressure(P);\n        system.init(0);\n        thermoOps.TPflash();\n\n        return system.getPhase(1).getComponent(0).getx();\n    }\n\n    @Override\n    public void setFittingParams(int i, double val) { params[i] = val; }\n}\n\n// Setup\nSystemInterface sys = new SystemSrkEos(280.0, 20.0);\nsys.addComponent(\"methane\", 0.9);\nsys.addComponent(\"CO2\", 0.1);\nsys.setMixingRule(\"classic\");\n\nKijFunction func = new KijFunction(sys);\nfunc.setInitialGuess(new double[]{0.05});\n\n// Experimental VLE data: T, P, x_methane, sigma\ndouble[][] expData = {\n    {250.0, 15.0, 0.88, 0.02},\n    {260.0, 20.0, 0.84, 0.02},\n    {270.0, 25.0, 0.80, 0.03}\n};\n\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\nfor (double[] row : expData) {\n    SampleValue s = new SampleValue(row[2], row[3], new double[]{row[0], row[1]});\n    s.setFunction(func);\n    samples.add(s);\n}\n\nSampleSet set = new SampleSet(samples);\nLevenbergMarquardt opt = new LevenbergMarquardt();\nopt.setSampleSet(set);\nopt.solve();\n\nSystem.out.printf(\"Fitted kij = %.4f%n\", func.params[0]);\n\n// Monte Carlo for uncertainty\nopt.runMonteCarloSimulation(200);\nopt.calcParameterStandardDeviation();\nSystem.out.printf(\"kij uncertainty = \u00b1%.4f%n\", opt.parameterStandardDeviation[0]);\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#example-3-analyzing-parameter-distribution","title":"Example 3: Analyzing Parameter Distribution","text":"<pre><code>import neqsim.statistics.montecarlosimulation.MonteCarloSimulation;\n\n// After fitting...\nMonteCarloSimulation mc = new MonteCarloSimulation(optimizer);\nmc.setNumberOfRuns(1000);\nmc.runSimulation();\n\ndouble[][] results = mc.createReportMatrix();\n\n// Histogram analysis\nint numBins = 20;\ndouble minVal = Double.MAX_VALUE, maxVal = Double.MIN_VALUE;\nfor (int i = 0; i &lt; results.length; i++) {\n    minVal = Math.min(minVal, results[i][0]);\n    maxVal = Math.max(maxVal, results[i][0]);\n}\n\nint[] histogram = new int[numBins];\ndouble binWidth = (maxVal - minVal) / numBins;\n\nfor (int i = 0; i &lt; results.length; i++) {\n    int bin = (int)((results[i][0] - minVal) / binWidth);\n    if (bin == numBins) bin--;\n    histogram[bin]++;\n}\n\n// Print histogram\nfor (int b = 0; b &lt; numBins; b++) {\n    double binCenter = minVal + (b + 0.5) * binWidth;\n    System.out.printf(\"%.4f: %s%n\", binCenter, \"*\".repeat(histogram[b]/2));\n}\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#best-practices","title":"Best Practices","text":""},{"location":"statistics/monte_carlo_simulation/#uncertainty-specification","title":"Uncertainty Specification","text":"<ul> <li>Use realistic experimental uncertainties</li> <li>Include all significant error sources</li> <li>Consider systematic vs random errors</li> </ul>"},{"location":"statistics/monte_carlo_simulation/#number-of-runs","title":"Number of Runs","text":"Data Size Model Complexity Suggested Runs &lt;10 points Simple 100-500 10-100 points Moderate 500-1000 &gt;100 points Complex 1000-5000"},{"location":"statistics/monte_carlo_simulation/#convergence-checking","title":"Convergence Checking","text":"<p>Ensure each Monte Carlo run converges:</p> <pre><code>// In a custom Monte Carlo loop\nfor (int run = 0; run &lt; numRuns; run++) {\n    LevenbergMarquardt opt = new LevenbergMarquardt();\n    opt.setSampleSet(randomizedSet);\n    opt.solve();\n\n    // Check convergence\n    if (opt.calcChiSquare() &gt; 100 * baseChiSquare) {\n        // Skip this run or investigate\n        System.out.println(\"Warning: Run \" + run + \" may not have converged\");\n    }\n}\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#reproducibility","title":"Reproducibility","text":"<p>Set random seed for reproducible results:</p> <pre><code>// The Colt library uses MersenneTwister\n// For reproducibility, would need to modify SampleSet implementation\n</code></pre>"},{"location":"statistics/monte_carlo_simulation/#computational-efficiency","title":"Computational Efficiency","text":"<ul> <li>Start with fewer runs for debugging</li> <li>Parallelize if independent (each run is independent)</li> <li>Cache expensive calculations in objective function</li> </ul>"},{"location":"statistics/monte_carlo_simulation/#limitations","title":"Limitations","text":"<ol> <li>Computational cost - N fits required</li> <li>Assumes independent measurements - Standard implementation</li> <li>No systematic error propagation - Only random uncertainties</li> <li>Memory for large N - Stores all fitted parameters</li> </ol>"},{"location":"statistics/monte_carlo_simulation/#references","title":"References","text":"<ol> <li>Press, W.H., et al. (2007). Numerical Recipes. Chapter 7: Random Numbers.</li> <li>Anderson, T.W. (2003). An Introduction to Multivariate Statistical Analysis.</li> <li>Efron, B., Tibshirani, R.J. (1993). An Introduction to the Bootstrap. Chapman &amp; Hall.</li> </ol>"},{"location":"statistics/parameter_fitting/","title":"Parameter Fitting","text":"<p>The parameter fitting subsystem provides robust nonlinear regression capabilities for thermodynamic model calibration.</p>"},{"location":"statistics/parameter_fitting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Levenberg-Marquardt Algorithm</li> <li>Creating Objective Functions</li> <li>Sample Data Management</li> <li>Parameter Bounds</li> <li>Convergence and Diagnostics</li> <li>Statistical Output</li> <li>Algorithm Variants</li> <li>Numerical Derivatives</li> <li>Examples</li> </ul>"},{"location":"statistics/parameter_fitting/#overview","title":"Overview","text":"<p>Location: <code>neqsim.statistics.parameterfitting</code></p> <p>The fitting framework minimizes the weighted sum of squared residuals:</p> \\[\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{y_i^{\\text{exp}} - y_i^{\\text{calc}}(\\vec{p})}{\\sigma_i} \\right)^2\\] <p>where: - \\(y_i^{\\text{exp}}\\) = experimental value - \\(y_i^{\\text{calc}}\\) = calculated value from model - \\(\\sigma_i\\) = standard deviation (uncertainty) - \\(\\vec{p}\\) = parameter vector</p>"},{"location":"statistics/parameter_fitting/#levenberg-marquardt-algorithm","title":"Levenberg-Marquardt Algorithm","text":"<p>The Levenberg-Marquardt (L-M) algorithm combines gradient descent with Gauss-Newton methods for robust nonlinear optimization.</p>"},{"location":"statistics/parameter_fitting/#algorithm-overview","title":"Algorithm Overview","text":"<p>At each iteration, the algorithm solves:</p> \\[(\\mathbf{J}^T \\mathbf{W} \\mathbf{J} + \\lambda \\mathbf{I}) \\Delta\\vec{p} = \\mathbf{J}^T \\mathbf{W} \\vec{r}\\] <p>where: - \\(\\mathbf{J}\\) = Jacobian matrix of partial derivatives - \\(\\mathbf{W}\\) = weight matrix (diagonal, \\(W_{ii} = 1/\\sigma_i^2\\)) - \\(\\lambda\\) = damping parameter - \\(\\vec{r}\\) = residual vector</p> <p>The damping parameter \\(\\lambda\\) adapts during iteration: - Large \\(\\lambda\\) \u2192 gradient descent (slow but stable) - Small \\(\\lambda\\) \u2192 Gauss-Newton (fast near minimum)</p>"},{"location":"statistics/parameter_fitting/#implementation","title":"Implementation","text":"<pre><code>import neqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardt;\nimport neqsim.statistics.parameterfitting.SampleSet;\n\n// Create optimizer\nLevenbergMarquardt optimizer = new LevenbergMarquardt();\n\n// Set sample data\noptimizer.setSampleSet(sampleSet);\n\n// Optional: configure iterations\noptimizer.setMaxNumberOfIterations(100);  // default: 50\n\n// Solve\noptimizer.solve();\n\n// Display results\noptimizer.displayResult();\noptimizer.displayCurveFit();\n</code></pre>"},{"location":"statistics/parameter_fitting/#solve-loop-internals","title":"Solve Loop Internals","text":"<p>The <code>solve()</code> method: 1. Calculates initial \\(\\chi^2\\) and matrices 2. Iteratively:    - Computes trial parameters with current \\(\\lambda\\)    - Checks parameter bounds    - Evaluates new \\(\\chi^2\\)    - Accepts/rejects step and updates \\(\\lambda\\) 3. Terminates when \\(|\\Delta\\chi^2/\\chi^2| &lt; \\epsilon\\) or max iterations</p>"},{"location":"statistics/parameter_fitting/#creating-objective-functions","title":"Creating Objective Functions","text":""},{"location":"statistics/parameter_fitting/#extending-levenbergmarquardtfunction","title":"Extending LevenbergMarquardtFunction","text":"<pre><code>import neqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardtFunction;\n\npublic class MyFittingFunction extends LevenbergMarquardtFunction {\n\n    public MyFittingFunction() {\n        // Initialize parameter count\n        params = new double[2];\n    }\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        // dependentValues: independent variables from SampleValue\n        // params[]: fitting parameters\n\n        double x = dependentValues[0];\n        double y = dependentValues[1];\n\n        // Model equation: z = a * exp(-b * x) + c * y\n        double calculated = params[0] * Math.exp(-params[1] * x) + params[2] * y;\n\n        return calculated;\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n</code></pre>"},{"location":"statistics/parameter_fitting/#with-thermodynamic-system","title":"With Thermodynamic System","text":"<p>For thermodynamic fitting, functions can include system and thermoOps:</p> <pre><code>public class VLEFittingFunction extends LevenbergMarquardtFunction {\n\n    public VLEFittingFunction(SystemInterface system, ThermodynamicOperations thermoOps) {\n        this.system = system;\n        this.thermoOps = thermoOps;\n        params = new double[1];  // One kij parameter\n    }\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        double T = dependentValues[0];  // Temperature [K]\n        double P = dependentValues[1];  // Pressure [bar]\n\n        // Set kij from fitting parameter\n        system.getPhase(0).getMixingRule()\n            .setBinaryInteractionParameter(0, 1, params[0]);\n        system.getPhase(1).getMixingRule()\n            .setBinaryInteractionParameter(0, 1, params[0]);\n\n        // Set conditions and flash\n        system.setTemperature(T);\n        system.setPressure(P);\n        system.init(0);\n        thermoOps.TPflash();\n\n        // Return calculated property (e.g., liquid composition)\n        return system.getPhase(1).getComponent(0).getx();\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n</code></pre>"},{"location":"statistics/parameter_fitting/#initial-guess","title":"Initial Guess","text":"<p>Always set an initial guess before solving:</p> <pre><code>function.setInitialGuess(new double[]{0.1, 500.0, 1.0});\n</code></pre>"},{"location":"statistics/parameter_fitting/#sample-data-management","title":"Sample Data Management","text":""},{"location":"statistics/parameter_fitting/#samplevalue-class","title":"SampleValue Class","text":"<p>Each data point is a <code>SampleValue</code>:</p> <pre><code>import neqsim.statistics.parameterfitting.SampleValue;\n\n// Constructor: SampleValue(value, stdDev, independentVariables)\ndouble[] independentVars = {300.0, 10.0, 0.5};  // T, P, x\nSampleValue sample = new SampleValue(0.25, 0.01, independentVars);\n\n// Attach objective function\nsample.setFunction(myFunction);\n</code></pre>"},{"location":"statistics/parameter_fitting/#key-methods","title":"Key Methods","text":"Method Description <code>getSampleValue()</code> Get experimental value <code>getStandardDeviation()</code> Get experimental uncertainty <code>getDependentValues()</code> Get independent variables array <code>setFunction(function)</code> Attach objective function <code>getFunction()</code> Retrieve attached function"},{"location":"statistics/parameter_fitting/#sampleset-class","title":"SampleSet Class","text":"<p>Collection of samples:</p> <pre><code>import neqsim.statistics.parameterfitting.SampleSet;\nimport java.util.ArrayList;\n\n// From ArrayList\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\nsamples.add(sample1);\nsamples.add(sample2);\nSampleSet sampleSet = new SampleSet(samples);\n\n// From array\nSampleValue[] arr = {sample1, sample2, sample3};\nSampleSet sampleSet = new SampleSet(arr);\n\n// Access samples\nSampleValue s = sampleSet.getSample(0);\nint n = sampleSet.getLength();\n</code></pre>"},{"location":"statistics/parameter_fitting/#key-methods_1","title":"Key Methods","text":"Method Description <code>add(sample)</code> Add a sample to the set <code>getSample(i)</code> Get sample at index i <code>getLength()</code> Number of samples <code>createNewNormalDistributedSet()</code> Clone with randomized values (for Monte Carlo)"},{"location":"statistics/parameter_fitting/#parameter-bounds","title":"Parameter Bounds","text":"<p>Constrain parameters to physically meaningful ranges:</p> <pre><code>// bounds[paramIndex] = {lowerBound, upperBound}\ndouble[][] bounds = new double[3][2];\n\nbounds[0] = new double[]{0.0, 10.0};      // 0 \u2264 param0 \u2264 10\nbounds[1] = new double[]{100.0, 2000.0};  // 100 \u2264 param1 \u2264 2000\nbounds[2] = new double[]{-1.0, 1.0};      // -1 \u2264 param2 \u2264 1\n\nfunction.setBounds(bounds);\n</code></pre> <p>During optimization, if a parameter exceeds its bounds, it is clamped to the boundary value.</p>"},{"location":"statistics/parameter_fitting/#typical-bounds-for-thermodynamic-parameters","title":"Typical Bounds for Thermodynamic Parameters","text":"Parameter Typical Range Binary interaction \\(k_{ij}\\) [-0.5, 0.5] Association energy \\(\\epsilon\\) [500, 10000] K Association volume \\(\\beta\\) [0.001, 0.1] Critical temperature ratio [0.5, 2.0]"},{"location":"statistics/parameter_fitting/#convergence-and-diagnostics","title":"Convergence and Diagnostics","text":""},{"location":"statistics/parameter_fitting/#iteration-control","title":"Iteration Control","text":"<pre><code>// Set maximum iterations (default: 50)\noptimizer.setMaxNumberOfIterations(100);\n\n// Check convergence\noptimizer.solve();  // Returns when converged or max iterations\n</code></pre>"},{"location":"statistics/parameter_fitting/#chi-square-calculation","title":"Chi-Square Calculation","text":"<pre><code>// Calculate current chi-square\ndouble chiSq = optimizer.calcChiSquare();\n\n// Reduced chi-square\nint dof = sampleSet.getLength() - numParameters;\ndouble reducedChiSq = chiSq / dof;\n</code></pre>"},{"location":"statistics/parameter_fitting/#goodness-of-fit-interpretation","title":"Goodness-of-Fit Interpretation","text":"Reduced \\(\\chi^2\\) Interpretation \u2248 1 Good fit &lt;&lt; 1 Uncertainties overestimated &gt;&gt; 1 Poor fit or underestimated uncertainties"},{"location":"statistics/parameter_fitting/#statistical-output","title":"Statistical Output","text":"<p>After successful fitting, obtain statistical measures:</p>"},{"location":"statistics/parameter_fitting/#covariance-matrix","title":"Covariance Matrix","text":"<pre><code>optimizer.calcCoVarianceMatrix();\n// Access: optimizer.coVarianceMatrix[i][j]\n</code></pre> <p>The covariance matrix provides parameter uncertainties and correlations.</p>"},{"location":"statistics/parameter_fitting/#parameter-standard-deviations","title":"Parameter Standard Deviations","text":"<pre><code>optimizer.calcParameterStandardDeviation();\n// Access: optimizer.parameterStandardDeviation[i]\n</code></pre> <p>Standard deviation from diagonal of covariance matrix: \\(\\sigma_i = \\sqrt{C_{ii}}\\)</p>"},{"location":"statistics/parameter_fitting/#correlation-matrix","title":"Correlation Matrix","text":"<pre><code>optimizer.calcCorrelationMatrix();\n// Access: optimizer.parameterCorrelationMatrix[i][j]\n</code></pre> <p>Correlation: \\(\\rho_{ij} = \\frac{C_{ij}}{\\sqrt{C_{ii} C_{jj}}}\\)</p>"},{"location":"statistics/parameter_fitting/#parameter-uncertainty","title":"Parameter Uncertainty","text":"<pre><code>optimizer.calcParameterUncertainty();\n</code></pre> <p>Provides confidence intervals (typically 95%) on fitted parameters.</p>"},{"location":"statistics/parameter_fitting/#display-methods","title":"Display Methods","text":"<pre><code>// Summary statistics\noptimizer.displayResult();\n\n// Fitted vs experimental comparison\noptimizer.displayCurveFit();\n\n// Raw parameter values\ndouble[] params = sampleSet.getSample(0).getFunction().getFittingParams();\n</code></pre>"},{"location":"statistics/parameter_fitting/#algorithm-variants","title":"Algorithm Variants","text":""},{"location":"statistics/parameter_fitting/#levenbergmarquardtabsdev","title":"LevenbergMarquardtAbsDev","text":"<p>Minimizes sum of absolute deviations instead of squared deviations:</p> \\[\\text{SAD} = \\sum_{i=1}^{N} |y_i^{\\text{exp}} - y_i^{\\text{calc}}|\\] <p>More robust to outliers:</p> <pre><code>import neqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardtAbsDev;\n\nLevenbergMarquardtAbsDev optimizer = new LevenbergMarquardtAbsDev();\noptimizer.setSampleSet(sampleSet);\noptimizer.solve();\n</code></pre>"},{"location":"statistics/parameter_fitting/#levenbergmarquardtbiasdev","title":"LevenbergMarquardtBiasDev","text":"<p>Minimizes bias deviation, useful when systematic errors are suspected:</p> \\[\\text{Bias} = \\frac{1}{N} \\sum_{i=1}^{N} (y_i^{\\text{exp}} - y_i^{\\text{calc}})\\] <pre><code>import neqsim.statistics.parameterfitting.nonlinearparameterfitting.LevenbergMarquardtBiasDev;\n\nLevenbergMarquardtBiasDev optimizer = new LevenbergMarquardtBiasDev();\noptimizer.setSampleSet(sampleSet);\noptimizer.solve();\n</code></pre>"},{"location":"statistics/parameter_fitting/#numerical-derivatives","title":"Numerical Derivatives","text":"<p>Derivatives are computed numerically using Ridders' extrapolation method.</p>"},{"location":"statistics/parameter_fitting/#implementation_1","title":"Implementation","text":"<pre><code>import neqsim.statistics.parameterfitting.NumericalDerivative;\n\n// Compute derivative of sample prediction w.r.t. parameter\ndouble deriv = NumericalDerivative.calcDerivative(\n    statisticsObject,  // The StatisticsBaseClass\n    sampleNumber,      // Index of sample\n    parameterNumber    // Index of parameter\n);\n</code></pre>"},{"location":"statistics/parameter_fitting/#algorithm-details","title":"Algorithm Details","text":"<p>Ridders' method: 1. Evaluates function at progressively smaller step sizes 2. Uses polynomial extrapolation to estimate limit 3. Provides error estimate</p> <p>Parameters in implementation: - <code>CON = 1.4</code> - step reduction factor - <code>NTAB = 10</code> - maximum extrapolation iterations - Initial step size <code>h = 0.01</code></p>"},{"location":"statistics/parameter_fitting/#examples","title":"Examples","text":""},{"location":"statistics/parameter_fitting/#example-1-simple-polynomial-fit","title":"Example 1: Simple Polynomial Fit","text":"<pre><code>// Fit: y = a*x^2 + b*x + c\npublic class PolynomialFunction extends LevenbergMarquardtFunction {\n\n    public PolynomialFunction() {\n        params = new double[3];\n    }\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        double x = dependentValues[0];\n        return params[0]*x*x + params[1]*x + params[2];\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n\n// Usage\nPolynomialFunction func = new PolynomialFunction();\nfunc.setInitialGuess(new double[]{1.0, 1.0, 0.0});\n\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\n// Add data: y vs x with uncertainties\ndouble[][] data = {\n    {0.0, 0.5, 0.05},  // x, y, sigma\n    {1.0, 2.3, 0.1},\n    {2.0, 5.1, 0.1},\n    {3.0, 9.8, 0.2}\n};\n\nfor (double[] row : data) {\n    SampleValue s = new SampleValue(row[1], row[2], new double[]{row[0]});\n    s.setFunction(func);\n    samples.add(s);\n}\n\nSampleSet set = new SampleSet(samples);\nLevenbergMarquardt opt = new LevenbergMarquardt();\nopt.setSampleSet(set);\nopt.solve();\nopt.displayResult();\n</code></pre>"},{"location":"statistics/parameter_fitting/#example-2-fitting-binary-interaction-parameters","title":"Example 2: Fitting Binary Interaction Parameters","text":"<pre><code>// Create thermodynamic system\nSystemInterface system = new SystemSrkEos(280.0, 10.0);\nsystem.addComponent(\"methane\", 0.9);\nsystem.addComponent(\"CO2\", 0.1);\nsystem.setMixingRule(\"classic\");\n\nThermodynamicOperations thermoOps = new ThermodynamicOperations(system);\n\n// Create fitting function\nVLEFittingFunction func = new VLEFittingFunction(system, thermoOps);\nfunc.setInitialGuess(new double[]{0.1});  // Initial kij guess\n\n// Experimental VLE data: [T(K), P(bar), x_methane]\ndouble[][] expData = {\n    {250.0, 15.0, 0.85, 0.02},  // T, P, x, sigma\n    {260.0, 20.0, 0.82, 0.02},\n    {270.0, 25.0, 0.78, 0.03},\n    {280.0, 30.0, 0.75, 0.02}\n};\n\nArrayList&lt;SampleValue&gt; samples = new ArrayList&lt;&gt;();\nfor (double[] row : expData) {\n    double[] dep = {row[0], row[1]};  // T, P as independent vars\n    SampleValue s = new SampleValue(row[2], row[3], dep);\n    s.setFunction(func);\n    samples.add(s);\n}\n\nSampleSet set = new SampleSet(samples);\nLevenbergMarquardt opt = new LevenbergMarquardt();\nopt.setSampleSet(set);\nopt.solve();\n\n// Get fitted kij\ndouble kij = func.getFittingParams()[0];\nSystem.out.println(\"Fitted kij = \" + kij);\n\n// Run Monte Carlo for uncertainty\nopt.runMonteCarloSimulation(50);\n</code></pre>"},{"location":"statistics/parameter_fitting/#example-3-multi-parameter-fitting","title":"Example 3: Multi-Parameter Fitting","text":"<pre><code>// Fit Antoine equation: ln(Psat) = A - B/(C + T)\npublic class AntoineFunction extends LevenbergMarquardtFunction {\n\n    public AntoineFunction() {\n        params = new double[3];\n    }\n\n    @Override\n    public double calcValue(double[] dependentValues) {\n        double T = dependentValues[0];  // Temperature in K\n        return Math.exp(params[0] - params[1]/(params[2] + T));\n    }\n\n    @Override\n    public void setFittingParams(int i, double value) {\n        params[i] = value;\n    }\n}\n\n// Set bounds for Antoine parameters\ndouble[][] bounds = {\n    {0.0, 50.0},      // A\n    {0.0, 10000.0},   // B\n    {-300.0, 0.0}     // C (typically negative for Antoine)\n};\nantoineFunc.setBounds(bounds);\n</code></pre>"},{"location":"statistics/parameter_fitting/#troubleshooting","title":"Troubleshooting","text":""},{"location":"statistics/parameter_fitting/#poor-convergence","title":"Poor Convergence","text":"<ol> <li>Check initial guess - Start closer to expected solution</li> <li>Check bounds - Ensure solution is within bounds</li> <li>Increase iterations - <code>setMaxNumberOfIterations(200)</code></li> <li>Check data quality - Outliers can prevent convergence</li> </ol>"},{"location":"statistics/parameter_fitting/#singular-matrix-errors","title":"Singular Matrix Errors","text":"<ol> <li>Insufficient data - Need more data points than parameters</li> <li>Collinear data - Independent variables too correlated</li> <li>Poorly scaled parameters - Normalize parameter magnitudes</li> </ol>"},{"location":"statistics/parameter_fitting/#large-chi-square","title":"Large Chi-Square","text":"<ol> <li>Model inadequate - Try different model form</li> <li>Underestimated uncertainties - Review experimental errors</li> <li>Systematic errors - Check for bias in data</li> </ol>"},{"location":"statistics/parameter_fitting/#references","title":"References","text":"<ol> <li>Marquardt, D.W. (1963). An Algorithm for Least-Squares Estimation of Nonlinear Parameters. SIAM J. Appl. Math., 11(2), 431-441.</li> <li>Press, W.H., et al. (2007). Numerical Recipes. Chapter 15: Modeling of Data.</li> <li>Poling, B.E., Prausnitz, J.M., O'Connell, J.P. (2001). The Properties of Gases and Liquids. 5<sup>th</sup> Edition. McGraw-Hill.</li> </ol>"},{"location":"thermo/","title":"Thermodynamic Documentation Set","text":"<p>This folder collects topic-specific documentation for using NeqSim's thermodynamic, PVT, and physical property capabilities. Each page is intended to be self-contained while pointing to related guides so you can jump directly to the workflows you need.</p>"},{"location":"thermo/#package-structure","title":"Package Structure","text":"<pre><code>thermo/\n\u251c\u2500\u2500 system/       # Fluid system implementations (58 EoS classes)\n\u251c\u2500\u2500 phase/        # Phase types and calculations (62 classes)\n\u251c\u2500\u2500 component/    # Component properties (65 classes)\n\u251c\u2500\u2500 mixingrule/   # Mixing rules for EoS\n\u2514\u2500\u2500 characterization/  # Plus fraction characterization\n</code></pre>"},{"location":"thermo/#subpackage-documentation","title":"Subpackage Documentation","text":"Subpackage Description Documentation system Equations of state implementations system/README.md phase Phase modeling (gas, liquid, solid) phase/README.md component Component property calculations component/README.md mixingrule Binary interaction parameters mixingrule/README.md characterization Plus fraction characterization characterization/README.md"},{"location":"thermo/#guide-contents","title":"Guide Contents","text":""},{"location":"thermo/#core-guides","title":"Core Guides","text":"<ul> <li>Fluid Creation Guide: Comprehensive guide to creating fluids in NeqSim, including all available equations of state, mixing rules, and model selection guidelines.</li> <li>Mixing Rules Guide: Detailed documentation on mixing rules, including mathematical formulations, binary interaction parameters, and usage examples for different applications.</li> <li>Flash Calculations Guide: Comprehensive documentation of flash calculations available via ThermodynamicOperations, including TP, PH, PS, VU flashes, saturation calculations, and hydrate equilibria.</li> </ul>"},{"location":"thermo/#database-documentation","title":"Database Documentation","text":"<ul> <li>Component Database Guide: Detailed documentation of the COMP pure component parameters database, including parameter descriptions, units, and links to thermodynamic models.</li> <li>INTER Table Guide: Detailed documentation of the INTER binary interaction parameters database, including column reference for all EoS, CPA, Huron-Vidal, Wong-Sandler, and NRTL parameters.</li> </ul>"},{"location":"thermo/#reference-documentation","title":"Reference Documentation","text":"<ul> <li>Mathematical Models: Equations of state, activity-coefficient formulations, and transport correlations available in NeqSim.</li> <li>GERG-2008 and EOS-CG: Detailed guide to the reference equations of state for natural gas and CCS applications.</li> </ul>"},{"location":"thermo/#application-guides","title":"Application Guides","text":"<ul> <li>Thermodynamic Workflows: How to set up systems, select models, and perform common equilibrium calculations.</li> <li>PVT and Fluid Characterization: Building realistic fluid descriptions, including heavy-end handling and lab-data reconciliation.</li> <li>Thermodynamic Operations: Flash calculations, phase envelopes, and other process-centric operations.</li> <li>Physical Properties: Density, viscosity, surface tension, and transport-property calculations.</li> </ul> <p>Each document favors short, reproducible code snippets using the Java API so the same ideas transfer to other supported languages (Python/Matlab) with minor syntax changes.</p>"},{"location":"thermo/component_database_guide/","title":"Pure Component Parameters Database (COMP)","text":"<p>This guide provides detailed documentation of the COMP database, which stores pure component parameters used by NeqSim's thermodynamic models. Understanding these parameters is essential for model selection, debugging, and extending NeqSim with new components.</p>"},{"location":"thermo/component_database_guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Database Overview</li> <li>Database Location and Format</li> <li>Parameter Categories</li> <li>Basic Properties</li> <li>Critical Properties</li> <li>Vapor Pressure Parameters</li> <li>Ideal Gas Heat Capacity</li> <li>Liquid Phase Properties</li> <li>Transport Properties</li> <li>Equation of State Parameters</li> <li>Association Parameters (CPA/SAFT)</li> <li>Hydrate Parameters</li> <li>Thermodynamic Reference Data</li> <li>Parameter Reference Table</li> <li>Link to Thermodynamic Models</li> <li>Component Types</li> <li>Accessing Parameters in Code</li> <li>Adding Custom Components</li> <li>Related Database Tables</li> </ul>"},{"location":"thermo/component_database_guide/#database-overview","title":"Database Overview","text":"<p>The COMP table is the primary pure component property database in NeqSim. It contains over 150 parameters per component, organized into functional groups that support different thermodynamic models and property calculations.</p> <p>Key characteristics: - ~260 components in the standard database - CSV format for easy maintenance and version control - Loaded at runtime into an in-memory H2 database - Extensible via temporary tables or database modification</p>"},{"location":"thermo/component_database_guide/#database-location-and-format","title":"Database Location and Format","text":"Item Value File Path <code>src/main/resources/data/COMP.csv</code> Runtime Path <code>data/COMP.csv</code> (in JAR) Format CSV with header row Encoding UTF-8 Primary Key ID (integer) Lookup Key NAME (string, case-sensitive)"},{"location":"thermo/component_database_guide/#parameter-categories","title":"Parameter Categories","text":""},{"location":"thermo/component_database_guide/#basic-properties","title":"Basic Properties","text":"Column Description Unit Model Usage <code>ID</code> Unique component identifier - Internal indexing <code>NAME</code> Component name for lookup - <code>addComponent(\"methane\", ...)</code> <code>CASnumber</code> CAS Registry Number - Component identification <code>COMPTYPE</code> Component type classification - Model selection (see Component Types) <code>COMPINDEX</code> Component index in database - Internal ordering <code>FORMULA</code> Chemical formula - Element calculations <code>MOLARMASS</code> Molar mass g/mol All models (stored internally as kg/mol)"},{"location":"thermo/component_database_guide/#critical-properties","title":"Critical Properties","text":"<p>These parameters are fundamental to all cubic equations of state (SRK, PR, etc.).</p> Column Description Unit Model Usage <code>TC</code> Critical temperature \u00b0C Converted to K internally: \\(T_c = T_{C,db} + 273.15\\) <code>PC</code> Critical pressure bara SRK, PR, CPA EoS parameter a and b <code>ACSFACT</code> Acentric factor (\u03c9) - Alpha function: \\(m = f(\\omega)\\) <code>CRITVOL</code> Critical molar volume cm\u00b3/mol Critical compressibility: \\(Z_c = \\frac{P_c V_c}{R T_c}\\) <code>NORMBOIL</code> Normal boiling point \u00b0C Stored as K internally <p>Model linkage: - SRK EoS: \\(a = 0.42748 \\frac{R^2 T_c^2}{P_c}\\), \\(b = 0.08664 \\frac{R T_c}{P_c}\\) - PR EoS: \\(a = 0.45724 \\frac{R^2 T_c^2}{P_c}\\), \\(b = 0.07780 \\frac{R T_c}{P_c}\\) - Alpha function: \\(\\alpha(T) = [1 + m(1-\\sqrt{T_r})]^2\\) where \\(m = f(\\omega)\\)</p>"},{"location":"thermo/component_database_guide/#vapor-pressure-parameters","title":"Vapor Pressure Parameters","text":"<p>Parameters for Antoine-type vapor pressure correlations.</p> Column Description Unit Model Usage <code>AntoineVapPresLiqType</code> Equation type - <code>pow10</code>, <code>log</code>, <code>exp</code>, <code>loglog</code> <code>ANTOINEA</code> Antoine A coefficient - Vapor pressure calculation <code>ANTOINEB</code> Antoine B coefficient - Vapor pressure calculation <code>ANTOINEC</code> Antoine C coefficient - Vapor pressure calculation <code>ANTOINED</code> Antoine D coefficient - Extended Antoine <code>ANTOINEE</code> Antoine E coefficient - Extended Antoine <code>ANTOINESolidA</code> Solid vapor pressure A - Sublimation pressure <code>ANTOINESolidB</code> Solid vapor pressure B - Sublimation pressure <code>ANTOINESolidC</code> Solid vapor pressure C - Sublimation pressure <p>Antoine equation forms: - <code>pow10</code>: \\(\\log_{10}(P_{sat}) = A - \\frac{B}{T + C}\\) (P in mmHg, T in \u00b0C) - <code>log</code>: \\(\\ln(P_{sat}) = A + \\frac{B}{T} + C \\ln(T) + D T^E\\) - <code>exp</code>: \\(P_{sat} = \\exp(A - \\frac{B}{T + C})\\)</p>"},{"location":"thermo/component_database_guide/#ideal-gas-heat-capacity","title":"Ideal Gas Heat Capacity","text":"<p>Polynomial coefficients for ideal gas heat capacity: \\(C_p^{ig} = A + BT + CT^2 + DT^3 + ET^4\\)</p> Column Description Unit <code>CPA</code> Coefficient A J/(mol\u00b7K) <code>CPB</code> Coefficient B J/(mol\u00b7K\u00b2) <code>CPC</code> Coefficient C J/(mol\u00b7K\u00b3) <code>CPD</code> Coefficient D J/(mol\u00b7K\u2074) <code>CPE</code> Coefficient E J/(mol\u00b7K\u2075) <code>CPsolid1-5</code> Solid phase Cp coefficients J/(mol\u00b7K) <code>CPliquid1-5</code> Liquid phase Cp coefficients J/(mol\u00b7K) <p>Usage: Enthalpy, entropy, and Gibbs energy departure functions for all EoS models.</p>"},{"location":"thermo/component_database_guide/#liquid-phase-properties","title":"Liquid Phase Properties","text":"Column Description Unit Model Usage <code>LIQDENS</code> Liquid density at standard conditions g/cm\u00b3 Density correlations <code>RACKETZ</code> Rackett compressibility factor - Rackett liquid density: \\(V = V_c Z_{RA}^{[1+(1-T_r)^{2/7}]}\\) <code>racketZCPA</code> Rackett Z for CPA model - CPA volume correction <code>volcorrSRK_T</code> SRK volume translation - P\u00e9neloux correction: \\(V_{corr} = V_{EoS} - c\\) <code>volcorrCPA_T</code> CPA volume translation - CPA P\u00e9neloux correction <code>STDDENS</code> Standard density g/cm\u00b3 Reference conditions <code>LIQUIDDENSITYCOEFS1-5</code> Liquid density correlation coefficients - Temperature-dependent density"},{"location":"thermo/component_database_guide/#transport-properties","title":"Transport Properties","text":"Column Description Unit Model Usage <code>DIPOLEMOMENT</code> Dipole moment Debye Polar corrections <code>VISCFACT</code> Viscosity correction factor - Corresponding states <code>LIQVISCMODEL</code> Liquid viscosity model type - Model selection (1-4) <code>LIQVISC1-4</code> Liquid viscosity parameters - Andrade equation: \\(\\ln(\\eta) = A + B/T + C\\ln(T) + DT\\) <code>LIQUIDCONDUCTIVITY1-3</code> Liquid thermal conductivity - \\(k = A + BT + CT^2\\) <code>PARACHOR</code> Parachor - Surface tension: \\(\\sigma^{1/4} = P[\\rho_L - \\rho_V]\\) <code>PARACHOR_CPA</code> Parachor for CPA model - CPA surface tension <code>criticalViscosity</code> Critical viscosity Pa\u00b7s Transport correlations"},{"location":"thermo/component_database_guide/#equation-of-state-parameters","title":"Equation of State Parameters","text":""},{"location":"thermo/component_database_guide/#attractive-term-parameters","title":"Attractive Term Parameters","text":"Column Description Unit Model Usage <code>PVMODEL</code> PV model type - <code>Classic</code> for standard EoS <code>MC1</code>, <code>MC2</code>, <code>MC3</code> Mathias-Copeman parameters (SRK) - Enhanced alpha function <code>MCPR1</code>, <code>MCPR2</code>, <code>MCPR3</code> Mathias-Copeman parameters (PR) - PR alpha function <code>TwuCoon1-3</code> Twu-Coon alpha function parameters - Twu-Coon attractive term <code>SCHWARTZENTRUBER1-3</code> Schwartzentruber parameters - Schwartzentruber EoS <code>MC1Solid-MC3Solid</code> Solid phase Mathias-Copeman - Solid fugacity <p>Mathias-Copeman alpha function: $\\(\\alpha = [1 + c_1(1-\\sqrt{T_r}) + c_2(1-\\sqrt{T_r})^2 + c_3(1-\\sqrt{T_r})^3]^2\\)$</p>"},{"location":"thermo/component_database_guide/#lennard-jones-parameters","title":"Lennard-Jones Parameters","text":"Column Description Unit Model Usage <code>LJDIAMETER</code> LJ molecular diameter \u00c5 Gas viscosity, diffusion <code>LJEPS</code> LJ energy parameter K \u03b5/k_B <code>SphericalCoreRadius</code> Hard-core radius - LJ potential <code>LJDIAMETERHYDRATE</code> LJ diameter for hydrates \u00c5 Hydrate equilibrium <code>LJEPSHYDRATE</code> LJ energy for hydrates K Hydrate cage interaction"},{"location":"thermo/component_database_guide/#association-parameters-cpasaft","title":"Association Parameters (CPA/SAFT)","text":"<p>Parameters for Cubic-Plus-Association (CPA) and PC-SAFT models.</p> Column Description Unit Model Usage <code>associationsites</code> Number of association sites - 0, 1, 2, 3, or 4 <code>associationscheme</code> Association scheme - <code>0</code>, <code>1A</code>, <code>2A</code>, <code>2B</code>, <code>3B</code>, <code>4C</code> <code>associationenergy</code> Association energy (\u03b5^AB) J/mol CPA association term <code>associationboundingvolume_SRK</code> Association volume (\u03b2) for SRK-CPA - SRK-CPA <code>associationboundingvolume_PR</code> Association volume (\u03b2) for PR-CPA - PR-CPA <code>aCPA_SRK</code> CPA a parameter (SRK base) Pa\u00b7m\u2076/mol\u00b2 SRK-CPA <code>bCPA_SRK</code> CPA b parameter (SRK base) m\u00b3/mol SRK-CPA <code>mCPA_SRK</code> CPA m parameter (SRK base) - SRK-CPA <code>aCPA_PR</code> CPA a parameter (PR base) Pa\u00b7m\u2076/mol\u00b2 PR-CPA <code>bCPA_PR</code> CPA b parameter (PR base) m\u00b3/mol PR-CPA <code>mCPA_PR</code> CPA m parameter (PR base) - PR-CPA"},{"location":"thermo/component_database_guide/#pc-saft-parameters","title":"PC-SAFT Parameters","text":"Column Description Unit Model Usage <code>mSAFT</code> Number of segments - Chain length <code>sigmaSAFT</code> Segment diameter \u00c5 Hard-sphere term <code>epsikSAFT</code> Segment energy K \u03b5/k_B <code>associationboundingvolume_PCSAFT</code> Association volume - PC-SAFT association <code>associationenergy_PCSAFT</code> Association energy K PC-SAFT association <p>Association schemes: | Scheme | Sites | Example Molecules | |--------|-------|-------------------| | <code>0</code> | 0 | Non-associating (hydrocarbons) | | <code>1A</code> | 1 | HCl, aromatic compounds | | <code>2A</code> | 2 | CO\u2082 (electron donor/acceptor) | | <code>2B</code> | 2 | Alcohols (1 proton donor, 1 acceptor) | | <code>3B</code> | 3 | Amines | | <code>4C</code> | 4 | Water, glycols (2 donors, 2 acceptors) |</p>"},{"location":"thermo/component_database_guide/#hydrate-parameters","title":"Hydrate Parameters","text":"<p>Parameters for gas hydrate equilibrium calculations.</p> Column Description Unit Model Usage <code>HydrateFormer</code> Hydrate-forming capability - <code>yes</code> or <code>no</code> <code>HydrateA1Small</code>, <code>HydrateB1Small</code> Type I small cage (512) - Langmuir constants <code>HydrateA1Large</code>, <code>HydrateB1Large</code> Type I large cage (51262) - Langmuir constants <code>HydrateA2Small</code>, <code>HydrateB2Small</code> Type II small cage (512) - Langmuir constants <code>HydrateA2Large</code>, <code>HydrateB2Large</code> Type II large cage (51264) - Langmuir constants <code>A1_smallGF-B2_largeGF</code> Graffis parameters - Alternative parameterization <code>SphericalCoreRadiusHYDRATE</code> Core radius for hydrates - Cavity occupation"},{"location":"thermo/component_database_guide/#thermodynamic-reference-data","title":"Thermodynamic Reference Data","text":"Column Description Unit Model Usage <code>Href</code> Reference enthalpy J/mol Enthalpy calculations <code>GIBBSENERGYOFFORMATION</code> Gibbs energy of formation J/mol Chemical equilibrium <code>ENTHALPYOFFORMATION</code> Standard enthalpy of formation J/mol Reaction thermodynamics <code>ABSOLUTEENTROPY</code> Absolute entropy J/(mol\u00b7K) Entropy calculations <code>HEATOFFUSION</code> Heat of fusion J/mol Solid-liquid equilibrium <code>Hsub</code> Heat of sublimation J/mol Solid-vapor equilibrium <code>TRIPLEPOINTTEMPERATURE</code> Triple point temperature K Phase boundaries <code>TRIPLEPOINTPRESSURE</code> Triple point pressure bar Phase boundaries <code>TRIPLEPOINTDENSITY</code> Triple point density kg/m\u00b3 Reference state <code>MELTINGPOINTTEMPERATURE</code> Melting point K Solid calculations"},{"location":"thermo/component_database_guide/#ionic-and-electrolyte-parameters","title":"Ionic and Electrolyte Parameters","text":"Column Description Unit Model Usage <code>IONICCHARGE</code> Ionic charge - Electrolyte models <code>REFERENCESTATETYPE</code> Reference state - <code>solvent</code> or <code>solute</code> <code>DIELECTRICPARAMETER1-5</code> Dielectric parameters - Electrolyte activity <code>DeshMatIonicDiameter</code> Debye-H\u00fcckel diameter \u00c5 Electrolyte models <code>calcActivity</code> Activity calculation flag - 0 or 1"},{"location":"thermo/component_database_guide/#henrys-law-parameters","title":"Henry's Law Parameters","text":"Column Description Unit <code>HenryCoef1</code> Henry constant A - <code>HenryCoef2</code> Henry constant B - <code>HenryCoef3</code> Henry constant C - <code>HenryCoef4</code> Henry constant D - <p>Henry's law correlation: $\\(\\ln(H) = A + \\frac{B}{T} + C\\ln(T) + DT\\)$</p>"},{"location":"thermo/component_database_guide/#solid-phase-parameters","title":"Solid Phase Parameters","text":"Column Description Unit <code>SOLIDDENSITYCOEFS1-5</code> Solid density coefficients - <code>HEATOFVAPORIZATIONCOEFS1-5</code> Heat of vaporization coefficients - <code>waxformer</code> Wax-forming component -"},{"location":"thermo/component_database_guide/#parameter-reference-table","title":"Parameter Reference Table","text":"<p>Complete parameter list with units and typical values:</p> Parameter Unit Example (methane) Example (water) <code>MOLARMASS</code> g/mol 16.043 18.015 <code>TC</code> \u00b0C -82.59 374.15 <code>PC</code> bara 45.99 220.89 <code>ACSFACT</code> - 0.0115 0.344 <code>CRITVOL</code> cm\u00b3/mol 99.0 56.0 <code>NORMBOIL</code> \u00b0C -161.55 100.0 <code>LIQDENS</code> g/cm\u00b3 0.422 0.999 <code>RACKETZ</code> - 0.0 0.0 <code>DIPOLEMOMENT</code> Debye 0.0 1.8 <code>associationsites</code> - 0 4 <code>HydrateFormer</code> - yes no"},{"location":"thermo/component_database_guide/#link-to-thermodynamic-models","title":"Link to Thermodynamic Models","text":""},{"location":"thermo/component_database_guide/#how-parameters-feed-into-models","title":"How Parameters Feed into Models","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      COMP Database                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  TC, PC, ACSFACT  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Cubic EoS (SRK, PR)          \u2502\n\u2502  MC1, MC2, MC3    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Mathias-Copeman \u03b1(T)         \u2502\n\u2502  TwuCoon1-3       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Twu-Coon \u03b1(T)                \u2502\n\u2502  aCPA, bCPA, mCPA \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; CPA EoS                      \u2502\n\u2502  associationsites \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; CPA/SAFT Association         \u2502\n\u2502  mSAFT, \u03c3SAFT, \u03b5SAFT \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; PC-SAFT                       \u2502\n\u2502  UNIFAC groups    \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Activity models              \u2502\n\u2502  LJDIAMETER, LJEPS \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Transport properties         \u2502\n\u2502  HydrateA/B params \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Hydrate equilibrium          \u2502\n\u2502  CPA, CPB, CPC... \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Enthalpy/Entropy             \u2502\n\u2502  ANTOINEA-E       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Vapor pressure               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"thermo/component_database_guide/#model-parameter-mapping","title":"Model-Parameter Mapping","text":"Model Class Key Parameters <code>SystemSrkEos</code> TC, PC, ACSFACT, MC1-3, RACKETZ <code>SystemPrEos</code> TC, PC, ACSFACT, MCPR1-3 <code>SystemSrkCPA</code> aCPA_SRK, bCPA_SRK, mCPA_SRK, associationsites, associationenergy, associationboundingvolume_SRK <code>SystemPrCPA</code> aCPA_PR, bCPA_PR, mCPA_PR, associationboundingvolume_PR <code>SystemPCSAFT</code> mSAFT, sigmaSAFT, epsikSAFT, associationboundingvolume_PCSAFT <code>SystemGERG2008Eos</code> Uses internal GERG parameters, but TC/PC for initialization <code>SystemUNIFAC</code> TC, PC (for vapor), UNIFAC groups from UNIFACcomp table"},{"location":"thermo/component_database_guide/#component-types","title":"Component Types","text":"<p>The <code>COMPTYPE</code> field classifies components for model selection:</p> Type Description Examples <code>HC</code> Hydrocarbon methane, ethane, propane, benzene <code>inert</code> Inert gas nitrogen, CO2, oxygen, argon <code>ion</code> Ionic species Na+, Cl-, HCO3-, Ca++ <code>amine</code> Amine compounds MDEA, MEA, DEA <code>alcohol</code> Alcohols methanol, ethanol <code>glycol</code> Glycol compounds MEG, DEG, TEG <code>ice</code> Ice/solid water ice <code>TBP</code> TBP pseudo-component Generated from characterization <code>plus</code> Plus fraction C7+, C10+, etc."},{"location":"thermo/component_database_guide/#accessing-parameters-in-code","title":"Accessing Parameters in Code","text":""},{"location":"thermo/component_database_guide/#reading-component-properties","title":"Reading Component Properties","text":"<pre><code>// Create a system and access component properties\nSystemInterface fluid = new SystemSrkEos(298.15, 10.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.init(0);\n\n// Access pure component parameters\nComponentInterface comp = fluid.getPhase(0).getComponent(\"methane\");\ndouble Tc = comp.getTC();           // Critical temperature [K]\ndouble Pc = comp.getPC();           // Critical pressure [bara]\ndouble omega = comp.getAcentricFactor();  // Acentric factor [-]\ndouble Mw = comp.getMolarMass();    // Molar mass [kg/mol]\ndouble Tb = comp.getNormalBoilingPoint(); // Normal boiling point [K]\n\nSystem.out.println(\"Methane Tc = \" + Tc + \" K\");\nSystem.out.println(\"Methane Pc = \" + Pc + \" bara\");\nSystem.out.println(\"Methane \u03c9 = \" + omega);\n</code></pre>"},{"location":"thermo/component_database_guide/#modifying-component-properties","title":"Modifying Component Properties","text":"<pre><code>// Modify properties for sensitivity analysis\ncomp.setTC(190.6);  // Set new Tc in Kelvin\ncomp.setPC(46.0);   // Set new Pc in bara\ncomp.setAcentricFactor(0.012);\n\n// Re-initialize to apply changes\nfluid.init(0);\n</code></pre>"},{"location":"thermo/component_database_guide/#adding-custom-components","title":"Adding Custom Components","text":""},{"location":"thermo/component_database_guide/#method-1-database-modification","title":"Method 1: Database Modification","text":"<p>Add a new row to <code>COMP.csv</code> with all required parameters.</p>"},{"location":"thermo/component_database_guide/#method-2-runtime-addition","title":"Method 2: Runtime Addition","text":"<pre><code>// Add a pseudo-component with custom properties\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);\n\n// Add TBP fraction with molar mass and density\nfluid.addTBPfraction(\"C7_custom\", 0.1, 95.0, 0.72);  // name, moles, MW, SG\n\n// Or add component and modify properties\nfluid.addComponent(\"n-heptane\", 1.0);\nComponentInterface comp = fluid.getPhase(0).getComponent(\"n-heptane\");\ncomp.setTC(540.0);\ncomp.setPC(27.4);\ncomp.setAcentricFactor(0.35);\n\n// Initialize database for binary parameters\nfluid.createDatabase(true);\nfluid.setMixingRule(2);\n</code></pre>"},{"location":"thermo/component_database_guide/#method-3-temporary-tables","title":"Method 3: Temporary Tables","text":"<pre><code>// Enable temporary tables for session-specific components\nNeqSimDataBase.setCreateTemporaryTables(true);\n\n// Components added to \"comptemp\" table\nfluid.getPhase(0).getComponent(0).insertComponentIntoDatabase(\"comptemp\");\n\n// Remember to disable after use\nNeqSimDataBase.setCreateTemporaryTables(false);\n</code></pre>"},{"location":"thermo/component_database_guide/#related-database-tables","title":"Related Database Tables","text":"<p>The COMP table works with several related tables:</p> Table Purpose Key Columns <code>INTER</code> Binary interaction parameters (kij) comp1, comp2, kij, model <code>UNIFACcomp</code> UNIFAC group assignments compname, group, count <code>UNIFACGroupParam</code> UNIFAC group parameters groupid, R, Q <code>UNIFACInterParam*</code> UNIFAC group interaction parameters group1, group2, aij <code>MBWR32param</code> MBWR equation parameters comp, coefficients <code>AdsorptionParameters</code> Adsorption isotherm parameters comp, adsorbent, params"},{"location":"thermo/component_database_guide/#see-also","title":"See Also","text":"<ul> <li>Fluid Creation Guide - How to create fluids using these parameters</li> <li>Mixing Rules Guide - Binary interaction parameters (kij)</li> <li>Mathematical Models - Model equations using these parameters</li> </ul>"},{"location":"thermo/component_database_guide/#references","title":"References","text":"<ol> <li>Soave, G. (1972). Equilibrium constants from a modified Redlich-Kwong equation of state. Chemical Engineering Science, 27(6), 1197-1203.</li> <li>Peng, D. Y., &amp; Robinson, D. B. (1976). A new two-constant equation of state. Industrial &amp; Engineering Chemistry Fundamentals, 15(1), 59-64.</li> <li>Kontogeorgis, G. M., et al. (1999). An equation of state for associating fluids. Industrial &amp; Engineering Chemistry Research, 38(10), 4073-4082.</li> <li>Gross, J., &amp; Sadowski, G. (2001). Perturbed-chain SAFT: An equation of state based on a perturbation theory for chain molecules. Industrial &amp; Engineering Chemistry Research, 40(4), 1244-1260.</li> </ol>"},{"location":"thermo/flash_calculations_guide/","title":"Flash Calculations Guide","text":"<p>This guide provides comprehensive documentation of flash calculations available in NeqSim via the <code>ThermodynamicOperations</code> class. Flash calculations determine the equilibrium state of a thermodynamic system by solving phase equilibrium equations under specified constraints.</p>"},{"location":"thermo/flash_calculations_guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Basic Usage</li> <li>Flash Types</li> <li>TP Flash (Temperature-Pressure)</li> <li>PH Flash (Pressure-Enthalpy)</li> <li>PS Flash (Pressure-Entropy)</li> <li>PU Flash (Pressure-Internal Energy)</li> <li>TV Flash (Temperature-Volume)</li> <li>TS Flash (Temperature-Entropy)</li> <li>VH Flash (Volume-Enthalpy)</li> <li>VU Flash (Volume-Internal Energy)</li> <li>VS Flash (Volume-Entropy)</li> <li>Saturation Calculations</li> <li>Bubble Point</li> <li>Dew Point</li> <li>Water Dew Point</li> <li>Hydrocarbon Dew Point</li> <li>Special Flash Types</li> <li>Solid Phase Flash</li> <li>Critical Point Flash</li> <li>Gradient Flash</li> <li>Phase Fraction Flash</li> <li>Reference EoS Flash Methods</li> <li>GERG-2008 Flashes</li> <li>Leachman (Hydrogen) Flashes</li> <li>Vega (CO\u2082) Flashes</li> <li>Hydrate Calculations</li> <li>Unit Handling</li> <li>Error Handling</li> <li>Best Practices</li> <li>API Reference Table</li> </ul>"},{"location":"thermo/flash_calculations_guide/#overview","title":"Overview","text":"<p>Flash calculations solve phase equilibrium problems by finding: - The number and types of phases present - The composition of each phase - The phase fractions (vapor/liquid/solid split) - Temperature or pressure (for non-TP flashes)</p> <p>The mathematical basis is the equality of chemical potentials (or fugacities) for all components across all phases:</p> \\[f_i^{vapor} = f_i^{liquid} = f_i^{solid}\\] <p>where \\(f_i\\) is the fugacity of component \\(i\\).</p>"},{"location":"thermo/flash_calculations_guide/#basic-usage","title":"Basic Usage","text":"<p>All flash calculations use the <code>ThermodynamicOperations</code> class:</p> <pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\n// 1. Create a fluid system\nSystemInterface fluid = new SystemSrkEos(298.15, 50.0);  // T in K, P in bara\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"ethane\", 0.15);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\n// 2. Create operations object\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n\n// 3. Run the flash calculation\nops.TPflash();\n\n// 4. Access results\nSystem.out.println(\"Vapor fraction: \" + fluid.getBeta());\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\nSystem.out.println(\"Temperature: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"Pressure: \" + fluid.getPressure(\"bara\") + \" bara\");\n</code></pre>"},{"location":"thermo/flash_calculations_guide/#flash-types","title":"Flash Types","text":""},{"location":"thermo/flash_calculations_guide/#tp-flash-temperature-pressure","title":"TP Flash (Temperature-Pressure)","text":"<p>The most common flash type. Given temperature and pressure, find phase split and compositions.</p> <p>Method signatures: <pre><code>void TPflash()\nvoid TPflash(boolean checkForSolids)\n</code></pre></p> <p>Example: <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"n-heptane\", 0.1);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Results\ndouble vaporFraction = fluid.getBeta();  // Molar vapor fraction\ndouble liquidDensity = fluid.getPhase(\"oil\").getDensity(\"kg/m3\");\n</code></pre></p> <p>With solid phase checking: <pre><code>fluid.setSolidPhaseCheck(true);\nops.TPflash(true);  // Includes solid equilibrium\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#ph-flash-pressure-enthalpy","title":"PH Flash (Pressure-Enthalpy)","text":"<p>Given pressure and total enthalpy, find temperature and phase split. Essential for: - Valve/throttling calculations (isenthalpic expansion) - Heat exchanger design - Process streams after heating/cooling</p> <p>Method signatures: <pre><code>void PHflash(double Hspec)                    // H in J\nvoid PHflash(double Hspec, String unit)       // Supported: J, J/mol, J/kg, kJ/kg\nvoid PHflash(double Hspec, int type)          // type 0 = standard\n</code></pre></p> <p>Example - Joule-Thomson expansion: <pre><code>SystemInterface fluid = new SystemSrkEos(350.0, 100.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\n// Store inlet enthalpy\ndouble inletH = fluid.getEnthalpy(\"J\");\n\n// Reduce pressure (isenthalpic process)\nfluid.setPressure(10.0, \"bara\");\n\n// Find new temperature at same enthalpy\nops.PHflash(inletH);\n\nSystem.out.println(\"Outlet temperature: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\n// Demonstrates Joule-Thomson cooling\n</code></pre></p> <p>With unit specification: <pre><code>// Enthalpy specified in kJ/kg\nops.PHflash(-150.0, \"kJ/kg\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#ps-flash-pressure-entropy","title":"PS Flash (Pressure-Entropy)","text":"<p>Given pressure and total entropy, find temperature and phase split. Used for: - Isentropic compression/expansion - Turbine/compressor calculations - Ideal work calculations</p> <p>Method signatures: <pre><code>void PSflash(double Sspec)                    // S in J/K\nvoid PSflash(double Sspec, String unit)       // Supported: J/K, J/molK, J/kgK, kJ/kgK\n</code></pre></p> <p>Example - Isentropic compression: <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 10.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initPhysicalProperties();\n\n// Inlet conditions\ndouble T1 = fluid.getTemperature(\"K\");\ndouble S_inlet = fluid.getEntropy(\"J/K\");\n\n// Compress to higher pressure (isentropic)\nfluid.setPressure(50.0, \"bara\");\nops.PSflash(S_inlet);\n\ndouble T2 = fluid.getTemperature(\"K\");\nSystem.out.println(\"Isentropic outlet T: \" + (T2 - 273.15) + \" \u00b0C\");\n\n// Compare to actual with polytropic efficiency\ndouble eta_poly = 0.85;\ndouble T2_actual = T1 + (T2 - T1) / eta_poly;\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#pu-flash-pressure-internal-energy","title":"PU Flash (Pressure-Internal Energy)","text":"<p>Given pressure and internal energy, find temperature and phase split.</p> <p>Method signatures: <pre><code>void PUflash(double Uspec)                    // U in J\nvoid PUflash(double Uspec, String unit)       // Supported: J, J/mol, J/kg, kJ/kg\nvoid PUflash(double Pspec, double Uspec, String unitP, String unitU)\n</code></pre></p> <p>Example: <pre><code>ops.PUflash(100.0, -500.0, \"bara\", \"kJ/kg\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#tv-flash-temperature-volume","title":"TV Flash (Temperature-Volume)","text":"<p>Given temperature and total volume, find pressure and phase split. Used for: - Fixed-volume vessel calculations - Constant volume processes</p> <p>Method signatures: <pre><code>void TVflash(double Vspec)                    // V in cm\u00b3\nvoid TVflash(double Vspec, String unit)       // Supported: m3\n</code></pre></p> <p>Example - Fixed volume vessel: <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 10.0);\nfluid.addComponent(\"nitrogen\", 1.0);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Vessel volume = 1 m\u00b3\ndouble vesselVolume = 1.0;  // m\u00b3\n\n// Heat the vessel (isochoric process)\nfluid.setTemperature(400.0, \"K\");\nops.TVflash(vesselVolume, \"m3\");\n\nSystem.out.println(\"New pressure: \" + fluid.getPressure(\"bara\") + \" bara\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#ts-flash-temperature-entropy","title":"TS Flash (Temperature-Entropy)","text":"<p>Given temperature and entropy, find pressure and phase split.</p> <p>Method signatures: <pre><code>void TSflash(double Sspec)                    // S in J/K\nvoid TSflash(double Sspec, String unit)       // Supported: J/K, J/molK, J/kgK, kJ/kgK\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#vh-flash-volume-enthalpy","title":"VH Flash (Volume-Enthalpy)","text":"<p>Given volume and enthalpy, find temperature, pressure, and phase split. Used for: - Dynamic simulations - Closed system energy balances</p> <p>Method signatures: <pre><code>void VHflash(double Vspec, double Hspec)\nvoid VHflash(double V, double H, String unitV, String unitH)\n</code></pre></p> <p>Example: <pre><code>ops.VHflash(0.5, -50000.0, \"m3\", \"J\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#vu-flash-volume-internal-energy","title":"VU Flash (Volume-Internal Energy)","text":"<p>Given volume and internal energy, find temperature, pressure, and phase split. Critical for: - Dynamic vessel simulations - Depressurization calculations - Blowdown modeling</p> <p>Method signatures: <pre><code>void VUflash(double Vspec, double Uspec)\nvoid VUflash(double V, double U, String unitV, String unitU)\n</code></pre></p> <p>Example - Dynamic depressurization: <pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(300.0, 100.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"CO2\", 0.1);\nfluid.setMixingRule(10);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\n// Initial state\ndouble V0 = fluid.getVolume(\"m3\");\ndouble U0 = fluid.getInternalEnergy(\"J\");\n\n// Simulate adiabatic expansion (U constant, V increases)\ndouble V_new = V0 * 2.0;  // Volume doubles\nops.VUflash(V_new, U0, \"m3\", \"J\");\n\nSystem.out.println(\"New T: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"New P: \" + fluid.getPressure(\"bara\") + \" bara\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#vs-flash-volume-entropy","title":"VS Flash (Volume-Entropy)","text":"<p>Given volume and entropy, find temperature, pressure, and phase split.</p> <p>Method signatures: <pre><code>void VSflash(double Vspec, double Sspec)\nvoid VSflash(double V, double S, String unitV, String unitS)\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#saturation-calculations","title":"Saturation Calculations","text":""},{"location":"thermo/flash_calculations_guide/#bubble-point","title":"Bubble Point","text":"<p>Calculate the bubble point (onset of vaporization) at a given temperature or pressure.</p> <p>Temperature flash (find T at given P): <pre><code>void bubblePointTemperatureFlash()\n</code></pre></p> <p>Pressure flash (find P at given T): <pre><code>void bubblePointPressureFlash()\nvoid bubblePointPressureFlash(boolean derivatives)  // Include dP/dT, dP/dx\n</code></pre></p> <p>Example: <pre><code>SystemInterface fluid = new SystemSrkEos(298.15, 10.0);\nfluid.addComponent(\"propane\", 0.5);\nfluid.addComponent(\"n-butane\", 0.5);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n\n// Find bubble point pressure at 25\u00b0C\nfluid.setTemperature(298.15, \"K\");\nops.bubblePointPressureFlash();\nSystem.out.println(\"Bubble point pressure: \" + fluid.getPressure(\"bara\") + \" bara\");\n\n// Find bubble point temperature at 5 bar\nfluid.setPressure(5.0, \"bara\");\nops.bubblePointTemperatureFlash();\nSystem.out.println(\"Bubble point temperature: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#dew-point","title":"Dew Point","text":"<p>Calculate the dew point (onset of condensation) at a given temperature or pressure.</p> <p>Temperature flash: <pre><code>void dewPointTemperatureFlash()\nvoid dewPointTemperatureFlash(boolean derivatives)\n</code></pre></p> <p>Pressure flash: <pre><code>void dewPointPressureFlash()\n</code></pre></p> <p>Example: <pre><code>// Natural gas dew point\nSystemInterface gas = new SystemSrkEos(298.15, 50.0);\ngas.addComponent(\"methane\", 0.85);\ngas.addComponent(\"ethane\", 0.08);\ngas.addComponent(\"propane\", 0.04);\ngas.addComponent(\"n-butane\", 0.02);\ngas.addComponent(\"n-pentane\", 0.01);\ngas.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\n\n// Find dew point at 50 bar\nops.dewPointTemperatureFlash();\nSystem.out.println(\"Hydrocarbon dew point: \" + gas.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#water-dew-point","title":"Water Dew Point","text":"<p>Calculate the water dew point (onset of water condensation).</p> <p>Methods: <pre><code>void waterDewPointTemperatureFlash()\nvoid waterDewPointTemperatureMultiphaseFlash()  // For complex systems\n</code></pre></p> <p>Example: <pre><code>SystemInterface wetGas = new SystemSrkCPAstatoil(298.15, 80.0);\nwetGas.addComponent(\"methane\", 0.95);\nwetGas.addComponent(\"water\", 0.05);\nwetGas.setMixingRule(10);\n\nThermodynamicOperations ops = new ThermodynamicOperations(wetGas);\nops.waterDewPointTemperatureFlash();\n\nSystem.out.println(\"Water dew point: \" + wetGas.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#hydrocarbon-dew-point","title":"Hydrocarbon Dew Point","text":"<p>Calculate the cricondentherm (maximum temperature for two-phase region).</p> <pre><code>void dewPointPressureFlashHC()\n</code></pre>"},{"location":"thermo/flash_calculations_guide/#special-flash-types","title":"Special Flash Types","text":""},{"location":"thermo/flash_calculations_guide/#solid-phase-flash","title":"Solid Phase Flash","text":"<p>For systems with potential solid precipitation (wax, ice, hydrates).</p> <pre><code>void TPSolidflash()\nvoid PHsolidFlash(double Hspec)\nvoid freezingPointTemperatureFlash()\n</code></pre> <p>Example - Wax precipitation: <pre><code>SystemInterface oil = new SystemSrkEos(320.0, 10.0);\noil.addComponent(\"n-C20\", 0.1);\noil.addComponent(\"n-C10\", 0.9);\noil.setSolidPhaseCheck(\"n-C20\");\noil.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(oil);\nops.freezingPointTemperatureFlash();\nSystem.out.println(\"Wax appearance temperature: \" + oil.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#critical-point-flash","title":"Critical Point Flash","text":"<p>Find the critical point of a mixture.</p> <pre><code>void criticalPointFlash()\n</code></pre> <p>Example: <pre><code>SystemInterface mix = new SystemSrkEos(300.0, 50.0);\nmix.addComponent(\"methane\", 0.7);\nmix.addComponent(\"ethane\", 0.3);\nmix.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(mix);\nops.criticalPointFlash();\n\nSystem.out.println(\"Critical T: \" + mix.getTemperature(\"K\") + \" K\");\nSystem.out.println(\"Critical P: \" + mix.getPressure(\"bara\") + \" bara\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#gradient-flash","title":"Gradient Flash","text":"<p>Calculate composition variation with depth (gravitational segregation).</p> <pre><code>SystemInterface TPgradientFlash(double height, double temperature)\n</code></pre> <p>Parameters: - <code>height</code>: Depth in meters - <code>temperature</code>: Temperature at depth in Kelvin</p>"},{"location":"thermo/flash_calculations_guide/#phase-fraction-flash","title":"Phase Fraction Flash","text":"<p>Find conditions for a specified phase fraction.</p> <pre><code>void constantPhaseFractionPressureFlash(double fraction)      // Find P at given vapor fraction\nvoid constantPhaseFractionTemperatureFlash(double fraction)   // Find T at given vapor fraction\nvoid TVfractionFlash(double Vfraction)                        // Volume fraction based\n</code></pre>"},{"location":"thermo/flash_calculations_guide/#reference-eos-flash-methods","title":"Reference EoS Flash Methods","text":"<p>For high-accuracy calculations, NeqSim provides flash methods using reference equations of state.</p>"},{"location":"thermo/flash_calculations_guide/#gerg-2008-flashes","title":"GERG-2008 Flashes","text":"<p>For natural gas systems with GERG-2008 accuracy:</p> <pre><code>void PHflashGERG2008(double Hspec)\nvoid PSflashGERG2008(double Sspec)\n</code></pre> <p>Example: <pre><code>SystemInterface gas = new SystemGERG2008Eos(280.0, 100.0);\ngas.addComponent(\"methane\", 0.9);\ngas.addComponent(\"ethane\", 0.06);\ngas.addComponent(\"CO2\", 0.04);\n\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\nops.TPflash();\ndouble H = gas.getEnthalpy(\"J\");\n\ngas.setPressure(50.0);\nops.PHflashGERG2008(H);  // High-accuracy isenthalpic flash\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#leachman-hydrogen-flashes","title":"Leachman (Hydrogen) Flashes","text":"<p>For pure hydrogen systems:</p> <pre><code>void PHflashLeachman(double Hspec)\nvoid PSflashLeachman(double Sspec)\n</code></pre>"},{"location":"thermo/flash_calculations_guide/#vega-co2-flashes","title":"Vega (CO\u2082) Flashes","text":"<p>For pure CO\u2082 systems:</p> <pre><code>void PHflashVega(double Hspec)\nvoid PSflashVega(double Sspec)\n</code></pre>"},{"location":"thermo/flash_calculations_guide/#hydrate-calculations","title":"Hydrate Calculations","text":"<p>NeqSim provides specialized calculations for gas hydrate formation.</p> <p>Formation temperature: <pre><code>void hydrateFormationTemperature()\nvoid hydrateFormationTemperature(double initialGuess)\nvoid hydrateFormationTemperature(int structure)  // 0=ice, 1=sI, 2=sII\n</code></pre></p> <p>Formation pressure: <pre><code>void hydrateFormationPressure()\n</code></pre></p> <p>Inhibitor calculations: <pre><code>void hydrateInhibitorConcentration(String inhibitor, double targetT)\nvoid hydrateInhibitorConcentrationSet(String inhibitor, double wtFrac)\n</code></pre></p> <p>Example: <pre><code>SystemInterface gas = new SystemSrkCPAstatoil(280.0, 100.0);\ngas.addComponent(\"methane\", 0.9);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"CO2\", 0.02);\ngas.addComponent(\"water\", 0.03);\ngas.setMixingRule(10);\ngas.setHydrateCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\nops.hydrateFormationTemperature();\n\nSystem.out.println(\"Hydrate formation T: \" + gas.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#unit-handling","title":"Unit Handling","text":"<p>Most flash methods accept unit specifications for flexibility:</p>"},{"location":"thermo/flash_calculations_guide/#enthalpy-units-ph-flash","title":"Enthalpy Units (PH Flash)","text":"Unit Description <code>J</code> Joules (total) <code>J/mol</code> Joules per mole <code>J/kg</code> Joules per kilogram <code>kJ/kg</code> Kilojoules per kilogram"},{"location":"thermo/flash_calculations_guide/#entropy-units-ps-flash","title":"Entropy Units (PS Flash)","text":"Unit Description <code>J/K</code> Joules per Kelvin (total) <code>J/molK</code> Joules per mole-Kelvin <code>J/kgK</code> Joules per kg-Kelvin <code>kJ/kgK</code> Kilojoules per kg-Kelvin"},{"location":"thermo/flash_calculations_guide/#volume-units","title":"Volume Units","text":"Unit Description <code>m3</code> Cubic meters (default) cm\u00b3 for internal methods"},{"location":"thermo/flash_calculations_guide/#error-handling","title":"Error Handling","text":"<p>Flash calculations can fail if: - Conditions are outside valid range - No solution exists (e.g., above critical point for saturation) - Convergence not achieved</p> <p>Best practice: <pre><code>try {\n    ops.dewPointTemperatureFlash();\n} catch (IsNaNException e) {\n    System.err.println(\"No dew point found: \" + e.getMessage());\n}\n\n// Check for valid result\nif (Double.isNaN(fluid.getTemperature())) {\n    System.err.println(\"Flash calculation did not converge\");\n}\n</code></pre></p>"},{"location":"thermo/flash_calculations_guide/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always initialize before flashing: <pre><code>fluid.init(0);  // Basic initialization\nops.TPflash();\nfluid.init(3);  // Full thermodynamic initialization after flash\n</code></pre></p> </li> <li> <p>Reuse ThermodynamicOperations: <pre><code>// Good - single instance\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nfor (double T : temperatures) {\n    fluid.setTemperature(T, \"K\");\n    ops.TPflash();\n}\n</code></pre></p> </li> <li> <p>Clone fluids for independent calculations: <pre><code>SystemInterface fluid2 = fluid.clone();\nThermodynamicOperations ops2 = new ThermodynamicOperations(fluid2);\n</code></pre></p> </li> <li> <p>Check phase existence before accessing: <pre><code>if (fluid.hasPhaseType(\"gas\")) {\n    double gasRho = fluid.getPhase(\"gas\").getDensity(\"kg/m3\");\n}\n</code></pre></p> </li> <li> <p>Use appropriate EoS for the application:</p> </li> <li>Hydrocarbons: SRK or PR</li> <li>Polar/associating: CPA</li> <li>Natural gas (high accuracy): GERG-2008</li> <li>CO\u2082 systems: CPA or Vega</li> </ol>"},{"location":"thermo/flash_calculations_guide/#api-reference-table","title":"API Reference Table","text":"Method Input Specs Output Use Case <code>TPflash()</code> T, P phases, compositions General equilibrium <code>PHflash(H)</code> P, H T, phases Valves, heat exchangers <code>PSflash(S)</code> P, S T, phases Compressors, turbines <code>PUflash(U)</code> P, U T, phases Energy balance <code>TVflash(V)</code> T, V P, phases Fixed-volume systems <code>TSflash(S)</code> T, S P, phases Process analysis <code>VHflash(V,H)</code> V, H T, P, phases Dynamic simulation <code>VUflash(V,U)</code> V, U T, P, phases Blowdown, depressurization <code>VSflash(V,S)</code> V, S T, P, phases Isentropic vessel <code>bubblePointTemperatureFlash()</code> P T_bubble Evaporator design <code>bubblePointPressureFlash()</code> T P_bubble Vapor pressure <code>dewPointTemperatureFlash()</code> P T_dew Condenser design <code>dewPointPressureFlash()</code> T P_dew Dew point control <code>waterDewPointTemperatureFlash()</code> P T_wdp Gas dehydration <code>hydrateFormationTemperature()</code> P T_hydrate Hydrate prevention <code>criticalPointFlash()</code> - T_c, P_c Mixture critical"},{"location":"thermo/flash_calculations_guide/#see-also","title":"See Also","text":"<ul> <li>Fluid Creation Guide - Creating thermodynamic systems</li> <li>Mixing Rules Guide - Configuring phase equilibrium models</li> <li>Component Database Guide - Pure component parameters</li> <li>Thermodynamic Operations - Overview of operations</li> </ul>"},{"location":"thermo/flash_calculations_guide/#references","title":"References","text":"<ol> <li>Michelsen, M.L. &amp; Mollerup, J.M. (2007). Thermodynamic Models: Fundamentals &amp; Computational Aspects.</li> <li>Rachford, H.H. &amp; Rice, J.D. (1952). Procedure for Use of Electronic Digital Computers in Calculating Flash Vaporization.</li> <li>Kunz, O. &amp; Wagner, W. (2012). The GERG-2008 Wide-Range Equation of State for Natural Gases.</li> </ol>"},{"location":"thermo/fluid_creation_guide/","title":"Creating Fluids in NeqSim","text":"<p>This guide provides comprehensive documentation on how to create and configure thermodynamic fluids in NeqSim, including available equations of state, mixing rules, and best practices.</p>"},{"location":"thermo/fluid_creation_guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Basic Fluid Creation</li> <li>Equations of State Overview</li> <li>Cubic Equations of State</li> <li>Advanced Equations of State</li> <li>Reference Equations (Helmholtz-Based)</li> <li>Activity Coefficient Models</li> <li>Electrolyte Models</li> <li>Mixing Rules</li> <li>Adding Components</li> <li>Heavy Fraction Characterization</li> <li>Complete Examples</li> <li>Model Selection Guidelines</li> </ol>"},{"location":"thermo/fluid_creation_guide/#1-basic-fluid-creation","title":"1. Basic Fluid Creation","text":"<p>Creating a fluid in NeqSim follows a consistent pattern:</p> <pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermo.system.SystemInterface;\n\n// 1. Create the fluid with initial temperature (K) and pressure (bara)\nSystemInterface fluid = new SystemSrkEos(298.15, 10.0);\n\n// 2. Add components\nfluid.addComponent(\"methane\", 0.90);    // name, moles\nfluid.addComponent(\"ethane\", 0.05);\nfluid.addComponent(\"propane\", 0.05);\n\n// 3. Set up the mixing rule\nfluid.setMixingRule(\"classic\");\n\n// 4. Initialize the fluid\nfluid.init(0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#constructor-parameters","title":"Constructor Parameters","text":"<p>All fluid system classes accept these constructor signatures:</p> Constructor Description <code>SystemXXX()</code> Default: 298.15 K, 1.0 bara <code>SystemXXX(T, P)</code> Temperature (K), Pressure (bara) <code>SystemXXX(T, P, checkForSolids)</code> With solid phase checking enabled"},{"location":"thermo/fluid_creation_guide/#2-equations-of-state-overview","title":"2. Equations of State Overview","text":"<p>NeqSim provides a wide range of thermodynamic models organized into categories:</p> Category Use Cases Examples Cubic EoS General hydrocarbon processing SRK, PR, PR-1978 CPA (Cubic Plus Association) Polar/associating fluids (water, glycols, alcohols) SRK-CPA, PR-CPA Reference EoS High-accuracy natural gas, CCS GERG-2008, EOS-CG SAFT-based Complex molecular interactions PC-SAFT Activity Coefficient Non-ideal liquid mixtures UNIFAC, NRTL Electrolyte Aqueous salt solutions Electrolyte-CPA, Pitzer Specialized Specific applications Soreide-Whitson (sour gas/brine)"},{"location":"thermo/fluid_creation_guide/#3-cubic-equations-of-state","title":"3. Cubic Equations of State","text":""},{"location":"thermo/fluid_creation_guide/#31-soave-redlich-kwong-srk-family","title":"3.1 Soave-Redlich-Kwong (SRK) Family","text":""},{"location":"thermo/fluid_creation_guide/#systemsrkeos","title":"SystemSrkEos","text":"<p>The standard SRK equation of state. Best for general gas and light hydrocarbon applications.</p> <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"CO2\", 0.2);\nfluid.setMixingRule(\"classic\");\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemsrkpenelouxeos","title":"SystemSrkPenelouxEos","text":"<p>SRK with Peneloux volume correction for improved liquid density predictions.</p> <pre><code>SystemInterface fluid = new SystemSrkPenelouxEos(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemsrkmathiascopeman","title":"SystemSrkMathiasCopeman","text":"<p>SRK with Mathias-Copeman alpha function for better vapor pressure predictions.</p> <pre><code>SystemInterface fluid = new SystemSrkMathiasCopeman(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemsrktwucooneos","title":"SystemSrkTwuCoonEos","text":"<p>SRK with Twu-Coon alpha function.</p> <pre><code>SystemInterface fluid = new SystemSrkTwuCoonEos(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#32-peng-robinson-pr-family","title":"3.2 Peng-Robinson (PR) Family","text":""},{"location":"thermo/fluid_creation_guide/#systempreos","title":"SystemPrEos","text":"<p>Standard Peng-Robinson equation. Widely used for oil and gas applications.</p> <pre><code>SystemInterface fluid = new SystemPrEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.7);\nfluid.addComponent(\"n-heptane\", 0.3);\nfluid.setMixingRule(\"classic\");\n</code></pre> <p>The PR equation is expressed as: $$ P = \\frac{RT}{v - b} - \\frac{a \\alpha}{v(v + b) + b(v - b)} $$</p>"},{"location":"thermo/fluid_creation_guide/#systempreos1978","title":"SystemPrEos1978","text":"<p>Original 1978 Peng-Robinson formulation with modified alpha function.</p> <pre><code>SystemInterface fluid = new SystemPrEos1978(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemprmathiascopeman","title":"SystemPrMathiasCopeman","text":"<p>PR with Mathias-Copeman alpha function for polar components.</p> <pre><code>SystemInterface fluid = new SystemPrMathiasCopeman(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#33-other-cubic-eos","title":"3.3 Other Cubic EoS","text":""},{"location":"thermo/fluid_creation_guide/#systemrkeos","title":"SystemRKEos","text":"<p>Original Redlich-Kwong equation (historical interest, less accurate).</p> <pre><code>SystemInterface fluid = new SystemRKEos(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemtsteos","title":"SystemTSTEos","text":"<p>Twu-Sim-Tassone equation of state.</p> <pre><code>SystemInterface fluid = new SystemTSTEos(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#4-advanced-equations-of-state","title":"4. Advanced Equations of State","text":""},{"location":"thermo/fluid_creation_guide/#41-cpa-cubic-plus-association","title":"4.1 CPA (Cubic Plus Association)","text":"<p>CPA models add an association term to handle hydrogen bonding in polar molecules like water, alcohols, and glycols.</p>"},{"location":"thermo/fluid_creation_guide/#systemsrkcpastatoil","title":"SystemSrkCPAstatoil","text":"<p>The Equinor (formerly Statoil) implementation of SRK-CPA. Recommended for water-hydrocarbon systems.</p> <pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(300.0, 50.0);\nfluid.addComponent(\"water\", 0.1);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"MEG\", 0.05);  // Mono-ethylene glycol\nfluid.setMixingRule(10);  // CPA mixing rule with temperature/composition dependency\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemsrkcpa-systemsrkcpas","title":"SystemSrkCPA / SystemSrkCPAs","text":"<p>Alternative CPA implementations.</p> <pre><code>SystemInterface fluid = new SystemSrkCPA(300.0, 50.0);\nfluid.setMixingRule(7);  // CPA mixing rule\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#systemprcpa","title":"SystemPrCPA","text":"<p>Peng-Robinson with CPA association term.</p> <pre><code>SystemInterface fluid = new SystemPrCPA(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#42-pc-saft","title":"4.2 PC-SAFT","text":"<p>Perturbed Chain Statistical Associating Fluid Theory. Good for polymers and complex molecules.</p> <pre><code>SystemInterface fluid = new SystemPCSAFT(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.5);\nfluid.addComponent(\"ethane\", 0.5);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#43-umr-pru-universal-mixing-rule","title":"4.3 UMR-PRU (Universal Mixing Rule)","text":"<p>Peng-Robinson with UNIFAC-based mixing rules for improved predictions.</p> <pre><code>SystemInterface fluid = new SystemUMRPRUEos(300.0, 50.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#5-reference-equations-helmholtz-based","title":"5. Reference Equations (Helmholtz-Based)","text":"<p>For high-accuracy applications, NeqSim provides reference equations of state based on the Helmholtz free energy:</p> \\[ \\alpha(\\delta, \\tau, \\bar{x}) = \\alpha^0(\\delta, \\tau, \\bar{x}) + \\alpha^r(\\delta, \\tau, \\bar{x}) \\]"},{"location":"thermo/fluid_creation_guide/#51-gerg-2008","title":"5.1 GERG-2008","text":"<p>The ISO 20765-2 standard for natural gas. Highest accuracy for custody transfer and fiscal metering.</p> <p>Supported components (21): Methane, Nitrogen, CO2, Ethane, Propane, n-Butane, i-Butane, n-Pentane, i-Pentane, n-Hexane, n-Heptane, n-Octane, n-Nonane, n-Decane, Hydrogen, Oxygen, CO, Water, Helium, Argon.</p> <pre><code>import neqsim.thermo.system.SystemGERG2008Eos;\n\nSystemInterface fluid = new SystemGERG2008Eos(288.15, 50.0);\nfluid.addComponent(\"methane\", 0.90);\nfluid.addComponent(\"ethane\", 0.05);\nfluid.addComponent(\"propane\", 0.03);\nfluid.addComponent(\"nitrogen\", 0.02);\nfluid.createDatabase(true);\n\n// Access GERG-specific properties\ndouble density = fluid.getPhase(0).getDensity_GERG2008();\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#52-eos-cg","title":"5.2 EOS-CG","text":"<p>Extension of GERG-2008 for CCS (Carbon Capture and Storage) applications. Includes combustion gas components.</p> <p>Additional components: SO2, NO, NO2, and others relevant to flue gas.</p> <pre><code>import neqsim.thermo.system.SystemEOSCGEos;\n\nSystemInterface fluid = new SystemEOSCGEos(300.0, 100.0);\nfluid.addComponent(\"CO2\", 0.95);\nfluid.addComponent(\"nitrogen\", 0.03);\nfluid.addComponent(\"oxygen\", 0.02);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#53-other-reference-equations","title":"5.3 Other Reference Equations","text":"Class Description <code>SystemSpanWagnerEos</code> Span-Wagner equation for CO2 <code>SystemLeachmanEos</code> Leachman equation for hydrogen <code>SystemBWRSEos</code> Benedict-Webb-Rubin-Starling <code>SystemBnsEos</code> BNS equation of state"},{"location":"thermo/fluid_creation_guide/#6-activity-coefficient-models","title":"6. Activity Coefficient Models","text":"<p>For non-ideal liquid mixtures, especially polar and chemical systems:</p>"},{"location":"thermo/fluid_creation_guide/#61-unifac","title":"6.1 UNIFAC","text":"<p>Group contribution method for activity coefficients.</p> <pre><code>import neqsim.thermo.system.SystemUNIFAC;\n\nSystemInterface fluid = new SystemUNIFAC(300.0, 1.0);\nfluid.addComponent(\"methanol\", 0.3);\nfluid.addComponent(\"water\", 0.7);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#62-nrtl","title":"6.2 NRTL","text":"<p>Non-Random Two-Liquid model.</p> <pre><code>import neqsim.thermo.system.SystemNRTL;\n\nSystemInterface fluid = new SystemNRTL(300.0, 1.0);\nfluid.addComponent(\"ethanol\", 0.4);\nfluid.addComponent(\"water\", 0.6);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#63-ge-wilson","title":"6.3 GE-Wilson","text":"<p>Wilson equation for activity coefficients.</p> <pre><code>import neqsim.thermo.system.SystemGEWilson;\n\nSystemInterface fluid = new SystemGEWilson(300.0, 1.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#7-electrolyte-models","title":"7. Electrolyte Models","text":"<p>For systems containing salts and ions in aqueous solutions:</p>"},{"location":"thermo/fluid_creation_guide/#71-electrolyte-cpa-equinor","title":"7.1 Electrolyte-CPA (Equinor)","text":"<pre><code>import neqsim.thermo.system.SystemElectrolyteCPAstatoil;\n\nSystemInterface fluid = new SystemElectrolyteCPAstatoil(298.15, 1.0);\nfluid.addComponent(\"water\", 1.0);\nfluid.addComponent(\"Na+\", 0.1);\nfluid.addComponent(\"Cl-\", 0.1);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#72-sreide-whitson","title":"7.2 S\u00f8reide-Whitson","text":"<p>Modified PR for sour gas systems and brine.</p> <pre><code>import neqsim.thermo.system.SystemSoreideWhitson;\n\nSystemSoreideWhitson fluid = new SystemSoreideWhitson(350.0, 200.0);\nfluid.addComponent(\"methane\", 0.7);\nfluid.addComponent(\"CO2\", 0.15);\nfluid.addComponent(\"H2S\", 0.05);\nfluid.addComponent(\"water\", 0.1);\nfluid.addSalinity(2.0, \"mole/sec\");  // Add salinity\nfluid.setMixingRule(11);  // Soreide-Whitson mixing rule\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#73-pitzer-model","title":"7.3 Pitzer Model","text":"<p>For concentrated electrolyte solutions.</p> <pre><code>import neqsim.thermo.system.SystemPitzer;\n\nSystemInterface fluid = new SystemPitzer(298.15, 1.0);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#8-mixing-rules","title":"8. Mixing Rules","text":"<p>Mixing rules determine how pure-component parameters are combined for mixtures. Set via <code>setMixingRule()</code>:</p>"},{"location":"thermo/fluid_creation_guide/#81-available-mixing-rules","title":"8.1 Available Mixing Rules","text":"Value Name Description 1 <code>NO</code> Classic with all kij = 0 (no interaction) 2 <code>CLASSIC</code> Classic van der Waals with kij from database 3 <code>CLASSIC_HV</code> Huron-Vidal with database parameters 4 <code>HV</code> Huron-Vidal including temperature-dependent HVDijT 5 <code>WS</code> Wong-Sandler (NRTL-based coupling) 7 <code>CPA_MIX</code> Classic with CPA kij from database 8 <code>CLASSIC_T</code> Classic with temperature-dependent kij 9 <code>CLASSIC_T_CPA</code> Classic T-dependent kij for CPA 10 <code>CLASSIC_TX_CPA</code> Classic T and composition dependent kij for CPA 11 <code>SOREIDE_WHITSON</code> S\u00f8reide-Whitson mixing rule 12 <code>CLASSIC_T2</code> Alternative temperature-dependent classic"},{"location":"thermo/fluid_creation_guide/#82-setting-mixing-rules","title":"8.2 Setting Mixing Rules","text":"<pre><code>// By integer value\nfluid.setMixingRule(2);\n\n// By name (string)\nfluid.setMixingRule(\"classic\");\nfluid.setMixingRule(\"HV\");\nfluid.setMixingRule(\"WS\");\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#83-mixing-rule-recommendations","title":"8.3 Mixing Rule Recommendations","text":"Application Recommended Mixing Rule Light hydrocarbons <code>classic</code> (2) CO2-hydrocarbon <code>classic</code> (2) with tuned kij Polar mixtures <code>HV</code> (4) or <code>WS</code> (5) Water-hydrocarbon (CPA) <code>CPA_MIX</code> (7) or <code>CLASSIC_TX_CPA</code> (10) Sour gas with brine <code>SOREIDE_WHITSON</code> (11)"},{"location":"thermo/fluid_creation_guide/#9-adding-components","title":"9. Adding Components","text":""},{"location":"thermo/fluid_creation_guide/#91-basic-component-addition","title":"9.1 Basic Component Addition","text":"<pre><code>// Add by name and moles\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\n\n// Add with flow rate and unit\nfluid.addComponent(\"methane\", 100.0, \"kg/hr\");\nfluid.addComponent(\"ethane\", 50.0, \"Sm3/day\");\n\n// Add multiple components at once\nString[] names = {\"methane\", \"ethane\", \"propane\"};\ndouble[] moles = {0.85, 0.10, 0.05};\nfluid.addComponents(names, moles);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#92-supported-units","title":"9.2 Supported Units","text":"<p>For <code>addComponent(name, value, unit)</code>: - Molar: <code>mol/sec</code>, <code>mol/hr</code> - Mass: <code>kg/sec</code>, <code>kg/hr</code> - Volumetric: <code>Sm3/hr</code>, <code>Sm3/day</code>, <code>MSm3/day</code>, <code>Nlitre/min</code></p>"},{"location":"thermo/fluid_creation_guide/#93-common-component-names","title":"9.3 Common Component Names","text":"<p>NeqSim's database includes hundreds of components. Common names:</p> <p>Hydrocarbons: <code>methane</code>, <code>ethane</code>, <code>propane</code>, <code>i-butane</code>, <code>n-butane</code>, <code>i-pentane</code>, <code>n-pentane</code>, <code>n-hexane</code>, <code>n-heptane</code>, <code>n-octane</code>, <code>n-nonane</code>, <code>n-decane</code></p> <p>Inorganics: <code>nitrogen</code>, <code>oxygen</code>, <code>CO2</code>, <code>H2S</code>, <code>water</code>, <code>hydrogen</code>, <code>helium</code>, <code>argon</code></p> <p>Polar/Associating: <code>methanol</code>, <code>ethanol</code>, <code>MEG</code> (mono-ethylene glycol), <code>TEG</code> (tri-ethylene glycol), <code>DEG</code></p> <p>Ions: <code>Na+</code>, <code>K+</code>, <code>Ca++</code>, <code>Mg++</code>, <code>Cl-</code>, <code>SO4--</code>, <code>HCO3-</code></p>"},{"location":"thermo/fluid_creation_guide/#10-heavy-fraction-characterization","title":"10. Heavy Fraction Characterization","text":"<p>For petroleum fluids, NeqSim supports TBP (True Boiling Point) and plus-fraction characterization.</p>"},{"location":"thermo/fluid_creation_guide/#101-tbp-fractions","title":"10.1 TBP Fractions","text":"<pre><code>SystemInterface oil = new SystemSrkEos(350.0, 100.0);\noil.createDatabase(true);  // Required before adding TBP fractions\n\n// addTBPfraction(name, moles, molarMass [g/mol], density [g/cm3])\noil.addTBPfraction(\"C7\", 0.05, 96.0, 0.738);\noil.addTBPfraction(\"C8\", 0.04, 107.0, 0.765);\noil.addTBPfraction(\"C9\", 0.03, 121.0, 0.781);\noil.addTBPfraction(\"C10\", 0.02, 134.0, 0.792);\n\noil.setMixingRule(\"classic\");\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#102-plus-fractions","title":"10.2 Plus Fractions","text":"<pre><code>// addPlusFraction(name, moles, molarMass [g/mol], density [g/cm3])\noil.addPlusFraction(\"C20+\", 0.10, 350.0, 0.88);\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#103-tbp-characterization-models","title":"10.3 TBP Characterization Models","text":"<p>NeqSim provides several models for estimating critical properties from TBP data:</p> <pre><code>// Set TBP model before adding fractions\nfluid.getCharacterization().setTBPModel(\"PedersenSRK\");  // Default for SRK\nfluid.getCharacterization().setTBPModel(\"PedersenPR\");   // Default for PR\nfluid.getCharacterization().setTBPModel(\"Lee-Kesler\");\nfluid.getCharacterization().setTBPModel(\"Twu\");\nfluid.getCharacterization().setTBPModel(\"RiaziDaubert\");\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#11-complete-examples","title":"11. Complete Examples","text":""},{"location":"thermo/fluid_creation_guide/#111-natural-gas-processing","title":"11.1 Natural Gas Processing","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class NaturalGasExample {\n    public static void main(String[] args) {\n        // Create SRK fluid at pipeline conditions\n        SystemInterface gas = new SystemSrkEos(283.15, 70.0);\n\n        // Typical natural gas composition\n        gas.addComponent(\"nitrogen\", 0.02);\n        gas.addComponent(\"CO2\", 0.01);\n        gas.addComponent(\"methane\", 0.85);\n        gas.addComponent(\"ethane\", 0.06);\n        gas.addComponent(\"propane\", 0.03);\n        gas.addComponent(\"i-butane\", 0.01);\n        gas.addComponent(\"n-butane\", 0.01);\n        gas.addComponent(\"i-pentane\", 0.005);\n        gas.addComponent(\"n-pentane\", 0.005);\n\n        gas.setMixingRule(\"classic\");\n\n        // Flash calculation\n        ThermodynamicOperations ops = new ThermodynamicOperations(gas);\n        ops.TPflash();\n        gas.initProperties();\n\n        // Display results\n        System.out.println(\"Density: \" + gas.getDensity(\"kg/m3\") + \" kg/m3\");\n        System.out.println(\"Z-factor: \" + gas.getZ());\n        System.out.println(\"Molecular weight: \" + gas.getMolarMass() * 1000 + \" g/mol\");\n    }\n}\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#112-water-hydrocarbon-system-with-cpa","title":"11.2 Water-Hydrocarbon System with CPA","text":"<pre><code>import neqsim.thermo.system.SystemSrkCPAstatoil;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class WaterHydrocarbonExample {\n    public static void main(String[] args) {\n        // CPA for associating systems\n        SystemInterface fluid = new SystemSrkCPAstatoil(323.15, 50.0);\n\n        fluid.addComponent(\"methane\", 0.70);\n        fluid.addComponent(\"ethane\", 0.10);\n        fluid.addComponent(\"propane\", 0.05);\n        fluid.addComponent(\"water\", 0.10);\n        fluid.addComponent(\"MEG\", 0.05);\n\n        fluid.setMixingRule(10);  // Temperature and composition dependent CPA\n\n        ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        System.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\n        fluid.prettyPrint();\n    }\n}\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#113-high-accuracy-fiscal-metering-gerg-2008","title":"11.3 High-Accuracy Fiscal Metering (GERG-2008)","text":"<pre><code>import neqsim.thermo.system.SystemGERG2008Eos;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class FiscalMeteringExample {\n    public static void main(String[] args) {\n        // GERG-2008 for custody transfer accuracy\n        SystemInterface gas = new SystemGERG2008Eos(288.15, 40.0);\n\n        gas.addComponent(\"methane\", 0.92);\n        gas.addComponent(\"ethane\", 0.04);\n        gas.addComponent(\"propane\", 0.02);\n        gas.addComponent(\"nitrogen\", 0.01);\n        gas.addComponent(\"CO2\", 0.01);\n\n        gas.createDatabase(true);\n\n        ThermodynamicOperations ops = new ThermodynamicOperations(gas);\n        ops.TPflash();\n\n        // GERG-specific high-accuracy density\n        double gergDensity = gas.getPhase(0).getDensity_GERG2008();\n        System.out.println(\"GERG-2008 Density: \" + gergDensity + \" kg/m3\");\n    }\n}\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#114-oil-characterization","title":"11.4 Oil Characterization","text":"<pre><code>import neqsim.thermo.system.SystemPrEos;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class OilCharacterizationExample {\n    public static void main(String[] args) {\n        SystemInterface oil = new SystemPrEos(350.0, 150.0);\n        oil.createDatabase(true);\n\n        // Light ends\n        oil.addComponent(\"nitrogen\", 0.005);\n        oil.addComponent(\"CO2\", 0.02);\n        oil.addComponent(\"methane\", 0.35);\n        oil.addComponent(\"ethane\", 0.08);\n        oil.addComponent(\"propane\", 0.06);\n        oil.addComponent(\"i-butane\", 0.02);\n        oil.addComponent(\"n-butane\", 0.03);\n        oil.addComponent(\"i-pentane\", 0.02);\n        oil.addComponent(\"n-pentane\", 0.02);\n        oil.addComponent(\"n-hexane\", 0.03);\n\n        // TBP fractions (moles, MW g/mol, density g/cm3)\n        oil.addTBPfraction(\"C7\", 0.05, 96.0, 0.738);\n        oil.addTBPfraction(\"C8\", 0.04, 107.0, 0.765);\n        oil.addTBPfraction(\"C9\", 0.03, 121.0, 0.781);\n        oil.addTBPfraction(\"C10\", 0.02, 134.0, 0.792);\n\n        // Plus fraction\n        oil.addPlusFraction(\"C11+\", 0.18, 250.0, 0.85);\n\n        oil.setMixingRule(\"classic\");\n\n        ThermodynamicOperations ops = new ThermodynamicOperations(oil);\n        ops.TPflash();\n        oil.initProperties();\n\n        oil.prettyPrint();\n    }\n}\n</code></pre>"},{"location":"thermo/fluid_creation_guide/#12-model-selection-guidelines","title":"12. Model Selection Guidelines","text":""},{"location":"thermo/fluid_creation_guide/#quick-reference-table","title":"Quick Reference Table","text":"System Type Recommended Model Mixing Rule Dry natural gas <code>SystemSrkEos</code> or <code>SystemPrEos</code> <code>classic</code> (2) Wet gas / condensate <code>SystemPrEos</code> <code>classic</code> (2) Black oil <code>SystemPrEos</code> with TBP <code>classic</code> (2) Water-hydrocarbon <code>SystemSrkCPAstatoil</code> <code>CLASSIC_TX_CPA</code> (10) Glycol dehydration <code>SystemSrkCPAstatoil</code> <code>CPA_MIX</code> (7) Sour gas / brine <code>SystemSoreideWhitson</code> <code>SOREIDE_WHITSON</code> (11) Fiscal metering <code>SystemGERG2008Eos</code> N/A CCS / CO2 transport <code>SystemEOSCGEos</code> N/A Electrolyte solutions <code>SystemElectrolyteCPAstatoil</code> N/A Polar organics <code>SystemUNIFAC</code> or <code>SystemNRTL</code> N/A"},{"location":"thermo/fluid_creation_guide/#decision-flow","title":"Decision Flow","text":"<ol> <li>Is high accuracy required for custody transfer? \u2192 Use GERG-2008</li> <li>Does the system contain water, glycols, or alcohols? \u2192 Use CPA models</li> <li>Is it a sour gas system with brine? \u2192 Use S\u00f8reide-Whitson</li> <li>Is it a standard hydrocarbon system? \u2192 Use SRK or PR</li> <li>Does it contain electrolytes? \u2192 Use Electrolyte-CPA or Pitzer</li> <li>Is it a non-ideal organic mixture? \u2192 Use UNIFAC or NRTL</li> </ol>"},{"location":"thermo/fluid_creation_guide/#performance-vs-accuracy-trade-offs","title":"Performance vs. Accuracy Trade-offs","text":"Model Type Speed Accuracy Best For Cubic (SRK/PR) Fast Good General process simulation CPA Medium Very Good Polar/associating systems GERG-2008 Slow Excellent Fiscal metering, calibration UNIFAC Medium Good Chemical process design"},{"location":"thermo/fluid_creation_guide/#see-also","title":"See Also","text":"<ul> <li>Thermodynamic Workflows - Flash calculations and operations</li> <li>PVT and Fluid Characterization - Heavy fraction handling</li> <li>Mathematical Models - Equation details</li> <li>GERG-2008 and EOS-CG - Reference equation details</li> <li>Physical Properties - Transport property calculations</li> </ul>"},{"location":"thermo/gerg2008_eoscg/","title":"GERG-2008 and EOS-CG Equations of State","text":"<p>NeqSim supports the GERG-2008 and EOS-CG equations of state, which are reference-quality models explicit in the Helmholtz free energy. These models are widely used for high-accuracy property calculations in natural gas and CCS (Carbon Capture and Storage) applications.</p>"},{"location":"thermo/gerg2008_eoscg/#1-mathematical-framework","title":"1. Mathematical Framework","text":"<p>Both GERG-2008 and EOS-CG share the same fundamental mathematical structure. They are fundamental equations of state explicit in the dimensionless Helmholtz free energy \\(\\alpha\\).</p> <p>The dimensionless Helmholtz energy \\(\\alpha\\) is separated into an ideal gas part \\(\\alpha^0\\) and a residual part \\(\\alpha^r\\):</p> \\[ \\alpha(\\delta, \\tau, \\bar{x}) = \\frac{a(\\rho, T, \\bar{x})}{RT} = \\alpha^0(\\delta, \\tau, \\bar{x}) + \\alpha^r(\\delta, \\tau, \\bar{x}) \\] <p>Where: *   \\(\\delta = \\rho / \\rho_r\\) is the reduced density. *   \\(\\tau = T_r / T\\) is the inverse reduced temperature. *   \\(\\bar{x}\\) is the vector of mole fractions.</p>"},{"location":"thermo/gerg2008_eoscg/#ideal-gas-contribution-alpha0","title":"Ideal Gas Contribution (\\(\\alpha^0\\))","text":"<p>The ideal gas part is determined from the ideal gas heat capacity of the mixture components:</p> \\[ \\alpha^0(\\delta, \\tau, \\bar{x}) = \\sum_{i=1}^{N} x_i \\left[ \\alpha_{0i}^0(\\delta, \\tau) + \\ln x_i \\right] \\]"},{"location":"thermo/gerg2008_eoscg/#residual-contribution-alphar","title":"Residual Contribution (\\(\\alpha^r\\))","text":"<p>The residual part accounts for intermolecular forces and real fluid behavior. It is typically expressed as a sum of polynomial and exponential terms fitted to high-accuracy experimental data:</p> \\[ \\alpha^r(\\delta, \\tau, \\bar{x}) = \\sum_{i=1}^{N} x_i \\alpha_{0i}^r(\\delta, \\tau) + \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} x_i x_j F_{ij} \\alpha_{ij}^r(\\delta, \\tau) \\] <p>This structure allows for extremely high accuracy in density, speed of sound, and heat capacity calculations, often superior to cubic equations of state (like SRK or PR), especially in the supercritical region.</p>"},{"location":"thermo/gerg2008_eoscg/#2-gerg-2008","title":"2. GERG-2008","text":"<p>Full Name: GERG-2008 Wide-Range Equation of State for Natural Gases and Other Mixtures. Authors: O. Kunz and W. Wagner (Ruhr-Universit\u00e4t Bochum). Standard: ISO 20765-2.</p>"},{"location":"thermo/gerg2008_eoscg/#application","title":"Application","text":"<p>GERG-2008 is the standard reference equation for natural gas transport, processing, and custody transfer. It covers 21 components typical of natural gas.</p>"},{"location":"thermo/gerg2008_eoscg/#supported-components-21","title":"Supported Components (21)","text":"<p>Methane, Nitrogen, Carbon Dioxide, Ethane, Propane, Butanes, Pentanes, Hexane, Heptane, Octane, Nonane, Decane, Hydrogen, Oxygen, Carbon Monoxide, Water, Helium, Argon.</p>"},{"location":"thermo/gerg2008_eoscg/#usage-in-neqsim","title":"Usage in NeqSim","text":"<p>To use GERG-2008 in NeqSim, use the <code>SystemGERG2008Eos</code> class.</p> <pre><code>import neqsim.thermo.system.SystemGERG2008Eos;\nimport neqsim.thermo.system.SystemInterface;\n\npublic class GergExample {\n    public static void main(String[] args) {\n        // Create system\n        SystemInterface fluid = new SystemGERG2008Eos(298.15, 10.0); // T in K, P in bara\n\n        // Add components\n        fluid.addComponent(\"methane\", 0.9);\n        fluid.addComponent(\"ethane\", 0.1);\n\n        // Initialize\n        fluid.createDatabase(true);\n        fluid.setMixingRule(\"classic\"); // Not strictly used by GERG but good practice for init\n\n        // Flash calculation\n        neqsim.thermodynamicoperations.ThermodynamicOperations ops = \n            new neqsim.thermodynamicoperations.ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        // Retrieve properties\n        // Note: GERG-2008 properties are often accessed via specific methods\n        double density = fluid.getPhase(0).getDensity_GERG2008();\n        double[] props = fluid.getPhase(0).getProperties_GERG2008();\n\n        System.out.println(\"Density (GERG): \" + density + \" kg/m3\");\n    }\n}\n</code></pre>"},{"location":"thermo/gerg2008_eoscg/#3-eos-cg","title":"3. EOS-CG","text":"<p>Full Name: EOS-CG: A Helmholtz energy equation of state for combustion gases and CCS mixtures. Authors: J. Gernert and R. Span (Ruhr-Universit\u00e4t Bochum).</p>"},{"location":"thermo/gerg2008_eoscg/#application_1","title":"Application","text":"<p>EOS-CG is an extension of the GERG framework designed for Carbon Capture and Storage (CCS) and combustion gas applications. It includes additional components found in flue gases and impurities relevant to CO2 transport.</p>"},{"location":"thermo/gerg2008_eoscg/#supported-components-27","title":"Supported Components (27)","text":"<p>Includes all 21 components from GERG-2008, plus: *   Sulfur Dioxide (SO\u2082) *   Nitrogen Monoxide (NO) *   Nitrogen Dioxide (NO\u2082) *   Hydrogen Chloride (HCl) *   Chlorine (Cl\u2082) *   Carbonyl Sulfide (COS)</p> <p>Recent PRs refreshed the EOS-CG component tables with updated critical properties and binary interaction data, improving phase behavior for acid-gas heavy blends. The refresh aligns the library with the latest GERG-compatible datasets so CCS mixtures match reference densities and sound speed benchmarks more closely.</p>"},{"location":"thermo/gerg2008_eoscg/#usage-in-neqsim_1","title":"Usage in NeqSim","text":"<p>To use EOS-CG in NeqSim, use the <code>SystemEOSCGEos</code> class.</p> <pre><code>import neqsim.thermo.system.SystemEOSCGEos;\nimport neqsim.thermo.system.SystemInterface;\n\npublic class EosCgExample {\n    public static void main(String[] args) {\n        // Create system\n        SystemInterface fluid = new SystemEOSCGEos(298.15, 50.0);\n\n        // Add components (including CCS impurities)\n        fluid.addComponent(\"CO2\", 0.95);\n        fluid.addComponent(\"SO2\", 0.05);\n\n        // Initialize and Flash\n        fluid.createDatabase(true);\n        neqsim.thermodynamicoperations.ThermodynamicOperations ops = \n            new neqsim.thermodynamicoperations.ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        // Retrieve properties\n        double density = fluid.getPhase(0).getDensity_EOSCG();\n\n        System.out.println(\"Density (EOS-CG): \" + density + \" kg/m3\");\n    }\n}\n</code></pre>"},{"location":"thermo/gerg2008_eoscg/#4-literature-references","title":"4. Literature References","text":"<ol> <li>GERG-2008: Kunz, O., &amp; Wagner, W. (2012). The GERG-2008 Wide-Range Equation of State for Natural Gases and Other Mixtures: An Expansion of GERG-2004. Journal of Chemical &amp; Engineering Data, 57(11), 3032\u20133091.</li> <li>EOS-CG: Gernert, J., &amp; Span, R. (2016). EOS-CG: A Helmholtz energy equation of state for combustion gases and CCS mixtures. The Journal of Chemical Thermodynamics, 93, 274\u2013293.</li> </ol>"},{"location":"thermo/inter_table_guide/","title":"INTER Table: Binary Interaction Coefficients Database","text":"<p>This guide documents the INTER table in NeqSim, which contains binary interaction parameters (BIPs) for thermodynamic models including equations of state (EoS), activity coefficient models, and CPA association parameters.</p>"},{"location":"thermo/inter_table_guide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Table Structure</li> <li>Column Reference</li> <li>Component Pair Identification</li> <li>EoS Interaction Parameters</li> <li>Huron-Vidal Parameters</li> <li>Wong-Sandler Parameters</li> <li>NRTL Parameters</li> <li>CPA Association Parameters</li> <li>Relation to Mixing Rules</li> <li>Usage Examples</li> <li>Setting Custom Parameters</li> <li>TBP Fractions and Default Values</li> </ul>"},{"location":"thermo/inter_table_guide/#overview","title":"Overview","text":"<p>The INTER table is the central repository for all binary interaction parameters in NeqSim. It stores parameters for:</p> <ol> <li>Cubic EoS - Classical \\(k_{ij}\\) values for SRK and PR</li> <li>CPA EoS - Association and \\(k_{ij}\\) for CPA model</li> <li>Huron-Vidal - \\(\\alpha\\), \\(g_{ij}\\), \\(g_{ji}\\) parameters</li> <li>Wong-Sandler - Integration with UNIFAC</li> <li>NRTL - \\(\\alpha\\), \\(g_{ij}\\), \\(g_{ji}\\) for activity coefficients</li> <li>Soreide-Whitson - Oil-water systems</li> <li>Desmukh-Mather - Amine systems</li> </ol> <p>Location: <code>src/main/resources/data/INTER.csv</code></p> <p>Database table name: <code>INTER</code> (or <code>INTERTEMP</code> for temporary tables)</p>"},{"location":"thermo/inter_table_guide/#table-structure","title":"Table Structure","text":"<p>The INTER table contains one row per component pair. Each row has parameters for multiple thermodynamic models, allowing the same fluid definition to be used with different mixing rules.</p> <p>Example entry: <pre><code>ID,COMP1,COMP2,HVTYPE,KIJSRK,KIJTSRK,KIJTType,KIJPR,KIJTPR,KIJPCSAFT,...\n6950,CO2,methane,Classic,0.0973,0,0,0.0973,0,...\n</code></pre></p>"},{"location":"thermo/inter_table_guide/#column-reference","title":"Column Reference","text":""},{"location":"thermo/inter_table_guide/#component-pair-identification","title":"Component Pair Identification","text":"Column Type Description <code>ID</code> Integer Unique row identifier <code>COMP1</code> String First component name (must match COMP table) <code>COMP2</code> String Second component name (must match COMP table) <p>Important: Component pairs are symmetric. NeqSim searches for both <code>(COMP1=A, COMP2=B)</code> and <code>(COMP1=B, COMP2=A)</code>.</p>"},{"location":"thermo/inter_table_guide/#eos-interaction-parameters","title":"EoS Interaction Parameters","text":"<p>These parameters are used in the classical van der Waals mixing rules for cubic equations of state.</p> Column Type Description Used By <code>KIJSRK</code> Double Binary interaction parameter for SRK EoS <code>SystemSrkEos</code> <code>KIJTSRK</code> Double Temperature correction to \\(k_{ij}\\) for SRK SRK with T-dependent kij <code>KIJTType</code> Integer Type of temperature dependence (0, 1, 2) All EoS <code>KIJPR</code> Double Binary interaction parameter for PR EoS <code>SystemPrEos</code> <code>KIJTPR</code> Double Temperature correction to \\(k_{ij}\\) for PR PR with T-dependent kij <code>KIJPCSAFT</code> Double Binary interaction for PC-SAFT EoS <code>SystemPCSAFT</code> <p>Temperature dependence types (<code>KIJTType</code>): - <code>0</code> - No temperature dependence: \\(k_{ij}(T) = k_{ij}\\) - <code>1</code> - Inverse temperature: \\(k_{ij}(T) = k_{ij} + k_{ij}^T / T\\) - <code>2</code> - Linear temperature: \\(k_{ij}(T) = k_{ij} + k_{ij}^T \\cdot T\\)</p> <p>Mathematical role:</p> <p>The \\(k_{ij}\\) parameter appears in the classical mixing rule for the EoS attractive parameter:</p> \\[a_{mix} = \\sum_i \\sum_j x_i x_j \\sqrt{a_i a_j} (1 - k_{ij})\\] <p>A positive \\(k_{ij}\\) reduces the attractive interactions between unlike molecules.</p>"},{"location":"thermo/inter_table_guide/#huron-vidal-parameters","title":"Huron-Vidal Parameters","text":"<p>Huron-Vidal mixing rules combine an EoS with an activity coefficient model.</p> Column Type Description <code>HVTYPE</code> String Type of mixing rule (<code>\"Classic\"</code> or <code>\"HV\"</code>) <code>HVALPHA</code> Double NRTL non-randomness parameter (\\(\\alpha\\)) <code>HVGIJ</code> Double NRTL interaction parameter \\(g_{ij}\\) (J/mol) <code>HVGJI</code> Double NRTL interaction parameter \\(g_{ji}\\) (J/mol) <code>HVGIJT</code> Double Temperature derivative of \\(g_{ij}\\) <code>HVGJIT</code> Double Temperature derivative of \\(g_{ji}\\) <p>Note: When <code>HVTYPE = \"Classic\"</code>, the Huron-Vidal parameters are not used.</p> <p>Mathematical formulation:</p> \\[\\tau_{ij} = \\frac{g_{ij} - g_{jj}}{RT} = \\frac{\\Delta g_{ij}}{RT}\\] \\[G_{ij} = \\exp(-\\alpha_{ij} \\tau_{ij})\\]"},{"location":"thermo/inter_table_guide/#wong-sandler-parameters","title":"Wong-Sandler Parameters","text":"<p>Wong-Sandler mixing rules provide thermodynamic consistency between high and low pressure limits.</p> Column Type Description <code>WSTYPE</code> String Type (<code>\"Classic\"</code> or <code>\"WS\"</code>) <code>KIJWS</code> Double Wong-Sandler interaction parameter <code>KIJWSunifac</code> Double WS parameter for UNIFAC integration <code>CalcWij</code> Integer Flag for calculated vs fitted W parameters <code>W1</code>, <code>W2</code>, <code>W3</code> Double Second virial coefficient parameters <code>WSGIJT</code> Double Temperature derivative for WS \\(g_{ij}\\) <code>WSGJIT</code> Double Temperature derivative for WS \\(g_{ji}\\)"},{"location":"thermo/inter_table_guide/#nrtl-parameters","title":"NRTL Parameters","text":"<p>Non-Random Two-Liquid parameters for activity coefficient calculations.</p> Column Type Description <code>NRTLALPHA</code> Double Non-randomness parameter \\(\\alpha_{ij}\\) (typically 0.2-0.47) <code>NRTLGIJ</code> Double Interaction parameter \\(g_{ij}\\) (J/mol) <code>NRTLGJI</code> Double Interaction parameter \\(g_{ji}\\) (J/mol) <p>NRTL Activity Coefficient:</p> \\[\\ln \\gamma_i = \\frac{\\sum_j x_j \\tau_{ji} G_{ji}}{\\sum_k x_k G_{ki}} + \\sum_j \\frac{x_j G_{ij}}{\\sum_k x_k G_{kj}} \\left( \\tau_{ij} - \\frac{\\sum_m x_m \\tau_{mj} G_{mj}}{\\sum_k x_k G_{kj}} \\right)\\]"},{"location":"thermo/inter_table_guide/#cpa-association-parameters","title":"CPA Association Parameters","text":"<p>These parameters control cross-association in the CPA (Cubic Plus Association) equation of state.</p> Column Type Description <code>cpakij_SRK</code> Double SRK-CPA binary interaction parameter <code>cpakijT_SRK</code> Double Temperature correction for CPA \\(k_{ij}\\) <code>cpakijx_SRK</code> Double Composition-dependent \\(k_{ij}\\) (asymmetric) <code>cpakjix_SRK</code> Double Composition-dependent \\(k_{ji}\\) (asymmetric) <code>cpakij_PR</code> Double PR-CPA binary interaction parameter <code>cpaAssosiationType</code> Integer Association scheme type (0, 1, 2, ...) <code>cpaBetaCross</code> Double Cross-association volume parameter \\(\\beta^{AB}\\) <code>cpaEpsCross</code> Double Cross-association energy parameter \\(\\epsilon^{AB}\\) (K) <p>Association scheme types: - <code>0</code> - No induced association - <code>1</code> - CR1 combining rule (Elliott rule) - <code>2</code> - CR2 combining rule (geometric mean) - Other values - Custom fitted parameters</p> <p>Cross-association combining rules:</p> <p>When <code>cpaAssosiationType = 1</code> (CR1/Elliott rule): $\\(\\epsilon^{AB}_{ij} = \\frac{\\epsilon^{AA}_{ii} + \\epsilon^{BB}_{jj}}{2}\\)$ $\\(\\beta^{AB}_{ij} = \\sqrt{\\beta^{AA}_{ii} \\beta^{BB}_{jj}}\\)$</p> <p>When explicit values are provided in <code>cpaBetaCross</code> and <code>cpaEpsCross</code>, they override the combining rules.</p>"},{"location":"thermo/inter_table_guide/#physical-property-parameters","title":"Physical Property Parameters","text":"Column Type Description <code>GIJVISC</code> Double Viscosity mixing parameter <code>KIJWhitsonSoriede</code> Double Soreide-Whitson correlation parameter"},{"location":"thermo/inter_table_guide/#desmukh-mather-parameters","title":"Desmukh-Mather Parameters","text":"<p>For amine-gas systems with the Desmukh-Mather model.</p> Column Type Description <code>aijDesMath</code> Double Desmukh-Mather \\(a_{ij}\\) parameter <code>bijDesMath</code> Double Desmukh-Mather \\(b_{ij}\\) parameter"},{"location":"thermo/inter_table_guide/#relation-to-mixing-rules","title":"Relation to Mixing Rules","text":"<p>The INTER table parameters are loaded when you call <code>setMixingRule()</code>. The mixing rule number determines which columns are read:</p> Mixing Rule Number Parameters Used Classic (kij=0) 1 None (all kij set to 0) Classic (from database) 2 <code>KIJSRK</code>/<code>KIJPR</code> Classic + T-dependent 3 <code>KIJSRK</code>, <code>KIJTSRK</code>, <code>KIJTType</code> Huron-Vidal 4 <code>HVALPHA</code>, <code>HVGIJ</code>, <code>HVGJI</code> Wong-Sandler 5 <code>KIJWS</code>, <code>W1-W3</code>, NRTL params CPA 7 <code>cpakij_SRK</code>, <code>cpaBetaCross</code>, <code>cpaEpsCross</code> CPA + T-dependent 9 + <code>cpakijT_SRK</code> CPA + composition-dependent 10 + <code>cpakijx_SRK</code>, <code>cpakjix_SRK</code> <p>Example: <pre><code>// Classic with database kij\nfluid.setMixingRule(2);  // or fluid.setMixingRule(\"classic\");\n\n// Uses KIJSRK/KIJPR columns from INTER table\n</code></pre></p>"},{"location":"thermo/inter_table_guide/#usage-examples","title":"Usage Examples","text":""},{"location":"thermo/inter_table_guide/#accessing-binary-interaction-parameters","title":"Accessing Binary Interaction Parameters","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermo.phase.PhaseEos;\n\nSystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"CO2\", 0.2);\nfluid.setMixingRule(\"classic\");  // Loads from INTER table\n\n// Get kij value\nPhaseEos phase = (PhaseEos) fluid.getPhase(0);\ndouble kij = phase.getMixingRule().getBinaryInteractionParameter(0, 1);\nSystem.out.println(\"kij(methane-CO2) = \" + kij);  // 0.0973\n</code></pre>"},{"location":"thermo/inter_table_guide/#setting-custom-binary-parameters","title":"Setting Custom Binary Parameters","text":"<pre><code>// Method 1: Using component names (recommended)\nfluid.setBinaryInteractionParameter(\"methane\", \"CO2\", 0.10);\n\n// Method 2: Using component indices\n((PhaseEos) fluid.getPhase(0)).getMixingRule()\n    .setBinaryInteractionParameter(0, 1, 0.10);\n((PhaseEos) fluid.getPhase(1)).getMixingRule()\n    .setBinaryInteractionParameter(0, 1, 0.10);\n</code></pre>"},{"location":"thermo/inter_table_guide/#setting-temperature-dependent-parameters","title":"Setting Temperature-Dependent Parameters","text":"<pre><code>// Set temperature coefficient\n((PhaseEos) fluid.getPhase(0)).getMixingRule()\n    .setBinaryInteractionParameterT1(0, 1, -0.001);\n\n// kij(T) = kij + kijT * T  (when KIJTType=2)\n</code></pre>"},{"location":"thermo/inter_table_guide/#getting-all-binary-parameters","title":"Getting All Binary Parameters","text":"<pre><code>double[][] kijMatrix = ((PhaseEos) fluid.getPhase(0))\n    .getMixingRule().getBinaryInteractionParameters();\n\n// Print matrix\nfor (int i = 0; i &lt; fluid.getNumberOfComponents(); i++) {\n    for (int j = 0; j &lt; fluid.getNumberOfComponents(); j++) {\n        System.out.print(kijMatrix[i][j] + \" \");\n    }\n    System.out.println();\n}\n</code></pre>"},{"location":"thermo/inter_table_guide/#cpa-cross-association-example","title":"CPA Cross-Association Example","text":"<pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.7);\nfluid.addComponent(\"water\", 0.2);\nfluid.addComponent(\"MEG\", 0.1);\nfluid.setMixingRule(10);  // CPA with composition-dependent kij\n\n// Cross-association parameters are loaded automatically:\n// - cpaBetaCross for methane-water\n// - cpaEpsCross for water-MEG association\n</code></pre>"},{"location":"thermo/inter_table_guide/#setting-custom-parameters","title":"Setting Custom Parameters","text":""},{"location":"thermo/inter_table_guide/#adding-new-component-pairs","title":"Adding New Component Pairs","text":"<p>To add interaction parameters for a new component pair:</p> <ol> <li> <p>Add to INTER.csv: <pre><code>99999,newcomp1,newcomp2,Classic,0.05,0,0,0.05,0,0,0,0,0,0,0,0,0,Classic,0.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.05\n</code></pre></p> </li> <li> <p>Or set programmatically: <pre><code>fluid.setBinaryInteractionParameter(\"newcomp1\", \"newcomp2\", 0.05);\n</code></pre></p> </li> </ol>"},{"location":"thermo/inter_table_guide/#asymmetric-parameters","title":"Asymmetric Parameters","text":"<p>Some mixing rules support asymmetric \\(k_{ij} \\neq k_{ji}\\):</p> <pre><code>// Set kij (component i with j)\n((PhaseEos) fluid.getPhase(0)).getMixingRule()\n    .setBinaryInteractionParameterij(i, j, 0.05);\n\n// Set kji (component j with i)\n((PhaseEos) fluid.getPhase(0)).getMixingRule()\n    .setBinaryInteractionParameterji(i, j, 0.03);\n</code></pre>"},{"location":"thermo/inter_table_guide/#tbp-fractions-and-default-values","title":"TBP Fractions and Default Values","text":"<p>For undefined pseudo-components (TBP fractions), NeqSim uses correlations or default values:</p>"},{"location":"thermo/inter_table_guide/#default-kij-values-for-tbp-fractions","title":"Default kij Values for TBP Fractions","text":"Component TBP Fraction Default \\(k_{ij}\\) CO2 All 0.10 N2 All 0.08 H2O All 0.20 MEG All 0.20"},{"location":"thermo/inter_table_guide/#calculated-parameters","title":"Calculated Parameters","text":"<p>When <code>setCalcEOSInteractionParameters(true)</code> is called, NeqSim calculates \\(k_{ij}\\) from critical volumes:</p> \\[k_{ij} = 1 - \\left( \\frac{2 \\sqrt[3]{V_{c,i} V_{c,j}}}{V_{c,i}^{1/3} + V_{c,j}^{1/3}} \\right)^n\\] <p>where \\(n\\) is configurable (default = 6).</p>"},{"location":"thermo/inter_table_guide/#column-summary-table","title":"Column Summary Table","text":"Category Columns Identification ID, COMP1, COMP2 SRK EoS KIJSRK, KIJTSRK PR EoS KIJPR, KIJTPR PC-SAFT KIJPCSAFT Temperature Type KIJTType Huron-Vidal HVTYPE, HVALPHA, HVGIJ, HVGJI, HVGIJT, HVGJIT Wong-Sandler WSTYPE, KIJWS, KIJWSunifac, CalcWij, W1, W2, W3, WSGIJT, WSGJIT NRTL NRTLALPHA, NRTLGIJ, NRTLGJI CPA cpakij_SRK, cpakijT_SRK, cpakijx_SRK, cpakjix_SRK, cpakij_PR, cpaAssosiationType, cpaBetaCross, cpaEpsCross Physical Properties GIJVISC Soreide-Whitson KIJWhitsonSoriede Desmukh-Mather aijDesMath, bijDesMath"},{"location":"thermo/inter_table_guide/#typical-parameter-values","title":"Typical Parameter Values","text":""},{"location":"thermo/inter_table_guide/#common-k_ij-values-srkpr","title":"Common \\(k_{ij}\\) Values (SRK/PR)","text":"Pair \\(k_{ij}\\) Notes CH4 - C2H6 0.003 Very similar molecules CH4 - CO2 0.097 Significant non-ideality CH4 - H2S 0.08 Acid gas CH4 - N2 0.032 Typical CH4 - H2O 0.45-0.65 Polar-nonpolar (CPA: ~-0.08) CO2 - H2S 0.10-0.12 Acid gas pair CO2 - C3H8 0.12-0.14 H2O - MEG 0.13 CPA model"},{"location":"thermo/inter_table_guide/#cpa-association-parameters_1","title":"CPA Association Parameters","text":"Pair \\(\\beta^{AB}\\) \\(\\epsilon^{AB}\\) (K) H2O - MEG 0.055 2000-2500 H2O - methanol 0.039 2000-2500 CO2 - H2O 0.085 0 (solvation)"},{"location":"thermo/inter_table_guide/#references","title":"References","text":"<ol> <li>Soave, G. (1972). Equilibrium Constants from a Modified Redlich-Kwong Equation of State. Chem. Eng. Sci.</li> <li>Peng, D.Y., Robinson, D.B. (1976). A New Two-Constant Equation of State. Ind. Eng. Chem. Fundam.</li> <li>Huron, M.J., Vidal, J. (1979). New Mixing Rules in Simple Equations of State. Fluid Phase Equilib.</li> <li>Wong, D.S.H., Sandler, S.I. (1992). A Theoretically Correct Mixing Rule. AIChE J.</li> <li>Kontogeorgis, G.M., et al. (2006). Multicomponent Phase Equilibrium Calculations for Water-Methanol-Alkane Mixtures. Fluid Phase Equilib.</li> <li>Soreide, I., Whitson, C.H. (1992). Peng-Robinson Predictions for Hydrocarbons, CO2, N2, and H2S with Pure Water and NaCl Brine. Fluid Phase Equilib.</li> </ol>"},{"location":"thermo/mathematical_models/","title":"Mathematical Models in NeqSim","text":"<p>NeqSim bundles several thermodynamic and transport models so you can switch between correlations without rewriting system setup code. The sections below summarize the most commonly used options and when to consider them.</p>"},{"location":"thermo/mathematical_models/#equations-of-state-eos","title":"Equations of State (EoS)","text":"<p>NeqSim primarily uses cubic equations of state of the general form:</p> \\[ P = \\frac{RT}{v - b} - \\frac{a(T)}{(v + \\epsilon b)(v + \\sigma b)} \\] <p>where \\(P\\) is pressure, \\(T\\) is temperature, \\(v\\) is molar volume, \\(R\\) is the gas constant, and \\(a(T), b\\) are the energy and co-volume parameters.</p>"},{"location":"thermo/mathematical_models/#supported-families","title":"Supported Families","text":"<ul> <li> <p>Peng\u2013Robinson (PR) family (\\(\\epsilon = 1 - \\sqrt{2}, \\sigma = 1 + \\sqrt{2}\\)):   Standard PR (<code>SystemPrEos</code>), volume-corrected variants (Peneloux), and tuned versions such as the S\u00f8reide\u2013Whitson model for sour service. Suitable for general gas/condensate and light-oil systems.</p> </li> <li> <p>Soave\u2013Redlich\u2013Kwong (SRK) family (\\(\\epsilon = 0, \\sigma = 1\\)):   Core SRK (<code>SystemSrkEos</code>), SRK-Twu, and CPA-SRK for associating fluids such as water and glycols.</p> </li> <li> <p>Cubic-Plus-Association (CPA):   Adds an association term to the SRK or PR equation to represent hydrogen bonding:   [   P = P_{\\text{cubic}} - \\frac{1}{2} RT \\rho \\sum_i x_i \\sum_{A_i} \\left( 1 - X_{A_i} \\right) \\frac{\\partial \\ln g}{\\partial v}   ]   where \\(X_{A_i}\\) is the fraction of site A on molecule i not bonded to other active sites.</p> </li> <li> <p>Activity-coefficient hybrids:   Huron\u2013Vidal and Wong\u2013Sandler mixing rules combine cubic EoS with excess-Gibbs models (\\(G^E\\)) for improved liquid-phase behavior.</p> </li> </ul>"},{"location":"thermo/mathematical_models/#selecting-an-eos","title":"Selecting an EoS","text":"<p><pre><code>SystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"n-heptane\", 0.1);\nfluid.setMixingRule(2); // 2 = Huron\u2013Vidal; use 1 for classical van der Waals\n</code></pre> Use <code>SystemSrkCPAstatoil</code> or <code>SystemSrkCPAs</code> when hydrogen bonding is important, and prefer PR variants for high-pressure gas processing.</p>"},{"location":"thermo/mathematical_models/#reference-equations-of-state-helmholtz-energy","title":"Reference Equations of State (Helmholtz Energy)","text":"<p>For high-accuracy applications involving natural gas or CCS mixtures, NeqSim supports multi-parameter equations of state explicit in the Helmholtz free energy:</p> <ul> <li>GERG-2008 (<code>SystemGERG2008Eos</code>): The ISO 20765-2 standard for natural gas.</li> <li>EOS-CG (<code>SystemEOSCGEos</code>): An extension of GERG-2008 for combustion gases and CCS mixtures (including impurities like SO2, NO, NO2).</li> </ul> <p>See the GERG-2008 and EOS-CG guide for details.</p>"},{"location":"thermo/mathematical_models/#activity-coefficient-models","title":"Activity-Coefficient Models","text":"<p>NeqSim provides NRTL/UNIQUAC/UNIFAC variants for non-ideal liquid mixtures. They can be used directly for gamma-phi flashes or combined with cubic EoS via Wong\u2013Sandler mixing rules.</p> <p><pre><code>SystemInterface fluid = new SystemFurstElectrolyteEos(298.15, 1.0);\nfluid.addComponent(\"water\", 1.0);\nfluid.addComponent(\"ethanol\", 1.0);\nfluid.setMixingRule(4); // enables Wong\u2013Sandler (NRTL) coupling\n</code></pre> Load binary-interaction parameters via <code>mixingRuleName</code> or by reading custom datasets to align with lab data.</p>"},{"location":"thermo/mathematical_models/#hydrate-and-solid-models","title":"Hydrate and Solid Models","text":"<p>For hydrate prediction, enable <code>hydrateCheck(true)</code> and select a hydrate model (<code>CPA</code>-based or classical van der Waals\u2013Platteeuw) depending on accuracy and speed requirements. Wax precipitation can be modeled using solid-phase enabled systems (e.g., PR with solid checks) and tuned heavy-end characterizations.</p>"},{"location":"thermo/mathematical_models/#transport-and-physical-property-correlations","title":"Transport and Physical Property Correlations","text":"<ul> <li>Viscosity: Low-pressure correlations (e.g., Chung) and high-pressure gas correlations plus heavy-oil extensions. CPA fluids can include association corrections for viscosity.</li> <li>Thermal conductivity: Dense-phase corrections layered on dilute-gas references.</li> <li>Surface tension: Parachor correlations tied to component critical properties.</li> <li>Diffusion and mass transfer: Fickian diffusion coefficients and film models for unit operations.</li> </ul> <p>Choose property packages that match the flow regime: cubic EoS with corresponding-state transport for gas processing, CPA with association corrections for aqueous systems, and heavy-oil tuned correlations for late-life reservoirs.</p>"},{"location":"thermo/mixing_rules_guide/","title":"Mixing Rules in NeqSim","text":"<p>This guide provides comprehensive documentation on mixing rules available in NeqSim, including mathematical formulations, usage patterns, and recommendations for different applications.</p>"},{"location":"thermo/mixing_rules_guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Mixing Rules</li> <li>Setting Mixing Rules</li> <li>Classic Mixing Rules</li> <li>Huron-Vidal Mixing Rules</li> <li>Wong-Sandler Mixing Rule</li> <li>CPA Mixing Rules</li> <li>S\u00f8reide-Whitson Mixing Rule</li> <li>Binary Interaction Parameters (kij)</li> <li>Complete Reference Table</li> <li>Examples by Application</li> </ol>"},{"location":"thermo/mixing_rules_guide/#1-introduction-to-mixing-rules","title":"1. Introduction to Mixing Rules","text":"<p>Mixing rules determine how pure-component parameters from an equation of state are combined to calculate mixture properties. For cubic equations of state like SRK and PR, the key parameters are:</p> <ul> <li>a: Energy parameter (attraction term)</li> <li>b: Co-volume parameter (repulsion term)</li> </ul> <p>The general form of cubic EoS mixing rules is:</p> \\[ a_{mix} = \\sum_i \\sum_j x_i x_j a_{ij} \\] \\[ b_{mix} = \\sum_i x_i b_i \\] <p>Where the cross-parameter \\(a_{ij}\\) is typically calculated using a combining rule:</p> \\[ a_{ij} = \\sqrt{a_i a_j}(1 - k_{ij}) \\] <p>The binary interaction parameter \\(k_{ij}\\) is crucial for accurate phase equilibrium predictions.</p>"},{"location":"thermo/mixing_rules_guide/#2-setting-mixing-rules","title":"2. Setting Mixing Rules","text":"<p>NeqSim provides three ways to set mixing rules:</p>"},{"location":"thermo/mixing_rules_guide/#21-by-integer-value","title":"2.1 By Integer Value","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"CO2\", 0.2);\nfluid.setMixingRule(2);  // Classic mixing rule\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#22-by-name-string","title":"2.2 By Name (String)","text":"<pre><code>fluid.setMixingRule(\"classic\");\nfluid.setMixingRule(\"HV\");\nfluid.setMixingRule(\"WS\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#23-by-enum-type","title":"2.3 By Enum Type","text":"<pre><code>import neqsim.thermo.mixingrule.EosMixingRuleType;\n\nfluid.setMixingRule(EosMixingRuleType.CLASSIC);\nfluid.setMixingRule(EosMixingRuleType.byName(\"classic\"));\nfluid.setMixingRule(EosMixingRuleType.byValue(2));\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#24-with-ge-model-for-huron-vidalwong-sandler","title":"2.4 With GE Model (for Huron-Vidal/Wong-Sandler)","text":"<pre><code>// Huron-Vidal with UNIFAC\nfluid.setMixingRule(\"HV\", \"UNIFAC_UMRPRU\");\n\n// Wong-Sandler with NRTL\nfluid.setMixingRule(\"WS\", \"NRTL\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#3-classic-mixing-rules","title":"3. Classic Mixing Rules","text":""},{"location":"thermo/mixing_rules_guide/#31-no-kij-0-type-1","title":"3.1 NO (kij = 0) - Type 1","text":"<p>The simplest mixing rule with no binary interactions. All \\(k_{ij}\\) values are set to zero.</p> \\[ a_{ij} = \\sqrt{a_i a_j} \\] <p>Use case: Quick calculations, ideal mixture approximations, or when no interaction parameters are available.</p> <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.7);\nfluid.addComponent(\"ethane\", 0.3);\nfluid.setMixingRule(1);  // or fluid.setMixingRule(\"NO\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#32-classic-type-2","title":"3.2 CLASSIC - Type 2","text":"<p>The standard van der Waals one-fluid mixing rule with binary interaction parameters from the NeqSim database.</p> \\[ a_{mix} = \\sum_i \\sum_j x_i x_j \\sqrt{a_i a_j}(1 - k_{ij}) \\] \\[ b_{mix} = \\sum_i x_i b_i \\] <p>Use case: General hydrocarbon systems, natural gas processing, most industrial applications.</p> <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"CO2\", 0.10);\nfluid.addComponent(\"nitrogen\", 0.05);\nfluid.setMixingRule(2);  // or fluid.setMixingRule(\"classic\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#33-classic_t-type-8","title":"3.3 CLASSIC_T - Type 8","text":"<p>Classic mixing rule with temperature-dependent binary interaction parameters:</p> \\[ k_{ij}(T) = k_{ij,0} + k_{ij,T} \\cdot T \\] <p>Where \\(k_{ij,0}\\) is the reference value and \\(k_{ij,T}\\) is the temperature coefficient.</p> <p>Use case: Systems where kij varies significantly with temperature.</p> <pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"H2S\", 0.2);\nfluid.setMixingRule(8);  // Temperature-dependent classic\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#34-classic_t2-type-12","title":"3.4 CLASSIC_T2 - Type 12","text":"<p>Alternative temperature-dependent formulation:</p> \\[ k_{ij}(T) = k_{ij,0} + \\frac{k_{ij,T}}{T} \\] <p>Use case: Systems requiring inverse temperature dependency.</p> <pre><code>fluid.setMixingRule(12);\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#4-huron-vidal-mixing-rules","title":"4. Huron-Vidal Mixing Rules","text":"<p>Huron-Vidal (HV) mixing rules combine cubic EoS with activity coefficient models (like NRTL or UNIFAC) for improved liquid-phase behavior.</p>"},{"location":"thermo/mixing_rules_guide/#41-mathematical-framework","title":"4.1 Mathematical Framework","text":"<p>The excess Gibbs energy from an activity coefficient model is incorporated into the EoS:</p> \\[ a_{mix} = b_{mix} \\left( \\sum_i x_i \\frac{a_i}{b_i} - \\frac{G^E}{\\Lambda} \\right) \\] <p>Where: - \\(G^E\\) is the excess Gibbs energy from the activity coefficient model - \\(\\Lambda\\) is the EoS-specific constant (\u2248 0.693 for SRK)</p>"},{"location":"thermo/mixing_rules_guide/#42-classic_hv-type-3","title":"4.2 CLASSIC_HV - Type 3","text":"<p>Basic Huron-Vidal mixing rule with NRTL parameters from the database.</p> <pre><code>SystemInterface fluid = new SystemSrkEos(350.0, 10.0);\nfluid.addComponent(\"methanol\", 0.3);\nfluid.addComponent(\"water\", 0.4);\nfluid.addComponent(\"methane\", 0.3);\nfluid.setMixingRule(3);  // or fluid.setMixingRule(\"CLASSIC_HV\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#43-hv-type-4","title":"4.3 HV - Type 4","text":"<p>Enhanced Huron-Vidal with temperature-dependent parameters (HVDijT):</p> \\[ D_{ij}(T) = D_{ij,0} + D_{ij,T} \\cdot T \\] <p>Use case: Polar/non-polar mixtures, alcohol-water-hydrocarbon systems.</p> <pre><code>SystemInterface fluid = new SystemPrEos(320.0, 20.0);\nfluid.addComponent(\"ethanol\", 0.2);\nfluid.addComponent(\"water\", 0.5);\nfluid.addComponent(\"propane\", 0.3);\nfluid.setMixingRule(4);  // or fluid.setMixingRule(\"HV\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#44-huron-vidal-with-unifac","title":"4.4 Huron-Vidal with UNIFAC","text":"<p>For predictive calculations without fitted parameters, use UNIFAC:</p> <pre><code>SystemInterface fluid = new SystemSrkEos(320.0, 15.0);\nfluid.addComponent(\"ethanol\", 0.3);\nfluid.addComponent(\"n-hexane\", 0.4);\nfluid.addComponent(\"water\", 0.3);\n\n// HV with UNIFAC activity coefficients\nfluid.setMixingRule(\"HV\", \"UNIFAC_UMRPRU\");\n</code></pre> <p>Available GE models for HV: - <code>\"NRTL\"</code> - Non-Random Two-Liquid (default) - <code>\"UNIFAC_UMRPRU\"</code> - UNIFAC with UMR-PRU parameters - <code>\"UNIFAC\"</code> - Standard UNIFAC - <code>\"UNIFAC_PSRK\"</code> - UNIFAC with PSRK parameters</p>"},{"location":"thermo/mixing_rules_guide/#45-accessing-hv-parameters","title":"4.5 Accessing HV Parameters","text":"<pre><code>// Get the mixing rule interface\nHVMixingRulesInterface hvRule = (HVMixingRulesInterface) fluid.getPhase(0).getMixingRule();\n\n// Get/Set HV parameters\ndouble dij = hvRule.getHVDijParameter(0, 1);\nhvRule.setHVDijParameter(0, 1, 500.0);  // Set Dij in K\n\ndouble alpha = hvRule.getHValphaParameter(0, 1);\nhvRule.setHValphaParameter(0, 1, 0.3);  // Set alpha (non-randomness)\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#5-wong-sandler-mixing-rule","title":"5. Wong-Sandler Mixing Rule","text":""},{"location":"thermo/mixing_rules_guide/#51-overview","title":"5.1 Overview","text":"<p>The Wong-Sandler (WS) mixing rule provides theoretically correct behavior at both low and high densities by matching: - The second virial coefficient of the mixture - The excess Gibbs energy at infinite pressure</p>"},{"location":"thermo/mixing_rules_guide/#52-mathematical-formulation","title":"5.2 Mathematical Formulation","text":"\\[ b_{mix} = \\frac{\\sum_i \\sum_j x_i x_j \\left( b - \\frac{a}{RT} \\right)_{ij}}{1 - \\frac{A_\\infty^E}{CRT} - \\sum_i x_i \\frac{a_i}{RTb_i}} \\] \\[ a_{mix} = b_{mix} \\left( \\sum_i x_i \\frac{a_i}{b_i} + \\frac{A_\\infty^E}{C} \\right) \\] <p>Where \\(C\\) is an EoS-specific constant and \\(A_\\infty^E\\) is the excess Helmholtz energy at infinite pressure.</p>"},{"location":"thermo/mixing_rules_guide/#53-ws-type-5","title":"5.3 WS - Type 5","text":"<pre><code>SystemInterface fluid = new SystemPrEos(350.0, 30.0);\nfluid.addComponent(\"methanol\", 0.2);\nfluid.addComponent(\"water\", 0.5);\nfluid.addComponent(\"CO2\", 0.3);\nfluid.setMixingRule(5);  // or fluid.setMixingRule(\"WS\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#54-wong-sandler-with-nrtl","title":"5.4 Wong-Sandler with NRTL","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(320.0, 20.0);\nfluid.addComponent(\"acetone\", 0.3);\nfluid.addComponent(\"water\", 0.4);\nfluid.addComponent(\"methane\", 0.3);\n\n// WS with NRTL activity coefficients\nfluid.setMixingRule(\"WS\", \"NRTL\");\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#55-accessing-ws-parameters","title":"5.5 Accessing WS Parameters","text":"<pre><code>HVMixingRulesInterface wsRule = (HVMixingRulesInterface) fluid.getPhase(0).getMixingRule();\n\n// Get/Set Wong-Sandler kij parameter\ndouble kijWS = wsRule.getKijWongSandler(0, 1);\nwsRule.setKijWongSandler(0, 1, 0.1);\n</code></pre> <p>Use case: High-pressure VLE, polar/non-polar mixtures, CO2 capture systems.</p>"},{"location":"thermo/mixing_rules_guide/#6-cpa-mixing-rules","title":"6. CPA Mixing Rules","text":"<p>For Cubic-Plus-Association (CPA) equations of state, specialized mixing rules handle both the cubic EoS part and the association term.</p>"},{"location":"thermo/mixing_rules_guide/#61-cpa_mix-type-7","title":"6.1 CPA_MIX - Type 7","text":"<p>Classic mixing rule with CPA-specific binary interaction parameters from the database.</p> <pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(320.0, 50.0);\nfluid.addComponent(\"water\", 0.1);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"MEG\", 0.1);\nfluid.setMixingRule(7);  // CPA classic mixing\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#62-classic_t_cpa-type-9","title":"6.2 CLASSIC_T_CPA - Type 9","text":"<p>Temperature-dependent classic mixing rule for CPA systems:</p> <pre><code>fluid.setMixingRule(9);\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#63-classic_tx_cpa-type-10","title":"6.3 CLASSIC_TX_CPA - Type 10","text":"<p>Temperature and composition dependent mixing rule for CPA. This is the recommended mixing rule for CPA systems as it: - Uses asymmetric kij parameters (kij \u2260 kji) - Includes temperature dependency - Automatically selects the appropriate sub-type based on parameter symmetry</p> <pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(330.0, 100.0);\nfluid.addComponent(\"water\", 0.15);\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"MEG\", 0.10);\nfluid.addComponent(\"CO2\", 0.05);\nfluid.setMixingRule(10);  // Recommended for CPA\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#64-cross-association-parameters","title":"6.4 Cross-Association Parameters","text":"<p>CPA mixing rules also handle association site interactions between different molecules:</p> Association Scheme Description Examples CR-1 Cross-association with single site Water-MEG ER Elliott combining rule General polar systems 4C Four-site model Water, glycols 2B Two-site model Alcohols"},{"location":"thermo/mixing_rules_guide/#7-sreide-whitson-mixing-rule","title":"7. S\u00f8reide-Whitson Mixing Rule","text":""},{"location":"thermo/mixing_rules_guide/#71-overview","title":"7.1 Overview","text":"<p>The S\u00f8reide-Whitson mixing rule is specifically designed for systems containing: - Sour gases (CO2, H2S, N2) - Hydrocarbons - Aqueous brine solutions</p> <p>It uses composition and salinity-dependent binary interaction parameters.</p>"},{"location":"thermo/mixing_rules_guide/#72-soreide_whitson-type-11","title":"7.2 SOREIDE_WHITSON - Type 11","text":"<pre><code>import neqsim.thermo.system.SystemSoreideWhitson;\n\nSystemSoreideWhitson fluid = new SystemSoreideWhitson(350.0, 200.0);\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"CO2\", 0.15);\nfluid.addComponent(\"H2S\", 0.05);\nfluid.addComponent(\"water\", 0.10);\n\n// Add salinity (important for sour gas solubility)\nfluid.addSalinity(2.0, \"mole/sec\");\n\nfluid.setMixingRule(11);  // S\u00f8reide-Whitson mixing rule\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#73-salinity-dependent-kij","title":"7.3 Salinity-Dependent kij","text":"<p>The mixing rule calculates kij for water-gas interactions based on salinity (S in mol/kg):</p> <p>For CO2-water: $$ k_{ij} = -0.31092(1 + 0.156 S^{0.75}) + 0.236(1 + 0.178 S^{0.98}) T_r - 21.26 e<sup>{-6.72</sup> $$} - S</p> <p>For N2-water: $$ k_{ij} = -1.702(1 + 0.026 S^{0.75}) + 0.443(1 + 0.081 S^{0.75}) T_r $$</p> <p>For hydrocarbons-water: $$ k_{ij} = (1 + a_0 S) A_0 + (1 + a_1 S) A_1 T_r + (1 + a_2 S) A_2 T_r^2 $$</p> <p>Where \\(T_r\\) is the reduced temperature and the \\(A\\) and \\(a\\) coefficients depend on the acentric factor.</p> <p>Use case: Reservoir fluids with aqueous phases, sour gas processing, CCS with brine.</p>"},{"location":"thermo/mixing_rules_guide/#8-binary-interaction-parameters-kij","title":"8. Binary Interaction Parameters (kij)","text":""},{"location":"thermo/mixing_rules_guide/#81-default-database-values","title":"8.1 Default Database Values","text":"<p>NeqSim loads kij values from its internal database when you call <code>setMixingRule()</code>. These are stored in the <code>inter</code> table.</p>"},{"location":"thermo/mixing_rules_guide/#82-setting-custom-kij-values","title":"8.2 Setting Custom kij Values","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"CO2\", 0.1);\nfluid.setMixingRule(\"classic\");\n\n// Get the mixing rule interface\nEosMixingRulesInterface mixRule = fluid.getPhase(0).getMixingRule();\n\n// Set custom kij (symmetric: kij = kji)\nmixRule.setBinaryInteractionParameter(0, 1, 0.12);\n\n// Get current kij value\ndouble kij = mixRule.getBinaryInteractionParameter(0, 1);\nSystem.out.println(\"kij(CH4-CO2) = \" + kij);\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#83-setting-asymmetric-kij-for-cpa","title":"8.3 Setting Asymmetric kij (for CPA)","text":"<pre><code>// For CPA systems with asymmetric parameters\nmixRule.setBinaryInteractionParameterij(0, 1, 0.08);  // kij\nmixRule.setBinaryInteractionParameterji(0, 1, 0.12);  // kji\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#84-setting-temperature-dependent-kij","title":"8.4 Setting Temperature-Dependent kij","text":"<pre><code>// For mixing rules 8, 9, 12\n// kij(T) = kij0 + kijT * f(T)\nmixRule.setBinaryInteractionParameter(0, 1, 0.10);    // kij0\nmixRule.setBinaryInteractionParameterT1(0, 1, 0.001); // kijT\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#85-displaying-kij-matrix","title":"8.5 Displaying kij Matrix","text":"<pre><code>double[][] kijMatrix = mixRule.getBinaryInteractionParameters();\nfor (int i = 0; i &lt; fluid.getNumberOfComponents(); i++) {\n    for (int j = 0; j &lt; fluid.getNumberOfComponents(); j++) {\n        System.out.printf(\"kij[%d][%d] = %.4f  \", i, j, kijMatrix[i][j]);\n    }\n    System.out.println();\n}\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#9-complete-reference-table","title":"9. Complete Reference Table","text":"Type Name String Key Description Best For 1 <code>NO</code> <code>\"NO\"</code> All kij = 0 Quick estimates, ideal mixtures 2 <code>CLASSIC</code> <code>\"classic\"</code> Classic van der Waals with database kij General hydrocarbons 3 <code>CLASSIC_HV</code> <code>\"CLASSIC_HV\"</code> Huron-Vidal with database parameters Polar mixtures 4 <code>HV</code> <code>\"HV\"</code> Huron-Vidal with T-dependent parameters Alcohol-water-HC 5 <code>WS</code> <code>\"WS\"</code> Wong-Sandler High-pressure polar systems 7 <code>CPA_MIX</code> <code>\"CPA_MIX\"</code> Classic for CPA systems Water-HC with CPA 8 <code>CLASSIC_T</code> <code>\"CLASSIC_T\"</code> T-dependent kij (linear) Temperature-sensitive kij 9 <code>CLASSIC_T_CPA</code> <code>\"CLASSIC_T_CPA\"</code> T-dependent for CPA CPA with T-dependency 10 <code>CLASSIC_TX_CPA</code> <code>\"CLASSIC_TX_CPA\"</code> T and x dependent for CPA Recommended for CPA 11 <code>SOREIDE_WHITSON</code> <code>\"SOREIDE_WHITSON\"</code> Salinity-dependent Sour gas, brine systems 12 <code>CLASSIC_T2</code> <code>\"CLASSIC_T2\"</code> T-dependent (inverse) Alternative T-dependency"},{"location":"thermo/mixing_rules_guide/#10-examples-by-application","title":"10. Examples by Application","text":""},{"location":"thermo/mixing_rules_guide/#101-natural-gas-processing","title":"10.1 Natural Gas Processing","text":"<pre><code>SystemInterface gas = new SystemSrkEos(280.0, 70.0);\ngas.addComponent(\"nitrogen\", 0.02);\ngas.addComponent(\"CO2\", 0.03);\ngas.addComponent(\"methane\", 0.85);\ngas.addComponent(\"ethane\", 0.06);\ngas.addComponent(\"propane\", 0.04);\ngas.setMixingRule(\"classic\");  // Type 2\n\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\nops.TPflash();\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#102-glycol-dehydration-cpa","title":"10.2 Glycol Dehydration (CPA)","text":"<pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(320.0, 50.0);\nfluid.addComponent(\"methane\", 0.80);\nfluid.addComponent(\"water\", 0.05);\nfluid.addComponent(\"TEG\", 0.15);  // Triethylene glycol\nfluid.setMixingRule(10);  // CLASSIC_TX_CPA - recommended for CPA\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#103-amine-gas-treating","title":"10.3 Amine Gas Treating","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(323.0, 20.0);\nfluid.addComponent(\"CO2\", 0.15);\nfluid.addComponent(\"H2S\", 0.05);\nfluid.addComponent(\"methane\", 0.60);\nfluid.addComponent(\"MDEA\", 0.10);  // Methyldiethanolamine\nfluid.addComponent(\"water\", 0.10);\nfluid.setMixingRule(\"HV\", \"NRTL\");  // Huron-Vidal with NRTL\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#104-co2-capture-and-storage","title":"10.4 CO2 Capture and Storage","text":"<pre><code>SystemInterface fluid = new SystemPrEos(350.0, 150.0);\nfluid.addComponent(\"CO2\", 0.90);\nfluid.addComponent(\"nitrogen\", 0.05);\nfluid.addComponent(\"oxygen\", 0.02);\nfluid.addComponent(\"water\", 0.03);\nfluid.setMixingRule(\"WS\");  // Wong-Sandler for high pressure\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#105-sour-gas-with-brine","title":"10.5 Sour Gas with Brine","text":"<pre><code>SystemSoreideWhitson fluid = new SystemSoreideWhitson(380.0, 250.0);\nfluid.addComponent(\"methane\", 0.65);\nfluid.addComponent(\"CO2\", 0.20);\nfluid.addComponent(\"H2S\", 0.05);\nfluid.addComponent(\"water\", 0.10);\nfluid.addSalinity(\"NaCl\", 3.0, \"mole/sec\");  // Add NaCl salinity\nfluid.setMixingRule(11);  // S\u00f8reide-Whitson\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\nfluid.prettyPrint();\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#106-pharmaceuticalchemical-unifac-predictive","title":"10.6 Pharmaceutical/Chemical (UNIFAC Predictive)","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(298.0, 1.0);\nfluid.addComponent(\"ethanol\", 0.3);\nfluid.addComponent(\"acetone\", 0.3);\nfluid.addComponent(\"water\", 0.4);\nfluid.setMixingRule(\"HV\", \"UNIFAC_UMRPRU\");  // Predictive UNIFAC\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n</code></pre>"},{"location":"thermo/mixing_rules_guide/#see-also","title":"See Also","text":"<ul> <li>Fluid Creation Guide - Complete guide to creating fluids</li> <li>Mathematical Models - EoS equations and derivations</li> <li>Thermodynamic Workflows - Flash calculations and operations</li> <li>PVT and Fluid Characterization - Heavy fraction handling</li> </ul>"},{"location":"thermo/physical_properties/","title":"Physical Property Calculations","text":"<p>NeqSim computes phase and mixture properties after thermodynamic initialization. This guide highlights the most used methods and how to choose appropriate models.</p>"},{"location":"thermo/physical_properties/#density-and-compressibility","title":"Density and Compressibility","text":"<ul> <li>Call <code>fluid.initPhysicalProperties()</code> or <code>fluid.initProperties()</code> after a flash to populate density (<code>getDensity()</code>) and compressibility (<code>getZ()</code>).</li> <li>Apply volume-shifted PR/SRK models when liquid density underpredicts lab data.</li> </ul>"},{"location":"thermo/physical_properties/#viscosity","title":"Viscosity","text":"<ul> <li><code>getViscosity()</code> on a phase returns dynamic viscosity. Correlations switch automatically based on system type:</li> <li>Corresponding-states for gases and light condensates.</li> <li>Heavy-oil extensions when TBP fractions or high molar masses are present.</li> <li>Association-corrected viscosity for CPA systems.</li> <li>Use <code>setMixingRule(7)</code> or CPA fluids when hydrogen bonding impacts rheology (water, glycols).</li> </ul>"},{"location":"thermo/physical_properties/#thermal-conductivity-and-heat-capacity","title":"Thermal Conductivity and Heat Capacity","text":"<ul> <li><code>getThermalConductivity()</code> provides phase thermal conductivity using dense-gas corrections.</li> <li><code>getCp()</code> and <code>getEnthalpy()</code> support energy balances. Reinitialize (<code>init(3)</code>) if temperature changes substantially between calls.</li> </ul>"},{"location":"thermo/physical_properties/#surface-and-interfacial-tension","title":"Surface and Interfacial Tension","text":"<ul> <li><code>getInterfacialTension(phase1, phase2)</code> calculates tension between phases (e.g., gas-oil, gas-water) using parachor correlations tied to the active EOS.</li> <li>Ensure both phases are present after a flash; otherwise, perform a two-phase flash at representative separator conditions first.</li> </ul>"},{"location":"thermo/physical_properties/#diffusion-and-mass-transfer","title":"Diffusion and Mass Transfer","text":"<ul> <li><code>getDiffusionCoefficient()</code> is available on phases for estimating film and molecular diffusion coefficients.</li> <li>In unit operations, enable mass-transfer calculations to access local Sherwood correlations and film models.</li> </ul>"},{"location":"thermo/physical_properties/#numerical-tips","title":"Numerical Tips","text":"<ul> <li>Always flash (<code>TPflash</code>, <code>PHflash</code>, etc.) before requesting properties; raw composition-only systems do not hold valid properties.</li> <li>When looping over many states, reuse fluids and call <code>initPhysicalProperties()</code> after each state change to refresh transport properties without repeating equilibrium calculations.</li> </ul>"},{"location":"thermo/pvt_fluid_characterization/","title":"PVT and Fluid Characterization","text":"<p>Accurate phase behavior predictions start with a realistic fluid description. NeqSim supports full compositional models, TBP cuts, and black-oil style pseudo-components.</p>"},{"location":"thermo/pvt_fluid_characterization/#building-compositions","title":"Building Compositions","text":"<ol> <li>Known components: Add pure components directly using critical-property data from the internal database.</li> <li>Plus fractions (C7+): Use <code>addPlusFraction(name, moles, molarMass, density)</code> when only overall heavy fraction data are available.</li> <li>TBP/assay data: Use <code>addTBPfraction(name, moles, density, molarMass)</code> to preserve multiple heavy cuts with their own boiling ranges.</li> </ol> <pre><code>SystemInterface oil = new SystemSrkEos(323.15, 150.0);\noil.createDatabase(true);\noil.addComponent(\"nitrogen\", 0.01);\noil.addComponent(\"methane\", 0.60);\noil.addTBPfraction(\"C7\", 0.08, 0.73, 7.5);\noil.addTBPfraction(\"C10\", 0.10, 0.80, 10.5);\noil.addPlusFraction(\"C20+\", 0.21, 0.92, 22.0);\noil.setMixingRule(2);\n</code></pre>"},{"location":"thermo/pvt_fluid_characterization/#tuning-and-regression","title":"Tuning and Regression","text":"<ul> <li>Binary interaction parameters (kij): Adjust kij tables (<code>setBinaryInteractionParameter</code>) to match dew/bubble points.</li> <li>Volume shift/critical-point matching: Enable volume corrections on PR/SRK fluids to improve density fits.</li> <li>Plus-fraction splitting: Use <code>splitTBPfraction</code> to subdivide heavy cuts using predefined distillation curves.</li> <li>Viscosity tuning: Adjust heavy-end Watson K or user-defined viscosity correlations when matching lab rheology.</li> </ul>"},{"location":"thermo/pvt_fluid_characterization/#pvt-reports","title":"PVT Reports","text":"<p>After running <code>ThermodynamicOperations.TPflash()</code>, collect standard PVT outputs: <pre><code>oil.initProperties();\nSystem.out.println(\"Bo at separator: \" + oil.getPhase(\"oil\").getVolume() / oil.getTotalNumberOfMoles());\nSystem.out.println(\"GOR at separator: \" + oil.getPhase(\"gas\").getNumberOfMoles()/oil.getPhase(\"oil\").getNumberOfMoles());\n</code></pre> For multi-stage separators, clone the fluid after each flash and continue flashing at downstream conditions.</p>"},{"location":"thermo/pvt_fluid_characterization/#data-management","title":"Data Management","text":"<ul> <li>Store compositions and tuned parameters as JSON using <code>toJson()</code> for reproducible studies.</li> <li>Use <code>addFluid(existingSystem)</code> to combine live-oil and gas-cap fluids or to merge lab and model data sets.</li> <li>When integrating with black-oil simulators, export pseudo-component properties (MW, density, Z-factor) for each stage.</li> </ul>"},{"location":"thermo/thermodynamic_operations/","title":"Thermodynamic Operations","text":"<p>Thermodynamic operations execute equilibrium and property tasks using a configured fluid. Most workflows create a <code>ThermodynamicOperations</code> object once and reuse it for multiple calls.</p>"},{"location":"thermo/thermodynamic_operations/#flash-calculations","title":"Flash Calculations","text":"<ul> <li><code>TPflash()</code>: Calculates phase split at specified temperature and pressure. Run <code>initProperties()</code> afterward for density/viscosity.</li> <li><code>PHflash(P, H)</code> and <code>PSflash(P, S)</code>: Solve for temperature/phase split given enthalpy or entropy targets\u2014useful for compressors and turbines.</li> <li><code>TVflash(T, V)</code>: Volume-constrained flash for fixed-volume cells.</li> <li><code>UVflash(U, V)</code>: Energy- and volume-constrained flash for transient simulations.</li> </ul> <pre><code>ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\ndouble vaporFraction = fluid.getBeta();\n</code></pre>"},{"location":"thermo/thermodynamic_operations/#phase-envelopes","title":"Phase Envelopes","text":"<ul> <li>PT envelope: <code>ops.calcPTphaseEnvelope()</code> fills critical point, cricondenbar, cricondentherm, and two-phase boundary.</li> <li>Hydrate curves: Enable <code>hydrateCheck(true)</code> before calling <code>ops.hydrateFormationTemperature(pressure)</code>.</li> <li>Wax/solid envelopes: Use a solid-enabled system and call <code>ops.calcSolidFormationTemperature()</code>.</li> </ul>"},{"location":"thermo/thermodynamic_operations/#property-routines","title":"Property Routines","text":"<p>After flashes, properties are available on each phase: - <code>getDensity()</code> or <code>getNumberOfMoles()</code> for molar/volume properties. - <code>getEnthalpy()</code>, <code>getEntropy()</code>, and <code>getCp()</code> for energy balances. - <code>getViscosity()</code>, <code>getThermalConductivity()</code>, and <code>getInterfacialTension()</code> for transport analyses.</p>"},{"location":"thermo/thermodynamic_operations/#electrolytes-and-reactions","title":"Electrolytes and Reactions","text":"<ul> <li>Electrolytes: Build systems such as <code>SystemFurstElectrolyteEos</code> or <code>SystemElectrolyteCPAstatoil</code>, add salts/acids, and enable charge balance. Use <code>ops.electrolyteFlash()</code> for salt precipitation studies.</li> <li>Chemical reactions: Define reactions with stoichiometry and equilibrium constants, then call <code>ops.calcChemicalEquilibrium()</code> to couple them into flashes.</li> </ul>"},{"location":"thermo/thermodynamic_operations/#best-practices","title":"Best Practices","text":"<ul> <li>Always reinitialize (<code>fluid.init(3)</code>) after changing temperature, pressure, or composition significantly.</li> <li>Reuse the same <code>ThermodynamicOperations</code> instance when sweeping conditions to avoid rebuilding internal caches.</li> <li>For performance-sensitive loops, pre-allocate fluids and avoid repeated parsing of the component database.</li> </ul>"},{"location":"thermo/thermodynamic_workflows/","title":"Thermodynamic Workflows","text":"<p>Use these recipes to configure fluids and run equilibrium calculations with NeqSim. The Java snippets mirror the workflow used in other language bindings.</p>"},{"location":"thermo/thermodynamic_workflows/#1-build-a-fluid","title":"1. Build a Fluid","text":"<pre><code>SystemInterface fluid = new SystemPrEos(313.15, 80.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.05);\nfluid.addTBPfraction(\"C7+\", 0.10, 0.45, 8.0); // name, moles, density [g/cc], MW\nfluid.createDatabase(true); // enable access to component data\nfluid.setMixingRule(1); // classical van der Waals mixing rule\nfluid.init(0);\n</code></pre> <p>Tips: - Always call <code>createDatabase(true)</code> before adding TBP fractions so critical properties and acentric factors are filled automatically. - Use <code>addPlusFraction</code> for simpler heavy-end inputs, or <code>addFluid</code> to merge two existing systems.</p>"},{"location":"thermo/thermodynamic_workflows/#2-choose-a-model-and-mixing-rule","title":"2. Choose a Model and Mixing Rule","text":"<ul> <li><code>setMixingRule(1)</code>: classical quadratic kij.</li> <li><code>setMixingRule(2)</code>: Huron\u2013Vidal (gamma-phi) coupling.</li> <li><code>setMixingRule(4)</code>: Wong\u2013Sandler (NRTL-based) coupling.</li> <li><code>setMixingRule(7)</code>: Simplified CPA cross-association rules.</li> </ul> <p>For lean gas, start with PR and kij from correlations; for rich liquids or polar systems, move to SRK-Twu + Huron\u2013Vidal or CPA-SRK.</p>"},{"location":"thermo/thermodynamic_workflows/#3-run-thermodynamic-operations","title":"3. Run Thermodynamic Operations","text":"<p>Instantiate <code>ThermodynamicOperations</code> with the configured fluid to access flash and envelope tools: <pre><code>ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\nfluid.initProperties();\nSystem.out.println(\"Vapor fraction: \" + fluid.getPhaseFraction(0));\n</code></pre> Common operations include: - <code>PSflash(pressure, entropy)</code>, <code>PHflash(pressure, enthalpy)</code> for process simulators. - <code>dewPointTemperature(pressure)</code> and <code>bubblePointPressure(temperature)</code> for PVT lab matches. - <code>calcPTphaseEnvelope()</code> and <code>calcPseudocriticalTemperature()</code> for compositional screening.</p>"},{"location":"thermo/thermodynamic_workflows/#4-save-and-reuse-states","title":"4. Save and Reuse States","text":"<p>Export an EOS state to JSON or clone fluids when sweeping conditions: <pre><code>SystemInterface clone = fluid.clone();\nclone.setTemperature(280.0);\nclone.setPressure(10.0);\nnew ThermodynamicOperations(clone).TPflash();\n</code></pre></p>"},{"location":"thermo/thermodynamic_workflows/#5-debugging-and-validation","title":"5. Debugging and Validation","text":"<ul> <li>Call <code>display()</code> on the fluid to dump compositions, kij values, and phase properties.</li> <li>Use <code>calcChemicalEquilibrium()</code> after setting reaction stoichiometry to couple reactions into flashes.</li> <li>Compare <code>getMolarMass()</code> and <code>getZ()</code> against lab PVT data to verify characterization accuracy.</li> </ul>"},{"location":"thermo/characterization/","title":"Characterization Package","text":"<p>Documentation for plus fraction characterization in NeqSim.</p>"},{"location":"thermo/characterization/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Plus Fraction Methods</li> <li>Characterization Approaches</li> <li>TBP Methods</li> <li>Examples</li> </ul>"},{"location":"thermo/characterization/#overview","title":"Overview","text":"<p>Location: <code>neqsim.thermo.characterization</code></p> <p>The characterization package handles petroleum plus fraction characterization: - Converting C7+ (or other plus fractions) into pseudo-components - Estimating critical properties from correlations - Splitting heavy ends into discrete pseudo-components</p>"},{"location":"thermo/characterization/#plus-fraction-methods","title":"Plus Fraction Methods","text":""},{"location":"thermo/characterization/#adding-plus-fractions","title":"Adding Plus Fractions","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\n\nSystemSrkEos fluid = new SystemSrkEos(373.15, 100.0);\n\n// Light components\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.08);\nfluid.addComponent(\"n-butane\", 0.05);\n\n// C7+ as single pseudo-component\nfluid.addTBPfraction(\"C7+\", 0.07, 150.0, 0.78);  // name, moles, MW, SG\n</code></pre>"},{"location":"thermo/characterization/#multiple-plus-fractions","title":"Multiple Plus Fractions","text":"<pre><code>// Split C7+ into multiple fractions\nfluid.addTBPfraction(\"C7\", 0.02, 96.0, 0.727);\nfluid.addTBPfraction(\"C8\", 0.015, 107.0, 0.749);\nfluid.addTBPfraction(\"C9\", 0.01, 121.0, 0.768);\nfluid.addTBPfraction(\"C10+\", 0.025, 180.0, 0.82);\n</code></pre>"},{"location":"thermo/characterization/#characterization-approaches","title":"Characterization Approaches","text":""},{"location":"thermo/characterization/#pedersen-method","title":"Pedersen Method","text":"<pre><code>import neqsim.thermo.characterization.PedersenCharacterization;\n\n// Characterize using Pedersen correlations\nPedersenCharacterization charPedersen = new PedersenCharacterization(fluid);\ncharPedersen.characterize();\n</code></pre>"},{"location":"thermo/characterization/#whitson-gamma-distribution","title":"Whitson Gamma Distribution","text":"<pre><code>import neqsim.thermo.characterization.WhitsonCharacterization;\n\n// Characterize using Whitson gamma distribution\nWhitsonCharacterization charWhitson = new WhitsonCharacterization(fluid);\ncharWhitson.setAlpha(1.0);  // Shape parameter\ncharWhitson.characterize();\n</code></pre>"},{"location":"thermo/characterization/#tbp-methods","title":"TBP Methods","text":""},{"location":"thermo/characterization/#adding-tbp-fractions","title":"Adding TBP Fractions","text":"<pre><code>// addTBPfraction(name, moles, MW, specificGravity)\nfluid.addTBPfraction(\"C7\", moles, 96.0, 0.727);\n\n// addPlusFraction with characterization\nfluid.addPlusFraction(\"C20+\", moles, 400.0, 0.90);\n</code></pre>"},{"location":"thermo/characterization/#property-estimation","title":"Property Estimation","text":"<p>For pseudo-components, critical properties are estimated using correlations:</p> Correlation Properties Estimated Twu Tc, Pc, omega from MW, SG Lee-Kesler Tc, Pc, omega from Tb, SG Riazi-Daubert Tb from MW, SG Pedersen Tc, Pc, omega for petroleum"},{"location":"thermo/characterization/#examples","title":"Examples","text":""},{"location":"thermo/characterization/#example-1-natural-gas-with-c7","title":"Example 1: Natural Gas with C7+","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\nSystemSrkEos gas = new SystemSrkEos(373.15, 100.0);\n\n// Wellstream composition\ngas.addComponent(\"nitrogen\", 0.015);\ngas.addComponent(\"CO2\", 0.020);\ngas.addComponent(\"methane\", 0.750);\ngas.addComponent(\"ethane\", 0.080);\ngas.addComponent(\"propane\", 0.045);\ngas.addComponent(\"i-butane\", 0.012);\ngas.addComponent(\"n-butane\", 0.020);\ngas.addComponent(\"i-pentane\", 0.008);\ngas.addComponent(\"n-pentane\", 0.010);\ngas.addComponent(\"n-hexane\", 0.015);\n\n// C7+ fraction\ngas.addTBPfraction(\"C7+\", 0.025, 145.0, 0.78);\n\ngas.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(gas);\nops.TPflash();\n\nSystem.out.println(\"Gas fraction: \" + gas.getGasPhase().getBeta());\nSystem.out.println(\"C7+ in gas: \" + gas.getGasPhase().getComponent(\"C7+_PC\").getx());\n</code></pre>"},{"location":"thermo/characterization/#example-2-oil-characterization","title":"Example 2: Oil Characterization","text":"<pre><code>// Black oil with detailed C7+ split\nSystemSrkEos oil = new SystemSrkEos(350.0, 50.0);\n\noil.addComponent(\"methane\", 0.40);\noil.addComponent(\"ethane\", 0.08);\noil.addComponent(\"propane\", 0.06);\noil.addComponent(\"n-butane\", 0.04);\noil.addComponent(\"n-pentane\", 0.03);\noil.addComponent(\"n-hexane\", 0.03);\n\n// Detailed C7+ split\noil.addTBPfraction(\"C7\", 0.05, 96.0, 0.727);\noil.addTBPfraction(\"C8\", 0.05, 107.0, 0.749);\noil.addTBPfraction(\"C9\", 0.04, 121.0, 0.768);\noil.addTBPfraction(\"C10\", 0.04, 134.0, 0.782);\noil.addTBPfraction(\"C11\", 0.03, 147.0, 0.793);\noil.addTBPfraction(\"C12+\", 0.15, 250.0, 0.85);\n\noil.setMixingRule(\"classic\");\n</code></pre>"},{"location":"thermo/characterization/#related-documentation","title":"Related Documentation","text":"<ul> <li>PVT Fluid Characterization - Detailed characterization guide</li> <li>Fluid Creation Guide - Creating fluids</li> <li>Thermo Package - Package overview</li> </ul>"},{"location":"thermo/component/","title":"Component Package","text":"<p>Documentation for component modeling in NeqSim.</p>"},{"location":"thermo/component/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Component Interface</li> <li>Pure Component Properties</li> <li>Component in Phase</li> <li>Component Types</li> <li>Database Components</li> </ul>"},{"location":"thermo/component/#overview","title":"Overview","text":"<p>Location: <code>neqsim.thermo.component</code></p> <p>The component package contains 65+ classes for modeling pure component properties and their behavior in mixtures.</p>"},{"location":"thermo/component/#component-interface","title":"Component Interface","text":""},{"location":"thermo/component/#accessing-components","title":"Accessing Components","text":"<pre><code>// By name\nComponentInterface methane = fluid.getComponent(\"methane\");\n\n// By index\nComponentInterface comp = fluid.getComponent(0);\n\n// In specific phase\nComponentInterface methaneInGas = fluid.getGasPhase().getComponent(\"methane\");\n</code></pre>"},{"location":"thermo/component/#common-methods","title":"Common Methods","text":"<pre><code>ComponentInterface comp = fluid.getComponent(\"methane\");\n\n// Pure component properties\ndouble Tc = comp.getTC();           // Critical temperature (K)\ndouble Pc = comp.getPC();           // Critical pressure (bar)\ndouble omega = comp.getAcentricFactor();\ndouble MW = comp.getMolarMass();    // kg/mol\n\n// Composition\ndouble z = comp.getz();             // Overall mole fraction\ndouble x = comp.getx();             // Phase mole fraction\ndouble n = comp.getNumberOfMolesInPhase();\n\n// Fugacity\ndouble f = comp.getFugacity();\ndouble phi = comp.getFugacityCoefficient();\n</code></pre>"},{"location":"thermo/component/#pure-component-properties","title":"Pure Component Properties","text":""},{"location":"thermo/component/#critical-properties","title":"Critical Properties","text":"<pre><code>ComponentInterface comp = fluid.getComponent(\"propane\");\n\ndouble Tc = comp.getTC();        // 369.83 K\ndouble Pc = comp.getPC();        // 42.48 bar\ndouble Vc = comp.getVc();        // Critical volume (m\u00b3/mol)\ndouble Zc = comp.getZc();        // Critical Z-factor\ndouble omega = comp.getAcentricFactor();  // 0.1523\n</code></pre>"},{"location":"thermo/component/#physical-properties","title":"Physical Properties","text":"<pre><code>// Molecular properties\ndouble MW = comp.getMolarMass();            // kg/mol\ndouble Tb = comp.getNormalBoilingPoint();   // K\ndouble Tf = comp.getTriplePointTemperature(); // K\n\n// Reference properties\ndouble dHf = comp.getEnthalpyOfFormation(); // kJ/mol\ndouble dGf = comp.getGibbsEnergyOfFormation();\ndouble Href = comp.getReferencePotential();\n</code></pre>"},{"location":"thermo/component/#eos-parameters","title":"EoS Parameters","text":"<pre><code>// SRK/PR parameters\ndouble a = comp.geta();     // Attraction parameter\ndouble b = comp.getb();     // Co-volume parameter\n\n// CPA parameters (for associating)\ndouble eps = comp.getAssociationEnergy();\ndouble beta = comp.getAssociationVolume();\n\n// PC-SAFT parameters\ndouble m = comp.getmSAFTi();        // Segment number\ndouble sigma = comp.getSigmaSAFTi(); // Segment diameter\ndouble epsilon = comp.getEpsSAFTi(); // Dispersion energy\n</code></pre>"},{"location":"thermo/component/#component-in-phase","title":"Component in Phase","text":""},{"location":"thermo/component/#phase-composition","title":"Phase Composition","text":"<pre><code>PhaseInterface gas = fluid.getGasPhase();\nComponentInterface methane = gas.getComponent(\"methane\");\n\n// Mole fraction in phase\ndouble x_i = methane.getx();\n\n// Fugacity coefficient\ndouble phi_i = methane.getFugacityCoefficient();\ndouble lnPhi = methane.getLogFugacityCoefficient();\n\n// Fugacity\ndouble f_i = methane.getFugacity();\n\n// Chemical potential\ndouble mu_i = methane.getChemicalPotential();\n\n// Activity (for liquid phases)\ndouble a_i = methane.getActivity();\ndouble gamma = methane.getActivityCoefficient();\n</code></pre>"},{"location":"thermo/component/#partial-properties","title":"Partial Properties","text":"<pre><code>// Partial molar volume\ndouble Vbar_i = comp.getPartialMolarVolume();\n\n// Partial molar enthalpy\ndouble Hbar_i = comp.getPartialMolarEnthalpy();\n\n// Partial molar entropy\ndouble Sbar_i = comp.getPartialMolarEntropy();\n</code></pre>"},{"location":"thermo/component/#derivatives","title":"Derivatives","text":"<pre><code>// Fugacity coefficient derivatives\ndouble dPhidT = comp.getdfugdT();        // d(ln \u03c6)/dT\ndouble dPhidP = comp.getdfugdP();        // d(ln \u03c6)/dP\ndouble dPhidx = comp.getdfugdx(j);       // d(ln \u03c6_i)/dx_j\n</code></pre>"},{"location":"thermo/component/#component-types","title":"Component Types","text":""},{"location":"thermo/component/#eos-components","title":"EoS Components","text":"<pre><code>// Standard EoS component\nComponentEos compEos = (ComponentEos) fluid.getComponent(\"methane\");\n\n// Access EoS-specific properties\ndouble ai = compEos.getaT();  // Temperature-dependent a\ndouble bi = compEos.getb();\ndouble alphai = compEos.getAlpha();\n</code></pre>"},{"location":"thermo/component/#cpa-components","title":"CPA Components","text":"<pre><code>// For associating components\nComponentCPA compCPA = (ComponentCPA) fluid.getComponent(\"water\");\n\n// Association properties\ndouble eps = compCPA.getAssociationEnergy();\ndouble beta = compCPA.getAssociationVolume();\nint sites = compCPA.getNumberOfAssociationSites();\n\n// Association fraction\ndouble X_A = compCPA.getXsite(0);  // Fraction of site A unbonded\n</code></pre>"},{"location":"thermo/component/#pc-saft-components","title":"PC-SAFT Components","text":"<pre><code>ComponentPCSAFT compSAFT = (ComponentPCSAFT) fluid.getComponent(\"n-hexane\");\n\ndouble m = compSAFT.getmSAFTi();      // Chain length\ndouble sigma = compSAFT.getSigmaSAFTi(); // Segment diameter (\u00c5)\ndouble eps = compSAFT.getEpsSAFTi();  // Dispersion energy (K)\n</code></pre>"},{"location":"thermo/component/#electrolyte-components","title":"Electrolyte Components","text":"<pre><code>// Ions\nComponentElectrolyte ion = (ComponentElectrolyte) fluid.getComponent(\"Na+\");\n\ndouble charge = ion.getIonicCharge();\ndouble diameter = ion.getIonicDiameter();\n</code></pre>"},{"location":"thermo/component/#pseudo-components","title":"Pseudo-Components","text":"<pre><code>// Plus fraction components\nComponentTBP plus = (ComponentTBP) fluid.getComponent(\"C7+\");\n\ndouble Tb = plus.getNormalBoilingPoint();\ndouble SG = plus.getSpecificGravity();\ndouble MW = plus.getMolarMass();\n</code></pre>"},{"location":"thermo/component/#database-components","title":"Database Components","text":""},{"location":"thermo/component/#available-components","title":"Available Components","text":"<p>NeqSim includes a database with 100+ components:</p> Category Examples Light gases nitrogen, oxygen, CO2, H2S, hydrogen Hydrocarbons methane through n-C20 Cyclic cyclohexane, benzene, toluene Polar water, methanol, ethanol, MEG, DEG, TEG Amines MDEA, MEA, DEA, piperazine Refrigerants R-134a, R-32, ammonia"},{"location":"thermo/component/#adding-components","title":"Adding Components","text":"<pre><code>// Add from database\nfluid.addComponent(\"methane\", 1.0);\n\n// Add with alias\nfluid.addComponent(\"CO2\", 0.5);  // Carbon dioxide\n\n// Add pseudo-component (TBP method)\nfluid.addTBPfraction(\"C10\", 0.1, 140.0, 0.75);  // name, moles, MW, SG\n\n// Add plus fraction\nfluid.addPlusFraction(\"C7+\", 0.05, 150.0, 0.78);\n</code></pre>"},{"location":"thermo/component/#component-name-lookup","title":"Component Name Lookup","text":"<pre><code>// Check if component exists\nboolean exists = fluid.hasComponent(\"methane\");\n\n// Get component index\nint index = fluid.getComponentIndex(\"ethane\");\n</code></pre>"},{"location":"thermo/component/#example-component-properties-report","title":"Example: Component Properties Report","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\n\nSystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.setMixingRule(\"classic\");\nfluid.init(0);\n\nSystem.out.println(\"Component Properties:\");\nSystem.out.println(\"-------------------------------------------\");\nSystem.out.printf(\"%-10s %8s %8s %8s %8s%n\", \n    \"Name\", \"Tc(K)\", \"Pc(bar)\", \"omega\", \"MW\");\nSystem.out.println(\"-------------------------------------------\");\n\nfor (int i = 0; i &lt; fluid.getNumberOfComponents(); i++) {\n    ComponentInterface comp = fluid.getComponent(i);\n    System.out.printf(\"%-10s %8.2f %8.2f %8.4f %8.4f%n\",\n        comp.getName(),\n        comp.getTC(),\n        comp.getPC(),\n        comp.getAcentricFactor(),\n        comp.getMolarMass() * 1000);  // g/mol\n}\n</code></pre>"},{"location":"thermo/component/#related-documentation","title":"Related Documentation","text":"<ul> <li>System Package - Fluid systems</li> <li>Phase Package - Phase modeling</li> <li>Mixing Rules - Binary interactions</li> <li>Thermo Package - Package overview</li> </ul>"},{"location":"thermo/mixingrule/","title":"Mixing Rules Package","text":"<p>Documentation for mixing rules in NeqSim equations of state.</p>"},{"location":"thermo/mixingrule/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Classic Mixing Rules</li> <li>CPA Mixing Rules</li> <li>Activity Coefficient Mixing Rules</li> <li>Binary Interaction Parameters</li> </ul>"},{"location":"thermo/mixingrule/#overview","title":"Overview","text":"<p>Location: <code>neqsim.thermo.mixingrule</code></p> <p>Mixing rules define how pure component EoS parameters combine in mixtures.</p>"},{"location":"thermo/mixingrule/#classic-mixing-rules","title":"Classic Mixing Rules","text":""},{"location":"thermo/mixingrule/#van-der-waals-one-fluid-rules","title":"Van der Waals One-Fluid Rules","text":"\\[a_m = \\sum_i \\sum_j x_i x_j \\sqrt{a_i a_j}(1 - k_{ij})\\] \\[b_m = \\sum_i x_i b_i\\]"},{"location":"thermo/mixingrule/#usage","title":"Usage","text":"<pre><code>// Classic mixing rule\nfluid.setMixingRule(\"classic\");\n// or\nfluid.setMixingRule(2);\n</code></pre>"},{"location":"thermo/mixingrule/#asymmetric-kij","title":"Asymmetric kij","text":"<pre><code>// Set binary interaction parameter\nfluid.getInterphaseProperties().setParameter(\"kij\", \"CO2\", \"methane\", 0.12);\n</code></pre>"},{"location":"thermo/mixingrule/#cpa-mixing-rules","title":"CPA Mixing Rules","text":"<p>For associating systems (water, alcohols, amines).</p>"},{"location":"thermo/mixingrule/#usage_1","title":"Usage","text":"<pre><code>// CPA-specific mixing rule\nSystemSrkCPAstatoil fluid = new SystemSrkCPAstatoil(T, P);\nfluid.setMixingRule(10);\n</code></pre>"},{"location":"thermo/mixingrule/#cross-association","title":"Cross-Association","text":"<p>Cross-association between different associating molecules is handled via combining rules:</p> \\[\\epsilon^{A_iB_j} = \\frac{\\epsilon^{A_i} + \\epsilon^{B_j}}{2}\\] \\[\\beta^{A_iB_j} = \\sqrt{\\beta^{A_i}\\beta^{B_j}}\\]"},{"location":"thermo/mixingrule/#activity-coefficient-mixing-rules","title":"Activity Coefficient Mixing Rules","text":""},{"location":"thermo/mixingrule/#huron-vidal","title":"Huron-Vidal","text":"<pre><code>// SRK with Huron-Vidal mixing\nSystemSrkHuronVidal fluid = new SystemSrkHuronVidal(T, P);\nfluid.setMixingRule(\"HV\");\n</code></pre>"},{"location":"thermo/mixingrule/#wong-sandler","title":"Wong-Sandler","text":"<pre><code>// Wong-Sandler mixing rule\nfluid.setMixingRule(\"WS\");\n</code></pre>"},{"location":"thermo/mixingrule/#schwarzentruber-renon","title":"Schwarzentruber-Renon","text":"<p>Combines EoS with UNIFAC.</p> <pre><code>SystemSrkSchwartzentruberRenon fluid = new SystemSrkSchwartzentruberRenon(T, P);\n</code></pre>"},{"location":"thermo/mixingrule/#binary-interaction-parameters","title":"Binary Interaction Parameters","text":""},{"location":"thermo/mixingrule/#accessing-kij","title":"Accessing kij","text":"<pre><code>double kij = fluid.getInterphaseProperties().getParameter(\"kij\", \"CO2\", \"methane\");\n</code></pre>"},{"location":"thermo/mixingrule/#setting-kij","title":"Setting kij","text":"<pre><code>fluid.getInterphaseProperties().setParameter(\"kij\", \"CO2\", \"methane\", 0.12);\n</code></pre>"},{"location":"thermo/mixingrule/#temperature-dependent-kij","title":"Temperature-Dependent kij","text":"\\[k_{ij}(T) = k_{ij}^0 + k_{ij}^1 \\cdot T + k_{ij}^2 \\cdot T^2\\]"},{"location":"thermo/mixingrule/#mixing-rule-numbers","title":"Mixing Rule Numbers","text":"Number Mixing Rule 1 No mixing 2 Classic (Van der Waals) 4 Huron-Vidal 7 Wong-Sandler 9 Schwarzentruber-Renon 10 CPA"},{"location":"thermo/mixingrule/#related-documentation","title":"Related Documentation","text":"<ul> <li>INTER Table Guide - Binary parameters database</li> <li>Mixing Rules Guide - Detailed guide</li> <li>Thermo Package - Package overview</li> </ul>"},{"location":"thermo/phase/","title":"Phase Package","text":"<p>Documentation for phase modeling in NeqSim.</p>"},{"location":"thermo/phase/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Phase Types</li> <li>Phase Interface</li> <li>Gas Phase</li> <li>Liquid Phase</li> <li>Aqueous Phase</li> <li>Solid Phases</li> </ul>"},{"location":"thermo/phase/#overview","title":"Overview","text":"<p>Location: <code>neqsim.thermo.phase</code></p> <p>The phase package contains 62+ classes for modeling different phase types. Each phase type inherits from a base class that implements the PhaseInterface.</p>"},{"location":"thermo/phase/#phase-types","title":"Phase Types","text":""},{"location":"thermo/phase/#available-phase-classes","title":"Available Phase Classes","text":"Category Classes Gas <code>PhaseGas</code>, <code>PhaseGasEos</code>, <code>PhaseGasCPA</code>, <code>PhaseGasPCSAFT</code> Liquid <code>PhaseLiquid</code>, <code>PhaseLiquidEos</code>, <code>PhaseLiquidCPA</code>, <code>PhaseLiquidPCSAFT</code> Aqueous <code>PhaseAqueous</code>, <code>PhaseAqueousEos</code> Solid <code>PhaseSolid</code>, <code>PhaseSolidComplex</code>, <code>PhaseHydrate</code>, <code>PhaseWax</code>"},{"location":"thermo/phase/#phase-hierarchy","title":"Phase Hierarchy","text":"<pre><code>PhaseInterface\n\u2514\u2500\u2500 Phase (abstract base)\n    \u251c\u2500\u2500 PhaseEos (EoS phases)\n    \u2502   \u251c\u2500\u2500 PhaseGasEos\n    \u2502   \u251c\u2500\u2500 PhaseLiquidEos\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 PhaseCPA (CPA phases)\n    \u2502   \u251c\u2500\u2500 PhaseGasCPA\n    \u2502   \u251c\u2500\u2500 PhaseLiquidCPA\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 PhaseSolid\n        \u251c\u2500\u2500 PhaseHydrate\n        \u2514\u2500\u2500 PhaseWax\n</code></pre>"},{"location":"thermo/phase/#phase-interface","title":"Phase Interface","text":""},{"location":"thermo/phase/#common-methods","title":"Common Methods","text":"<pre><code>PhaseInterface phase = fluid.getPhase(0);\n\n// Phase fraction\ndouble beta = phase.getBeta();  // Mole fraction of total\ndouble betaV = phase.getBetaV(); // Volume fraction\n\n// Thermodynamic properties\ndouble T = phase.getTemperature();\ndouble P = phase.getPressure();\ndouble V = phase.getMolarVolume();\ndouble rho = phase.getDensity(\"kg/m3\");\ndouble Z = phase.getZ();\n\n// Energetic properties\ndouble H = phase.getEnthalpy(\"kJ/kg\");\ndouble S = phase.getEntropy(\"kJ/kgK\");\ndouble G = phase.getGibbsEnergy();\ndouble U = phase.getInternalEnergy();\ndouble A = phase.getHelmholtzEnergy();\n\n// Heat capacities\ndouble Cp = phase.getCp(\"J/molK\");\ndouble Cv = phase.getCv(\"J/molK\");\n\n// Transport properties\ndouble visc = phase.getViscosity(\"cP\");\ndouble k = phase.getThermalConductivity(\"W/mK\");\ndouble D = phase.getDiffusionCoefficient(\"m2/s\");\n\n// Speed of sound\ndouble u = phase.getSoundSpeed(\"m/s\");\n</code></pre>"},{"location":"thermo/phase/#component-access","title":"Component Access","text":"<pre><code>// Get component in phase\nComponentInterface comp = phase.getComponent(\"methane\");\n\n// Mole fraction in phase\ndouble x = comp.getx();\n\n// Fugacity\ndouble f = comp.getFugacity();\ndouble phi = comp.getFugacityCoefficient();\n</code></pre>"},{"location":"thermo/phase/#gas-phase","title":"Gas Phase","text":""},{"location":"thermo/phase/#properties","title":"Properties","text":"<pre><code>PhaseInterface gas = fluid.getGasPhase();\n\n// Compressibility\ndouble Z = gas.getZ();\n\n// Density\ndouble rhoGas = gas.getDensity(\"kg/m3\");\n\n// Viscosity\ndouble muGas = gas.getViscosity(\"cP\");\n\n// Specific volume\ndouble Vm = gas.getMolarVolume();\n</code></pre>"},{"location":"thermo/phase/#gas-phase-types","title":"Gas Phase Types","text":"<pre><code>// Standard EoS gas phase\nPhaseGasEos gasEos = (PhaseGasEos) fluid.getGasPhase();\n\n// CPA gas phase (for associating components)\nPhaseGasCPA gasCPA = (PhaseGasCPA) fluid.getGasPhase();\n\n// PC-SAFT gas phase\nPhaseGasPCSAFT gasSAFT = (PhaseGasPCSAFT) fluid.getGasPhase();\n</code></pre>"},{"location":"thermo/phase/#liquid-phase","title":"Liquid Phase","text":""},{"location":"thermo/phase/#oil-phase","title":"Oil Phase","text":"<pre><code>PhaseInterface oil = fluid.getLiquidPhase();\n\n// Liquid density\ndouble rhoLiq = oil.getDensity(\"kg/m3\");\n\n// API gravity\ndouble API = 141.5 / (oil.getDensity(\"g/cm3\") / 0.999) - 131.5;\n\n// Viscosity\ndouble muOil = oil.getViscosity(\"cP\");\n</code></pre>"},{"location":"thermo/phase/#multiple-liquid-phases","title":"Multiple Liquid Phases","text":"<pre><code>// When system has multiple liquid phases\nif (fluid.getNumberOfLiquidPhases() &gt; 1) {\n    PhaseInterface oil = fluid.getPhase(\"oil\");\n    PhaseInterface aqueous = fluid.getPhase(\"aqueous\");\n}\n</code></pre>"},{"location":"thermo/phase/#aqueous-phase","title":"Aqueous Phase","text":"<p>For water-rich liquid phases.</p> <pre><code>PhaseInterface aqueous = fluid.getPhase(\"aqueous\");\n\n// Water activity\ndouble aW = aqueous.getComponent(\"water\").getActivity();\n\n// pH (if electrolytes present)\ndouble pH = aqueous.getpH();\n\n// Ionic strength\ndouble I = aqueous.getIonicStrength();\n</code></pre>"},{"location":"thermo/phase/#solid-phases","title":"Solid Phases","text":""},{"location":"thermo/phase/#general-solid","title":"General Solid","text":"<pre><code>// Enable solid phase check\nfluid.setSolidPhaseCheck(true);\n\n// Get solid phase if formed\nif (fluid.hasSolidPhase()) {\n    PhaseInterface solid = fluid.getSolidPhase();\n    double solidFraction = solid.getBeta();\n}\n</code></pre>"},{"location":"thermo/phase/#hydrate-phase","title":"Hydrate Phase","text":"<pre><code>// Hydrate formation check\nfluid.setHydrateCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nif (fluid.hasHydrate()) {\n    PhaseInterface hydrate = fluid.getPhase(\"hydrate\");\n    double hydrateTemp = fluid.getHydrateTemperature();\n}\n</code></pre>"},{"location":"thermo/phase/#wax-phase","title":"Wax Phase","text":"<pre><code>// Wax formation check\nfluid.setWaxCheck(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nif (fluid.hasWax()) {\n    PhaseInterface wax = fluid.getPhase(\"wax\");\n    double waxFraction = wax.getBeta();\n}\n</code></pre>"},{"location":"thermo/phase/#phase-identification","title":"Phase Identification","text":""},{"location":"thermo/phase/#phase-type-detection","title":"Phase Type Detection","text":"<pre><code>// Get phase type\nString type = phase.getPhaseTypeName();  // \"gas\", \"oil\", \"aqueous\", etc.\n\n// Check phase type\nboolean isGas = phase.getType() == PhaseType.GAS;\nboolean isLiquid = phase.getType() == PhaseType.LIQUID;\nboolean isAqueous = phase.getType() == PhaseType.AQUEOUS;\n</code></pre>"},{"location":"thermo/phase/#stability-analysis","title":"Stability Analysis","text":"<pre><code>// Phase stability check\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.checkStability();\n\nboolean stable = fluid.isPhaseStable();\n</code></pre>"},{"location":"thermo/phase/#phase-properties-calculation","title":"Phase Properties Calculation","text":""},{"location":"thermo/phase/#eos-properties","title":"EoS Properties","text":"<pre><code>// Fugacity coefficients\nfor (int i = 0; i &lt; phase.getNumberOfComponents(); i++) {\n    double phi = phase.getComponent(i).getFugacityCoefficient();\n    double lnPhi = phase.getComponent(i).getLogFugacityCoefficient();\n}\n\n// Compressibility factor derivatives\ndouble dZdT = phase.getdZdT();\ndouble dZdP = phase.getdZdP();\n\n// Fugacity coefficient derivatives\ndouble dPhidT = phase.getComponent(0).getdfugdT();\ndouble dPhidP = phase.getComponent(0).getdfugdP();\n</code></pre>"},{"location":"thermo/phase/#mixing-properties","title":"Mixing Properties","text":"<pre><code>// Excess properties\ndouble GE = phase.getExcessGibbsEnergy();\ndouble HE = phase.getExcessEnthalpy();\ndouble SE = phase.getExcessEntropy();\ndouble VE = phase.getExcessVolume();\n\n// Activity coefficients (for liquid)\ndouble gamma = phase.getComponent(\"ethanol\").getActivityCoefficient();\n</code></pre>"},{"location":"thermo/phase/#example-phase-analysis","title":"Example: Phase Analysis","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\nSystemSrkEos fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.80);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.addComponent(\"n-pentane\", 0.05);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\n\nfor (int p = 0; p &lt; fluid.getNumberOfPhases(); p++) {\n    PhaseInterface phase = fluid.getPhase(p);\n\n    System.out.println(\"\\nPhase \" + (p + 1) + \": \" + phase.getPhaseTypeName());\n    System.out.println(\"  Mole fraction: \" + phase.getBeta());\n    System.out.println(\"  Density: \" + phase.getDensity(\"kg/m3\") + \" kg/m\u00b3\");\n    System.out.println(\"  Z-factor: \" + phase.getZ());\n    System.out.println(\"  Viscosity: \" + phase.getViscosity(\"cP\") + \" cP\");\n\n    System.out.println(\"  Composition:\");\n    for (int i = 0; i &lt; phase.getNumberOfComponents(); i++) {\n        String name = phase.getComponent(i).getName();\n        double x = phase.getComponent(i).getx();\n        System.out.printf(\"    %s: %.4f%n\", name, x);\n    }\n}\n</code></pre>"},{"location":"thermo/phase/#related-documentation","title":"Related Documentation","text":"<ul> <li>System Package - Fluid systems</li> <li>Component Package - Component properties</li> <li>Thermo Package - Package overview</li> </ul>"},{"location":"thermo/system/","title":"Thermo System Package","text":"<p>Documentation for fluid system implementations in NeqSim.</p>"},{"location":"thermo/system/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>System Hierarchy</li> <li>Cubic Equations of State</li> <li>Association Equations</li> <li>SAFT-Based EoS</li> <li>Activity Models</li> <li>Reference EoS</li> </ul>"},{"location":"thermo/system/#overview","title":"Overview","text":"<p>Location: <code>neqsim.thermo.system</code></p> <p>The system package contains 58+ implementations of thermodynamic models, from simple ideal gas to complex associating equations of state.</p>"},{"location":"thermo/system/#system-hierarchy","title":"System Hierarchy","text":"<pre><code>SystemInterface\n\u2514\u2500\u2500 SystemThermo (abstract base)\n    \u251c\u2500\u2500 SystemEos (cubic EoS base)\n    \u2502   \u251c\u2500\u2500 SystemSrkEos\n    \u2502   \u251c\u2500\u2500 SystemPrEos\n    \u2502   \u2514\u2500\u2500 ...\n    \u251c\u2500\u2500 SystemSrkCPA (CPA base)\n    \u2502   \u251c\u2500\u2500 SystemSrkCPAstatoil\n    \u2502   \u2514\u2500\u2500 ...\n    \u2514\u2500\u2500 SystemPCSAFT (SAFT base)\n        \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"thermo/system/#cubic-equations-of-state","title":"Cubic Equations of State","text":""},{"location":"thermo/system/#soave-redlich-kwong-srk","title":"Soave-Redlich-Kwong (SRK)","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\n\nSystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.setMixingRule(\"classic\");\n</code></pre> \\[P = \\frac{RT}{V-b} - \\frac{a\\alpha(T)}{V(V+b)}\\]"},{"location":"thermo/system/#peng-robinson-pr","title":"Peng-Robinson (PR)","text":"<pre><code>import neqsim.thermo.system.SystemPrEos;\n\nSystemPrEos fluid = new SystemPrEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.setMixingRule(\"classic\");\n</code></pre> \\[P = \\frac{RT}{V-b} - \\frac{a\\alpha(T)}{V(V+b)+b(V-b)}\\]"},{"location":"thermo/system/#available-cubic-eos-classes","title":"Available Cubic EoS Classes","text":"Class Description <code>SystemSrkEos</code> Standard SRK <code>SystemPrEos</code> Standard PR <code>SystemSrkMathiasCopeman</code> SRK with Mathias-Copeman alpha <code>SystemPrMathiasCopeman</code> PR with Mathias-Copeman alpha <code>SystemSrkSchwartzentruberRenon</code> SRK with GE mixing <code>SystemPrSchwartzentruberRenon</code> PR with GE mixing <code>SystemSrkTwuCoon</code> SRK with Twu-Coon alpha <code>SystemPrTwuCoon</code> PR with Twu-Coon alpha <code>SystemPrDanesh</code> PR with Danesh modifications"},{"location":"thermo/system/#alpha-function-options","title":"Alpha Function Options","text":"<pre><code>// Standard Soave alpha\nSystemSrkEos std = new SystemSrkEos(T, P);\n\n// Mathias-Copeman alpha (better for polar)\nSystemSrkMathiasCopeman mc = new SystemSrkMathiasCopeman(T, P);\n\n// Twu-Coon alpha\nSystemSrkTwuCoon tc = new SystemSrkTwuCoon(T, P);\n</code></pre>"},{"location":"thermo/system/#association-equations","title":"Association Equations","text":""},{"location":"thermo/system/#cpa-cubic-plus-association","title":"CPA (Cubic-Plus-Association)","text":"<p>For systems with hydrogen bonding (water, alcohols, glycols, amines).</p> <pre><code>import neqsim.thermo.system.SystemSrkCPAstatoil;\n\nSystemSrkCPAstatoil fluid = new SystemSrkCPAstatoil(298.15, 10.0);\nfluid.addComponent(\"water\", 1.0);\nfluid.addComponent(\"methane\", 2.0);\nfluid.setMixingRule(10);  // CPA mixing rule\n</code></pre>"},{"location":"thermo/system/#available-cpa-classes","title":"Available CPA Classes","text":"Class Description <code>SystemSrkCPAstatoil</code> SRK-CPA (Equinor parameters) <code>SystemPrCPA</code> PR-CPA <code>SystemSrkCPA</code> SRK-CPA (generic) <code>SystemElectrolyteCPA</code> CPA with electrolytes"},{"location":"thermo/system/#cpa-mixing-rules","title":"CPA Mixing Rules","text":"<pre><code>// Standard CPA mixing rule\nfluid.setMixingRule(10);\n\n// With cross-association\nfluid.setMixingRule(10);\n</code></pre>"},{"location":"thermo/system/#saft-based-eos","title":"SAFT-Based EoS","text":""},{"location":"thermo/system/#pc-saft","title":"PC-SAFT","text":"<p>Statistical Associating Fluid Theory with perturbed chain.</p> <pre><code>import neqsim.thermo.system.SystemPCSAFT;\n\nSystemPCSAFT fluid = new SystemPCSAFT(298.15, 10.0);\nfluid.addComponent(\"methane\", 1.0);\nfluid.addComponent(\"n-hexane\", 0.5);\nfluid.setMixingRule(\"classic\");\n</code></pre>"},{"location":"thermo/system/#epcsaft-electrolyte-pc-saft","title":"ePCSAFT (Electrolyte PC-SAFT)","text":"<pre><code>import neqsim.thermo.system.SystemElectrolytePCSAFT;\n\nSystemElectrolytePCSAFT brine = new SystemElectrolytePCSAFT(298.15, 1.0);\nbrine.addComponent(\"water\", 1.0);\nbrine.addComponent(\"Na+\", 0.1);\nbrine.addComponent(\"Cl-\", 0.1);\n</code></pre>"},{"location":"thermo/system/#activity-models","title":"Activity Models","text":""},{"location":"thermo/system/#nrtl","title":"NRTL","text":"<pre><code>import neqsim.thermo.system.SystemNRTL;\n\nSystemNRTL liquid = new SystemNRTL(298.15, 1.0);\nliquid.addComponent(\"ethanol\", 0.5);\nliquid.addComponent(\"water\", 0.5);\n</code></pre>"},{"location":"thermo/system/#unifac","title":"UNIFAC","text":"<pre><code>import neqsim.thermo.system.SystemUNIFAC;\n\nSystemUNIFAC liquid = new SystemUNIFAC(298.15, 1.0);\nliquid.addComponent(\"acetone\", 0.5);\nliquid.addComponent(\"water\", 0.5);\n</code></pre>"},{"location":"thermo/system/#eosge-combinations","title":"EoS/GE Combinations","text":"<pre><code>// SRK with UNIFAC for liquid\nSystemSrkSchwartzentruberRenon fluid = new SystemSrkSchwartzentruberRenon(T, P);\n</code></pre>"},{"location":"thermo/system/#reference-eos","title":"Reference EoS","text":""},{"location":"thermo/system/#gerg-2008","title":"GERG-2008","text":"<p>High-accuracy reference equation for natural gas.</p> <pre><code>import neqsim.thermo.system.SystemGERG2008;\n\nSystemGERG2008 gas = new SystemGERG2008(288.15, 50.0);\ngas.addComponent(\"nitrogen\", 0.02);\ngas.addComponent(\"CO2\", 0.01);\ngas.addComponent(\"methane\", 0.85);\ngas.addComponent(\"ethane\", 0.08);\ngas.addComponent(\"propane\", 0.04);\n</code></pre> <p>Accuracy:  - Density: \u00b10.1% (normal conditions) - Speed of sound: \u00b10.1%</p>"},{"location":"thermo/system/#umr-pru","title":"UMR-PRU","text":"<p>Universal Mixing Rule with PR EoS.</p> <pre><code>import neqsim.thermo.system.SystemUMRPRU;\n\nSystemUMRPRU lng = new SystemUMRPRU(110.0, 1.0);\nlng.addComponent(\"methane\", 0.92);\nlng.addComponent(\"ethane\", 0.05);\nlng.addComponent(\"propane\", 0.03);\n</code></pre>"},{"location":"thermo/system/#creating-custom-systems","title":"Creating Custom Systems","text":""},{"location":"thermo/system/#temperature-and-pressure","title":"Temperature and Pressure","text":"<pre><code>// Create at specific T, P\nSystemSrkEos fluid = new SystemSrkEos(300.0, 10.0);  // K, bar\n\n// Change conditions later\nfluid.setTemperature(350.0);\nfluid.setPressure(50.0);\n\n// With units\nfluid.setTemperature(25.0, \"C\");\nfluid.setPressure(50.0, \"bara\");\n</code></pre>"},{"location":"thermo/system/#components","title":"Components","text":"<pre><code>// By name and moles\nfluid.addComponent(\"methane\", 100.0);\n\n// By index\nfluid.addComponent(0, 100.0);\n\n// TBP fraction (for plus fractions)\nfluid.addTBPfraction(\"C7+\", 10.0, 150.0, 0.78);  // name, moles, MW, SG\n\n// Set mole fractions directly\ndouble[] z = {0.85, 0.10, 0.05};\nfluid.setMolarComposition(z);\n</code></pre>"},{"location":"thermo/system/#phase-specifications","title":"Phase Specifications","text":"<pre><code>// Force number of phases\nfluid.setNumberOfPhases(2);\n\n// Specify phase types\nfluid.setPhaseType(0, \"gas\");\nfluid.setPhaseType(1, \"oil\");\n\n// Allow solid phases\nfluid.setSolidPhaseCheck(true);\n</code></pre>"},{"location":"thermo/system/#system-methods","title":"System Methods","text":""},{"location":"thermo/system/#initialization","title":"Initialization","text":"<pre><code>// Initialize thermodynamic properties\nfluid.init(0);  // Molar volumes only\nfluid.init(1);  // Plus fugacity coefficients\nfluid.init(2);  // Plus all derivatives\nfluid.init(3);  // Plus second derivatives\n</code></pre>"},{"location":"thermo/system/#property-access","title":"Property Access","text":"<pre><code>// Bulk properties\ndouble rho = fluid.getDensity(\"kg/m3\");\ndouble MW = fluid.getMolarMass(\"kg/mol\");\ndouble H = fluid.getEnthalpy(\"kJ/kg\");\ndouble S = fluid.getEntropy(\"kJ/kgK\");\ndouble Cp = fluid.getCp(\"J/molK\");\ndouble Cv = fluid.getCv(\"J/molK\");\ndouble Z = fluid.getZ();\ndouble kappa = fluid.getKappa();  // Cp/Cv\n\n// Transport properties\ndouble visc = fluid.getViscosity(\"cP\");\ndouble k = fluid.getThermalConductivity(\"W/mK\");\n\n// Phase properties\ndouble gasZ = fluid.getGasPhase().getZ();\ndouble liqRho = fluid.getLiquidPhase().getDensity(\"kg/m3\");\n</code></pre>"},{"location":"thermo/system/#cloning","title":"Cloning","text":"<pre><code>// Deep copy\nSystemInterface copy = fluid.clone();\n\n// Modify copy without affecting original\ncopy.setTemperature(400.0);\n</code></pre>"},{"location":"thermo/system/#related-documentation","title":"Related Documentation","text":"<ul> <li>Phase Package - Phase modeling</li> <li>Component Package - Component properties</li> <li>Mixing Rules - Binary interactions</li> <li>Thermo Package - Package overview</li> </ul>"},{"location":"thermodynamicoperations/","title":"Thermodynamic Operations Package","text":"<p>The <code>thermodynamicoperations</code> package provides flash calculations, phase envelope construction, and chemical equilibrium solvers.</p>"},{"location":"thermodynamicoperations/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Flash Calculations</li> <li>Phase Envelope Operations</li> <li>Property Generators</li> <li>Usage Examples</li> </ul>"},{"location":"thermodynamicoperations/#overview","title":"Overview","text":"<p>Location: <code>neqsim.thermodynamicoperations</code></p> <p>Purpose: - Perform phase equilibrium calculations (flash operations) - Calculate phase envelopes and critical points - Generate property tables - Handle chemical equilibrium</p> <p>Main Entry Point: <code>ThermodynamicOperations</code></p> <pre><code>import neqsim.thermodynamicoperations.ThermodynamicOperations;\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();  // Temperature-Pressure flash\n</code></pre>"},{"location":"thermodynamicoperations/#package-structure","title":"Package Structure","text":"<pre><code>thermodynamicoperations/\n\u251c\u2500\u2500 ThermodynamicOperations.java     # Main facade class\n\u251c\u2500\u2500 BaseOperation.java               # Base class for operations\n\u251c\u2500\u2500 OperationInterface.java          # Operation interface\n\u2502\n\u251c\u2500\u2500 flashops/                        # Flash calculations\n\u2502   \u251c\u2500\u2500 TPflash.java                 # Temperature-Pressure flash\n\u2502   \u251c\u2500\u2500 PHflash.java                 # Pressure-Enthalpy flash\n\u2502   \u251c\u2500\u2500 PSFlash.java                 # Pressure-Entropy flash\n\u2502   \u251c\u2500\u2500 TVflash.java                 # Temperature-Volume flash\n\u2502   \u251c\u2500\u2500 VUflash.java                 # Volume-Internal Energy flash\n\u2502   \u251c\u2500\u2500 VHflash.java                 # Volume-Enthalpy flash\n\u2502   \u251c\u2500\u2500 VSflash.java                 # Volume-Entropy flash\n\u2502   \u251c\u2500\u2500 TSFlash.java                 # Temperature-Entropy flash\n\u2502   \u251c\u2500\u2500 PUflash.java                 # Pressure-Internal Energy flash\n\u2502   \u251c\u2500\u2500 TVfractionFlash.java         # Temperature-Vapor fraction flash\n\u2502   \u251c\u2500\u2500 dTPflash.java                # Dual temperature flash\n\u2502   \u251c\u2500\u2500 TPmultiflash.java            # Multiphase TP flash\n\u2502   \u251c\u2500\u2500 SolidFlash.java              # Flash with solids\n\u2502   \u251c\u2500\u2500 CriticalPointFlash.java      # Critical point calculation\n\u2502   \u251c\u2500\u2500 RachfordRice.java            # Rachford-Rice solver\n\u2502   \u2514\u2500\u2500 saturationops/               # Saturation calculations\n\u2502       \u251c\u2500\u2500 BubblePointPressureFlash.java\n\u2502       \u251c\u2500\u2500 BubblePointTemperatureFlash.java\n\u2502       \u251c\u2500\u2500 DewPointPressureFlash.java\n\u2502       \u251c\u2500\u2500 DewPointTemperatureFlash.java\n\u2502       \u251c\u2500\u2500 WaterDewPointFlash.java\n\u2502       \u2514\u2500\u2500 HydrateEquilibrium.java\n\u2502\n\u251c\u2500\u2500 phaseenvelopeops/                # Phase envelope calculations\n\u2502   \u251c\u2500\u2500 multicomponentenvelopeops/\n\u2502   \u2502   \u251c\u2500\u2500 PTPhaseEnvelope.java\n\u2502   \u2502   \u2514\u2500\u2500 PHPhaseEnvelope.java\n\u2502   \u2514\u2500\u2500 reactivecurves/\n\u2502       \u2514\u2500\u2500 ReactivePhaseEnvelope.java\n\u2502\n\u251c\u2500\u2500 chemicalequilibrium/             # Chemical equilibrium\n\u2502   \u2514\u2500\u2500 ChemicalEquilibrium.java\n\u2502\n\u2514\u2500\u2500 propertygenerator/               # Property tables\n    \u2514\u2500\u2500 OLGApropertyTableGenerator.java\n</code></pre>"},{"location":"thermodynamicoperations/#flash-calculations","title":"Flash Calculations","text":""},{"location":"thermodynamicoperations/#flash-types","title":"Flash Types","text":"Flash Type Method Known Variables Solved Variables TP <code>TPflash()</code> T, P Phase amounts, compositions PH <code>PHflash(H)</code> P, H T, phase amounts, compositions PS <code>PSflash(S)</code> P, S T, phase amounts, compositions TV <code>TVflash(V)</code> T, V P, phase amounts, compositions VU <code>VUflash(V, U)</code> V, U T, P, phase amounts VH <code>VHflash(V, H)</code> V, H T, P, phase amounts VS <code>VSflash(V, S)</code> V, S T, P, phase amounts TS <code>TSflash(S)</code> T, S P, phase amounts, compositions PU <code>PUflash(U)</code> P, U T, phase amounts, compositions"},{"location":"thermodynamicoperations/#tp-flash","title":"TP Flash","text":"<p>The most common flash calculation - given temperature and pressure, find equilibrium phases.</p> <pre><code>SystemInterface fluid = new SystemSrkEos(298.15, 50.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"ethane\", 0.1);\nfluid.setMixingRule(\"classic\");\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\nSystem.out.println(\"Vapor fraction: \" + fluid.getBeta());\n</code></pre>"},{"location":"thermodynamicoperations/#ph-flash-adiabatic","title":"PH Flash (Adiabatic)","text":"<p>Find temperature given pressure and enthalpy - essential for adiabatic processes.</p> <pre><code>// Initial state\ndouble H = fluid.getEnthalpy();\n\n// Change pressure\nfluid.setPressure(20.0);\n\n// Find new temperature at same enthalpy\nops.PHflash(H);\n\nSystem.out.println(\"New temperature: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre>"},{"location":"thermodynamicoperations/#ps-flash-isentropic","title":"PS Flash (Isentropic)","text":"<p>Find temperature given pressure and entropy - for isentropic compression/expansion.</p> <pre><code>double S = fluid.getEntropy();\nfluid.setPressure(100.0);\nops.PSflash(S);\n\nSystem.out.println(\"Isentropic temperature: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\n</code></pre>"},{"location":"thermodynamicoperations/#vu-flash-dynamic","title":"VU Flash (Dynamic)","text":"<p>For dynamic simulations - given volume and internal energy, find T and P.</p> <pre><code>double V = fluid.getVolume();\ndouble U = fluid.getInternalEnergy();\n\n// Simulate heat addition\ndouble Unew = U + 10000.0;  // Add 10 kJ\n\nops.VUflash(V, Unew);\nSystem.out.println(\"New T: \" + fluid.getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"New P: \" + fluid.getPressure() + \" bar\");\n</code></pre>"},{"location":"thermodynamicoperations/#tv-fraction-flash","title":"TV Fraction Flash","text":"<p>Find pressure at given vapor/liquid fraction.</p> <pre><code>// Find pressure where vapor fraction = 0.5\nops.TVfractionFlash(0.5);\nSystem.out.println(\"Pressure at 50% vapor: \" + fluid.getPressure() + \" bar\");\n</code></pre>"},{"location":"thermodynamicoperations/#saturation-operations","title":"Saturation Operations","text":""},{"location":"thermodynamicoperations/#bubble-point","title":"Bubble Point","text":"<pre><code>// Bubble point pressure at current temperature\nops.bubblePointPressureFlash(false);\ndouble Pbub = fluid.getPressure();\n\n// Bubble point temperature at current pressure  \nops.bubblePointTemperatureFlash();\ndouble Tbub = fluid.getTemperature();\n</code></pre>"},{"location":"thermodynamicoperations/#dew-point","title":"Dew Point","text":"<pre><code>// Dew point pressure at current temperature\nops.dewPointPressureFlash();\ndouble Pdew = fluid.getPressure();\n\n// Dew point temperature at current pressure\nops.dewPointTemperatureFlash();\ndouble Tdew = fluid.getTemperature();\n</code></pre>"},{"location":"thermodynamicoperations/#water-dew-point","title":"Water Dew Point","text":"<pre><code>// Water dew point temperature at given pressure\nops.waterDewPointTemperatureFlash();\ndouble TwaterDew = fluid.getTemperature();\n</code></pre>"},{"location":"thermodynamicoperations/#hydrate-equilibrium","title":"Hydrate Equilibrium","text":"<pre><code>// Hydrate equilibrium temperature\nops.hydrateEquilibriumTemperature();\ndouble Thyd = fluid.getTemperature();\n\n// Hydrate equilibrium pressure\nfluid.setTemperature(278.15);\nops.hydrateEquilibriumPressure();\ndouble Phyd = fluid.getPressure();\n</code></pre>"},{"location":"thermodynamicoperations/#phase-envelope-operations","title":"Phase Envelope Operations","text":""},{"location":"thermodynamicoperations/#pt-phase-envelope","title":"PT Phase Envelope","text":"<pre><code>ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.calcPTphaseEnvelope();\n\n// Get results\ndouble[][] envelope = ops.getOperation().get2DData();\n// envelope[0] = temperatures (K)\n// envelope[1] = pressures (bar)\n\n// Get cricondenbar and cricondentherm\ndouble cricondenbar = ops.getOperation().getCricondenbar();\ndouble cricondentherm = ops.getOperation().getCricondentherm();\n</code></pre>"},{"location":"thermodynamicoperations/#ph-phase-envelope","title":"PH Phase Envelope","text":"<pre><code>ops.calcPHenveloppe();\ndouble[][] phEnvelope = ops.getOperation().get2DData();\n</code></pre>"},{"location":"thermodynamicoperations/#property-generators","title":"Property Generators","text":""},{"location":"thermodynamicoperations/#olga-property-tables","title":"OLGA Property Tables","text":"<p>Generate property tables for multiphase flow simulators.</p> <pre><code>import neqsim.thermodynamicoperations.propertygenerator.OLGApropertyTableGenerator;\n\nOLGApropertyTableGenerator generator = new OLGApropertyTableGenerator(fluid);\ngenerator.setFileName(\"fluid_properties\");\n\n// Set ranges\ngenerator.setPressureRange(1.0, 200.0, 50);   // 1-200 bar, 50 points\ngenerator.setTemperatureRange(250.0, 400.0, 30); // 250-400 K, 30 points\ngenerator.setWaterCutRange(0.0, 1.0, 5);      // 0-100% water cut, 5 points\n\ngenerator.run();\n</code></pre>"},{"location":"thermodynamicoperations/#chemical-equilibrium","title":"Chemical Equilibrium","text":"<p>For reactive systems, calculate equilibrium composition considering reactions.</p> <pre><code>// Set up reactive system\nSystemInterface reactive = new SystemSrkEos(700.0, 10.0);\nreactive.addComponent(\"methane\", 1.0);\nreactive.addComponent(\"water\", 2.0);\nreactive.addComponent(\"CO2\", 0.0);\nreactive.addComponent(\"hydrogen\", 0.0);\n\n// Enable chemical reactions\nreactive.setChemicalReactions(true);\n\nThermodynamicOperations ops = new ThermodynamicOperations(reactive);\nops.calcChemicalEquilibrium();\n\n// Get equilibrium composition\nfor (int i = 0; i &lt; reactive.getNumberOfComponents(); i++) {\n    System.out.println(reactive.getComponent(i).getName() + \n        \": \" + reactive.getComponent(i).getx() + \" mol/mol\");\n}\n</code></pre>"},{"location":"thermodynamicoperations/#multi-phase-flash","title":"Multi-Phase Flash","text":"<p>Handle systems with multiple liquid phases, solids, or hydrates.</p> <pre><code>SystemInterface fluid = new SystemSrkCPAstatoil(273.15 + 5, 100.0);\nfluid.addComponent(\"methane\", 0.90);\nfluid.addComponent(\"water\", 0.10);\nfluid.setMixingRule(\"CPA_Statoil\");\nfluid.setMultiPhaseCheck(true);  // Enable multi-phase check\n\nThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nSystem.out.println(\"Number of phases: \" + fluid.getNumberOfPhases());\nfor (int i = 0; i &lt; fluid.getNumberOfPhases(); i++) {\n    System.out.println(\"Phase \" + i + \": \" + fluid.getPhase(i).getPhaseTypeName());\n}\n</code></pre>"},{"location":"thermodynamicoperations/#solid-flash-wax-ice","title":"Solid Flash (Wax, Ice)","text":"<pre><code>fluid.setSolidPhaseCheck(\"wax\");\nops.TPsolidflash();\n</code></pre>"},{"location":"thermodynamicoperations/#advanced-options","title":"Advanced Options","text":""},{"location":"thermodynamicoperations/#calculation-identifiers","title":"Calculation Identifiers","text":"<p>Track calculations with UUIDs for parallel processing.</p> <pre><code>UUID calcId = UUID.randomUUID();\nops.TPflash(calcId);\n</code></pre>"},{"location":"thermodynamicoperations/#flash-settings","title":"Flash Settings","text":"<pre><code>// Set maximum iterations\nops.setMaxIterations(100);\n\n// Set convergence tolerance\nops.setTolerance(1e-10);\n</code></pre>"},{"location":"thermodynamicoperations/#best-practices","title":"Best Practices","text":"<ol> <li>Always set mixing rule before flash calculations</li> <li>Initialize fluid with <code>createDatabase(true)</code> for new components</li> <li>Use multi-phase check when expecting multiple liquid phases</li> <li>Check convergence after flash - verify <code>getNumberOfPhases()</code> makes sense</li> <li>Handle exceptions for failed convergence</li> </ol>"},{"location":"thermodynamicoperations/#related-documentation","title":"Related Documentation","text":"<ul> <li>Flash Calculations Guide - Detailed flash examples</li> <li>Fluid Creation Guide - Setting up fluids</li> <li>Mathematical Models - EoS formulations</li> </ul>"},{"location":"util/","title":"Utilities Package","text":"<p>The <code>util</code> package provides common utilities for database access, unit conversion, serialization, exceptions, and threading.</p>"},{"location":"util/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Package Structure</li> <li>Database Access</li> <li>Unit Conversion</li> <li>Serialization</li> <li>Exceptions</li> <li>Threading</li> </ul>"},{"location":"util/#overview","title":"Overview","text":"<p>Location: <code>neqsim.util</code></p> <p>Purpose: - Database connectivity and queries - Unit conversion utilities - Object serialization and deserialization - Custom exception handling - Thread pool management - Python integration</p>"},{"location":"util/#package-structure","title":"Package Structure","text":"<pre><code>util/\n\u251c\u2500\u2500 NamedBaseClass.java           # Base class with name property\n\u251c\u2500\u2500 NamedInterface.java           # Named interface\n\u251c\u2500\u2500 NeqSimLogging.java            # Logging utilities\n\u251c\u2500\u2500 NeqSimThreadPool.java         # Thread pool management\n\u251c\u2500\u2500 ExcludeFromJacocoGeneratedReport.java\n\u2502\n\u251c\u2500\u2500 database/                     # Database access\n\u2502   \u251c\u2500\u2500 NeqSimDataBase.java       # Main database class\n\u2502   \u251c\u2500\u2500 NeqSimContractDataBase.java\n\u2502   \u251c\u2500\u2500 NeqSimExperimentDatabase.java\n\u2502   \u2514\u2500\u2500 NeqSimFluidDataBase.java\n\u2502\n\u251c\u2500\u2500 exception/                    # Custom exceptions\n\u2502   \u251c\u2500\u2500 InvalidInputException.java\n\u2502   \u251c\u2500\u2500 ThermoException.java\n\u2502   \u2514\u2500\u2500 NotImplementedException.java\n\u2502\n\u251c\u2500\u2500 generator/                    # Code generation\n\u2502   \u2514\u2500\u2500 PropertyGenerator.java\n\u2502\n\u251c\u2500\u2500 manifest/                     # Manifest handling\n\u2502   \u2514\u2500\u2500 ManifestHandler.java\n\u2502\n\u251c\u2500\u2500 python/                       # Python integration\n\u2502   \u2514\u2500\u2500 PythonIntegration.java\n\u2502\n\u251c\u2500\u2500 serialization/                # Serialization utilities\n\u2502   \u2514\u2500\u2500 SerializationManager.java\n\u2502\n\u251c\u2500\u2500 unit/                         # Unit conversion\n\u2502   \u251c\u2500\u2500 Units.java\n\u2502   \u2514\u2500\u2500 UnitConverter.java\n\u2502\n\u2514\u2500\u2500 util/                         # General utilities\n    \u2514\u2500\u2500 Utilities.java\n</code></pre>"},{"location":"util/#database-access","title":"Database Access","text":""},{"location":"util/#neqsimdatabase","title":"NeqSimDataBase","text":"<p>Main class for database connectivity.</p> <pre><code>import neqsim.util.database.NeqSimDataBase;\n\n// Get database connection\ntry (NeqSimDataBase db = new NeqSimDataBase()) {\n    // Execute query\n    ResultSet rs = db.getResultSet(\n        \"SELECT * FROM comp WHERE compname = 'methane'\"\n    );\n\n    while (rs.next()) {\n        double Tc = rs.getDouble(\"TC\");\n        double Pc = rs.getDouble(\"PC\");\n        double omega = rs.getDouble(\"ACF\");\n    }\n}\n</code></pre>"},{"location":"util/#database-configuration","title":"Database Configuration","text":"<pre><code>// Set database path (for embedded Derby)\nNeqSimDataBase.setDataBaseType(\"Derby\");\nNeqSimDataBase.setConnectionString(\"jdbc:derby:NeqSimDatabase\");\n\n// Or use PostgreSQL\nNeqSimDataBase.setDataBaseType(\"PostgreSQL\");\nNeqSimDataBase.setConnectionString(\"jdbc:postgresql://localhost:5432/neqsim\");\nNeqSimDataBase.setUsername(\"user\");\nNeqSimDataBase.setPassword(\"password\");\n</code></pre>"},{"location":"util/#predefined-queries","title":"Predefined Queries","text":"<pre><code>// Component data\nNeqSimFluidDataBase.getComponentData(\"methane\");\n\n// Binary interaction parameters\nNeqSimFluidDataBase.getInteractionParameters(\"methane\", \"ethane\", \"SRK\");\n\n// Experiment data\nNeqSimExperimentDatabase.getExperimentData(\"VLE_CH4_CO2\");\n</code></pre>"},{"location":"util/#unit-conversion","title":"Unit Conversion","text":""},{"location":"util/#units-class","title":"Units Class","text":"<pre><code>import neqsim.util.unit.Units;\n\n// Temperature conversions\ndouble tempK = Units.temperatureToKelvin(25.0, \"C\");      // 298.15 K\ndouble tempC = Units.temperatureFromKelvin(298.15, \"C\");  // 25.0 \u00b0C\ndouble tempF = Units.temperatureFromKelvin(298.15, \"F\");  // 77.0 \u00b0F\n\n// Pressure conversions\ndouble pressPa = Units.pressureToPascal(10.0, \"bara\");    // 1e6 Pa\ndouble pressBara = Units.pressureFromPascal(1e6, \"bara\"); // 10.0 bar\n\n// Flow rate conversions\ndouble flowKgH = Units.flowRateToSI(1000.0, \"kg/hr\");     // kg/s\ndouble flowMSm3 = Units.flowRateFromSI(10.0, \"MSm3/day\"); // MSm\u00b3/day\n</code></pre>"},{"location":"util/#supported-units","title":"Supported Units","text":"Property Units Temperature K, C, F, R Pressure Pa, bara, barg, psia, psig, atm, mmHg, kPa, MPa Flow rate kg/s, kg/hr, lb/hr, Sm3/hr, MSm3/day, mol/s, kmol/hr Volume m3, L, ft3, bbl, gal Density kg/m3, g/cm3, lb/ft3 Viscosity Pa.s, cP, mPa.s Energy J, kJ, MJ, cal, BTU Power W, kW, MW, hp"},{"location":"util/#in-fluid-properties","title":"In Fluid Properties","text":"<pre><code>// Temperature\ndouble T_C = fluid.getTemperature(\"C\");\ndouble T_K = fluid.getTemperature(\"K\");\nfluid.setTemperature(25.0, \"C\");\n\n// Pressure\ndouble P_bara = fluid.getPressure(\"bara\");\ndouble P_psia = fluid.getPressure(\"psia\");\nfluid.setPressure(50.0, \"bara\");\n\n// Flow rate\ndouble flow_kghr = stream.getFlowRate(\"kg/hr\");\ndouble flow_Sm3 = stream.getFlowRate(\"Sm3/hr\");\nstream.setFlowRate(1000.0, \"kg/hr\");\n\n// Density\ndouble rho = fluid.getDensity(\"kg/m3\");\ndouble rho_lbft3 = fluid.getDensity(\"lb/ft3\");\n\n// Enthalpy\ndouble H_kJ = fluid.getEnthalpy(\"kJ/kg\");\n</code></pre>"},{"location":"util/#serialization","title":"Serialization","text":""},{"location":"util/#serializationmanager","title":"SerializationManager","text":"<p>Save and load NeqSim objects.</p> <pre><code>import neqsim.util.serialization.SerializationManager;\n\n// Save fluid to file\nSystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"ethane\", 0.1);\n\nSerializationManager.save(fluid, \"myfluid.neqsim\");\n\n// Load fluid from file\nSystemInterface loadedFluid = SerializationManager.load(\"myfluid.neqsim\");\n</code></pre>"},{"location":"util/#process-system-serialization","title":"Process System Serialization","text":"<pre><code>// Save process system\nProcessSystem process = new ProcessSystem();\n// ... add equipment ...\n\n// Save to file\nprocess.save(\"myprocess.neqsim\");\n\n// Load from file\nProcessSystem loaded = ProcessSystem.load(\"myprocess.neqsim\");\n</code></pre>"},{"location":"util/#deep-copy-via-serialization","title":"Deep Copy via Serialization","text":"<pre><code>// Clone using serialization (deep copy)\nSystemInterface clone = fluid.clone();\n\n// Or for process equipment\nProcessEquipmentInterface copy = equipment.copy();\n</code></pre>"},{"location":"util/#exceptions","title":"Exceptions","text":""},{"location":"util/#custom-exceptions","title":"Custom Exceptions","text":"<pre><code>import neqsim.util.exception.*;\n\n// Invalid input\nif (temperature &lt; 0) {\n    throw new InvalidInputException(\"Temperature\", \n        \"Temperature must be positive\");\n}\n\n// Thermodynamic calculation failure\ntry {\n    ops.TPflash();\n} catch (ThermoException e) {\n    System.err.println(\"Flash calculation failed: \" + e.getMessage());\n}\n\n// Not implemented feature\nthrow new NotImplementedException(\"This feature\", \n    \"Will be available in next release\");\n</code></pre>"},{"location":"util/#exception-handling-pattern","title":"Exception Handling Pattern","text":"<pre><code>try {\n    ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n    ops.TPflash();\n} catch (InvalidInputException e) {\n    // Handle invalid inputs\n    logger.error(\"Invalid input: \" + e.getMessage());\n} catch (ThermoException e) {\n    // Handle calculation failures\n    logger.error(\"Calculation failed: \" + e.getMessage());\n} catch (Exception e) {\n    // Handle unexpected errors\n    logger.error(\"Unexpected error\", e);\n}\n</code></pre>"},{"location":"util/#threading","title":"Threading","text":""},{"location":"util/#neqsimthreadpool","title":"NeqSimThreadPool","text":"<p>Manage parallel calculations.</p> <pre><code>import neqsim.util.NeqSimThreadPool;\n\n// Configure thread pool\nNeqSimThreadPool.setNumberOfThreads(8);\n\n// Submit tasks\nFuture&lt;Double&gt; result1 = NeqSimThreadPool.submit(() -&gt; {\n    // Parallel calculation\n    return calculateProperty1();\n});\n\nFuture&lt;Double&gt; result2 = NeqSimThreadPool.submit(() -&gt; {\n    return calculateProperty2();\n});\n\n// Get results\ndouble prop1 = result1.get();\ndouble prop2 = result2.get();\n</code></pre>"},{"location":"util/#parallel-flash-calculations","title":"Parallel Flash Calculations","text":"<pre><code>// Run multiple flashes in parallel\nList&lt;SystemInterface&gt; fluids = prepareFluids();\n\nList&lt;Future&lt;SystemInterface&gt;&gt; futures = fluids.stream()\n    .map(f -&gt; NeqSimThreadPool.submit(() -&gt; {\n        ThermodynamicOperations ops = new ThermodynamicOperations(f);\n        ops.TPflash();\n        return f;\n    }))\n    .collect(Collectors.toList());\n\n// Collect results\nfor (Future&lt;SystemInterface&gt; future : futures) {\n    SystemInterface result = future.get();\n    // Process result\n}\n</code></pre>"},{"location":"util/#logging","title":"Logging","text":""},{"location":"util/#neqsimlogging","title":"NeqSimLogging","text":"<p>Configure logging.</p> <pre><code>import neqsim.util.NeqSimLogging;\n\n// Set log level\nNeqSimLogging.setLogLevel(Level.DEBUG);\n\n// Log messages\nNeqSimLogging.info(\"Process started\");\nNeqSimLogging.debug(\"Temperature: \" + T);\nNeqSimLogging.error(\"Calculation failed\", exception);\n</code></pre>"},{"location":"util/#log4j2-configuration","title":"Log4j2 Configuration","text":"<p>NeqSim uses Log4j2. Configure via <code>log4j2.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Configuration status=\"WARN\"&gt;\n  &lt;Appenders&gt;\n    &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt;\n      &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt;\n    &lt;/Console&gt;\n  &lt;/Appenders&gt;\n  &lt;Loggers&gt;\n    &lt;Root level=\"info\"&gt;\n      &lt;AppenderRef ref=\"Console\"/&gt;\n    &lt;/Root&gt;\n    &lt;Logger name=\"neqsim\" level=\"debug\"/&gt;\n  &lt;/Loggers&gt;\n&lt;/Configuration&gt;\n</code></pre>"},{"location":"util/#python-integration","title":"Python Integration","text":""},{"location":"util/#direct-java-access","title":"Direct Java Access","text":"<pre><code>import jpype\nimport jpype.imports\nfrom jpype.types import *\n\n# Start JVM\njpype.startJVM(classpath=['neqsim.jar'])\n\nfrom neqsim.thermo.system import SystemSrkEos\nfrom neqsim.thermodynamicoperations import ThermodynamicOperations\n\n# Create fluid\nfluid = SystemSrkEos(300.0, 50.0)\nfluid.addComponent(\"methane\", 0.9)\nfluid.addComponent(\"ethane\", 0.1)\nfluid.setMixingRule(\"classic\")\n\n# Flash\nops = ThermodynamicOperations(fluid)\nops.TPflash()\n\nprint(f\"Density: {fluid.getDensity('kg/m3'):.2f} kg/m\u00b3\")\n</code></pre>"},{"location":"util/#named-objects","title":"Named Objects","text":""},{"location":"util/#namedbaseclass","title":"NamedBaseClass","text":"<p>Base class for named objects.</p> <pre><code>public class MyEquipment extends NamedBaseClass {\n    public MyEquipment(String name) {\n        super(name);\n    }\n}\n\n// Usage\nMyEquipment eq = new MyEquipment(\"E-100\");\nString name = eq.getName();\neq.setName(\"E-101\");\n</code></pre>"},{"location":"util/#best-practices","title":"Best Practices","text":"<ol> <li>Close database connections - Use try-with-resources</li> <li>Handle units explicitly - Always specify units in API calls</li> <li>Use thread pool for parallel calculations</li> <li>Serialize for persistence - Save/load complex objects</li> <li>Log appropriately - Use debug for details, info for important events</li> </ol>"},{"location":"util/#related-documentation","title":"Related Documentation","text":"<ul> <li>Developer Setup - Environment configuration</li> <li>Component Database Guide - Database tables</li> </ul>"},{"location":"wiki/","title":"NeqSim Wiki","text":"<p>Welcome to the NeqSim documentation. This wiki collects tips and guides for using the library and contributing to development.</p> <ul> <li>Getting started</li> <li>Thermodynamics Guide</li> <li>Fluid Characterization</li> <li>Process Simulation Guide</li> <li>Advanced Process Simulation</li> <li>Logical Unit Operations</li> <li>Usage examples</li> <li>Frequently asked questions</li> </ul> <p>NeqSim (Non-Equilibrium Simulator) is a Java library for estimating fluid properties and process design. The library contains models for phase behavior and physical properties of fluids and can easily be extended with new models. Development was initiated at the Norwegian University of Science and Technology (NTNU).</p> <p>NeqSim is part of the NeqSim project. Releases are provided as jar files from GitHub and can be added as a dependency in your own Java projects. This folder holds additional documentation for the NeqSim project. Below are useful pages:</p> <ul> <li>JUnit test overview</li> <li>Flash calculations validated by tests</li> <li>PVT simulation workflows</li> <li>Transient process simulation patterns</li> <li>Black-oil flash playbook</li> <li>Property flash workflows</li> <li>Gas quality standards from tests</li> <li>Java simulations from Colab notebooks</li> <li>Distillation column algorithm</li> <li>Gibbs reactor</li> <li>Humid air mathematics</li> <li>Flow meter models</li> <li>Air cooler unit operation</li> <li>Heat exchanger mechanical design</li> <li>Water cooler</li> <li>Steam heater</li> <li>Battery storage unit</li> <li>Solar panel unit operation</li> <li>Process control framework</li> </ul>"},{"location":"wiki/advanced_process_simulation/","title":"Advanced Process Simulation","text":"<p>This guide covers advanced features of NeqSim's process simulation capabilities, including recycles, control systems, and dynamic simulation.</p>"},{"location":"wiki/advanced_process_simulation/#1-recycles","title":"1. Recycles","text":"<p>In process simulation, a recycle loop occurs when a downstream stream is fed back to an upstream unit. NeqSim handles this using the <code>Recycle</code> class, which iterates until the properties of the recycled stream converge.</p>"},{"location":"wiki/advanced_process_simulation/#how-it-works","title":"How it Works","text":"<p>The <code>Recycle</code> unit operation compares the properties (flow rate, composition, temperature, pressure) of the stream from the previous iteration with the current iteration. If the difference is within a specified tolerance, the loop is considered converged.</p>"},{"location":"wiki/advanced_process_simulation/#example-usage","title":"Example Usage","text":"<pre><code>import neqsim.process.equipment.util.Recycle;\nimport neqsim.process.equipment.mixer.StaticMixer;\n// ... other imports\n\n// 1. Create Feed and Recycle Streams\nStream feed = new Stream(\"Feed\", fluid);\nStream recycleStream = new Stream(\"Recycle Stream\", fluid.clone()); // Initial guess\n\n// 2. Mix Feed and Recycle\nStaticMixer mixer = new StaticMixer(\"Mixer\");\nmixer.addStream(feed);\nmixer.addStream(recycleStream);\n\n// ... Process units (e.g., Compressor, Cooler, Separator) ...\nSeparator separator = new Separator(\"Separator\", cooler.getOutletStream());\n\n// 3. Define the Recycle Unit\n// The input to the Recycle unit is the stream you want to recycle (e.g., liquid from separator)\nRecycle recycle = new Recycle(\"Recycle Controller\");\nrecycle.addStream(separator.getLiquidOutStream());\n\n// 4. Connect Recycle Output back to Mixer\n// IMPORTANT: The output of the Recycle unit is what you connect to the upstream mixer\nrecycleStream = recycle.getOutletStream(); \nmixer.replaceStream(1, recycleStream); // Or set it up initially if possible\n\n// 5. Add to ProcessSystem\nprocess.add(feed);\nprocess.add(mixer);\n// ... add other units ...\nprocess.add(recycle); // Add recycle last or where appropriate in sequence\n\n// 6. Run\nprocess.run();\n</code></pre>"},{"location":"wiki/advanced_process_simulation/#tuning","title":"Tuning","text":"<p>You can adjust the tolerance and maximum iterations: <pre><code>recycle.setTolerance(1e-6);\nrecycle.setMaximumIterations(50);\n</code></pre></p>"},{"location":"wiki/advanced_process_simulation/#2-controllers-pid","title":"2. Controllers (PID)","text":"<p>NeqSim allows you to add PID controllers to automate the operation of equipment, such as valves or compressors, to maintain a specific setpoint (e.g., pressure, flow, level).</p>"},{"location":"wiki/advanced_process_simulation/#components","title":"Components","text":"<ul> <li>ControllerDevice: The PID controller logic.</li> <li>Transmitter: Measures the process variable (PV).</li> <li>Control Element: The equipment being adjusted (OP), usually a valve.</li> </ul>"},{"location":"wiki/advanced_process_simulation/#example-flow-control","title":"Example: Flow Control","text":"<pre><code>import neqsim.process.controllerdevice.ControllerDeviceBaseClass;\nimport neqsim.process.measurementdevice.VolumeFlowTransmitter;\nimport neqsim.process.equipment.valve.ThrottlingValve;\n\n// 1. Create the Stream and Valve\nStream stream = new Stream(\"Stream\", fluid);\nThrottlingValve valve = new ThrottlingValve(\"Control Valve\", stream);\n\n// 2. Create a Transmitter\n// Measures flow rate of the stream\nVolumeFlowTransmitter flowTransmitter = new VolumeFlowTransmitter(stream);\nflowTransmitter.setUnit(\"kg/hr\");\nflowTransmitter.setMaximumValue(100.0);\nflowTransmitter.setMinimumValue(0.0);\n\n// 3. Create the Controller\nControllerDeviceBaseClass flowController = new ControllerDeviceBaseClass();\nflowController.setTransmitter(flowTransmitter);\nflowController.setReverseActing(true); // Action depends on process physics\nflowController.setControllerSetPoint(50.0); // Target Flow\nflowController.setControllerParameters(0.5, 100.0, 0.0); // Kp, Ti, Td\n\n// 4. Assign Controller to Valve\nvalve.setController(flowController);\n\n// 5. Add to ProcessSystem\nprocess.add(stream);\nprocess.add(valve);\nprocess.add(flowTransmitter); // Transmitter must be added to system\n\n// 6. Run\nprocess.run();\n</code></pre>"},{"location":"wiki/advanced_process_simulation/#3-dynamic-simulation","title":"3. Dynamic Simulation","text":"<p>NeqSim supports dynamic (transient) simulation, allowing you to model how the process changes over time. This is useful for studying startup/shutdown, control system tuning, and buffer tank sizing.</p>"},{"location":"wiki/advanced_process_simulation/#setup-for-dynamics","title":"Setup for Dynamics","text":"<ol> <li>Enable Dynamic Calculation: Some units need explicit flags (e.g., <code>separator.setCalculateSteadyState(false)</code>).</li> <li>Geometry: Units like separators and tanks require physical dimensions (diameter, length) to calculate volume and levels.</li> <li>Time Step: Set the simulation time step.</li> </ol>"},{"location":"wiki/advanced_process_simulation/#example-loop","title":"Example Loop","text":"<pre><code>// ... Setup system with valves, separators, controllers ...\n\n// Configure unit for dynamics\nseparator.setCalculateSteadyState(false); // Enable dynamic level calculation\nseparator.setInternalDiameter(2.0);\nseparator.setSeparatorLength(5.0);\n\n// Run steady state first to get initial condition\nprocess.run();\n\n// Dynamic Loop\ndouble timeStep = 10.0; // seconds\nprocess.setTimeStep(timeStep);\n\nfor (int i = 0; i &lt; 100; i++) {\n    process.runTransient();\n\n    // Log results\n    double time = i * timeStep;\n    double level = separator.getLiquidLevel();\n    double pressure = separator.getGasOutStream().getPressure();\n\n    System.out.println(\"Time: \" + time + \" s, Level: \" + level + \", Pressure: \" + pressure);\n}\n</code></pre>"},{"location":"wiki/advanced_process_simulation/#key-methods","title":"Key Methods","text":"<ul> <li><code>process.setTimeStep(double seconds)</code>: Sets the integration step.</li> <li><code>process.runTransient()</code>: Advances the simulation by one time step.</li> <li><code>unit.setCalculateSteadyState(boolean)</code>: Toggles between steady-state (mass balance) and dynamic (accumulation) modes for specific equipment.</li> </ul>"},{"location":"wiki/advanced_process_simulation/#4-combining-process-systems-processmodel","title":"4. Combining Process Systems (ProcessModel)","text":"<p>For large simulations, it is often better to split the plant into smaller, manageable <code>ProcessSystem</code> objects (e.g., \"Inlet Separation\", \"Gas Compression\", \"Oil Stabilization\") and then combine them into a single <code>ProcessModel</code>.</p>"},{"location":"wiki/advanced_process_simulation/#benefits","title":"Benefits","text":"<ul> <li>Modularity: Develop and test sections independently.</li> <li>Organization: Keeps large flowsheets structured.</li> <li>Execution Control: The <code>ProcessModel</code> manages the execution of sub-systems.</li> </ul>"},{"location":"wiki/advanced_process_simulation/#example","title":"Example","text":"<pre><code>import neqsim.process.processmodel.ProcessModel;\nimport neqsim.process.processmodel.ProcessSystem;\n\n// 1. Create Individual Process Systems\nProcessSystem inletSystem = new ProcessSystem();\ninletSystem.setName(\"Inlet Section\");\n// ... add units to inletSystem ...\n\nProcessSystem compressionSystem = new ProcessSystem();\ncompressionSystem.setName(\"Compression Section\");\n// ... add units to compressionSystem ...\n\n// 2. Connect Systems\n// Typically, a stream from the first system is used as input to the second\nStream gasFromInlet = (Stream) inletSystem.getUnit(\"Inlet Separator\").getGasOutStream();\nCompressor compressor = new Compressor(\"1st Stage Compressor\", gasFromInlet);\ncompressionSystem.add(compressor);\n\n// 3. Create ProcessModel\nProcessModel plantModel = new ProcessModel();\nplantModel.add(\"Inlet\", inletSystem);\nplantModel.add(\"Compression\", compressionSystem);\n\n// 4. Run the Full Model\nplantModel.run();\n</code></pre> <p>The <code>ProcessModel</code> will execute the added systems in the order they were added (or based on internal logic if configured). It ensures that data flows correctly between the connected systems.</p>"},{"location":"wiki/advanced_process_simulation/#5-reusable-templates-and-composition-helpers","title":"5. Reusable templates and composition helpers","text":"<p>To reduce boilerplate when assembling larger flowsheets, reuse the <code>Recycle</code>, controller, and <code>ProcessModel</code> patterns as pre-made building blocks. The following templates can be copied as-is or combined inside a <code>ProcessModel</code> catalog to let automated agents stitch together flowsheets without rewiring every unit manually.</p>"},{"location":"wiki/advanced_process_simulation/#template-inlet-separator-train-with-recycle","title":"Template: Inlet separator train with recycle","text":"<p>Building blocks: feed stream \u2192 choke valve (optional) \u2192 inlet cooler \u2192 three-phase separator \u2192 level/pressure controllers \u2192 recycle loop.</p> <p>Why this helps: captures the standard inlet handling motif (cooling, phase split, level trim) while providing a ready-made recycle loop for gas reprocessing or compressor suction stabilization.</p> <pre><code>// Streams\nStream feed = new Stream(\"Feed\", feedFluid);\nStream recycleStream = new Stream(\"Recycle Seed\", feedFluid.clone());\n\n// Front-end conditioning\nThrottlingValve choke = new ThrottlingValve(\"Choke\", feed);\nCooler inletCooler = new Cooler(\"Inlet Cooler\", choke.getOutletStream());\nSeparator inletSep = new Separator(\"Inlet Separator\", inletCooler.getOutletStream());\n\n// Controllers\nLevelTransmitter levelTI = new LevelTransmitter(inletSep);\nControllerDeviceBaseClass levelController = new ControllerDeviceBaseClass();\nlevelController.setTransmitter(levelTI);\nlevelController.setControllerSetPoint(0.6); // 60% level\nlevelController.setReverseActing(true);\nThrottlingValve levelValve = new ThrottlingValve(\"Liquid LV\", inletSep.getLiquidOutStream());\nlevelValve.setController(levelController);\n\nPressureTransmitter pTI = new PressureTransmitter(inletSep);\nControllerDeviceBaseClass pressureController = new ControllerDeviceBaseClass();\npressureController.setTransmitter(pTI);\npressureController.setControllerSetPoint(50.0); // bara\npressureController.setReverseActing(false);\nThrottlingValve pressureValve = new ThrottlingValve(\"Gas PCV\", inletSep.getGasOutStream());\npressureValve.setController(pressureController);\n\n// Recycle\nRecycle recycle = new Recycle(\"Separator Gas Recycle\");\nrecycle.addStream(pressureValve.getOutletStream());\nrecycle.setTolerance(1e-6);\nrecycle.setMaximumIterations(50);\n\n// Stitch recycle back to the front-end mixer (or directly to choke/cooler)\nStaticMixer frontMixer = new StaticMixer(\"Front Mixer\");\nfrontMixer.addStream(feed);\nfrontMixer.addStream(recycle.getOutletStream());\nchoke.setOutletStream(frontMixer.getOutStream());\n\n// Register in a ProcessSystem\nProcessSystem inletSystem = new ProcessSystem();\ninletSystem.add(feed, recycleStream, choke, inletCooler, inletSep, levelTI, levelValve, pTI, pressureValve, recycle, frontMixer);\n</code></pre> <p>Composition hints: - Expose <code>inletSep.getGasOutStream()</code> and <code>inletSep.getOilOutStream()</code> as outputs so other templates (e.g., gas compression or stabilizer) can consume them. - When embedding inside a <code>ProcessModel</code>, add this system first so downstream templates can reference the separator gas as an upstream dependency.</p>"},{"location":"wiki/advanced_process_simulation/#template-two-stage-compression-with-interstage-cooling","title":"Template: Two-stage compression with interstage cooling","text":"<p>Building blocks: gas feed \u2192 stage 1 compressor \u2192 interstage cooler + separator (optional) \u2192 stage 2 compressor \u2192 aftercooler \u2192 pressure controller or recycle.</p> <p>Why this helps: standardizes multi-stage compression including thermal conditioning between stages and hooks for surge/recycle control.</p> <pre><code>// Assume gasFeed is provided by an upstream template (e.g., inlet separator train)\nCompressor comp1 = new Compressor(\"1st Stage\", gasFeed);\nCooler intercooler = new Cooler(\"Interstage Cooler\", comp1.getOutletStream());\nSeparator interSep = new Separator(\"Interstage Separator\", intercooler.getOutletStream());\n\nCompressor comp2 = new Compressor(\"2nd Stage\", interSep.getGasOutStream());\nCooler afterCooler = new Cooler(\"Aftercooler\", comp2.getOutletStream());\n\n// Discharge pressure control via recycle\nPressureTransmitter dischargePT = new PressureTransmitter(afterCooler);\nControllerDeviceBaseClass dischargePC = new ControllerDeviceBaseClass();\ndischargePC.setTransmitter(dischargePT);\ndischargePC.setControllerSetPoint(100.0); // bara\ndischargePC.setReverseActing(false);\n\nThrottlingValve recycleValve = new ThrottlingValve(\"Discharge Recycle Valve\", afterCooler.getOutletStream());\nrecycleValve.setController(dischargePC);\n\nRecycle dischargeRecycle = new Recycle(\"Compression Recycle\");\ndischargeRecycle.addStream(recycleValve.getOutletStream());\ndischargeRecycle.setTolerance(1e-7);\ndischargeRecycle.setMaximumIterations(75);\n\n// Tie recycle back to first-stage suction\nStaticMixer suctionMixer = new StaticMixer(\"Suction Mixer\");\nsuctionMixer.addStream(gasFeed);\nsuctionMixer.addStream(dischargeRecycle.getOutletStream());\ncomp1.setInletStream(suctionMixer.getOutStream());\n\n// Organize as a ProcessSystem for catalog reuse\nProcessSystem compressionSystem = new ProcessSystem();\ncompressionSystem.add(comp1, intercooler, interSep, comp2, afterCooler, dischargePT, recycleValve, dischargeRecycle, suctionMixer);\n</code></pre> <p>Composition hints: - When combined with the inlet separator template, connect <code>gasFeed</code> to <code>inletSep.getGasOutStream()</code> and merge the <code>ProcessSystem</code> instances using <code>ProcessModel</code>. - Expose optional outputs (e.g., <code>interSep.getOilOutStream()</code>) for condensate handling templates. - PID tuning parameters (<code>setControllerParameters</code>) can be kept in a shared catalog so AI agents can swap them without editing structure.</p>"},{"location":"wiki/air_cooler/","title":"Air cooler unit operation","text":"<p>The <code>AirCooler</code> is a simple process unit for estimating the amount of cooling air needed when a process stream is cooled by ambient air. The calculation makes use of the humid air utility in NeqSim to evaluate the enthalpy rise of the air between the inlet and outlet temperature.</p> <p>For a given inlet temperature, outlet temperature and relative humidity of the air, the mass flow of dry air is obtained from</p> \\[ \\dot m_{air} = \\frac{Q}{h_{out}-h_{in}} \\] <p>where <code>Q</code> is the heat removed from the process stream in watt and <code>h_{in}</code> and <code>h_{out}</code> are the specific humid\u2013air enthalpies in kJ per kg dry air. The volumetric flow is calculated from the ideal\u2013gas relation at the inlet conditions.</p> <p>Basic usage:</p> <pre><code>AirCooler cooler = new AirCooler(\"air cooler\", stream);\ncooler.setOutTemperature(40.0, \"C\");\ncooler.setAirInletTemperature(20.0, \"C\");\ncooler.setAirOutletTemperature(30.0, \"C\");\ncooler.setRelativeHumidity(0.5);\n</code></pre>"},{"location":"wiki/battery_storage/","title":"Battery storage unit","text":"<p>The <code>BatteryStorage</code> unit stores electrical energy for later use. It maintains an internal state-of-charge and exchanges power with the rest of a process through its energy stream. Positive duty on the energy stream represents charging while negative duty represents power delivery.</p> <p>The battery can be combined with other power generation units such as <code>FuelCell</code> or <code>GasTurbine</code> to buffer excess electricity or supply power during demand peaks.</p> <pre><code>BatteryStorage battery = new BatteryStorage(\"battery\", 5.0e5);\nFuelCell cell = new FuelCell(\"cell\", fuel, oxidant);\n\ncell.run();\n// store half of the produced power for one hour\nbattery.charge(-cell.getEnergyStream().getDuty() / 2.0, 1.0);\nbattery.run();\n</code></pre>"},{"location":"wiki/beggs_and_brill_correlation/","title":"Beggs &amp; Brill Correlation for Multiphase Pipe Flow","text":""},{"location":"wiki/beggs_and_brill_correlation/#overview","title":"Overview","text":"<p>The Beggs &amp; Brill correlation (1973) is a widely-used empirical method for predicting pressure drop and liquid holdup in multiphase pipe flow. It handles:</p> <ul> <li>Horizontal, inclined, and vertical pipes</li> <li>All flow regimes (segregated, intermittent, distributed)</li> <li>Two-phase and three-phase flow (gas-oil-water)</li> </ul>"},{"location":"wiki/beggs_and_brill_correlation/#theory","title":"Theory","text":""},{"location":"wiki/beggs_and_brill_correlation/#total-pressure-gradient","title":"Total Pressure Gradient","text":"<p>The total pressure gradient consists of three components:</p> \\[\\frac{dP}{dL} = \\frac{dP}{dL}_{friction} + \\frac{dP}{dL}_{hydrostatic} + \\frac{dP}{dL}_{acceleration}\\] <p>In NeqSim, the acceleration term is typically neglected (small for steady flow), so:</p> \\[\\Delta P = \\Delta P_{friction} + \\Delta P_{hydrostatic}\\]"},{"location":"wiki/beggs_and_brill_correlation/#flow-regime-determination","title":"Flow Regime Determination","text":"<p>The correlation identifies four flow regimes based on dimensionless parameters:</p> Flow Regime Description Typical Conditions Segregated Stratified or wavy flow Low velocities, horizontal Intermittent Slug or plug flow Moderate velocities Distributed Bubble or mist flow High velocities Transition Between segregated and intermittent Transitional <p>Flow regime is determined by: - Froude number: \\(Fr = v_m^2 / (g \\cdot D)\\) - Input liquid volume fraction: \\(\\lambda_L = v_{SL} / v_m\\)</p> <p>Where: - \\(v_m = v_{SG} + v_{SL}\\) (mixture superficial velocity) - \\(v_{SG}\\) = gas superficial velocity - \\(v_{SL}\\) = liquid superficial velocity</p>"},{"location":"wiki/beggs_and_brill_correlation/#liquid-holdup-calculation","title":"Liquid Holdup Calculation","text":"<p>Liquid holdup (\\(H_L\\) or \\(E_L\\)) is the fraction of pipe cross-section occupied by liquid:</p> \\[H_L = H_L(0) \\cdot \\psi\\] <p>Where: - \\(H_L(0)\\) = horizontal holdup from regime-specific correlation - \\(\\psi\\) = inclination correction factor</p> <p>Horizontal holdup correlations:</p> Regime Correlation Segregated \\(H_L(0) = \\frac{0.98 \\lambda_L^{0.4846}}{Fr^{0.0868}}\\) Intermittent \\(H_L(0) = \\frac{0.845 \\lambda_L^{0.5351}}{Fr^{0.0173}}\\) Distributed \\(H_L(0) = \\frac{1.065 \\lambda_L^{0.5824}}{Fr^{0.0609}}\\)"},{"location":"wiki/beggs_and_brill_correlation/#friction-pressure-loss","title":"Friction Pressure Loss","text":"\\[\\Delta P_{friction} = \\frac{f_{tp} \\cdot \\rho_{ns} \\cdot v_m^2 \\cdot L}{2D}\\] <p>Where: - \\(f_{tp} = f_{ns} \\cdot e^S\\) (two-phase friction factor) - \\(f_{ns}\\) = no-slip friction factor (from Haaland equation) - \\(S\\) = slip correction factor - \\(\\rho_{ns}\\) = no-slip mixture density</p>"},{"location":"wiki/beggs_and_brill_correlation/#hydrostatic-pressure-drop","title":"Hydrostatic Pressure Drop","text":"\\[\\Delta P_{hydrostatic} = \\rho_m \\cdot g \\cdot \\Delta h\\] <p>Where: - \\(\\rho_m = \\rho_L \\cdot H_L + \\rho_G \\cdot (1 - H_L)\\) (mixture density with holdup) - \\(\\Delta h\\) = elevation change</p>"},{"location":"wiki/beggs_and_brill_correlation/#usage-in-neqsim","title":"Usage in NeqSim","text":""},{"location":"wiki/beggs_and_brill_correlation/#basic-configuration","title":"Basic Configuration","text":"<pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"flowline\", inletStream);\n\n// Geometry\npipe.setLength(1000);              // meters\npipe.setDiameter(0.1);             // meters\npipe.setElevation(100);            // meters (positive = uphill)\npipe.setAngle(5.7);                // degrees (alternative to elevation)\npipe.setPipeWallRoughness(4.6e-5); // meters (steel \u2248 0.046 mm)\n\n// Numerical settings\npipe.setNumberOfIncrements(20);    // segments for integration\n\npipe.run();\n</code></pre>"},{"location":"wiki/beggs_and_brill_correlation/#accessing-results","title":"Accessing Results","text":"<pre><code>// Overall results\ndouble pressureDrop = pipe.getInletPressure() - pipe.getOutletPressure();\ndouble outletTemp = pipe.getOutletTemperature();\n\n// Flow regime\nPipeBeggsAndBrills.FlowRegime regime = pipe.getFlowRegime();\n// Returns: SEGREGATED, INTERMITTENT, DISTRIBUTED, TRANSITION, or SINGLE_PHASE\n\n// Profile data (for segment i)\ndouble holdup = pipe.getSegmentLiquidHoldup(i);\ndouble mixtureDensity = pipe.getSegmentMixtureDensity(i);\ndouble velocity = pipe.getSegmentMixtureSuperficialVelocity(i);\n\n// Full profiles\nList&lt;Double&gt; pressureProfile = pipe.getPressureProfile();\nList&lt;Double&gt; temperatureProfile = pipe.getTemperatureProfile();\n</code></pre>"},{"location":"wiki/beggs_and_brill_correlation/#heat-transfer-options","title":"Heat Transfer Options","text":"<pre><code>// Adiabatic (default)\npipe.setRunAdiabatic(true);\n\n// With heat transfer\npipe.setRunAdiabatic(false);\npipe.setConstantSurfaceTemperature(283.15);  // 10\u00b0C ambient\npipe.setHeatTransferCoefficient(10.0);       // W/m\u00b2K\n// Or let it estimate:\npipe.setHeatTransferCoefficientMethod(\"Estimated\");\n</code></pre>"},{"location":"wiki/beggs_and_brill_correlation/#three-phase-flow-gas-oil-water","title":"Three-Phase Flow (Gas-Oil-Water)","text":"<p>For three-phase systems, the liquid phase properties are calculated as volume-weighted averages:</p> <pre><code>SystemInterface fluid = new SystemSrkEos(333.15, 30.0);\nfluid.addComponent(\"methane\", 3000, \"kg/hr\");\nfluid.addComponent(\"nC10\", 40000, \"kg/hr\");\nfluid.addComponent(\"water\", 20000, \"kg/hr\");\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);  // Enable water phase\n\nStream feed = new Stream(\"feed\", fluid);\nfeed.run();\n\nPipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"pipe\", feed);\n// ... configure and run\n</code></pre>"},{"location":"wiki/beggs_and_brill_correlation/#limitations","title":"Limitations","text":"<ol> <li>Developed for oil &amp; gas: Correlations based on oil/gas/water systems</li> <li>Pipe diameter range: Validated for 1-12 inch pipes</li> <li>Pressure range: Best for moderate pressures (1-100 bara)</li> <li>Inclination: Valid for -90\u00b0 to +90\u00b0 (horizontal to vertical)</li> <li>Viscosity: May underpredict for very high viscosity fluids</li> <li>Flow patterns: Simplified flow regime map; real systems may differ</li> </ol>"},{"location":"wiki/beggs_and_brill_correlation/#validation","title":"Validation","text":"<p>NeqSim's implementation has been validated against:</p> Test Case Reference Deviation Single-phase gas (turbulent) Darcy-Weisbach +0.5% Single-phase liquid (turbulent) Darcy-Weisbach -1.4% Single-phase liquid (laminar) Darcy-Weisbach 0.0% Two-phase horizontal Dukler, Homogeneous Reasonable Inclined pipes Steady-state physics Validated"},{"location":"wiki/beggs_and_brill_correlation/#references","title":"References","text":"<ol> <li> <p>Beggs, H.D. and Brill, J.P. (1973). \"A Study of Two-Phase Flow in Inclined Pipes\". Journal of Petroleum Technology, 25(5), 607-617.</p> </li> <li> <p>Brill, J.P. and Mukherjee, H. (1999). Multiphase Flow in Wells. SPE Monograph Series.</p> </li> <li> <p>Shoham, O. (2006). Mechanistic Modeling of Gas-Liquid Two-Phase Flow in Pipes. SPE Books.</p> </li> </ol>"},{"location":"wiki/beggs_and_brill_correlation/#see-also","title":"See Also","text":"<ul> <li>Pipeline Pressure Drop Overview</li> <li>Friction Factor Models</li> <li>Pipeline Transient Simulation</li> </ul>"},{"location":"wiki/black_oil_flash_playbook/","title":"Black-oil flash playbook from regression tests","text":"<p>The black-oil flash workflow is exercised in <code>SystemBlackOilTest</code>, which demonstrates both Eclipse deck import and direct tabular setup before running a flash. The following notes pair the tested setup with the theory it relies on so you can reproduce the flow efficiently.</p>"},{"location":"wiki/black_oil_flash_playbook/#importing-eclipse-pvt-decks","title":"Importing Eclipse PVT decks","text":"<p><code>testBasicFlash</code> constructs a minimal Eclipse deck with metric units, PVTO/PVTG/PVTW tables, and standard-condition densities, then feeds it to <code>EclipseBlackOilImporter.fromFile(...)</code>.\u3010F:src/test/java/neqsim/blackoil/SystemBlackOilTest.java\u2020L31-L74\u3011 The importer returns a <code>BlackOilPVTTable</code> and an initialized <code>SystemBlackOil</code> instance whose bubblepoint is read directly from the tables.</p> <p>Key steps mirrored from the test:</p> <ol> <li>Write the deck text to disk (or keep it in memory) and call the importer.</li> <li>Supply standard-condition densities (oil/gas/water) when constructing <code>SystemBlackOil</code>.</li> <li>Set the current pressure, temperature, and standard volumes (<code>setStdTotals</code>) before calling <code>flash()</code>.</li> <li>Inspect reservoir volumes, viscosities, and densities from the returned system object\u2014 the test only asserts positivity but those values correspond to the PVTO/PVTG/PVTW correlations.</li> </ol> <p>The flash solves phase-split mass balance for three pseudo-phases using deck-derived formation volume factors \\(B_o, B_g, B_w\\), dissolved gas\u2013oil ratio \\(R_s\\), and vaporized oil\u2013gas ratio \\(R_v\\). Reservoir volumes are calculated as</p> \\[ V_{res} = B_x \\times V_{std} \\] <p>for each phase \\(x\\in\\{o,g,w\\}\\), with viscosities pulled directly from the tables.</p>"},{"location":"wiki/black_oil_flash_playbook/#building-pvt-tables-in-code","title":"Building PVT tables in code","text":"<p><code>testDirectPVTTable</code> shows how to bypass deck parsing by interpolating PVTO/PVTG/PVTW data onto a merged pressure grid, then wrapping it in <code>BlackOilPVTTable.Record</code> entries.\u3010F:src/test/java/neqsim/blackoil/SystemBlackOilTest.java\u2020L77-L133\u3011 The resulting table is flashed the same way as the imported one.</p> <p>When scripting your own tests:</p> <ul> <li>Provide monotone pressure arrays for \\(B_o\\), \\(B_g\\), \\(B_w\\), \\(R_s\\), and \\(R_v\\) to avoid interpolation ambiguity.</li> <li>Use consistent viscosity units (Pa\u00b7s) and choose a bubblepoint (<code>Pb</code>) inside the pressure grid so gas liberation follows expected two-phase behavior.</li> <li>After <code>flash()</code>, validate density, viscosity, and reservoir volume signs as sanity checks, then compare against lab or simulator references.</li> </ul>"},{"location":"wiki/bottleneck_analysis/","title":"Bottleneck Analysis and Capacity Utilization","text":"<p>NeqSim provides functionality to analyze capacity utilization and identify bottlenecks in a process simulation. This feature is useful for production optimization and debottlenecking studies.</p>"},{"location":"wiki/bottleneck_analysis/#overview","title":"Overview","text":"<p>The bottleneck analysis identifies which unit operation in a process system is operating closest to its maximum design capacity. The analysis is based on the \"utilization ratio,\" defined as:</p> \\[ \\text{Utilization} = \\frac{\\text{Current Duty}}{\\text{Maximum Capacity}} \\] <p>The unit operation with the highest utilization ratio is considered the bottleneck.</p>"},{"location":"wiki/bottleneck_analysis/#key-concepts","title":"Key Concepts","text":""},{"location":"wiki/bottleneck_analysis/#1-capacity-duty-getcapacityduty","title":"1. Capacity Duty (<code>getCapacityDuty</code>)","text":"<p>The <code>getCapacityDuty()</code> method returns the current operating load of a unit operation. The definition of \"duty\" varies by equipment type: - Compressor: Total power consumption (Watts). - Separator: Gas outlet flow rate (\\(m^3/hr\\)). - Other Equipment: Default is 0.0 (needs implementation for specific units).</p>"},{"location":"wiki/bottleneck_analysis/#2-maximum-capacity-getcapacitymax","title":"2. Maximum Capacity (<code>getCapacityMax</code>)","text":"<p>The <code>getCapacityMax()</code> method returns the maximum design capacity of the equipment. This value is typically set in the equipment's mechanical design. - Compressor: <code>maxDesignPower</code> (Watts). - Separator: <code>maxDesignGassVolumeFlow</code> (\\(m^3/hr\\)).</p>"},{"location":"wiki/bottleneck_analysis/#3-rest-capacity-getrestcapacity","title":"3. Rest Capacity (<code>getRestCapacity</code>)","text":"<p>The <code>getRestCapacity()</code> method calculates the remaining available capacity: $$ \\text{Rest Capacity} = \\text{Maximum Capacity} - \\text{Current Duty} $$</p> <p>Use <code>ProductionOptimizer.OptimizationConfig.capacityRangeForType</code> to supply P10/P50/P90 envelopes for equipment without deterministic limits and specify a percentile via <code>capacityPercentile</code> (e.g., 0.1 for P10 or 0.9 for P90 stress tests).</p>"},{"location":"wiki/bottleneck_analysis/#implementation-details","title":"Implementation Details","text":""},{"location":"wiki/bottleneck_analysis/#processequipmentinterface","title":"ProcessEquipmentInterface","text":"<p>The <code>ProcessEquipmentInterface</code> defines the methods for capacity analysis: <pre><code>public double getCapacityDuty();\npublic double getCapacityMax();\npublic double getRestCapacity();\n</code></pre></p>"},{"location":"wiki/bottleneck_analysis/#processsystem","title":"ProcessSystem","text":"<p>The <code>ProcessSystem</code> class includes a method to identify the bottleneck: <pre><code>public ProcessEquipmentInterface getBottleneck();\n</code></pre> This method iterates through all unit operations in the system and returns the one with the highest utilization ratio.</p>"},{"location":"wiki/bottleneck_analysis/#supported-equipment","title":"Supported Equipment","text":"<p>Currently, the following equipment types support capacity analysis:</p> Equipment Duty Metric Capacity Parameter Compressor Power (W) <code>MechanicalDesign.maxDesignPower</code> with optional P10/P50/P90 overrides Separator Gas Flow (\\(m^3/hr\\)) <code>MechanicalDesign.maxDesignGassVolumeFlow</code> Pump Power (W) <code>MechanicalDesign.maxDesignPower</code> Heater Duty (W) <code>MechanicalDesign.maxDesignDuty</code> Cooler Duty (W) <code>MechanicalDesign.maxDesignDuty</code> ThrottlingValve Volume Flow (\\(m^3/hr\\)) <code>MechanicalDesign.maxDesignVolumeFlow</code> Pipeline Volume Flow (\\(m^3/hr\\)) <code>MechanicalDesign.maxDesignVolumeFlow</code> DistillationColumn Fs hydraulic factor <code>OptimizationConfig.columnFsFactorLimit</code> (default 2.5) Custom types User-supplied duty/limit lambdas Configure via <code>capacityRuleForType</code>"},{"location":"wiki/bottleneck_analysis/#example-usage","title":"Example Usage","text":"<p>The following example demonstrates how to set up a simulation, define capacities, and identify the bottleneck.</p> <pre><code>import neqsim.process.equipment.compressor.Compressor;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.processmodel.ProcessSystem;\nimport neqsim.thermo.system.SystemSrkEos;\n\npublic class BottleneckExample {\n    public static void main(String[] args) {\n        // 1. Create System\n        SystemSrkEos testSystem = new SystemSrkEos(298.15, 10.0);\n        testSystem.addComponent(\"methane\", 100.0);\n        testSystem.createDatabase(true);\n        testSystem.setMixingRule(2);\n\n        Stream inletStream = new Stream(\"inlet stream\", testSystem);\n        inletStream.setFlowRate(100.0, \"MSm3/day\");\n        inletStream.setTemperature(20.0, \"C\");\n        inletStream.setPressure(10.0, \"bara\");\n\n        // 2. Create Equipment and Set Capacities\n        Separator separator = new Separator(\"separator\", inletStream);\n        // Set Separator Capacity (e.g., 200 m3/hr)\n        separator.getMechanicalDesign().setMaxDesignGassVolumeFlow(200.0); \n\n        Compressor compressor = new Compressor(\"compressor\", separator.getGasOutStream());\n        compressor.setOutletPressure(50.0);\n        // Set Compressor Capacity (e.g., 5 MW)\n        compressor.getMechanicalDesign().maxDesignPower = 5000000.0; \n\n        // 3. Run Simulation\n        ProcessSystem process = new ProcessSystem();\n        process.add(inletStream);\n        process.add(separator);\n        process.add(compressor);\n        process.run();\n\n        // 4. Analyze Results\n        System.out.println(\"Separator Duty: \" + separator.getCapacityDuty());\n        System.out.println(\"Separator Max: \" + separator.getCapacityMax());\n        System.out.println(\"Compressor Duty: \" + compressor.getCapacityDuty());\n        System.out.println(\"Compressor Max: \" + compressor.getCapacityMax());\n\n        if (process.getBottleneck() != null) {\n            System.out.println(\"Bottleneck: \" + process.getBottleneck().getName());\n            double utilization = process.getBottleneck().getCapacityDuty() / process.getBottleneck().getCapacityMax();\n            System.out.println(\"Utilization: \" + (utilization * 100) + \"%\");\n        } else {\n            System.out.println(\"No bottleneck found (or capacity not set)\");\n        }\n\n        System.out.println(\"Compressor Rest Capacity: \" + compressor.getRestCapacity());\n    }\n}\n</code></pre>"},{"location":"wiki/bottleneck_analysis/#extending-to-other-equipment","title":"Extending to Other Equipment","text":"<p>To support capacity analysis for other equipment types (e.g., Pumps, Heat Exchangers), implement the <code>getCapacityDuty()</code> and <code>getCapacityMax()</code> methods in the respective classes. Ensure that the units for duty and capacity are consistent (e.g., both in Watts or both in kg/hr).</p>"},{"location":"wiki/bottleneck_analysis/#production-optimization","title":"Production Optimization","text":"<p>The bottleneck analysis feature is a powerful tool for optimizing production. By identifying the limiting constraint in a process, you can maximize throughput or identify the most effective upgrades (debottlenecking).</p>"},{"location":"wiki/bottleneck_analysis/#optimization-workflow","title":"Optimization Workflow","text":"<ol> <li>Define Objective: Configure one or more objectives (e.g., maximize throughput while penalizing power) using <code>OptimizationObjective</code> weights.</li> <li>Identify Constraints: Provide utilization limits per equipment name or type plus custom hard/soft constraints via <code>OptimizationConstraint</code>. Safety margins and capacity-uncertainty factors can be applied globally so bottleneck checks keep headroom.</li> <li>Iterative Solver (selectable):<ul> <li><code>BINARY_FEASIBILITY</code> (default) targets monotonic systems and searches on feasibility margins.</li> <li><code>GOLDEN_SECTION_SCORE</code> samples non-monotonic responses using weighted objectives and constraint penalties to guide the search.</li> <li><code>NELDER_MEAD_SCORE</code> applies a simplex-based heuristic to handle noisy or coupled objectives without assuming monotonicity.</li> <li><code>PARTICLE_SWARM_SCORE</code> explores the design space with a configurable swarm size/inertia/weights, useful when the objective landscape has multiple peaks.</li> </ul> </li> <li>Diagnostics &amp; reporting:<ul> <li>Each run keeps an <code>iterationHistory</code> with per-iteration utilization snapshots so you can plot trajectories of bottleneck movement and score versus candidate rate to understand convergence.</li> <li>Use <code>ProductionOptimizer.buildUtilizationSeries(result.getIterationHistory())</code> to feed plotting libraries or CSV exports and <code>formatUtilizationTimeline(...)</code> to highlight bottlenecks per iteration in Markdown.</li> <li>Use <code>ProductionOptimizer.formatUtilizationTable(result.getUtilizationRecords())</code> to render a quick Markdown table of duties, capacities, and limits for reports.</li> <li>Scenario helpers let you run a base case and multiple debottleneck cases in one call for side-by-side reporting, including KPI deltas and Markdown tables that highlight the gain relative to the baseline.</li> <li>Caching (enabled by default) reuses steady-state evaluations at similar rates to cut down on reruns during heuristic searches.</li> </ul> </li> </ol>"},{"location":"wiki/bottleneck_analysis/#example-using-productionoptimizer","title":"Example: Using <code>ProductionOptimizer</code>","text":"<p>The <code>ProductionOptimizer</code> utility adds structured reporting and constraint handling on top of the existing bottleneck functions:</p> <pre><code>import java.util.List;\nimport neqsim.process.util.optimization.ProductionOptimizer;\nimport neqsim.process.util.optimization.ProductionOptimizer.ConstraintSeverity;\nimport neqsim.process.util.optimization.ProductionOptimizer.OptimizationConfig;\nimport neqsim.process.util.optimization.ProductionOptimizer.OptimizationConstraint;\nimport neqsim.process.util.optimization.ProductionOptimizer.OptimizationObjective;\nimport neqsim.process.util.optimization.ProductionOptimizer.OptimizationResult;\n\nProductionOptimizer optimizer = new ProductionOptimizer();\n\nOptimizationConfig config = new OptimizationConfig(100.0, 5_000.0)\n    .rateUnit(\"kg/hr\")\n    .tolerance(5.0)\n    .defaultUtilizationLimit(0.95)\n    .utilizationMarginFraction(0.1) // keep 10% headroom on every unit\n    .capacityUncertaintyFraction(0.05) // down-rate capacities for uncertainty\n    .capacityPercentile(0.1) // pick P10/P50/P90 from optional ranges\n    .capacityRangeSpreadFraction(0.15) // auto-build P10/P90 around design capacity\n    .columnFsFactorLimit(2.2) // set column hydraulic headroom\n    .utilizationLimitForName(\"compressor\", 0.9);\n\nOptimizationObjective objective = new OptimizationObjective(\"maximize rate\",\n    proc -&gt; process.getBottleneck().getCapacityDuty(), 1.0);\n\nOptimizationConstraint keepPowerLow = OptimizationConstraint.lessThan(\"compressor load\",\n    proc -&gt; compressor.getCapacityDuty() / compressor.getCapacityMax(), 0.9,\n    ConstraintSeverity.SOFT, 5.0, \"Prefer 10% safety margin on compressor\");\n\n// Enforce equipment-type constraints (e.g., pressure ratio below 10 for all compressors)\nconfig.equipmentConstraintRule(new EquipmentConstraintRule(Compressor.class, \"pressure ratio\",\n    unit -&gt; ((Compressor) unit).getOutStream().getPressure() / ((Compressor) unit)\n        .getInletStream().getPressure(), 10.0,\n    ProductionOptimizer.ConstraintDirection.LESS_THAN, ConstraintSeverity.HARD, 0.0,\n    \"Keep pressure ratio within design\"));\n\nOptimizationResult result = optimizer.optimize(process, inletStream, config,\n    List.of(objective), List.of(keepPowerLow));\n\nSystem.out.println(\"Optimal rate: \" + result.getOptimalRate() + \" \" + result.getRateUnit());\nSystem.out.println(\"Bottleneck: \" + result.getBottleneck().getName());\nresult.getUtilizationRecords().forEach(record -&gt;\n    System.out.println(record.getEquipmentName() + \" utilization: \" + record.getUtilization()));\n// Optional: plot or log iteration history for transparency\nresult.getIterationHistory().forEach(iter -&gt; System.out.println(\n    \"Iter \" + iter.getRate() + \" \" + iter.getRateUnit() + \" bottleneck=\"\n        + iter.getBottleneckName() + \" feasible=\" + iter.isFeasible() + \" score=\"\n        + iter.getScore() + \" utilizationCount=\" + iter.getUtilizations().size()));\n\n// Quick high-level summary without manual bounds/objective wiring\nOptimizationSummary summary = optimizer.quickOptimize(process, inletStream);\nSystem.out.println(\"Max rate: \" + summary.getMaxRate() + \" \" + summary.getRateUnit());\nSystem.out.println(\"Limiting equipment: \" + summary.getLimitingEquipment()\n    + \" margin=\" + summary.getUtilizationMargin());\nSystem.out.println(ProductionOptimizer.formatUtilizationTimeline(result.getIterationHistory()));\n\n// Built-in capacity coverage now includes separators (liquid level fraction) and\n// MultiStream heat exchangers (duty vs design) in addition to compressors/pumps/columns.\n\n// Swarm search example via YAML/JSON specs\n// searchMode, swarmSize, inertiaWeight, and capacityPercentile can be provided per scenario\n</code></pre> <p>To vary multiple feeds or set points at once (e.g., two inlet streams plus a compressor pressure), define <code>ManipulatedVariable</code> instances and call the multi-variable overload:</p> <pre><code>ManipulatedVariable feedNorth = new ManipulatedVariable(\"north\", 100.0, 800.0, \"kg/hr\",\n    (proc, value) -&gt; northStream.setFlowRate(value, \"kg/hr\"));\nManipulatedVariable feedSouth = new ManipulatedVariable(\"south\", 100.0, 800.0, \"kg/hr\",\n    (proc, value) -&gt; southStream.setFlowRate(value, \"kg/hr\"));\nManipulatedVariable compressorSetPoint = new ManipulatedVariable(\"compressor pressure\", 40.0,\n    80.0, \"bara\", (proc, value) -&gt; compressor.setOutletPressure(value));\n\nOptimizationResult multiVar = optimizer.optimize(process, List.of(feedNorth, feedSouth,\n    compressorSetPoint), config.searchMode(SearchMode.PARTICLE_SWARM_SCORE), List.of(objective),\n    List.of(keepPowerLow));\n</code></pre>"},{"location":"wiki/bottleneck_analysis/#comparing-debottlenecking-scenarios","title":"Comparing debottlenecking scenarios","text":"<p>Use <code>compareScenarios</code> to run a baseline plus multiple upgrades and compute KPI deltas in one report-ready table:</p> <pre><code>ScenarioRequest baseCase = new ScenarioRequest(\"base\", baseProcess, baseFeed, baseConfig,\n    List.of(objective), List.of(keepPowerLow));\nScenarioRequest upgradeCase = new ScenarioRequest(\"upgrade\", upgradedProcess, upgradedFeed,\n    baseConfig, List.of(objective), List.of(keepPowerLow));\n\nList&lt;ScenarioKpi&gt; kpis = List.of(ScenarioKpi.optimalRate(\"kg/hr\"), ScenarioKpi.score());\nScenarioComparisonResult comparison = optimizer.compareScenarios(\n    List.of(baseCase, upgradeCase), kpis);\n\nSystem.out.println(ProductionOptimizer.formatScenarioComparisonTable(comparison, kpis));\n</code></pre> <p>The first scenario is treated as the baseline; each KPI cell shows <code>value (\u0394baseline)</code> so uplift from debottlenecking is immediately visible alongside bottleneck names and feasibility flags.</p>"},{"location":"wiki/bottleneck_analysis/#running-from-jsonyaml-specs","title":"Running from JSON/YAML specs","text":"<p>For reproducible CLI/CI runs, define scenarios in a YAML or JSON file (bounds, objectives, constraints) and load them via <code>ProductionOptimizationSpecLoader.load(...)</code> while passing in a registry of process models, feed streams, and metric functions keyed by name. This allows side-by-side optimization of investment options without hard-coding Java configuration:</p> <pre><code>scenarios:\n  - name: base\n    process: baseProcess\n    feedStream: inlet\n    lowerBound: 100.0\n    upperBound: 2000.0\n    rateUnit: kg/hr\n    searchMode: BINARY_FEASIBILITY\n    constraints:\n      - name: column_pressure\n        metric: columnPressureRatio\n        limit: 1.8\n        direction: LESS_THAN\n        severity: HARD\n  - name: upgrade\n    process: upgradedProcess\n    feedStream: inlet\n    lowerBound: 100.0\n    upperBound: 2500.0\n    rateUnit: kg/hr\n    searchMode: PARTICLE_SWARM_SCORE\n</code></pre> <p>After loading, call <code>optimizer.optimizeScenarios(...)</code> or <code>optimizer.compareScenarios(...)</code> to render side-by-side KPIs automatically for the pipeline or report.</p>"},{"location":"wiki/bottleneck_analysis/#advanced-yaml-with-multi-objective-scoring-and-variable-feeds","title":"Advanced YAML with multi-objective scoring and variable feeds","text":"<p>To mirror the multi-objective/variable-driven test coverage, you can encode both throughput and penalty objectives while letting a swarm search vary a feed stream directly:</p> <pre><code>scenarios:\n  - name: base\n    process: base\n    feedStream: feed1\n    lowerBound: 100.0\n    upperBound: 320.0\n    rateUnit: kg/hr\n    capacityPercentile: 0.9\n    objectives:\n      - name: rate\n        metric: throughput\n        weight: 1.0\n        type: MAXIMIZE\n      - name: compressorUtilPenalty\n        metric: compressorUtil\n        weight: -0.1\n        type: MAXIMIZE\n    constraints:\n      - name: utilizationCap\n        metric: compressorUtil\n        limit: 0.95\n        direction: LESS_THAN\n        severity: HARD\n        penaltyWeight: 0.0\n        description: Keep compressor within design\n  - name: upgrade\n    process: upgrade\n    lowerBound: 120.0\n    upperBound: 340.0\n    rateUnit: kg/hr\n    searchMode: PARTICLE_SWARM_SCORE\n    utilizationMarginFraction: 0.05\n    capacityPercentile: 0.9\n    variables:\n      - name: feed2Variable\n        stream: feed2\n        lowerBound: 120.0\n        upperBound: 340.0\n        unit: kg/hr\n    objectives:\n      - name: rate\n        metric: throughput\n        weight: 1.0\n        type: MAXIMIZE\n    constraints:\n      - name: utilizationCap\n        metric: compressorUtil\n        limit: 0.95\n        direction: LESS_THAN\n        severity: HARD\n        penaltyWeight: 0.0\n        description: Keep compressor within design\n</code></pre> <p>Hook this into <code>ProductionOptimizationSpecLoader.load(...)</code> with metric lambdas for <code>throughput</code> and <code>compressorUtil</code>, then call <code>optimizer.optimizeScenarios(...)</code> to exercise the same workflow shown in the regression test while generating Markdown comparison tables for reports.</p>"},{"location":"wiki/bottleneck_analysis/#real-world-spec-driven-workflows","title":"Real-world spec-driven workflows","text":"<p>The same YAML/JSON specs can be extended to mirror common operational optimization tasks instead of toy throughput maximization:</p> <p>1. Energy minimization across compressor trains</p> <p>Model a three-stage compression train with interstage coolers and set the objective to minimize total power while still honoring a required discharge pressure and anti-surge utilization headroom:</p> <pre><code>scenarios:\n  - name: energy_min_train\n    process: c_train\n    feedStream: feed_gas\n    lowerBound: 40.0\n    upperBound: 90.0\n    rateUnit: bara # target discharge pressure instead of flow\n    variables:\n      - name: stage1_pressure\n        unit: bara\n        lowerBound: 30.0\n        upperBound: 45.0\n        stream: stage1_out\n      - name: stage2_pressure\n        unit: bara\n        lowerBound: 50.0\n        upperBound: 70.0\n        stream: stage2_out\n    objectives:\n      - name: minimize_power\n        metric: totalPowerMw\n        weight: -1.0\n        type: MAXIMIZE\n    constraints:\n      - name: discharge_pressure\n        metric: dischargePressure\n        limit: 90.0\n        direction: GREATER_THAN\n        severity: HARD\n        description: Keep export pressure above spec\n      - name: anti_surge_headroom\n        metric: minSurgeMargin\n        limit: 1.1\n        direction: GREATER_THAN\n        severity: HARD\n        description: Maintain 10% margin to surge lines on all compressors\n    searchMode: PARTICLE_SWARM_SCORE\n    inertiaWeight: 0.8\n    swarmSize: 24\n</code></pre> <p>Wire metrics via the spec loader to compute <code>totalPowerMw</code> from compressor duties (sum of <code>getShaftWork()</code> per stage) and <code>minSurgeMargin</code> from a helper that returns the lowest ratio of operating flow to surge flow across the train. Inspect <code>result.getIterationHistory()</code> to see where power flattens out\u2014large step sizes in the swarm can reveal solver-cost bottlenecks when each iteration requires full thermodynamics and anti-surge calculations.</p> <p>2. Choke optimization under sand/erosion constraints</p> <p>Use a sand production limit and downstream separator capacity as hard constraints while maximizing oil throughput in a well/test separator setup. The choke opening becomes the manipulated variable, and penalty objectives can keep gas-lift rates reasonable:</p> <pre><code>scenarios:\n  - name: choke_max_oil\n    process: wellpad\n    feedStream: wellhead\n    lowerBound: 10.0\n    upperBound: 80.0\n    rateUnit: percent_open\n    variables:\n      - name: choke_opening\n        unit: percent\n        lowerBound: 10.0\n        upperBound: 80.0\n        stream: choke_setting\n    objectives:\n      - name: oil_rate\n        metric: stabilizedOilBpd\n        weight: 1.0\n        type: MAXIMIZE\n      - name: gaslift_penalty\n        metric: gasliftRate\n        weight: -0.05\n        type: MAXIMIZE\n    constraints:\n      - name: sand_limit\n        metric: sandRate\n        limit: 20.0\n        direction: LESS_THAN\n        severity: HARD\n        description: Protect downstream erosion limit (kg/day)\n      - name: separator_capacity\n        metric: separatorUtil\n        limit: 0.95\n        direction: LESS_THAN\n        severity: HARD\n        description: Keep test separator within design envelope\n    searchMode: BINARY_FEASIBILITY\n</code></pre> <p>For this case, metric functions can map to production tests: <code>sandRate</code> computed from empirical correlations, <code>separatorUtil</code> derived from <code>getCapacityDuty()/getCapacityMax()</code>, and <code>gasliftRate</code> pulled from a gas-lift valve set point. The feasibility-first search will quickly highlight whether the sand constraint or separator capacity is the binding limitation, while the iteration history logs identify performance hotspots (e.g., separator flash calculations dominating runtime during tight binary searches).</p>"},{"location":"wiki/bottleneck_analysis/#debottlenecking-studies","title":"Debottlenecking Studies","text":"<p>Once the bottleneck is identified (e.g., a compressor), you can simulate a \"debottlenecking\" project: 1.  Increase the capacity of the bottleneck equipment (e.g., <code>compressor.getMechanicalDesign().maxDesignPower = newPower</code>). 2.  Re-run the optimization loop. 3.  Identify the new bottleneck and the new maximum production rate. 4.  Calculate the ROI of the upgrade based on the increased production.</p>"},{"location":"wiki/choke_collapse_psd_protection/","title":"Choke Collapse PSD Protection Scenario","text":""},{"location":"wiki/choke_collapse_psd_protection/#overview","title":"Overview","text":"<p>This document describes a critical safety scenario where an inlet choke valve (throttle valve) suddenly fails open to 100%, causing rapid pressure rise in downstream equipment. A Process Shutdown (PSD) valve monitors the pressure and automatically closes when a High-High (HIHI) alarm is triggered, protecting the system from overpressure.</p>"},{"location":"wiki/choke_collapse_psd_protection/#scenario-description","title":"Scenario Description","text":""},{"location":"wiki/choke_collapse_psd_protection/#normal-operation","title":"Normal Operation","text":"<ul> <li>High pressure feed: 100 bara at inlet</li> <li>Choke valve: Operates at 30% opening to control pressure</li> <li>Target downstream pressure: ~50 bara</li> <li>PSD valve: 100% open (normally passing flow)</li> <li>HIHI alarm setpoint: 55 bara</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#failure-event","title":"Failure Event","text":"<ol> <li>t = 0.0 s: Choke valve fails open to 100%</li> <li>t = 0-3 s: Pressure rises rapidly from 50 to 56 bara</li> <li>t = 2.5 s: Pressure reaches 55 bara, triggering HI alarm</li> <li>t = 3.0 s: Pressure exceeds HIHI setpoint, PSD valve trips and closes</li> <li>t &gt; 3.0 s: PSD valve fully closed, system isolated and protected</li> </ol>"},{"location":"wiki/choke_collapse_psd_protection/#protection-response","title":"Protection Response","text":"<ul> <li>Response time: 3 seconds from failure to PSD closure</li> <li>Maximum pressure: 56 bara (contained below safe limits)</li> <li>PSD closure time: 2 seconds (fast-acting)</li> <li>Trip latching: PSD remains closed until manual reset</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#implementation","title":"Implementation","text":""},{"location":"wiki/choke_collapse_psd_protection/#system-configuration","title":"System Configuration","text":"<pre><code>// High pressure feed at 100 bara\nSystemInterface feedGas = new SystemSrkEos(273.15 + 40.0, 100.0);\nfeedGas.addComponent(\"methane\", 85.0);\nfeedGas.addComponent(\"ethane\", 8.0);\n// ... add other components\nfeedGas.setMixingRule(\"classic\");\n\nStream feedStream = new Stream(\"High Pressure Feed\", feedGas);\nfeedStream.setFlowRate(5000.0, \"kg/hr\");\nfeedStream.setPressure(100.0, \"bara\");\n\n// Choke valve - normally at 30% opening\nThrottlingValve chokeValve = new ThrottlingValve(\"Inlet Choke Valve\", feedStream);\nchokeValve.setPercentValveOpening(30.0);\nchokeValve.setOutletPressure(50.0);\n\nStream chokeOutlet = new Stream(\"Choke Outlet\", chokeValve.getOutletStream());\n\n// PSD valve for protection\nPSDValve psdValve = new PSDValve(\"PSD Inlet Protection\", chokeOutlet);\npsdValve.setPercentValveOpening(100.0);\npsdValve.setClosureTime(2.0); // Fast closure\n\n// Pressure transmitter with HIHI alarm\nPressureTransmitter pressureTransmitter = new PressureTransmitter(\n    \"Separator Inlet PT\", chokeOutlet);\n\nAlarmConfig alarmConfig = AlarmConfig.builder()\n    .highHighLimit(55.0)\n    .highLimit(52.0)\n    .deadband(0.5)\n    .delay(1.0)\n    .unit(\"bara\")\n    .build();\npressureTransmitter.setAlarmConfig(alarmConfig);\n\n// Link PSD valve to pressure transmitter\npsdValve.linkToPressureTransmitter(pressureTransmitter);\n</code></pre>"},{"location":"wiki/choke_collapse_psd_protection/#simulating-the-failure","title":"Simulating the Failure","text":"<pre><code>// Run initial steady state\nfeedStream.run();\nchokeValve.run();\npsdValve.run();\n\n// FAILURE EVENT: Choke valve fails open\nchokeValve.setPercentValveOpening(100.0);\n\n// Simulate dynamic response\ndouble timeStep = 0.5; // 0.5 second time steps\nfor (double time = 0.0; time &lt;= simulationTime; time += timeStep) {\n    // Run process\n    feedStream.run();\n    chokeValve.run();\n    chokeOutlet.run();\n\n    // Evaluate alarm\n    pressureTransmitter.evaluateAlarm(\n        chokeOutlet.getPressure(\"bara\"), timeStep, time);\n\n    // Run PSD transient behavior\n    psdValve.runTransient(timeStep, UUID.randomUUID());\n\n    // Check if PSD tripped\n    if (psdValve.hasTripped()) {\n        System.out.println(\"PSD valve tripped at \" + time + \" s\");\n        break;\n    }\n}\n</code></pre>"},{"location":"wiki/choke_collapse_psd_protection/#test-results","title":"Test Results","text":""},{"location":"wiki/choke_collapse_psd_protection/#choke-collapse-test","title":"Choke Collapse Test","text":"<pre><code>===== CHOKE COLLAPSE SCENARIO =====\nInitial Configuration:\n  Feed pressure: 100.0 bara\n  Choke opening: 30.0% (normal operation)\n  PSD opening: 100.0% (normal operation)\n  PSD HIHI setpoint: 55.0 bara\n\nTime (s) | Choke Opening | Pressure (bara) | Alarm State | PSD Opening | PSD Tripped\n---------|---------------|-----------------|-------------|-------------|------------\n    0.0  |     100.0%    |      50.00      |   NONE      |    100.0%   |    NO\n    0.5  |     100.0%    |      51.00      |   NONE      |    100.0%   |    NO\n    1.0  |     100.0%    |      52.00      |   NONE      |    100.0%   |    NO\n    1.5  |     100.0%    |      53.00      |   HI        |    100.0%   |    NO\n    2.0  |     100.0%    |      54.00      |   HI        |    100.0%   |    NO\n    2.5  |     100.0%    |      55.00      |   HI        |    100.0%   |    NO\n    3.0  |     100.0%    |      56.00      |   HIHI      |      0.0%   |    YES\n</code></pre> <p>Results: - \u2713 Choke failed open at t = 0.0 s - \u2713 PSD valve tripped at t = 3.0 s - \u2713 Maximum pressure: 56.00 bara (safely contained) - \u2713 System protected from overpressure</p>"},{"location":"wiki/choke_collapse_psd_protection/#recovery-test","title":"Recovery Test","text":"<pre><code>===== CHOKE REPAIR AND PSD RESET TEST =====\nStep 1: Simulating choke collapse...\n  PSD tripped at 56.0 bara\n\nStep 2: Repairing choke valve (returning to 30% opening)...\n  Choke repaired and pressure returned to 50 bara\n\nStep 3: Attempting to open PSD valve while still tripped...\n  \u2713 PSD correctly prevents opening while tripped\n\nStep 4: Resetting PSD valve...\n  PSD valve reset complete\n\nStep 5: Opening PSD valve to resume operation...\n  \u2713 PSD successfully opened to 100.0%\n\n===== RESET TEST SUMMARY =====\n\u2713 Choke collapse triggered PSD trip\n\u2713 Choke repaired (returned to 30% opening)\n\u2713 PSD prevented opening while tripped\n\u2713 PSD reset successful\n\u2713 System ready to resume normal operation\n</code></pre>"},{"location":"wiki/choke_collapse_psd_protection/#key-features-demonstrated","title":"Key Features Demonstrated","text":""},{"location":"wiki/choke_collapse_psd_protection/#1-rapid-failure-detection","title":"1. Rapid Failure Detection","text":"<ul> <li>Pressure rise detected within 1.5 seconds</li> <li>HI alarm activated at 53 bara</li> <li>HIHI alarm activated at 56 bara</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#2-automatic-protection","title":"2. Automatic Protection","text":"<ul> <li>PSD valve automatically trips on HIHI alarm</li> <li>Fast closure (2 seconds) minimizes pressure overshoot</li> <li>No manual intervention required for trip</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#3-trip-latching","title":"3. Trip Latching","text":"<ul> <li>PSD valve remains closed after trip</li> <li>Cannot be opened while in tripped state</li> <li>Requires manual reset before operation can resume</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#4-recovery-procedure","title":"4. Recovery Procedure","text":"<ol> <li>Repair/replace failed choke valve</li> <li>Verify pressure has returned to safe levels</li> <li>Reset PSD valve to clear trip state</li> <li>Manually open PSD valve to resume operation</li> </ol>"},{"location":"wiki/choke_collapse_psd_protection/#safety-analysis","title":"Safety Analysis","text":""},{"location":"wiki/choke_collapse_psd_protection/#layers-of-protection","title":"Layers of Protection","text":"Layer Device Setpoint Action Response Time 1 HI Alarm 52 bara Operator notification Immediate 2 HIHI Alarm 55 bara Triggers PSD closure 1 second delay 3 PSD Valve On HIHI Closes to 0% 2 seconds"},{"location":"wiki/choke_collapse_psd_protection/#effectiveness","title":"Effectiveness","text":"<ul> <li>Pressure containment: Maximum 56 bara vs. 100 bara feed pressure</li> <li>Response time: 3 seconds from failure to isolation</li> <li>Protection margin: 11% overshoot above HIHI setpoint</li> <li>Recovery capability: System can be safely restarted after repair</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#best-practices","title":"Best Practices","text":""},{"location":"wiki/choke_collapse_psd_protection/#1-alarm-configuration","title":"1. Alarm Configuration","text":"<pre><code>AlarmConfig alarmConfig = AlarmConfig.builder()\n    .highHighLimit(55.0)      // Trip setpoint\n    .highLimit(52.0)          // Early warning\n    .deadband(0.5)            // Prevent chattering\n    .delay(1.0)               // Confirmation time\n    .unit(\"bara\")\n    .build();\n</code></pre>"},{"location":"wiki/choke_collapse_psd_protection/#2-psd-valve-settings","title":"2. PSD Valve Settings","text":"<ul> <li>Closure time: Fast enough to prevent overpressure (2-3 seconds typical)</li> <li>Trip enabled: Always enabled during normal operation</li> <li>Reset requirement: Manual reset prevents inadvertent restart</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#3-testing","title":"3. Testing","text":"<ul> <li>Test PSD trip function regularly</li> <li>Simulate failure scenarios in training mode</li> <li>Verify alarm setpoints match design basis</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#related-safety-devices","title":"Related Safety Devices","text":"<p>This scenario complements other safety devices in NeqSim:</p>"},{"location":"wiki/choke_collapse_psd_protection/#comparison-matrix","title":"Comparison Matrix","text":"Feature PSD Valve Safety Valve (PSV) Rupture Disk Activation HIHI alarm Set pressure Burst pressure Response Fast closure Opens to relieve Bursts open Reset Manual Self-resetting Requires replacement Use Case Process shutdown Overpressure relief Last-resort protection Typical Setpoint 55 bara (HIHI) 55 bara (set) 65 bara (burst)"},{"location":"wiki/choke_collapse_psd_protection/#integrated-protection-strategy","title":"Integrated Protection Strategy","text":"<p>For complete system protection, use all three in series:</p> <ol> <li>PSD Valve (Primary): Isolates on abnormal process conditions</li> <li>PSV (Secondary): Relieves pressure if PSD fails</li> <li>Rupture Disk (Ultimate): Prevents catastrophic failure</li> </ol>"},{"location":"wiki/choke_collapse_psd_protection/#example-application","title":"Example Application","text":""},{"location":"wiki/choke_collapse_psd_protection/#production-separator-protection","title":"Production Separator Protection","text":"<pre><code>// High pressure feed from wellhead\nStream wellheadStream = new Stream(\"Wellhead\", highPressureGas);\nwellheadStream.setPressure(100.0, \"bara\");\n\n// Choke valve for flow control\nThrottlingValve chokeValve = new ThrottlingValve(\"Production Choke\", wellheadStream);\nchokeValve.setPercentValveOpening(30.0);\n\n// PSD valve for emergency isolation\nPSDValve psdValve = new PSDValve(\"ESD Inlet\", chokeValve.getOutletStream());\npsdValve.linkToPressureTransmitter(pressureTransmitter);\n\n// Production separator\nSeparator separator = new Separator(\"Production Sep\", psdValve.getOutletStream());\nseparator.setInternalDiameter(1.5);\nseparator.setSeparatorLength(4.0);\n\n// PSV for overpressure relief\nSafetyValve psv = new SafetyValve(\"PSV-101\", separator.getGasOutStream());\npsv.setSetPressure(55.0, \"bara\");\n\n// Rupture disk as last resort\nRuptureDisk ruptureDisk = new RuptureDisk(\"RD-101\", separator.getGasOutStream());\nruptureDisk.setBurstPressure(65.0, \"bara\");\n</code></pre>"},{"location":"wiki/choke_collapse_psd_protection/#references","title":"References","text":"<ul> <li>PSD Valve HIHI Trip Documentation</li> <li>Safety Valve (PSV) Documentation</li> <li>Rupture Disk Documentation</li> <li>Process Alarm System</li> </ul>"},{"location":"wiki/choke_collapse_psd_protection/#test-class","title":"Test Class","text":"<p>Complete test implementation: <code>neqsim.process.equipment.valve.ChokeCollapsePSDProtectionTest</code></p> <p>Run tests: <pre><code>mvn test -Dtest=ChokeCollapsePSDProtectionTest\n</code></pre></p>"},{"location":"wiki/distillation_column/","title":"Distillation column algorithm","text":"<p>This document describes the mathematical model and solver implementations that power the <code>DistillationColumn</code> class in NeqSim. The class maps directly to the files <code>src/main/java/neqsim/process/equipment/distillation/DistillationColumn.java</code> and <code>DistillationColumnMatrixSolver.java</code>.</p>"},{"location":"wiki/distillation_column/#governing-equations","title":"Governing equations","text":"<p>Each ideal-equilibrium tray satisfies the familiar MESH relationships:</p> <ol> <li>Total mass balance (tray j)</li> </ol> <p>[    V_{j-1} + L_{j+1} + F_j = V_j + L_j    ]</p> <ol> <li>Component balances</li> </ol> <p>[    V_{j-1} y_{i,j-1} + L_{j+1} x_{i,j+1} + F_j z_{i,j}    = V_j y_{i,j} + L_j x_{i,j}    ]</p> <ol> <li>Phase equilibrium (K-values)</li> </ol> <p>[    y_{i,j} = K_{i,j} x_{i,j}, \\qquad K_{i,j} = \\frac{\\hat f_{i,j}^{\\text{vap}}}{\\hat f_{i,j}^{\\text{liq}}}    ]</p> <ol> <li>Energy balance</li> </ol> <p>[    V_{j-1} h_{j-1}^{V} + L_{j+1} h_{j+1}^{L} + F_j h_j^{F} + Q_j    = V_j h_j^{V} + L_j h_j^{L}    ]</p> <p>NeqSim evaluates fugacity-based K-values and molar enthalpies through the active <code>SystemInterface</code>. The matrix solver also uses linearized component balances in tridiagonal form:</p> \\[ A_j l_{i,j-1} + B_j l_{i,j} + C_j l_{i,j+1} = D_{i,j} \\] <p>with stripping factors \\(S_j = K_{i,j} V_j / L_j\\) embedded in the diagonal terms.</p> <p>Temperature updates rely on the log-Newton step derived from \\(\\sum_i y_{i,j}=1\\):</p> \\[ \\Delta T_j = -\\frac{\\ln(\\sum_i K_{i,j} x_{i,j}) R T_j^2}{h_j^{V} - h_j^{L}} \\] <p>The code limits \\(\\Delta T_j\\) to \u00b15 K and enforces bounds of 50\u20131000 K for numerical stability.</p>"},{"location":"wiki/distillation_column/#column-preparation","title":"Column preparation","text":"<ol> <li>Feed assignment \u2013 feeds are attached with <code>addFeedStream</code>; unassigned feeds are    auto-placed near matching tray temperatures.</li> <li>Temperature seeding \u2013 <code>init()</code> runs the lowest feed tray, extrapolates temperatures    towards condenser and reboiler, and links neighbouring trays with vapour/liquid streams.</li> <li>Pressure profile \u2013 <code>prepareColumnForSolve()</code> imposes a linear pressure drop between the    configured bottom and top pressures (or inferred tray values when unspecified).</li> </ol>"},{"location":"wiki/distillation_column/#solver-implementations","title":"Solver implementations","text":"Solver Class/Method Strategy Notes <code>DIRECT_SUBSTITUTION</code> <code>solveSequential()</code> Classic two-sweep sequential substitution (liquids down, vapours up) with adaptive relaxation on temperatures and streams. Converges robustly for well-behaved systems; default choice. <code>DAMPED_SUBSTITUTION</code> <code>runDamped()</code> Same equations as direct substitution but starts with a user-defined fixed relaxation factor before enabling adaptation. Useful for stiff columns where the default step overshoots. <code>INSIDE_OUT</code> <code>solveInsideOut()</code> Quadrat-structure inside-out method: streams are relaxed against previous iterates while tray properties update using enthalpy-driven temperature corrections. Balances mass/energy less frequently to reduce cost and supports a polishing phase for tight tolerances. <code>BROYDEN</code> (experimental) <code>runBroyden()</code> Applies a secant correction on tray temperatures, effectively mixing current and previous deltas. Handy for rapid feasibility studies but less stable than inside-out. <code>MATRIX_SOLVER</code> <code>DistillationColumnMatrixSolver.solve()</code> Builds component flow equations into a TDMA system, blends constant molar overflow (CMO) estimates with sum-rate flows, then updates temperatures via the log-Newton scheme above. Eliminates explicit stream tearing by solving component balances directly; still refines temperatures iteratively."},{"location":"wiki/distillation_column/#sequential-substitution-details","title":"Sequential substitution details","text":"<ul> <li>Upward sweep: for trays below the lowest feed, new liquid draws from the tray above.</li> <li>Downward sweep: for trays above the lowest feed, vapour comes from the tray below.</li> <li>Convergence metric: average absolute temperature change.</li> <li>Relaxation policy: decreases when combined residual (temperature, mass, energy) grows by   more than 5 %, increases when it shrinks by more than 2 %.</li> <li>Default tolerances were tightened in recent iterations (temperature to 0.01 K, mass/energy to   1e-4 relative) to prevent premature termination when using highly non-ideal feeds.</li> </ul>"},{"location":"wiki/distillation_column/#inside-out-specifics","title":"Inside-out specifics","text":"<ul> <li>Maintains cached vapour/liquid streams (<code>previousGasStreams</code>, <code>previousLiquidStreams</code>).</li> <li><code>applyRelaxation()</code> mixes flow, temperature, pressure, and composition prior to cloning.</li> <li>Mass and energy balances are evaluated every few iterations (stride depends on tray count) and   more often near convergence.</li> <li>Optional polishing stage tightens tolerances to 1e-5 K / relative mass 1e-4 when base tolerances   are met but the user requires stricter balances.</li> <li>Tracks per-iteration mass and energy residuals alongside relaxed stream norms so operators can   audit the inside-out trajectory when debugging column stability.</li> <li>Records the peak relaxation factors applied to trays, providing a quick signal when the column   required aggressive damping to converge.</li> </ul>"},{"location":"wiki/distillation_column/#matrix-solver-specifics","title":"Matrix solver specifics","text":"<ul> <li>Precomputes feed molar contributions (<code>feedFlows</code>, vapor/liquid split) per tray.</li> <li>Builds stripping factors \\(S_j\\) to couple component molar flows between neighbouring trays.</li> <li>Uses constant molar overflow anchors (bottom vapour, top liquid) blended with instantaneous   sum-rate flows: \\( L_j = w L_{\\text{CMO},j} + (1-w) L_{\\text{SR},j} \\) with default   \\(w = 0.95\\).</li> <li>Applies damping on both component flows and total holdups to keep the linear update stable.</li> <li>Temperature correction follows the same log-Newton formula, requiring <code>system.init(2)</code> for   enthalpy data and <code>system.init(1)</code> afterwards to refresh K-values.</li> </ul>"},{"location":"wiki/distillation_column/#result-handling","title":"Result handling","text":"<p>Once any solver converges, the top gas outlet (<code>gasOutStream</code>) and bottom liquid outlet (<code>liquidOutStream</code>) are cloned from the respective trays. Mass, energy, and iteration statistics are exposed through getters such as <code>getLastIterationCount()</code>, <code>getLastMassResidual()</code>, and <code>getLastEnergyResidual()</code>.</p>"},{"location":"wiki/distillation_column/#further-improvements","title":"Further improvements","text":"<ul> <li>Support user-defined pressure profiles or tray-by-tray pressure drops.</li> <li>Provide Jacobian-based temperature updates for faster convergence with highly non-ideal feeds.</li> <li>Persist diagnostic data (residual history, damping schedule) for easier profiling across   solver types.</li> </ul>"},{"location":"wiki/esd_fire_alarm_system/","title":"ESD Fire Alarm System with Voting Logic","text":""},{"location":"wiki/esd_fire_alarm_system/#overview","title":"Overview","text":"<p>This implementation demonstrates a comprehensive Emergency Shutdown (ESD) system with fire alarm voting logic in NeqSim. The system showcases how multiple fire detectors can be used in a voting configuration to prevent spurious trips while ensuring safety when multiple alarms confirm a fire event.</p>"},{"location":"wiki/esd_fire_alarm_system/#key-features","title":"Key Features","text":""},{"location":"wiki/esd_fire_alarm_system/#1-firedetector-measurement-device","title":"1. FireDetector Measurement Device","text":"<p>Location: <code>src/main/java/neqsim/process/measurementdevice/FireDetector.java</code></p> <p>A new binary sensor for fire detection with features: - Binary state: fire detected (1.0) or no fire (0.0) - Configurable detection threshold and delay - Location/zone identification - Integration with alarm system - Signal level simulation for gradual detection - Reset capability for testing</p> <p>Example Usage: <pre><code>FireDetector fireDetector = new FireDetector(\"FD-101\", \"Separator Area - North\");\nfireDetector.setDetectionThreshold(0.5);\nfireDetector.setDetectionDelay(1.0);\n\n// Configure alarm\nAlarmConfig alarmConfig = AlarmConfig.builder()\n    .highLimit(0.5)\n    .delay(1.0)\n    .unit(\"binary\")\n    .build();\nfireDetector.setAlarmConfig(alarmConfig);\n\n// Detect fire\nfireDetector.detectFire();\n\n// Check status\nif (fireDetector.isFireDetected()) {\n    System.out.println(\"Fire detected!\");\n}\n</code></pre></p>"},{"location":"wiki/esd_fire_alarm_system/#2-voting-logic-patterns","title":"2. Voting Logic Patterns","text":""},{"location":"wiki/esd_fire_alarm_system/#2-out-of-2-voting","title":"2-out-of-2 Voting","text":"<p>Requires both fire detectors to activate before triggering ESD. Provides: - High confidence in fire event - Prevents single spurious alarm trips - Simple redundancy pattern</p>"},{"location":"wiki/esd_fire_alarm_system/#2-out-of-3-voting","title":"2-out-of-3 Voting","text":"<p>Any two of three detectors trigger ESD. Provides: - Greater reliability (tolerates one failed detector) - Still prevents spurious trips - Industry-standard safety configuration</p> <p>Implementation: <pre><code>// Count active alarms\nint activeAlarms = (fireDetector1.isFireDetected() ? 1 : 0)\n                 + (fireDetector2.isFireDetected() ? 1 : 0)\n                 + (fireDetector3.isFireDetected() ? 1 : 0);\n\n// Apply voting logic\nboolean esdShouldActivate = (activeAlarms &gt;= 2);\n\nif (esdShouldActivate &amp;&amp; !bdValve.isActivated()) {\n    bdValve.activate();\n    gasSplitter.setSplitFactors(new double[] {0.0, 1.0}); // Redirect to blowdown\n}\n</code></pre></p>"},{"location":"wiki/esd_fire_alarm_system/#3-complete-esd-blowdown-sequence","title":"3. Complete ESD Blowdown Sequence","text":"<p>The test demonstrates a realistic ESD scenario:</p> <p>Phase 1: Normal Operation (t=0-5s) - Process operating normally - Gas flows to process - No fire alarms active - BD valve closed</p> <p>Phase 2: First Fire Alarm (t=5s) - Fire detector FD-101 activates - Only 1 of 2 required alarms - ESD does NOT activate (awaiting confirmation) - System continues operating</p> <p>Phase 3: Second Fire Alarm (t=10s) - Fire detector FD-102 activates - 2 of 2 required alarms confirmed - ESD ACTIVATES - Flow redirected to blowdown - BD valve begins opening</p> <p>Phase 4: Blowdown with Emissions Tracking (t=10-20s) - BD valve opens over 5 seconds - Gas flows through orifice to flare - Flare combusts gas and tracks:   - Instantaneous heat release (MW)   - Instantaneous CO2 emission rate (kg/s)   - Cumulative heat released (GJ)   - Cumulative CO2 emissions (kg)   - Total gas burned (kg)</p>"},{"location":"wiki/esd_fire_alarm_system/#test-results","title":"Test Results","text":""},{"location":"wiki/esd_fire_alarm_system/#test-testesdwithtwofirealarmvoting","title":"Test: testESDWithTwoFireAlarmVoting","text":"<p>System Configuration: - Separator at 50 bara - Gas flow: 10,000 kg/hr (methane-rich mixture) - Two fire detectors with alarm configuration - Blowdown valve with 5-second opening time - Flare header at 1.5 bara</p> <p>Simulation Results (20-second blowdown): <pre><code>Time (s) | FD-101 | FD-102 | Alarms | BD Open (%) | BD Flow (kg/hr) | Flare Heat (MW) | CO2 Rate (kg/s) | Cumul Heat (GJ) | Cumul CO2 (kg)\n---------|--------|--------|--------|-------------|-----------------|-----------------|-----------------|-----------------|----------------\n     0.0 |   FIRE |   FIRE |      2 |         0.0 |        817,553  |        11,657   |         626.4   |           11.66 |          626.4\n     2.0 |   FIRE |   FIRE |      2 |         0.0 |        814,203  |        11,610   |         623.8   |           34.90 |         1875.3\n    10.0 |   FIRE |   FIRE |      2 |        20.0 |        803,959  |        11,464   |         616.0   |          127.08 |         6828.3\n    14.0 |   FIRE |   FIRE |      2 |       100.0 |        800,259  |        11,411   |         613.1   |          172.80 |         9285.0\n    20.0 |   FIRE |   FIRE |      2 |       100.0 |        795,957  |        11,349   |         609.8   |          241.04 |        12951.8\n</code></pre></p> <p>Final Summary: - \u2713 Total gas blown down: 4,695.7 kg - \u2713 Total heat released: 241.04 GJ (67 MWh) - \u2713 Total CO2 emissions: 12,951.8 kg (13 tonnes)</p>"},{"location":"wiki/esd_fire_alarm_system/#test-testesdwith2outof3firealarmvoting","title":"Test: testESDWith2OutOf3FireAlarmVoting","text":"<p>Tests voting combinations: 1. No alarms \u2192 ESD: NO 2. One alarm (FD-101) \u2192 ESD: NO 3. Two alarms (FD-101 + FD-102) \u2192 ESD: YES 4. Three alarms (all active) \u2192 ESD: YES 5. Reset one detector (FD-103) \u2192 ESD maintained with 2 remaining 6. Reset another (FD-102) \u2192 Only 1 active, but BD valve stays latched</p> <p>Key Safety Feature: BD valve remains activated even when alarms clear, requiring manual reset to prevent automatic system restoration during emergency.</p>"},{"location":"wiki/esd_fire_alarm_system/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    ESD FIRE ALARM SYSTEM                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nFire Detectors:                  Voting Logic:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  FD-101    \u2502\u2500\u2500\u2500\u2500\u2500\u2510           \u2502 Count Active    \u2502\n\u2502  (North)   \u2502     \u2502           \u2502 Alarms &gt;= 2?    \u2502\u2500\u2500\u25ba ESD Trigger\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                 \u2502\n                   \u2502           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  FD-102    \u2502\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  (South)   \u2502     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n                   \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  FD-103    \u2502\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502  (East)    \u2502 [Optional - for 2-out-of-3]\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nProcess Flow:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Separator  \u2502\u2500\u2500\u2500\u2500\u25ba\u2502 Splitter \u2502\u2500\u2500\u2500\u2500\u25ba\u2502  To Process \u2502\n\u2502  50 bara   \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2502\n                        \u2502 (ESD redirects flow)\n                        \u25bc\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502 BD Valve    \u2502\n                  \u2502 (opens 5s)  \u2502\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502  Orifice    \u2502 (flow control)\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502\n                        \u25bc\n                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                  \u2502   Flare     \u2502 \u25c4\u2500\u2500 Heat &amp; CO2\n                  \u2502  1.5 bara   \u2502     Calculations\n                  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"wiki/esd_fire_alarm_system/#emissions-calculations","title":"Emissions Calculations","text":"<p>The flare tracks cumulative values during blowdown:</p> <p>Heat Release: - Based on Lower Calorific Value (LCV) of gas - Calculated as: <code>Q = LCV \u00d7 Flow_rate</code> - Tracked in real-time and cumulative (GJ)</p> <p>CO2 Emissions: - Based on carbon content of components - Calculated as: <code>CO2 = \u03a3(moles_C \u00d7 MW_CO2)</code> - Assumes complete combustion - Tracked instantaneously (kg/s) and cumulative (kg)</p> <p>Gas Burned: - Total mass flow to flare integrated over time - Reported in kg and tonnes</p>"},{"location":"wiki/esd_fire_alarm_system/#test-execution","title":"Test Execution","text":"<p>Run all ESD fire alarm tests: <pre><code>mvnw test -Dtest=ESDFireAlarmSystemTest\n</code></pre></p> <p>Run specific test: <pre><code>mvnw test -Dtest=ESDFireAlarmSystemTest#testESDWithTwoFireAlarmVoting\n</code></pre></p>"},{"location":"wiki/esd_fire_alarm_system/#integration-points","title":"Integration Points","text":""},{"location":"wiki/esd_fire_alarm_system/#with-existing-neqsim-components","title":"With Existing NeqSim Components","text":"<p>Compatible Equipment: - <code>Separator</code> - Source vessel for blowdown - <code>Splitter</code> - Flow routing between process and blowdown - <code>BlowdownValve</code> - ESD-activated valve with transient opening - <code>Orifice</code> - ISO 5167 flow restriction - <code>Flare</code> - Combustion and emissions tracking - <code>PushButton</code> - Manual ESD activation (can be combined with fire alarms)</p> <p>Alarm System Integration: - <code>FireDetector</code> extends <code>MeasurementDeviceBaseClass</code> - Compatible with <code>AlarmConfig</code>, <code>AlarmState</code>, <code>AlarmLevel</code> - Can be used with controllers and process alarm managers - Supports delay, deadband, and threshold configuration</p>"},{"location":"wiki/esd_fire_alarm_system/#safety-instrumented-systems-sis-applications","title":"Safety Instrumented Systems (SIS) Applications","text":"<p>This implementation demonstrates concepts used in: - Fire and gas (F&amp;G) detection systems - Emergency shutdown (ESD) systems - Pressure relief and blowdown systems - Flare load management - Emissions tracking and reporting</p>"},{"location":"wiki/esd_fire_alarm_system/#best-practices-demonstrated","title":"Best Practices Demonstrated","text":"<ol> <li>Voting Logic: Prevents spurious trips while maintaining safety</li> <li>Safety Latching: BD valve stays activated until manual reset</li> <li>Alarm Confirmation: Requires multiple independent sensors</li> <li>Dynamic Simulation: Realistic transient behavior during blowdown</li> <li>Emissions Tracking: Cumulative tracking for regulatory compliance</li> <li>Comprehensive Testing: Both unit tests and integration scenarios</li> </ol>"},{"location":"wiki/esd_fire_alarm_system/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions: - Integration with gas detection sensors (LEL, toxic gas) - Temperature-based fire detection - Flame pattern recognition - Integration with process alarm managers - Automatic splitter control on ESD - Multiple ESD levels (ESD-1, ESD-2, etc.) - Heat detector integration - Smoke detector support - Time-stamped alarm logging - Alarm priority escalation</p>"},{"location":"wiki/esd_fire_alarm_system/#references","title":"References","text":"<ul> <li>ESD Blowdown System: <code>docs/ESD_BLOWDOWN_SYSTEM.md</code></li> <li>Process Control: <code>docs/wiki/process_control.md</code></li> <li>Test Overview: <code>docs/wiki/test-overview.md</code></li> <li>Alarm System: <code>src/main/java/neqsim/process/alarm/</code></li> </ul>"},{"location":"wiki/esd_fire_alarm_system/#files-createdmodified","title":"Files Created/Modified","text":""},{"location":"wiki/esd_fire_alarm_system/#new-files","title":"New Files:","text":"<ol> <li><code>src/main/java/neqsim/process/measurementdevice/FireDetector.java</code></li> <li><code>src/test/java/neqsim/process/equipment/valve/ESDFireAlarmSystemTest.java</code></li> <li><code>docs/wiki/esd_fire_alarm_system.md</code></li> </ol>"},{"location":"wiki/esd_fire_alarm_system/#key-dependencies","title":"Key Dependencies:","text":"<ul> <li><code>BlowdownValve</code> - ESD-activated valve</li> <li><code>Flare</code> - Emissions calculations</li> <li><code>AlarmConfig</code> - Alarm configuration</li> <li><code>Orifice</code> - Flow control</li> <li><code>Separator</code> - Dynamic vessel simulation</li> </ul>"},{"location":"wiki/esd_fire_alarm_system/#example-implementing-custom-voting-logic","title":"Example: Implementing Custom Voting Logic","text":"<pre><code>/**\n * Custom voting logic class for ESD systems.\n */\npublic class ESDVotingLogic {\n    private final List&lt;FireDetector&gt; detectors;\n    private final int requiredAlarms;\n    private final BlowdownValve bdValve;\n\n    public ESDVotingLogic(BlowdownValve bdValve, int requiredAlarms, \n                          FireDetector... detectors) {\n        this.bdValve = bdValve;\n        this.requiredAlarms = requiredAlarms;\n        this.detectors = Arrays.asList(detectors);\n    }\n\n    public void evaluate() {\n        int activeAlarms = (int) detectors.stream()\n                                          .filter(FireDetector::isFireDetected)\n                                          .count();\n\n        if (activeAlarms &gt;= requiredAlarms &amp;&amp; !bdValve.isActivated()) {\n            bdValve.activate();\n            System.out.println(\"ESD ACTIVATED: \" + activeAlarms + \n                             \" of \" + detectors.size() + \" alarms active\");\n        }\n    }\n\n    public boolean isESDActive() {\n        return bdValve.isActivated();\n    }\n}\n\n// Usage:\nESDVotingLogic esdLogic = new ESDVotingLogic(bdValve, 2, \n                                             fireDetector1, \n                                             fireDetector2, \n                                             fireDetector3);\n\n// In simulation loop:\nesdLogic.evaluate();\n</code></pre> <p>Author: ESOL Date: November 2025 Version: 1.0</p>"},{"location":"wiki/faq/","title":"FAQ","text":""},{"location":"wiki/faq/#where-can-i-find-the-api-documentation","title":"Where can I find the API documentation?","text":"<p>The full JavaDoc is available at https://htmlpreview.github.io/?https://github.com/equinor/neqsimhome/blob/master/javadoc/site/apidocs/index.html.</p>"},{"location":"wiki/faq/#how-do-i-run-the-tests","title":"How do I run the tests?","text":"<p>After cloning the repository, execute:</p> <pre><code>./mvnw test\n</code></pre>"},{"location":"wiki/faq/#who-maintains-neqsim","title":"Who maintains NeqSim?","text":"<p>The project is developed by Equinor with contributions from the community. Contact Even Solbraa (esolbraa@gmail.com) for questions.</p>"},{"location":"wiki/field_development_planning/","title":"Field Development Planning Module","text":"<p>The Field Development Planning module provides a comprehensive set of tools for modeling, scheduling, and optimizing oil and gas field development projects. This module integrates with NeqSim's existing process simulation capabilities to enable full-lifecycle field development planning.</p>"},{"location":"wiki/field_development_planning/#overview","title":"Overview","text":"<p>The module consists of four main classes:</p> Class Purpose <code>ProductionProfile</code> Decline curve modeling and production forecasting <code>WellScheduler</code> Well intervention and workover scheduling <code>FacilityCapacity</code> Facility bottleneck analysis and debottleneck planning <code>SensitivityAnalysis</code> Monte Carlo simulation for uncertainty quantification"},{"location":"wiki/field_development_planning/#package-location","title":"Package Location","text":"<pre><code>neqsim.process.util.fielddevelopment\n</code></pre>"},{"location":"wiki/field_development_planning/#quick-start","title":"Quick Start","text":""},{"location":"wiki/field_development_planning/#production-profile-decline-curves","title":"Production Profile - Decline Curves","text":"<p>Model production decline using industry-standard decline curve analysis:</p> <pre><code>import neqsim.process.util.fielddevelopment.ProductionProfile;\nimport neqsim.process.util.fielddevelopment.ProductionProfile.*;\n\n// Create a production profile for a well\nProductionProfile profile = new ProductionProfile(\"Well-A1\");\n\n// Set exponential decline parameters\n// Initial rate: 1000 bbl/day, Decline rate: 10%/year\nDeclineParameters params = new DeclineParameters(\n    DeclineType.EXPONENTIAL, \n    1000.0,  // Initial rate (bbl/day)\n    0.10,    // Decline rate (per year)\n    0.0,     // b-factor (not used for exponential)\n    0.0      // Plateau rate\n);\nprofile.setDeclineParameters(params);\n\n// Calculate rate at 2 years\ndouble rate = profile.calculateRate(2.0);\nSystem.out.println(\"Rate at 2 years: \" + rate + \" bbl/day\");\n\n// Calculate cumulative production over 5 years\ndouble cumulative = profile.calculateCumulativeProduction(5.0);\nSystem.out.println(\"Cumulative: \" + cumulative + \" bbl\");\n\n// Set economic limit and find field life\nprofile.setEconomicLimit(50.0); // bbl/day\ndouble fieldLife = profile.calculateTimeToEconomicLimit();\nSystem.out.println(\"Field life: \" + fieldLife + \" years\");\n\n// Generate monthly forecast\nLocalDate startDate = LocalDate.of(2024, 1, 1);\nProductionForecast forecast = profile.generateForecast(startDate, 10, 12);\nfor (ProductionPoint point : forecast.getProductionPoints()) {\n    System.out.println(point.getDate() + \": \" + point.getRate() + \" bbl/day\");\n}\n</code></pre>"},{"location":"wiki/field_development_planning/#decline-curve-types","title":"Decline Curve Types","text":"<p>The module supports three industry-standard decline curve models:</p>"},{"location":"wiki/field_development_planning/#exponential-decline","title":"Exponential Decline","text":"<p><pre><code>q(t) = q\u2080 \u00d7 e^(-Dt)\n</code></pre> Best for: Wells with constant percentage decline, tight reservoirs</p>"},{"location":"wiki/field_development_planning/#hyperbolic-decline","title":"Hyperbolic Decline","text":"<p><pre><code>q(t) = q\u2080 / (1 + bDt)^(1/b)\n</code></pre> Where b is the hyperbolic exponent (0 &lt; b &lt; 1). Best for: Wells with declining percentage decline rate.</p>"},{"location":"wiki/field_development_planning/#harmonic-decline","title":"Harmonic Decline","text":"<p><pre><code>q(t) = q\u2080 / (1 + Dt)\n</code></pre> Special case of hyperbolic with b = 1. Best for: Wells with slowly declining rate.</p>"},{"location":"wiki/field_development_planning/#plateau-production","title":"Plateau Production","text":"<p>Model plateau production before decline onset:</p> <pre><code>// 2-year plateau at 800 bbl/day before decline begins\nDeclineParameters params = new DeclineParameters(\n    DeclineType.EXPONENTIAL, \n    1000.0,  // Initial rate\n    0.10,    // Decline rate\n    0.0,     // b-factor\n    800.0    // Plateau rate\n);\nprofile.setDeclineParameters(params);\nprofile.setPlateauDuration(2.0); // years\n\n// During plateau (t &lt; 2 years), rate = 800 bbl/day\n// After plateau, exponential decline from 800 bbl/day\n</code></pre>"},{"location":"wiki/field_development_planning/#well-scheduler-intervention-planning","title":"Well Scheduler - Intervention Planning","text":"<p>Schedule and track well interventions, workovers, and availability:</p> <pre><code>import neqsim.process.util.fielddevelopment.WellScheduler;\nimport neqsim.process.util.fielddevelopment.WellScheduler.*;\n\n// Create scheduler\nWellScheduler scheduler = new WellScheduler(\"Platform-A\");\n\n// Add wells to the schedule\nscheduler.addWell(\"Well-A1\", LocalDate.of(2024, 1, 15), 500.0);\nscheduler.addWell(\"Well-A2\", LocalDate.of(2024, 3, 1), 450.0);\nscheduler.addWell(\"Well-A3\", LocalDate.of(2024, 5, 15), 400.0);\n\n// Update well status\nscheduler.updateWellStatus(\"Well-A1\", WellStatus.PRODUCING);\n\n// Schedule interventions\nIntervention workover = scheduler.scheduleIntervention(\n    \"Well-A1\",\n    InterventionType.WORKOVER_RIG,\n    LocalDate.of(2024, 9, 1),\n    21, // Duration in days\n    \"ESP replacement\"\n);\nworkover.setDailyCost(150_000.0);\nworkover.setEstimatedNpv(5_000_000.0);\n\nIntervention stimulation = scheduler.scheduleIntervention(\n    \"Well-A2\",\n    InterventionType.COILED_TUBING,\n    LocalDate.of(2024, 7, 15),\n    5,\n    \"Acid stimulation\"\n);\n\n// Check for scheduling conflicts\nboolean hasConflict = scheduler.hasSchedulingConflict(\n    \"Well-A1\", \n    LocalDate.of(2024, 9, 10), \n    7\n);\n\n// Calculate well availability\ndouble availability = scheduler.calculateAvailability(\n    \"Well-A1\",\n    LocalDate.of(2024, 1, 1),\n    LocalDate.of(2024, 12, 31)\n);\n\n// Get prioritized interventions (by NPV)\nList&lt;Intervention&gt; prioritized = scheduler.getPrioritizedInterventions();\n\n// Generate schedule and export Gantt chart\nScheduleResult result = scheduler.generateSchedule(\n    LocalDate.of(2024, 1, 1),\n    LocalDate.of(2025, 12, 31)\n);\nString ganttData = result.toGanttFormat();\n</code></pre>"},{"location":"wiki/field_development_planning/#intervention-types","title":"Intervention Types","text":"Type Description Typical Duration <code>COILED_TUBING</code> Stimulation, cleanout, scale removal 3-7 days <code>WIRELINE</code> Logging, perforating, mechanical work 1-5 days <code>SLICKLINE</code> Basic mechanical operations 1-3 days <code>WORKOVER_RIG</code> Major repairs, ESP/pump replacement 14-30 days <code>DRILLING_RIG</code> Sidetrack, deepening 30-90 days <code>SUBSEA_INTERVENTION</code> ROV/vessel-based work 7-21 days"},{"location":"wiki/field_development_planning/#well-status-tracking","title":"Well Status Tracking","text":"Status Description <code>PENDING</code> Well added but not yet on production <code>DRILLING</code> Actively being drilled <code>COMPLETING</code> Completion operations in progress <code>PRODUCING</code> On production <code>SHUT_IN</code> Temporarily shut in <code>WORKOVER</code> Undergoing workover operations <code>SUSPENDED</code> Long-term suspension <code>ABANDONED</code> Permanently abandoned"},{"location":"wiki/field_development_planning/#facility-capacity-bottleneck-analysis","title":"Facility Capacity - Bottleneck Analysis","text":"<p>Analyze facility capacity constraints and evaluate debottleneck options:</p> <pre><code>import neqsim.process.util.fielddevelopment.FacilityCapacity;\nimport neqsim.process.util.fielddevelopment.FacilityCapacity.*;\n\n// Create process system (using existing NeqSim capabilities)\nProcessSystem process = new ProcessSystem();\n// ... add equipment (separators, compressors, etc.)\nprocess.run();\n\n// Create facility capacity analyzer\nFacilityCapacity capacity = new FacilityCapacity(\"Platform-A\", process);\n\n// Identify primary bottleneck\nString bottleneck = capacity.identifyBottleneck();\nSystem.out.println(\"Primary bottleneck: \" + bottleneck);\n\n// Set equipment capacities\ncapacity.setMaxCapacity(\"Export Compressor\", 150000.0, \"kg/hr\");\ncapacity.setMaxCapacity(\"Inlet Separator\", 180000.0, \"kg/hr\");\ncapacity.setCurrentThroughput(\"Export Compressor\", 120000.0, \"kg/hr\");\n\n// Get capacity headroom\ndouble headroom = capacity.getCapacityHeadroom(\"Export Compressor\");\n\n// Find all equipment above 90% utilization\nList&lt;String&gt; criticalEquipment = capacity.getCriticalEquipment(0.90);\n\n// Define and evaluate debottleneck options\nDebottleneckOption option1 = new DebottleneckOption(\"Add Parallel Compressor\");\noption1.setCapexCost(10_000_000.0);\noption1.setAdditionalCapacity(50000.0);\noption1.setProductPrice(0.30);\noption1.setOperatingCostPerUnit(0.05);\noption1.setDiscountRate(0.10);\noption1.setProjectLifeYears(15);\n\nDebottleneckOption option2 = new DebottleneckOption(\"Upgrade Separator Internals\");\noption2.setCapexCost(3_000_000.0);\noption2.setAdditionalCapacity(20000.0);\n// ... set other parameters\n\ncapacity.addDebottleneckOption(option1);\ncapacity.addDebottleneckOption(option2);\n\n// Rank options by NPV\nList&lt;DebottleneckOption&gt; rankedOptions = capacity.rankDebottleneckOptions();\n\n// Generate capacity assessment report\nCapacityAssessment assessment = capacity.assess();\nString report = assessment.generateReport();\n\n// Define capacity periods for planning\ncapacity.addCapacityPeriod(new CapacityPeriod(\"2024\", 100000.0));\ncapacity.addCapacityPeriod(new CapacityPeriod(\"2025\", 120000.0));\ncapacity.addCapacityPeriod(new CapacityPeriod(\"2026\", 140000.0));\n\n// Calculate growth rate\ndouble growthRate = capacity.calculateCapacityGrowthRate();\n</code></pre>"},{"location":"wiki/field_development_planning/#integration-with-productionoptimizer","title":"Integration with ProductionOptimizer","text":"<p>The <code>FacilityCapacity</code> class leverages the existing <code>ProductionOptimizer</code> infrastructure for bottleneck analysis:</p> <pre><code>import neqsim.process.util.optimization.ProductionOptimizer;\n\n// FacilityCapacity wraps ProductionOptimizer\nFacilityCapacity capacity = new FacilityCapacity(\"Platform\", process);\n\n// Access underlying optimizer for advanced scenarios\nProductionOptimizer optimizer = capacity.getOptimizer();\n\n// Run scenario comparison\nScenarioRequest baseCase = new ScenarioRequest(process);\nScenarioRequest debottleneck = new ScenarioRequest(modifiedProcess);\n\nScenarioComparisonResult comparison = optimizer.compareScenarios(baseCase, debottleneck);\n</code></pre>"},{"location":"wiki/field_development_planning/#sensitivity-analysis-monte-carlo-simulation","title":"Sensitivity Analysis - Monte Carlo Simulation","text":"<p>Perform uncertainty analysis using Monte Carlo simulation:</p> <pre><code>import neqsim.process.util.fielddevelopment.SensitivityAnalysis;\nimport neqsim.process.util.fielddevelopment.SensitivityAnalysis.*;\n\n// Create sensitivity analysis\nSensitivityAnalysis sensitivity = new SensitivityAnalysis(\"Project Economics\");\n\n// Add uncertain parameters with probability distributions\nsensitivity.addParameter(new UncertainParameter(\n    \"OilPrice\",\n    DistributionType.NORMAL,\n    75.0,   // Mean\n    15.0    // Standard deviation\n));\n\nsensitivity.addParameter(new UncertainParameter(\n    \"Reserves\",\n    DistributionType.TRIANGULAR,\n    50_000_000.0,   // Minimum\n    100_000_000.0,  // Most likely\n    150_000_000.0   // Maximum\n));\n\nsensitivity.addParameter(new UncertainParameter(\n    \"Capex\",\n    DistributionType.UNIFORM,\n    500_000_000.0,  // Minimum\n    800_000_000.0   // Maximum\n));\n\nsensitivity.addParameter(new UncertainParameter(\n    \"RecoveryFactor\",\n    DistributionType.LOGNORMAL,\n    Math.log(0.35), // Mu (log of mean)\n    0.15            // Sigma\n));\n\n// Set correlated parameters\nsensitivity.setCorrelation(\"Reserves\", \"RecoveryFactor\", 0.5);\n\n// Configure and run Monte Carlo\nsensitivity.setNumberOfTrials(10000);\nsensitivity.setSeed(42L); // For reproducibility\nsensitivity.setConvergenceThreshold(0.01);\n\nMonteCarloResult result = sensitivity.runMonteCarlo();\n\n// Get probability statistics\ndouble p10 = result.getP10();  // 10th percentile (pessimistic)\ndouble p50 = result.getP50();  // 50th percentile (median)\ndouble p90 = result.getP90();  // 90th percentile (optimistic)\n\ndouble mean = result.getMean();\ndouble stdDev = result.getStandardDeviation();\n\nSystem.out.println(\"P10: \" + p10 + \" P50: \" + p50 + \" P90: \" + p90);\n\n// Check convergence\nif (result.isConverged()) {\n    System.out.println(\"Simulation converged after \" + result.getTrialCount() + \" trials\");\n}\n\n// Generate tornado diagram (sensitivity ranking)\nList&lt;TornadoEntry&gt; tornado = result.generateTornadoDiagram();\nfor (TornadoEntry entry : tornado) {\n    System.out.println(entry.getParameterName() + \": impact = \" + entry.getImpact());\n}\n\n// Get histogram data\nint[] histogram = result.generateHistogram(20);\n\n// Calculate sensitivity indices\ndouble oilPriceSensitivity = result.getSensitivityIndex(\"OilPrice\");\n\n// Export results\nString csvData = result.exportToCsv();\n</code></pre>"},{"location":"wiki/field_development_planning/#distribution-types","title":"Distribution Types","text":"Type Parameters Use Case <code>NORMAL</code> mean, std Symmetric uncertainty around expected value <code>LOGNORMAL</code> mu, sigma Positive-only values with right skew <code>TRIANGULAR</code> min, mode, max Expert judgment with defined range <code>UNIFORM</code> min, max Equal probability across range"},{"location":"wiki/field_development_planning/#sampling-formulas","title":"Sampling Formulas","text":"<p>Normal Distribution: <pre><code>X = \u03bc + \u03c3 \u00d7 Z\nwhere Z ~ N(0,1)\n</code></pre></p> <p>Lognormal Distribution: <pre><code>X = e^(\u03bc + \u03c3Z)\nwhere Z ~ N(0,1)\n</code></pre></p> <p>Triangular Distribution: <pre><code>if U &lt; (mode-min)/(max-min):\n    X = min + \u221a(U(max-min)(mode-min))\nelse:\n    X = max - \u221a((1-U)(max-min)(max-mode))\nwhere U ~ U(0,1)\n</code></pre></p> <p>Uniform Distribution: <pre><code>X = min + U(max - min)\nwhere U ~ U(0,1)\n</code></pre></p>"},{"location":"wiki/field_development_planning/#integration-example","title":"Integration Example","text":"<p>Combine all modules for comprehensive field development planning:</p> <pre><code>import neqsim.process.util.fielddevelopment.*;\nimport neqsim.process.processmodel.ProcessSystem;\nimport java.time.LocalDate;\n\npublic class FieldDevelopmentExample {\n\n    public static void main(String[] args) {\n        // 1. Create process system\n        ProcessSystem process = createProcessSystem();\n        process.run();\n\n        // 2. Analyze facility capacity\n        FacilityCapacity capacity = new FacilityCapacity(\"Production Platform\", process);\n        String bottleneck = capacity.identifyBottleneck();\n        System.out.println(\"Current bottleneck: \" + bottleneck);\n\n        // 3. Create production profiles for wells\n        ProductionProfile[] wellProfiles = new ProductionProfile[5];\n        for (int i = 0; i &lt; 5; i++) {\n            wellProfiles[i] = new ProductionProfile(\"Well-\" + (i + 1));\n            wellProfiles[i].setDeclineParameters(new DeclineParameters(\n                DeclineType.EXPONENTIAL, \n                500.0 - i * 50,  // Varying initial rates\n                0.12,\n                0.0,\n                0.0\n            ));\n        }\n\n        // 4. Schedule interventions\n        WellScheduler scheduler = new WellScheduler(\"Platform Scheduler\");\n        LocalDate today = LocalDate.now();\n\n        for (int i = 0; i &lt; 5; i++) {\n            scheduler.addWell(\"Well-\" + (i + 1), today.minusYears(2 - i), \n                wellProfiles[i].calculateRate(0));\n            scheduler.updateWellStatus(\"Well-\" + (i + 1), WellStatus.PRODUCING);\n        }\n\n        // Schedule workovers based on decline rate\n        scheduler.scheduleIntervention(\"Well-1\", InterventionType.WORKOVER_RIG,\n            today.plusMonths(6), 21, \"ESP replacement\");\n        scheduler.scheduleIntervention(\"Well-2\", InterventionType.COILED_TUBING,\n            today.plusMonths(9), 5, \"Acid stimulation\");\n\n        // 5. Run sensitivity analysis on key parameters\n        SensitivityAnalysis sensitivity = new SensitivityAnalysis(\"Field Economics\");\n\n        sensitivity.addParameter(new UncertainParameter(\"OilPrice\", \n            DistributionType.NORMAL, 75.0, 15.0));\n        sensitivity.addParameter(new UncertainParameter(\"TotalReserves\", \n            DistributionType.TRIANGULAR, 80e6, 100e6, 130e6));\n        sensitivity.addParameter(new UncertainParameter(\"Opex\", \n            DistributionType.UNIFORM, 15.0, 25.0));\n\n        sensitivity.setNumberOfTrials(5000);\n        MonteCarloResult mcResult = sensitivity.runMonteCarlo();\n\n        // 6. Generate reports\n        System.out.println(\"\\n=== Field Development Summary ===\\n\");\n\n        // Production forecast\n        ProductionForecast totalForecast = combinedForecast(wellProfiles, today, 10);\n        System.out.println(\"10-Year Production Forecast:\");\n        System.out.println(\"  Year 1: \" + totalForecast.getCumulativeProduction(1) + \" bbl\");\n        System.out.println(\"  Year 5: \" + totalForecast.getCumulativeProduction(5) + \" bbl\");\n        System.out.println(\"  Year 10: \" + totalForecast.getCumulativeProduction(10) + \" bbl\");\n\n        // Well schedule\n        ScheduleResult schedule = scheduler.generateSchedule(today, today.plusYears(5));\n        System.out.println(\"\\nWell Schedule:\");\n        System.out.println(\"  Active wells: \" + schedule.getWellCount());\n        System.out.println(\"  Planned interventions: \" + schedule.getTotalInterventions());\n\n        // Facility capacity\n        System.out.println(\"\\nFacility Capacity:\");\n        System.out.println(\"  Current utilization: \" + \n            (capacity.getOverallUtilization() * 100) + \"%\");\n        System.out.println(\"  Bottleneck equipment: \" + bottleneck);\n\n        // Uncertainty analysis\n        System.out.println(\"\\nEconomic Uncertainty (NPV):\");\n        System.out.println(\"  P10: $\" + String.format(\"%.1f\", mcResult.getP10() / 1e6) + \"M\");\n        System.out.println(\"  P50: $\" + String.format(\"%.1f\", mcResult.getP50() / 1e6) + \"M\");\n        System.out.println(\"  P90: $\" + String.format(\"%.1f\", mcResult.getP90() / 1e6) + \"M\");\n\n        // Tornado diagram\n        System.out.println(\"\\nKey Sensitivities:\");\n        for (TornadoEntry entry : mcResult.generateTornadoDiagram()) {\n            System.out.println(\"  \" + entry.getParameterName() + \n                \": \" + String.format(\"%.1f\", entry.getImpact() * 100) + \"% impact\");\n        }\n    }\n}\n</code></pre>"},{"location":"wiki/field_development_planning/#best-practices","title":"Best Practices","text":""},{"location":"wiki/field_development_planning/#production-profiles","title":"Production Profiles","text":"<ol> <li>Validate decline parameters against historical production data</li> <li>Use plateau periods for new wells with initial flush production</li> <li>Set realistic economic limits based on operating costs</li> <li>Consider type curves for analogous field comparison</li> </ol>"},{"location":"wiki/field_development_planning/#well-scheduling","title":"Well Scheduling","text":"<ol> <li>Prioritize interventions by NPV to maximize value</li> <li>Check for resource conflicts (rigs, vessels, crews)</li> <li>Build in contingency time for complex interventions</li> <li>Track well status to maintain production accounting</li> </ol>"},{"location":"wiki/field_development_planning/#facility-capacity","title":"Facility Capacity","text":"<ol> <li>Start with current bottleneck identification</li> <li>Evaluate multiple debottleneck options before deciding</li> <li>Consider staging of capacity expansion</li> <li>Update capacity data as field matures</li> </ol>"},{"location":"wiki/field_development_planning/#sensitivity-analysis","title":"Sensitivity Analysis","text":"<ol> <li>Use appropriate distributions for each uncertainty type</li> <li>Run enough trials for convergence (typically 5,000-10,000)</li> <li>Set correlations between dependent parameters</li> <li>Focus on tornado top items for risk mitigation</li> </ol>"},{"location":"wiki/field_development_planning/#related-documentation","title":"Related Documentation","text":"<ul> <li>Bottleneck Analysis Guide</li> <li>ProductionOptimizer Reference</li> <li>Process Scenario Runner</li> <li>Monte Carlo Statistics</li> </ul>"},{"location":"wiki/field_development_planning/#api-reference","title":"API Reference","text":"<p>See the Javadoc documentation for complete API details:</p> <ul> <li><code>ProductionProfile</code></li> <li><code>WellScheduler</code></li> <li><code>FacilityCapacity</code></li> <li><code>SensitivityAnalysis</code></li> </ul>"},{"location":"wiki/flash_equations_and_tests/","title":"Flash calculations validated by tests","text":"<p>NeqSim's flash algorithms are exercised heavily in the JUnit suite under <code>src/test/java/neqsim/thermodynamicoperations/flashops</code>. The tests document how the solvers are configured and what outputs they must reproduce, giving a reproducible view of the underlying theory.</p>"},{"location":"wiki/flash_equations_and_tests/#rachford-rice-vapor-fraction-solving","title":"Rachford-Rice vapor fraction solving","text":"<p><code>RachfordRiceTest</code> switches between the Nielsen (2023) and Michelsen (2001) variants of the Rachford\u2013Rice solver to verify that all implementations converge to the same vapor fraction for the same <code>K</code>-values and overall composition.\u3010F:src/test/java/neqsim/thermodynamicoperations/flashops/RachfordRiceTest.java\u2020L14-L39\u3011 The test uses a binary mixture with <code>z=[0.7, 0.3]</code> and <code>K=[2.0, 0.01]</code> and asserts a vapor fraction (\\(\\beta\\)) of 0.40707, which is the root of the classic balance equation:</p> \\[ \\sum_i z_i \\frac{K_i - 1}{1 + \\beta (K_i - 1)} = 0 \\] <p>The converged solution satisfies material balance between vapor and liquid while honoring the phase equilibrium ratios supplied by the <code>K</code>-values. Switching <code>RachfordRice.setMethod(...)</code> in the test demonstrates that NeqSim exposes multiple solver strategies for the same equation without altering the target root.\u3010F:src/test/java/neqsim/thermodynamicoperations/flashops/RachfordRiceTest.java\u2020L21-L33\u3011 When modeling your own flashes, choose a method that matches your numerical preferences; the test shows that the default and named methods must agree on the fundamental solution.</p>"},{"location":"wiki/flash_equations_and_tests/#tp-flash-energy-consistency","title":"TP flash energy consistency","text":"<p><code>TPFlashTest</code> configures multicomponent systems with cubic equations of state (Peng\u2013Robinson, UMR-PRU-MC, SRK-CPA) and validates both phase splits and energy properties after a <code>TPflash()</code> call. The tests cover low and high pressure regimes, multi-phase checks, and heavy pseudo-component handling.\u3010F:src/test/java/neqsim/thermodynamicoperations/flashops/TPFlashTest.java\u2020L19-L140\u3011 Assertions include vapor fraction (<code>getBeta()</code>), number of phases, and total enthalpy, confirming that the flash calculation preserves the combined internal energy and molar balance implied by the Rachford\u2013Rice solution and the chosen EOS.</p> <p>To mirror the test configuration:</p> <ul> <li>Create a <code>SystemInterface</code> instance with the appropriate EOS and reference conditions.</li> <li>Add light components, water, and TBP fractions as needed.</li> <li>Select a mixing rule (<code>setMixingRule(\"classic\")</code> or numeric variants) and enable multiphase detection if solids or water are expected.</li> <li>Apply pressure/temperature targets and call <code>new ThermodynamicOperations(system).TPflash()</code>.</li> <li>Reinitialize properties to obtain enthalpy, densities, and phase fractions for validation.</li> </ul> <p>The enthalpy checks in <code>testRun2</code> and <code>testRun3</code> highlight that the flash solution must satisfy both material balance and the caloric EOS relationships at the specified state points.\u3010F:src/test/java/neqsim/thermodynamicoperations/flashops/TPFlashTest.java\u2020L43-L82\u3011 If discrepancies appear in your own models, align your setup with the tested recipe before exploring alternative property packages.</p>"},{"location":"wiki/flow_meter_models/","title":"Flow meter models","text":"<p>This page documents the equations implemented in the <code>Orifice</code> equipment for computing flow through differential pressure meters. All variables are in SI units.</p>"},{"location":"wiki/flow_meter_models/#orifice-plate","title":"Orifice plate","text":"<p>The discharge coefficient \\(C\\) is calculated with the Reader\u2013Harris/Gallagher correlation as implemented in ISO\u00a05167:</p> \\[ C = 0.5961 + 0.0261\\beta^2 - 0.216\\beta^8 + 0.000521\\left(\\frac{10^6\\beta}{Re_D}\\right)^{0.7}     +(0.0188 + 0.0063A)\\beta^{3.5}\\left(\\frac{10^6}{Re_D}\\right)^{0.3}     +(0.043 + 0.080e^{-10L_1}-0.123e^{-7L_1})(1-0.11A)\\frac{\\beta^4}{1-\\beta^4}     -0.031(M_2' -0.8M_2'^{1.1})\\beta^{1.3} \\] <p>The expansibility factor is $$ \\epsilon = 1 - (0.351 +0.256\\beta^4 +0.93\\beta<sup>8)\\left[1-\\left(\\frac{P_2}{P_1}\\right)</sup>\\right] $$</p> <p>The mass flow rate is obtained iteratively from $$  m = \\left(\\tfrac{\\pi D<sup>2\\beta</sup>2}{4}\\right) C \\epsilon \\frac{\\sqrt{2\\rho(P_1-P_2)}}{\\sqrt{1-\\beta^4}}. $$</p>"},{"location":"wiki/fluid_characterization/","title":"Fluid Characterization in NeqSim","text":"<p>Real reservoir fluids often contain a complex mixture of heavy hydrocarbons (C7+) that cannot be represented by standard pure components. NeqSim provides a robust characterization framework to model these fluids using TBP (True Boiling Point) fractions and Plus fractions.</p> <p>Related Documentation: - TBP Fraction Models - Detailed guide on all available TBP models (Pedersen, Lee-Kesler, Riazi-Daubert, Twu, Cavett, Standing), model selection, and mathematical correlations</p>"},{"location":"wiki/fluid_characterization/#1-adding-heavy-fractions","title":"1. Adding Heavy Fractions","text":"<p>You can add heavy fractions to a system using two primary methods: <code>addTBPfraction</code> and <code>addPlusFraction</code>.</p>"},{"location":"wiki/fluid_characterization/#11-tbp-fractions","title":"1.1 TBP Fractions","text":"<p>Use <code>addTBPfraction</code> when you have data for specific carbon number cuts (e.g., C7, C8, C9) with defined properties.</p> <pre><code>// addTBPfraction(name, moles, molarMass_kg_mol, density_kg_m3)\nsystem.addTBPfraction(\"C7\", 1.0, 0.092, 0.73); \nsystem.addTBPfraction(\"C8\", 1.0, 0.104, 0.76);\n</code></pre>"},{"location":"wiki/fluid_characterization/#12-plus-fractions","title":"1.2 Plus Fractions","text":"<p>Use <code>addPlusFraction</code> for the final residue or \"plus\" fraction (e.g., C10+, C20+) where you only have average properties.</p> <pre><code>// addPlusFraction(name, moles, molarMass_kg_mol, density_kg_m3)\nsystem.addPlusFraction(\"C10+\", 10.0, 0.250, 0.85);\n</code></pre>"},{"location":"wiki/fluid_characterization/#2-characterization-process","title":"2. Characterization Process","text":"<p>After adding the components, you must run the characterization routine to split the plus fraction into pseudo-components and estimate their critical properties (Tc, Pc, w).</p>"},{"location":"wiki/fluid_characterization/#21-setting-the-model","title":"2.1 Setting the Model","text":"<p>NeqSim supports several characterization models. The most common is the Pedersen model.</p> <pre><code>// Set the TBP Model (affects how TBP fractions are treated)\nsystem.getCharacterization().setTBPModel(\"PedersenSRK\"); \n\n// Set the Plus Fraction Model (affects how the plus fraction is split)\nsystem.getCharacterization().setPlusFractionModel(\"Pedersen\");\n</code></pre>"},{"location":"wiki/fluid_characterization/#available-tbp-models","title":"Available TBP Models","text":"<p>NeqSim provides 10 TBP models for estimating critical properties (Tc, Pc, \u03c9) from molecular weight and density:</p> Model Best Application <code>PedersenSRK</code> General SRK EOS (default) <code>PedersenPR</code> General Peng-Robinson EOS <code>PedersenSRKHeavyOil</code> Heavy oils with SRK <code>PedersenPRHeavyOil</code> Heavy oils with PR <code>Lee-Kesler</code> General purpose, uses Watson K-factor <code>RiaziDaubert</code> Light fractions (MW &lt; 300 g/mol) <code>Twu</code> Paraffinic fluids, gas condensates <code>Cavett</code> Refining industry, API gravity corrections <code>Standing</code> Reservoir engineering <p>See TBP Fraction Models for detailed mathematical correlations and model selection guidelines.</p>"},{"location":"wiki/fluid_characterization/#available-plus-fraction-models","title":"Available Plus Fraction Models","text":""},{"location":"wiki/fluid_characterization/#pedersen-model","title":"Pedersen Model","text":"<p>The standard Pedersen model assumes an exponential distribution for the mole fraction \\(z_i\\) of each carbon number fraction \\(i\\):</p> \\[ z_i = \\exp(A + B \\cdot i) \\] <p>where \\(i\\) is the carbon number, and \\(A\\) and \\(B\\) are coefficients determined to match the total mole fraction and average molar mass of the plus fraction.</p> <p>The density \\(\\rho_i\\) is modeled as a logarithmic function of the carbon number:</p> \\[ \\rho_i = C + D \\cdot \\ln(i) \\] <p>where \\(C\\) and \\(D\\) are fitted coefficients.</p>"},{"location":"wiki/fluid_characterization/#whitson-gamma-model","title":"Whitson Gamma Model","text":"<p>The Whitson Gamma model uses a three-parameter Gamma probability density function (PDF) to describe the molar mass distribution:</p> \\[ p(M) = \\frac{(M - \\eta)^{\\alpha - 1} \\exp\\left(-\\frac{M - \\eta}{\\beta}\\right)}{\\beta^\\alpha \\Gamma(\\alpha)} \\] <p>where: *   \\(M\\) is the molar mass. *   \\(\\eta\\) is the minimum molar mass (default 90 g/mol). *   \\(\\alpha\\) is the shape factor (default 1.0). *   \\(\\beta\\) is the scale parameter, calculated as \\(\\beta = \\frac{M_{plus} - \\eta}{\\alpha}\\). *   \\(\\Gamma(\\alpha)\\) is the Gamma function.</p> <p>The mole fraction \\(z_i\\) for a pseudo-component covering the molar mass range \\([M_{L}, M_{U}]\\) is obtained by integrating the PDF:</p> \\[ z_i = z_{plus} \\int_{M_{L}}^{M_{U}} p(M) \\, dM \\] <p>The density of each pseudo-component is calculated using the Watson UOP characterization factor \\(K_w\\):</p> \\[ K_w = 4.5579 \\cdot (M_{plus})^{0.15178} \\cdot \\rho_{plus}^{-1.18241} \\] \\[ \\rho_i = 6.0108 \\cdot M_i^{0.17947} \\cdot K_w^{-1.18241} \\] <p>(Note: Molar masses are in g/mol and densities in g/cm\u00b3 for these correlations).</p>"},{"location":"wiki/fluid_characterization/#22-running-characterization","title":"2.2 Running Characterization","text":"<p>Once models are set, execute the characterization.</p> <pre><code>system.getCharacterization().characterisePlusFraction();\n</code></pre> <p>This process will: 1.  Extrapolate the molar distribution to C80+. 2.  Calculate properties for each carbon number. 3.  Group them into pseudo-components (if lumping is enabled).</p>"},{"location":"wiki/fluid_characterization/#3-lumping-modellumping","title":"3. Lumping (ModelLumping)","text":"<p>To reduce simulation time, it is often necessary to group the many characterized components into a smaller number of \"lumped\" pseudo-components.</p>"},{"location":"wiki/fluid_characterization/#31-configuring-lumping","title":"3.1 Configuring Lumping","text":"<p>You can control the lumping behavior via the <code>LumpingModel</code>.</p> <pre><code>// Set the lumping method (Default is \"PVTlumpingModel\")\nsystem.getCharacterization().setLumpingModel(\"PVTlumpingModel\");\n\n// Configure the number of pseudo-components to generate\nsystem.getCharacterization().getLumpingModel().setNumberOfLumpedComponents(12);\n</code></pre>"},{"location":"wiki/fluid_characterization/#32-full-example","title":"3.2 Full Example","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class CharacterizationExample {\n    public static void main(String[] args) {\n        // 1. Create System\n        SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\n        fluid.addComponent(\"nitrogen\", 0.5);\n        fluid.addComponent(\"CO2\", 1.0);\n        fluid.addComponent(\"methane\", 60.0);\n        fluid.addComponent(\"ethane\", 5.0);\n        fluid.addComponent(\"propane\", 3.0);\n\n        // 2. Add Heavy Fractions\n        fluid.addTBPfraction(\"C6\", 1.0, 0.086, 0.66);\n        fluid.addTBPfraction(\"C7\", 2.0, 0.092, 0.73);\n        fluid.addTBPfraction(\"C8\", 2.0, 0.104, 0.76);\n        fluid.addTBPfraction(\"C9\", 1.0, 0.118, 0.78);\n        fluid.addPlusFraction(\"C10+\", 15.0, 0.280, 0.84); // The Plus Fraction\n\n        // 3. Configure Characterization\n        fluid.getCharacterization().setTBPModel(\"PedersenSRK\");\n        fluid.getCharacterization().setPlusFractionModel(\"Pedersen\");\n\n        // 4. Configure Lumping\n        // We want to lump the C10+ distribution into 5 pseudo-components\n        fluid.getCharacterization().setLumpingModel(\"PVTlumpingModel\");\n        fluid.getCharacterization().getLumpingModel().setNumberOfLumpedComponents(5);\n\n        // 5. Run Characterization\n        fluid.getCharacterization().characterisePlusFraction();\n\n        // 6. Use the Fluid\n        fluid.setMixingRule(\"classic\");\n        ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        fluid.prettyPrint();\n    }\n}\n</code></pre>"},{"location":"wiki/fluid_characterization/#4-advanced-options","title":"4. Advanced Options","text":"<ul> <li>Heavy Oil: For very heavy oils, use <code>setPlusFractionModel(\"Pedersen Heavy Oil\")</code>.</li> <li>Whitson Gamma: Use <code>setPlusFractionModel(\"Whitson Gamma\")</code> if you have specific gamma distribution parameters.</li> <li>No Lumping: To keep all individual carbon number components (C6, C7... C80), use <code>setLumpingModel(\"no lumping\")</code>. Note that this will result in a system with many components, which is slower to simulate.</li> </ul>"},{"location":"wiki/friction_factor_models/","title":"Friction Factor Models in NeqSim Pipelines","text":""},{"location":"wiki/friction_factor_models/#overview","title":"Overview","text":"<p>Friction factor is a critical parameter in pressure drop calculations. NeqSim implements industry-standard correlations for both laminar and turbulent flow.</p>"},{"location":"wiki/friction_factor_models/#friction-factor-equations","title":"Friction Factor Equations","text":""},{"location":"wiki/friction_factor_models/#laminar-flow-re-2300","title":"Laminar Flow (Re &lt; 2300)","text":"<p>For laminar flow, the Darcy friction factor is:</p> \\[f = \\frac{64}{Re}\\] <p>Where Reynolds number: $\\(Re = \\frac{\\rho v D}{\\mu}\\)$</p>"},{"location":"wiki/friction_factor_models/#transition-zone-2300-re-4000","title":"Transition Zone (2300 &lt; Re &lt; 4000)","text":"<p>Linear interpolation between laminar and turbulent:</p> \\[f = f_{laminar} + \\frac{Re - 2300}{1700}(f_{turbulent,4000} - f_{laminar,2300})\\]"},{"location":"wiki/friction_factor_models/#turbulent-flow-re-4000","title":"Turbulent Flow (Re &gt; 4000)","text":""},{"location":"wiki/friction_factor_models/#haaland-equation-default","title":"Haaland Equation (Default)","text":"<p>NeqSim uses the Haaland equation, an explicit approximation of Colebrook-White:</p> \\[f = \\left[ -1.8 \\log_{10}\\left( \\left(\\frac{\\varepsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{Re} \\right) \\right]^{-2}\\] <p>Where: - \\(\\varepsilon\\) = pipe wall roughness (m) - \\(D\\) = pipe diameter (m) - \\(Re\\) = Reynolds number</p> <p>Advantages: - Explicit (no iteration required) - Accuracy within 1-2% of Colebrook-White - Computationally efficient</p>"},{"location":"wiki/friction_factor_models/#colebrook-white-equation-reference","title":"Colebrook-White Equation (Reference)","text":"<p>The implicit Colebrook-White equation (used for validation):</p> \\[\\frac{1}{\\sqrt{f}} = -2 \\log_{10}\\left( \\frac{\\varepsilon/D}{3.7} + \\frac{2.51}{Re\\sqrt{f}} \\right)\\] <p>Solved iteratively using Newton-Raphson method.</p>"},{"location":"wiki/friction_factor_models/#two-phase-friction-factor","title":"Two-Phase Friction Factor","text":"<p>For multiphase flow, the single-phase friction factor is modified:</p> \\[f_{tp} = f_{ns} \\cdot e^S\\] <p>Where: - \\(f_{ns}\\) = no-slip friction factor - \\(S\\) = slip correction factor (from Beggs &amp; Brill)</p> <p>The slip factor \\(S\\) depends on the liquid holdup ratio: $\\(y = \\frac{\\lambda_L}{H_L^2}\\)$</p> <p>For \\(1 &lt; y &lt; 1.2\\): $\\(S = \\ln(2.2y - 1.2)\\)$</p> <p>Otherwise: $\\(S = \\frac{\\ln(y)}{-0.0523 + 3.18\\ln(y) - 0.872[\\ln(y)]^2 + 0.01853[\\ln(y)]^4}\\)$</p>"},{"location":"wiki/friction_factor_models/#pipe-roughness-values","title":"Pipe Roughness Values","text":""},{"location":"wiki/friction_factor_models/#typical-roughness-values","title":"Typical Roughness Values","text":"Material Roughness \u03b5 (mm) Roughness \u03b5 (m) Commercial steel (new) 0.046 4.6\u00d710\u207b\u2075 Commercial steel (rusted) 0.15-0.3 1.5-3\u00d710\u207b\u2074 Stainless steel 0.015 1.5\u00d710\u207b\u2075 Drawn tubing (copper, brass) 0.0015 1.5\u00d710\u207b\u2076 Cast iron 0.26 2.6\u00d710\u207b\u2074 Concrete 0.3-3.0 3\u00d710\u207b\u2074 to 3\u00d710\u207b\u00b3 PVC/Plastic 0.0015-0.007 1.5-7\u00d710\u207b\u2076 GRP/FRP 0.01 1\u00d710\u207b\u2075"},{"location":"wiki/friction_factor_models/#setting-roughness-in-neqsim","title":"Setting Roughness in NeqSim","text":"<pre><code>// For PipeBeggsAndBrills\npipe.setPipeWallRoughness(4.6e-5);  // meters\n\n// For AdiabaticPipe\npipe.setWallRoughness(4.6e-5);      // meters\n</code></pre>"},{"location":"wiki/friction_factor_models/#implementation-details","title":"Implementation Details","text":""},{"location":"wiki/friction_factor_models/#reynolds-number-calculation","title":"Reynolds Number Calculation","text":"<p>For two-phase flow, the no-slip Reynolds number is used:</p> \\[Re_{ns} = \\frac{\\rho_{ns} \\cdot v_m \\cdot D}{\\mu_{ns}}\\] <p>Where: - \\(\\rho_{ns} = \\rho_L \\lambda_L + \\rho_G (1-\\lambda_L)\\) (no-slip density) - \\(\\mu_{ns} = \\mu_L \\lambda_L + \\mu_G (1-\\lambda_L)\\) (no-slip viscosity) - \\(v_m = v_{SG} + v_{SL}\\) (mixture velocity)</p>"},{"location":"wiki/friction_factor_models/#code-example","title":"Code Example","text":"<pre><code>// Get friction-related results\nPipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"pipe\", stream);\npipe.setLength(1000);\npipe.setDiameter(0.1);\npipe.setPipeWallRoughness(4.6e-5);\npipe.run();\n\n// Access Reynolds number and friction factor for each segment\nfor (int i = 1; i &lt;= pipe.getNumberOfIncrements(); i++) {\n    double Re = pipe.getSegmentMixtureReynoldsNumber(i);\n    // Friction factor is internal but affects pressure drop\n}\n</code></pre>"},{"location":"wiki/friction_factor_models/#validation-results","title":"Validation Results","text":"<p>Comparison of NeqSim friction factor implementation against Colebrook-White:</p> Reynolds \u03b5/D Haaland f Colebrook f Deviation 10,000 0.001 0.0380 0.0382 -0.5% 100,000 0.001 0.0227 0.0228 -0.4% 1,000,000 0.001 0.0197 0.0197 0.0% 10,000,000 0.001 0.0191 0.0191 0.0%"},{"location":"wiki/friction_factor_models/#common-issues","title":"Common Issues","text":""},{"location":"wiki/friction_factor_models/#1-zero-or-negative-friction-factor","title":"1. Zero or Negative Friction Factor","text":"<ul> <li>Cause: Very low Reynolds number or invalid inputs</li> <li>Solution: Check that flow rate, density, and viscosity are positive</li> </ul>"},{"location":"wiki/friction_factor_models/#2-unrealistic-pressure-drop","title":"2. Unrealistic Pressure Drop","text":"<ul> <li>Cause: Wrong roughness units (mm vs m)</li> <li>Solution: Always use meters for roughness</li> </ul>"},{"location":"wiki/friction_factor_models/#3-laminar-flow-not-recognized","title":"3. Laminar Flow Not Recognized","text":"<ul> <li>Cause: Re threshold set incorrectly</li> <li>Solution: NeqSim uses Re &lt; 2300 for laminar</li> </ul>"},{"location":"wiki/friction_factor_models/#references","title":"References","text":"<ol> <li> <p>Haaland, S.E. (1983). \"Simple and Explicit Formulas for the Friction Factor in Turbulent Pipe Flow\". Journal of Fluids Engineering, 105(1), 89-90.</p> </li> <li> <p>Colebrook, C.F. (1939). \"Turbulent Flow in Pipes with Particular Reference to the Transition Region Between Smooth and Rough Pipe Laws\". Journal of the Institution of Civil Engineers, 11, 133-156.</p> </li> <li> <p>Moody, L.F. (1944). \"Friction Factors for Pipe Flow\". Transactions of the ASME, 66, 671-684.</p> </li> </ol>"},{"location":"wiki/friction_factor_models/#see-also","title":"See Also","text":"<ul> <li>Pipeline Pressure Drop Overview</li> <li>Beggs &amp; Brill Correlation</li> </ul>"},{"location":"wiki/gas_quality_standards_from_tests/","title":"Gas quality standards validated by ISO 6976 tests","text":"<p>The ISO 6976 calorific value and Wobbe index calculations are verified in <code>Standard_ISO6976Test</code>. This page summarizes the tested configurations and equations so you can align custom gas-quality runs with the regression suite.</p>"},{"location":"wiki/gas_quality_standards_from_tests/#base-iso-6976-calculation","title":"Base ISO 6976 calculation","text":"<p><code>testCalculate</code> initializes a dry natural gas at 20 \u00b0C and 1 bar with a classic mixing rule and executes <code>Standard_ISO6976.calculate()</code> using volume-based reference conditions (0 \u00b0C volume base, 15.55 \u00b0C energy base).\u3010F:src/test/java/neqsim/standards/gasquality/Standard_ISO6976Test.java\u2020L23-L47\u3011 The test confirms the gross calorific value (GCV) of 39,614.57 kJ/Sm\u00b3 and Wobbe index (WI) of 44.61 MJ/Sm\u00b3.</p> <p>The Wobbe index relation checked in the test is</p> \\[ WI = \\frac{GCV}{\\sqrt{\\rho_r}}\\ , \\] <p>where \\(\\rho_r\\) is the relative density. Matching the test values indicates both combustion energy and density normalization are consistent with ISO 6976.</p>"},{"location":"wiki/gas_quality_standards_from_tests/#handling-reference-condition-overrides","title":"Handling reference condition overrides","text":"<p><code>testCalculateWithWrongReferenceState</code> shows that if non-standard reference temperatures are provided, the standard falls back to defined bases (15 \u00b0C for energy, 0 \u00b0C for volume) while still computing GCV and WI.\u3010F:src/test/java/neqsim/standards/gasquality/Standard_ISO6976Test.java\u2020L49-L73\u3011 Use this behavior to guard against user input errors without failing calculations.</p>"},{"location":"wiki/gas_quality_standards_from_tests/#including-pseudo-components","title":"Including pseudo-components","text":"<p><code>testCalculateWithPSeudo</code> adds a TBP pseudo-fraction to the gas and re-runs the calculation to verify heavier fractions contribute to higher heating value (GCV \u2248 42,378 kJ/Sm\u00b3).\u3010F:src/test/java/neqsim/standards/gasquality/Standard_ISO6976Test.java\u2020L75-L96\u3011 The setup demonstrates that ISO 6976 evaluation tolerates lumped heavy ends when a classic mixing rule and full flash initialization are applied.</p>"},{"location":"wiki/gas_quality_standards_from_tests/#full-property-audit","title":"Full-property audit","text":"<p><code>testCalculate2</code> and <code>testCalculate3</code> sweep alternative temperatures and reference pairs to assert a complete property set: compression factor, superior/inferior calorific values, Wobbe indices, relative density, and molar mass.\u3010F:src/test/java/neqsim/standards/gasquality/Standard_ISO6976Test.java\u2020L98-L200\u3011 The tests also run a process <code>Stream</code> to ensure downstream WI reporting matches the standard calculation.</p> <p>When configuring your own gas-quality evaluations:</p> <ul> <li>Always initialize the thermodynamic system (<code>init(0)</code>) before calling the standard.</li> <li>Select reference temperatures explicitly; unexpected inputs will be corrected but should be avoided for traceability.</li> <li>Validate both GCV and Wobbe index against expected tolerances to confirm combustion properties are consistent.</li> </ul>"},{"location":"wiki/getting_started/","title":"Getting started","text":"<p>Use this page as a launchpad into the NeqSim documentation. It mirrors the high-level structure from the Colab introduction notebook and links directly to reference guides and examples.</p>"},{"location":"wiki/getting_started/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Set up NeqSim locally</li> <li>Fundamentals and thermodynamics</li> <li>Fluid characterization and PVT workflows</li> <li>Process simulation</li> <li>Dynamic behavior and process safety</li> <li>Unit operations and equipment models</li> <li>Integration, control, and automation</li> <li>Examples and tutorials</li> </ul>"},{"location":"wiki/getting_started/#set-up-neqsim-locally","title":"Set up NeqSim locally","text":"<p>Clone the repository and build with the Maven wrapper:</p> <pre><code>git clone https://github.com/equinor/neqsim.git\ncd neqsim\n./mvnw install\n</code></pre> <p>The command downloads dependencies, compiles the project, and runs the test suite. For environment notes and troubleshooting tips, see the README and developer setup guide.</p>"},{"location":"wiki/getting_started/#fundamentals-and-thermodynamics","title":"Fundamentals and thermodynamics","text":"<ul> <li>Read the Thermodynamics Guide for an overview of models, correlations, and implementation notes.</li> <li>Explore validated calculations in Flash equations and tests and the Thermodynamics of gas processing.</li> <li>Review property-focused workflows in Property flash workflows and viscosity models in Viscosity models.</li> </ul>"},{"location":"wiki/getting_started/#fluid-characterization-and-pvt-workflows","title":"Fluid characterization and PVT workflows","text":"<ul> <li>Follow Fluid Characterization for setting up equations of state and component data.</li> <li>Use the PVT simulation workflows and Black-oil flash playbook for reservoir-focused setups.</li> <li>See Gas quality standards from tests for handling analytical measurements.</li> </ul>"},{"location":"wiki/getting_started/#process-simulation","title":"Process simulation","text":"<ul> <li>Start with the Process Simulation Guide for steady-state modeling patterns.</li> <li>Dive deeper into Advanced process simulation and Logical unit operations for custom flowsheets.</li> <li>Consult the Modules overview and Process calculator when wiring NeqSim into larger systems.</li> </ul>"},{"location":"wiki/getting_started/#dynamic-behavior-and-process-safety","title":"Dynamic behavior and process safety","text":"<ul> <li>Study dynamic blowdown and protection behavior in ESD blowdown systems, PSV dynamic sizing, and HIPPS implementation.</li> <li>Review layered safety topics in Integrated safety systems, HIPPS summary, and Layered safety architecture.</li> <li>For alarm logic and shutdown sequencing, see Alarm system guide, SIS logic implementation, and Integration safety chain tests.</li> </ul>"},{"location":"wiki/getting_started/#unit-operations-and-equipment-models","title":"Unit operations and equipment models","text":"<ul> <li>Browse individual equipment pages such as Distillation column, Air cooler, Water cooler, and Heat exchanger mechanical design.</li> <li>For specialized models, see Flow meter models, Battery storage unit, Solar panel, and Pump usage guide.</li> <li>Additional unit operations and mechanical details are covered in the Process logic enhancements series.</li> </ul>"},{"location":"wiki/getting_started/#integration-control-and-automation","title":"Integration, control, and automation","text":"<ul> <li>Connect NeqSim to control systems using the Process control framework and Real-time integration guide.</li> <li>Learn about runtime flexibility in Runtime logic flexibility and alarm handling in Alarm triggered logic example.</li> <li>For scripting and hybrid workflows, see Java simulations from Colab notebooks and Java/Python usage examples.</li> </ul>"},{"location":"wiki/getting_started/#examples-and-tutorials","title":"Examples and tutorials","text":"<ul> <li>Work through the Usage examples for end-to-end flows in both Java and Python.</li> <li>Try the Process transient simulation guide and Process simulation using NeqSim for hands-on modeling patterns.</li> <li>Explore extended topics such as Process automation and logic implementation summary and integration tests in Test overview.</li> </ul>"},{"location":"wiki/gibbs_reactor/","title":"Gibbs Reactor","text":"<p>The Gibbs Reactor is a chemical equilibrium reactor that computes outlet compositions by minimizing the total Gibbs free energy of the system. It is used for modeling chemical reactions at thermodynamic equilibrium.</p>"},{"location":"wiki/gibbs_reactor/#overview","title":"Overview","text":"<p>The <code>GibbsReactor</code> class performs chemical equilibrium calculations using Gibbs free energy minimization with Lagrange multipliers. The reactor automatically determines the equilibrium composition based on:</p> <ul> <li>Inlet stream composition</li> <li>Temperature and pressure conditions</li> <li>Elemental mass balance constraints</li> <li>Thermodynamic properties from the Gibbs database</li> </ul>"},{"location":"wiki/gibbs_reactor/#key-features","title":"Key Features","text":"<ul> <li>Isothermal and Adiabatic Modes: Supports both constant-temperature and heat-balanced operation</li> <li>Multi-component Systems: Handles complex mixtures with multiple reacting species</li> <li>Inert Components: Allows marking specific components as non-reactive</li> <li>Convergence Diagnostics: Provides detailed iteration metrics and mass balance verification</li> <li>Customizable Solver: Adjustable damping, tolerance, and iteration limits</li> </ul>"},{"location":"wiki/gibbs_reactor/#mathematical-background","title":"Mathematical Background","text":"<p>The reactor minimizes the objective function:</p> \\[G = \\sum_i n_i \\left( \\mu_i^0 + RT \\ln(\\phi_i y_i P) \\right) - \\sum_j \\lambda_j \\left( \\sum_i a_{ij} n_i - b_j \\right)\\] <p>Where: - \\(n_i\\) = molar amount of component \\(i\\) - \\(\\mu_i^0\\) = standard chemical potential of component \\(i\\) - \\(\\phi_i\\) = fugacity coefficient of component \\(i\\) - \\(y_i\\) = mole fraction of component \\(i\\) - \\(P\\) = pressure - \\(\\lambda_j\\) = Lagrange multiplier for element \\(j\\) - \\(a_{ij}\\) = number of atoms of element \\(j\\) in component \\(i\\) - \\(b_j\\) = total moles of element \\(j\\) (conserved)</p> <p>The Newton-Raphson method iteratively solves for compositions and Lagrange multipliers until convergence.</p>"},{"location":"wiki/gibbs_reactor/#basic-usage","title":"Basic Usage","text":"<pre><code>import neqsim.process.equipment.reactor.GibbsReactor;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create inlet stream\nSystemSrkEos system = new SystemSrkEos(298.15, 10.0);\nsystem.addComponent(\"methane\", 1.0, \"mol/sec\");\nsystem.addComponent(\"oxygen\", 2.0, \"mol/sec\");\nsystem.addComponent(\"CO2\", 0.0, \"mol/sec\");\nsystem.addComponent(\"water\", 0.0, \"mol/sec\");\nsystem.setMixingRule(2);\n\nStream inlet = new Stream(\"inlet\", system);\ninlet.run();\n\n// Create and configure reactor\nGibbsReactor reactor = new GibbsReactor(\"combustion reactor\", inlet);\nreactor.setEnergyMode(GibbsReactor.EnergyMode.ISOTHERMAL);\nreactor.setMaxIterations(5000);\nreactor.setConvergenceTolerance(1e-6);\nreactor.setDampingComposition(0.01);\nreactor.run();\n\n// Get results\nStream outlet = (Stream) reactor.getOutletStream();\nSystem.out.println(\"Outlet temperature: \" + outlet.getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"Conversion completed: \" + reactor.hasConverged());\n</code></pre>"},{"location":"wiki/gibbs_reactor/#configuration-options","title":"Configuration Options","text":""},{"location":"wiki/gibbs_reactor/#energy-mode","title":"Energy Mode","text":"<pre><code>// Isothermal: temperature remains constant\nreactor.setEnergyMode(GibbsReactor.EnergyMode.ISOTHERMAL);\n\n// Adiabatic: temperature changes based on reaction enthalpy\nreactor.setEnergyMode(GibbsReactor.EnergyMode.ADIABATIC);\n\n// Using string (case-insensitive)\nreactor.setEnergyMode(\"adiabatic\");\n</code></pre>"},{"location":"wiki/gibbs_reactor/#solver-parameters","title":"Solver Parameters","text":"Parameter Method Default Description Max Iterations <code>setMaxIterations(int)</code> 5000 Maximum Newton-Raphson iterations Convergence Tolerance <code>setConvergenceTolerance(double)</code> 1e-3 Convergence criterion for delta norm Damping Factor <code>setDampingComposition(double)</code> 0.05 Step size for composition updates <pre><code>reactor.setMaxIterations(10000);\nreactor.setConvergenceTolerance(1e-8);\nreactor.setDampingComposition(0.001);  // Smaller = more stable, slower\n</code></pre>"},{"location":"wiki/gibbs_reactor/#inert-components","title":"Inert Components","text":"<p>Mark components that should not participate in reactions:</p> <pre><code>// By name\nreactor.setComponentAsInert(\"nitrogen\");\nreactor.setComponentAsInert(\"argon\");\n\n// By index\nreactor.setComponentAsInert(0);\n</code></pre>"},{"location":"wiki/gibbs_reactor/#database-species","title":"Database Species","text":"<pre><code>// Use only components present in inlet stream (default)\nreactor.setUseAllDatabaseSpecies(false);\n\n// Add all species from Gibbs database (for product prediction)\nreactor.setUseAllDatabaseSpecies(true);\n</code></pre>"},{"location":"wiki/gibbs_reactor/#results-and-diagnostics","title":"Results and Diagnostics","text":""},{"location":"wiki/gibbs_reactor/#convergence-status","title":"Convergence Status","text":"<pre><code>if (reactor.hasConverged()) {\n    System.out.println(\"Solution converged in \" + reactor.getActualIterations() + \" iterations\");\n} else {\n    System.out.println(\"Failed to converge. Final error: \" + reactor.getFinalConvergenceError());\n}\n</code></pre>"},{"location":"wiki/gibbs_reactor/#thermodynamic-results","title":"Thermodynamic Results","text":"<pre><code>// Enthalpy of reaction (kJ)\ndouble deltaH = reactor.getEnthalpyOfReactions();\n\n// Temperature change in adiabatic mode (K)\ndouble deltaT = reactor.getTemperatureChange();\n\n// Reactor power (W, kW, or MW)\ndouble powerW = reactor.getPower(\"W\");\ndouble powerKW = reactor.getPower(\"kW\");\n</code></pre>"},{"location":"wiki/gibbs_reactor/#mass-balance-verification","title":"Mass Balance Verification","text":"<pre><code>// Check mass balance closure\ndouble massError = reactor.getMassBalanceError();  // Percentage error\nboolean balanced = reactor.getMassBalanceConverged();  // True if error &lt; 0.1%\n\n// Element-wise balance\ndouble[] elementIn = reactor.getElementMoleBalanceIn();\ndouble[] elementOut = reactor.getElementMoleBalanceOut();\ndouble[] elementDiff = reactor.getElementMoleBalanceDiff();\nString[] elementNames = reactor.getElementNames();  // [\"O\", \"N\", \"C\", \"H\", \"S\", \"Ar\", \"Z\"]\n</code></pre>"},{"location":"wiki/gibbs_reactor/#molar-flows","title":"Molar Flows","text":"<pre><code>List&lt;Double&gt; inletMoles = reactor.getInletMoles();\nList&lt;Double&gt; outletMoles = reactor.getOutletMoles();\n</code></pre>"},{"location":"wiki/gibbs_reactor/#specialized-reactor-gibbsreactorco2","title":"Specialized Reactor: GibbsReactorCO2","text":"<p>For CO2/acid gas systems, use <code>GibbsReactorCO2</code> which provides pre-configured reaction pathways:</p> <pre><code>import neqsim.process.equipment.reactor.GibbsReactorCO2;\n\nGibbsReactorCO2 acidGasReactor = new GibbsReactorCO2(\"acid gas reactor\", inlet);\nacidGasReactor.run();\n</code></pre> <p>Important Limitations of GibbsReactorCO2: - Only bulk (homogeneous) phase reactions are modeled - Surface reactions and heterogeneous catalysis are not included - Reactions are disabled when CO2 density falls below 300 kg/m\u00b3</p>"},{"location":"wiki/gibbs_reactor/#troubleshooting","title":"Troubleshooting","text":""},{"location":"wiki/gibbs_reactor/#convergence-issues","title":"Convergence Issues","text":"<ol> <li>Reduce damping factor: Try <code>setDampingComposition(0.001)</code> or smaller</li> <li>Increase iterations: Use <code>setMaxIterations(20000)</code></li> <li>Check initial compositions: Ensure products have small non-zero initial amounts</li> <li>Mark inerts: Components that don't react should be marked as inert</li> </ol>"},{"location":"wiki/gibbs_reactor/#mass-balance-errors","title":"Mass Balance Errors","text":"<p>If mass balance doesn't close: - Reduce the damping factor for better numerical stability - Check that all relevant species are included in the system - Verify component names match the Gibbs database</p>"},{"location":"wiki/gibbs_reactor/#numerical-instabilities","title":"Numerical Instabilities","text":"<p>For stiff systems: <pre><code>reactor.setDampingComposition(0.0001);  // Very small steps\nreactor.setMaxIterations(50000);        // Allow more iterations\nreactor.setConvergenceTolerance(1e-4);  // Relax tolerance slightly\n</code></pre></p>"},{"location":"wiki/gibbs_reactor/#gibbs-database","title":"Gibbs Database","text":"<p>The reactor uses thermodynamic data from CSV files in <code>src/main/resources/data/GibbsReactDatabase/</code>:</p> <ul> <li><code>GibbsReactDatabase.csv</code> - Component properties (elements, heat capacity, formation enthalpies)</li> <li><code>DatabaseGibbsFreeEnergyCoeff.csv</code> - Polynomial coefficients for Gibbs energy calculations</li> </ul>"},{"location":"wiki/gibbs_reactor/#supported-elements","title":"Supported Elements","text":"<p>The reactor tracks mass balance for: O, N, C, H, S, Ar, Z (charge)</p>"},{"location":"wiki/gibbs_reactor/#adding-custom-components","title":"Adding Custom Components","text":"<p>Custom components can be added to the database files following the existing format. Each component requires: - Elemental composition - Heat capacity coefficients (A, B, C, D) - Standard enthalpy of formation (\u0394Hf\u00b0 at 298.15 K) - Standard Gibbs energy of formation (\u0394Gf\u00b0 at 298.15 K) - Standard entropy (\u0394Sf\u00b0 at 298.15 K)</p>"},{"location":"wiki/gibbs_reactor/#see-also","title":"See Also","text":"<ul> <li>Process Equipment Overview</li> <li>Stream Documentation</li> <li>Thermodynamic Systems</li> </ul>"},{"location":"wiki/heat_exchanger_mechanical_design/","title":"Heat Exchanger Mechanical Design","text":""},{"location":"wiki/heat_exchanger_mechanical_design/#overview","title":"Overview","text":"<p>The <code>HeatExchangerMechanicalDesign</code> class provides sizing estimates for shell-and-tube, plate-and-frame, air cooler, and double-pipe exchangers. It can be attached to a full two-stream <code>HeatExchanger</code> or to single-stream <code>Heater</code> and <code>Cooler</code> units that supply an auxiliary utility specification. The mechanical design routine evaluates the candidate exchanger types, computes the required UA and approach temperatures, and selects a preferred configuration based on area, weight, or pressure-drop criteria.</p>"},{"location":"wiki/heat_exchanger_mechanical_design/#prerequisites","title":"Prerequisites","text":"<ul> <li>Run the process simulation so that the process-side temperatures, pressures, and duty are available.</li> <li>Ensure the equipment has been initialized (<code>initMechanicalDesign</code>) before requesting the sizing results.</li> </ul>"},{"location":"wiki/heat_exchanger_mechanical_design/#two-stream-heat-exchangers","title":"Two-Stream Heat Exchangers","text":"<p>For a <code>HeatExchanger</code>, the design routine uses the duty, stream inlet/outlet temperatures, and (if provided) UA or thermal effectiveness to compute the log-mean temperature difference (LMTD) and overall heat-transfer requirements. The selected exchanger geometry is exposed through <code>HeatExchangerSizingResult</code>.</p> <pre><code>HeatExchanger exchanger = new HeatExchanger(\"hx\", hotStream, coldStream);\nexchanger.run();\n\nexchanger.initMechanicalDesign();\nHeatExchangerMechanicalDesign design = exchanger.getMechanicalDesign();\ndesign.calcDesign();\n\nHeatExchangerSizingResult result = design.getSelectedSizingResult();\nSystem.out.println(result.getType() + \" area = \" + result.getRequiredArea());\n</code></pre>"},{"location":"wiki/heat_exchanger_mechanical_design/#single-stream-heaters-and-coolers","title":"Single-Stream Heaters and Coolers","text":"<p>A <code>Heater</code> or <code>Cooler</code> needs a <code>UtilityStreamSpecification</code> so the mechanical design can derive the utility-side temperatures or heat capacity rate.</p> <pre><code>Heater heater = new Heater(\"heater\", feed);\nheater.setOutTemperature(80.0, \"C\");\n\nUtilityStreamSpecification utility = new UtilityStreamSpecification();\nutility.setSupplyTemperature(180.0, \"C\");\nutility.setReturnTemperature(160.0, \"C\");\nutility.setOverallHeatTransferCoefficient(650.0);\nheater.setUtilitySpecification(utility);\n\nheater.run();\nheater.initMechanicalDesign();\nHeatExchangerMechanicalDesign design = heater.getMechanicalDesign();\ndesign.calcDesign();\n</code></pre> <p>The specification supports setting:</p> <ul> <li>Supply or return temperature (in K or degC).</li> <li>Approach temperature (if only a minimum pinch is known).</li> <li>Heat-capacity rate (<code>m*Cp</code>) to back-calculate the return temperature from duty.</li> <li>Overall heat-transfer coefficient to influence area estimates.</li> </ul> <p>You can also configure the utility through convenience setters such as <code>setUtilitySupplyTemperature</code>, <code>setUtilityReturnTemperature</code>, <code>setUtilityHeatCapacityRate</code>, and <code>setUtilityApproachTemperature</code>.</p>"},{"location":"wiki/heat_exchanger_mechanical_design/#inspecting-sizing-alternatives","title":"Inspecting Sizing Alternatives","text":"<p>All evaluated designs are available through <code>getSizingResults()</code>. Use the selection helpers to control the preferred configuration:</p> <pre><code>design.setCandidateTypes(\n    HeatExchangerType.SHELL_AND_TUBE,\n    HeatExchangerType.PLATE_AND_FRAME);\n\ndesign.setSelectionCriterion(SelectionCriterion.MIN_WEIGHT);\ndesign.calcDesign();\n</code></pre> <ul> <li><code>setManualSelection</code> forces a specific exchanger type when benchmarking alternatives.</li> <li><code>setSelectionCriterion</code> controls the automatic choice (area, weight, or pressure drop).</li> <li><code>getSizingSummary()</code> returns a short formatted overview suitable for logs or reports.</li> </ul>"},{"location":"wiki/heat_exchanger_mechanical_design/#related-topics","title":"Related Topics","text":"<ul> <li><code>UtilityStreamSpecification</code> (JavaDoc) for the full list of utility parameters.</li> <li>Unit tests in <code>HeaterCoolerMechanicalDesignTest</code> illustrate heater and cooler sizing workflows.</li> <li>The README section \"Heat exchanger mechanical design\" (see below) for a short summary.</li> </ul>"},{"location":"wiki/humid_air_math/","title":"Humid air mathematics","text":"<p>This page summarises the equations implemented in the <code>HumidAir</code> utility class for psychrometric calculations. The correlations are based on the ASHRAE Handbook Fundamentals (2017), CoolProp and the IAPWS formulation for the saturation pressure of water.</p>"},{"location":"wiki/humid_air_math/#saturation-pressure-of-water","title":"Saturation pressure of water","text":"<p>For temperatures \\(T\\) above the triple point the saturation vapour pressure \\(p_{ws}\\) in pascal is given by the IAPWS equation of Wagner and Pruss (2002)</p> \\[ \\ln\\left(\\frac{p_{ws}}{p_c}\\right) = \\frac{T_c}{T}\\left(a_1\\theta + a_2\\theta^{3/2} + a_3\\theta^3 + a_4\\theta^{7/2} + a_5\\theta^4 + a_6\\theta^{15/2}\\right) \\] <p>where \\(\\theta = 1 - T/T_c\\), \\(T_c = 647.096\\ \\text{K}\\) and \\(p_c = 22.064\\ \\text{MPa}\\). Below the triple point a sublimation correlation is used.</p>"},{"location":"wiki/humid_air_math/#humidity-ratio","title":"Humidity ratio","text":"<p>The humidity ratio \\(W\\) relates the mass of water vapour to the mass of dry air</p> \\[ W = \\varepsilon \\frac{p_w}{p - p_w} \\] <p>where \\(\\varepsilon = M_w/M_{da} \\approx 0.621945\\), \\(p\\) is the total pressure and \\(p_w\\) the partial pressure of water.</p> <p>For a given relative humidity \\(\\phi\\), the partial pressure is \\(p_w = \\phi p_{ws}\\).</p>"},{"location":"wiki/humid_air_math/#dew-point-temperature","title":"Dew point temperature","text":"<p>Given a humidity ratio, the dew point temperature \\(T_d\\) is found by solving \\(p_{ws}(T_d) = p_w\\). The <code>HumidAir</code> implementation uses a simple Newton iteration.</p>"},{"location":"wiki/humid_air_math/#specific-enthalpy","title":"Specific enthalpy","text":"<p>On a dry-air basis the specific enthalpy \\(h\\) in kJ/kg dry air is approximated by</p> \\[ h = 1.006\\,t + W (2501 + 1.86\\,t) \\] <p>where \\(t\\) is the temperature in degrees Celsius and \\(W\\) is the humidity ratio.</p>"},{"location":"wiki/humid_air_math/#saturated-specific-heat","title":"Saturated specific heat","text":"<p>CoolProp provides a correlation for the saturated humid-air specific heat \\(c_{p,\\text{sat}}\\) at 1\\,atm valid from 250\\,K to 300\\,K</p> \\[ c_{p,\\text{sat}} = 2.146\\,27073 \\times 10^{3} - 3.289\\,17768 \\times 10^{1}T + 1.894\\,71075 \\times 10^{-1}T^2 \\\\  - 4.862\\,90986 \\times 10^{-4}T^3 + 4.695\\,40143 \\times 10^{-7}T^4. \\]"},{"location":"wiki/java_simulation_from_colab_notebooks/","title":"Java simulations inspired by NeqSim Colab notebooks","text":"<p>This guide shows how to translate the interactive workflows from the NeqSim-Colab notebooks into pure Java simulations. The notebooks run NeqSim through a Python bridge, but the thermodynamics, process models, and solver settings are the same as in Java. Use this page to recreate those examples in IDEs or CI pipelines where Java is preferred.</p>"},{"location":"wiki/java_simulation_from_colab_notebooks/#prerequisites","title":"Prerequisites","text":"<ol> <li>Add the NeqSim dependency to your Maven or Gradle build (for Maven,    use <code>pom.xml</code> with groupId <code>com.github.equinor</code> and artifactId    <code>neqsim</code> from Maven Central).</li> <li>Ensure you have the same component names and units used in the    notebooks (mole fractions, bar, and Kelvin unless noted).</li> <li>Enable a database connection when you need accurate equation of state    parameters, mimicking the <code>fluid = fluid('srk')</code> cell in Colab.</li> </ol> <pre><code>SystemSrkEos fluid = new SystemSrkEos(288.15, 100.0);\nfluid.addComponent(\"methane\", 0.9);\nfluid.addComponent(\"ethane\", 0.05);\nfluid.addComponent(\"propane\", 0.03);\nfluid.addComponent(\"n-hexane\", 0.02);\nfluid.createDatabase();\nfluid.setMixingRule(2); // classic SRK as in the PVT notebooks\n</code></pre>"},{"location":"wiki/java_simulation_from_colab_notebooks/#mapping-common-notebooks-to-java","title":"Mapping common notebooks to Java","text":""},{"location":"wiki/java_simulation_from_colab_notebooks/#pvt-and-flash-notebooks","title":"PVT and flash notebooks","text":"<p>The PVT notebooks (e.g., <code>notebooks/PVT</code>) typically run TP or PT flashes followed by property extraction. In Java, use <code>ThermodynamicOperations</code> for the flashes and retrieve phase data from the <code>SystemInterface</code>.</p> <pre><code>ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\nops.TPflash();\n\nSystem.out.println(\"Z-factors: \" + Arrays.toString(fluid.getZ()));\nSystem.out.println(\"Phase fractions: \" + Arrays.toString(fluid.getPhaseFraction()));\nSystem.out.println(\"GOR (Sm3/Sm3): \" + fluid.getGOR());\n</code></pre> <p>For constant-volume or differential liberation sequences demonstrated in Colab, iterate flashes while updating pressure or removing produced vapour, mirroring the loop constructs in the notebooks.</p>"},{"location":"wiki/java_simulation_from_colab_notebooks/#lng-dehydration-and-membranes","title":"LNG, dehydration, and membranes","text":"<p>Process notebooks under <code>notebooks/LNG</code> and <code>notebooks/AI</code> connect streams to unit operations like heat exchangers, expanders, membranes, and glycol dehydrators. Build the same flows in Java using <code>ProcessSystem</code> and the corresponding unit classes.</p> <pre><code>ProcessSystem process = new ProcessSystem();\nStream feed = new Stream(\"feed\", fluid);\nfeed.setFlowRate(1.0, \"MSm3/day\");\n\nHeater chiller = new Heater(\"pre-cooler\", feed);\nchiller.setOutTemperature(248.15);\n\nThrottlingValve expander = new ThrottlingValve(\"expander\", chiller.getOutletStream());\nexpander.setOutletPressure(5.0); // bar\n\nSeparator coldSeparator = new Separator(\"cold separator\", expander.getOutletStream());\n\nprocess.add(feed);\nprocess.add(chiller);\nprocess.add(expander);\nprocess.add(coldSeparator);\nprocess.run();\n</code></pre> <p>Use <code>getOutletStream()</code> from each unit to pass streams to downstream operations. For dehydration, connect <code>Separator</code> gas outlets to <code>GlycolDehydrationlModule</code> and set specifications just as the notebook cells set target water content.</p>"},{"location":"wiki/java_simulation_from_colab_notebooks/#dynamic-and-digital-twin-notebooks","title":"Dynamic and digital-twin notebooks","text":"<p>The Industry 4.0 notebooks in <code>notebooks/AI</code> stream dynamic results to plots. In Java, enable dynamics by switching the <code>ProcessSystem</code> to transient mode and stepping the solver while logging sensor variables.</p> <pre><code>process.setTimeStep(0.5); // hours\nprocess.setMaxNumberOfTimeSteps(200);\nprocess.runTransient();\n\ndouble[] pressureTrace = expander.getOutletStream().getPressureProfile();\n</code></pre> <p>Attach PID controllers (<code>ControllerDevice</code>) to match the control loops in those notebooks\u2014for instance, controlling separator pressure via valve opening or maintaining dew point via coolant temperature.</p>"},{"location":"wiki/java_simulation_from_colab_notebooks/#exporting-results-for-notebooks","title":"Exporting results for notebooks","text":"<p>When you want to feed Java results back into a notebook (for validation or training), export stream tables as CSV or JSON. The Colab notebooks usually turn <code>pandas</code> DataFrames into charts; in Java, you can write the same tables using standard libraries.</p> <pre><code>try (PrintWriter writer = new PrintWriter(\"cold-separator-summary.csv\")) {\n    writer.println(\"step,pressure_bar,gas_rate_kgph,liquid_rate_kgph\");\n    for (int step = 0; step &lt; pressureTrace.length; step++) {\n        double p = coldSeparator.getGasOutStream().getPressureProfile()[step];\n        double gas = coldSeparator.getGasOutStream().getFlowRateProfile(\"kg/hr\")[step];\n        double liq = coldSeparator.getLiquidOutStream().getFlowRateProfile(\"kg/hr\")[step];\n        writer.printf(\"%d,%.3f,%.3f,%.3f%n\", step, p, gas, liq);\n    }\n}\n</code></pre> <p>You can then load these CSVs in Colab with <code>pandas.read_csv</code> to compare Java transient trajectories with the notebook runs.</p>"},{"location":"wiki/java_simulation_from_colab_notebooks/#tips-for-staying-aligned-with-the-notebooks","title":"Tips for staying aligned with the notebooks","text":"<ul> <li>Use the same unit systems shown in the cells (usually SI). The   <code>setTemperature</code>/<code>setPressure</code> methods accept unit strings identical to   the notebook helpers.</li> <li>Keep the same mixing rules and volume shift settings to reproduce   liquid yields, Wobbe indices, and dew-point calculations from the   Colab examples.</li> <li>For LPG and LNG cases, ensure low-temperature property packages (CPA or   SRK with volume correction) match the selections called out in the   notebook markdown cells.</li> <li>Dynamic notebooks often ramp valve openings or compressor speeds\u2014mirror   these with <code>setOpening</code> or <code>setCompressorSpeed</code> in a timestep loop for   close alignment.</li> </ul> <p>For additional notebook context and datasets, browse the NeqSim-Colab repository and open the relevant <code>.ipynb</code> files next to this Java guide.</p>"},{"location":"wiki/logical_unit_operations/","title":"Logical Unit Operations","text":"<p>NeqSim provides several \"logical\" unit operations that do not represent physical equipment but are used to control the simulation, transfer data, or perform calculations. These include <code>Calculator</code>, <code>Adjuster</code>, <code>SetPoint</code>, and <code>Recycle</code>.</p>"},{"location":"wiki/logical_unit_operations/#calculator","title":"Calculator","text":"<p>The <code>Calculator</code> unit operation allows for custom calculations and data manipulation within a process simulation. It is useful for calculating derived properties or implementing simple control logic. Custom lambdas are the preferred hook for AI-generated logic because they let you keep the same simulator graph while swapping in new behavior at runtime.</p>"},{"location":"wiki/logical_unit_operations/#usage","title":"Usage","text":"<ol> <li>Create: <code>Calculator calc = new Calculator(\"name\");</code></li> <li>Add Inputs: <code>calc.addInputVariable(inputUnit);</code></li> <li>Set Output: <code>calc.setOutputVariable(outputUnit);</code></li> <li>Define Logic: Use <code>setCalculationMethod</code> with a lambda expression.</li> </ol>"},{"location":"wiki/logical_unit_operations/#example","title":"Example","text":"<pre><code>Calculator energyCalc = new Calculator(\"Energy Calc\");\nenergyCalc.addInputVariable(inletStream);\nenergyCalc.setOutputVariable(outletStream);\n\nenergyCalc.setCalculationMethod((inputs, output) -&gt; {\n    Stream in = (Stream) inputs.get(0);\n    Stream out = (Stream) output;\n    double energy = in.LCV() * in.getFlowRate(\"Sm3/hr\");\n    // Adjust outlet temperature based on energy\n    out.setTemperature(300.0 + energy / 1e5, \"K\");\n});\n</code></pre>"},{"location":"wiki/logical_unit_operations/#declarative-presets-energy-balance-dew-point-targeting","title":"Declarative presets (energy balance, dew point targeting)","text":"<p>For frequently reused logic you can rely on <code>CalculatorLibrary</code> presets instead of hand-written lambdas. This makes it easier to reference calculations declaratively (e.g., from an AI agent or configuration file):</p> <pre><code>Calculator presetCalc = new Calculator(\"dew point targeter\");\npresetCalc.addInputVariable(feedStream);\npresetCalc.setOutputVariable(targetStream);\n\n// Apply by enum or by name\npresetCalc.setCalculationMethod(CalculatorLibrary.preset(CalculatorLibrary.Preset.DEW_POINT_TARGETING));\n// presetCalc.setCalculationMethod(CalculatorLibrary.byName(\"dewPointTargeting\"));\n</code></pre> <p>Available presets:</p> <ul> <li>ENERGY_BALANCE \u2013 matches the output stream enthalpy to the sum of input enthalpies by flashing at the output pressure.</li> <li>DEW_POINT_TARGETING \u2013 sets the output stream temperature to the source stream dew point at the output pressure (optionally with a temperature margin via <code>CalculatorLibrary.dewPointTargeting(double marginKelvin)</code>).</li> </ul>"},{"location":"wiki/logical_unit_operations/#adjuster","title":"Adjuster","text":"<p>The <code>Adjuster</code> is used to vary a parameter in one unit operation (the \"adjusted variable\") to achieve a specific value in another unit operation (the \"target variable\"). It is essentially a single-variable solver. Use lambdas for the getters/setters to keep the hook flexible for AI-generated control logic.</p>"},{"location":"wiki/logical_unit_operations/#standard-usage","title":"Standard Usage","text":"<p>You can specify standard properties like \"pressure\", \"temperature\", \"flow\", etc.</p> <pre><code>Adjuster adjuster = new Adjuster(\"Pressure Adjuster\");\nadjuster.setAdjustedVariable(inletStream, \"flow\", \"kg/hr\");\nadjuster.setTargetVariable(outletStream, \"pressure\", 50.0, \"bara\");\n</code></pre>"},{"location":"wiki/logical_unit_operations/#custom-target-calculation","title":"Custom Target Calculation","text":"<p>You can also define a custom function to calculate the target value from the target equipment. This is useful if the variable you want to control is not a standard property.</p> <pre><code>adjuster.setTargetValueCalculator((equipment) -&gt; {\n    Stream s = (Stream) equipment;\n    // Control based on a custom metric, e.g., Flow * Temperature\n    return s.getFlowRate(\"kg/hr\") * s.getTemperature(\"K\");\n});\n</code></pre>"},{"location":"wiki/logical_unit_operations/#custom-adjusted-variable","title":"Custom Adjusted Variable","text":"<p>You can also define custom logic for how to read and write the adjusted variable. This allows you to manipulate parameters that are not standard properties.</p> <pre><code>// Define how to read the current value of the adjusted variable\nadjuster.setAdjustedValueGetter((equipment) -&gt; {\n    return ((Stream) equipment).getTemperature(\"K\");\n});\n\n// Define how to set the new value of the adjusted variable\nadjuster.setAdjustedValueSetter((equipment, val) -&gt; {\n    ((Stream) equipment).setTemperature(val, \"K\");\n});\n</code></pre>"},{"location":"wiki/logical_unit_operations/#setpoint","title":"SetPoint","text":"<p>The <code>SetPoint</code> unit operation sets the value of a variable in a target unit operation equal to the value of a variable in a source unit operation. It is used for feed-forward control or simply copying values.</p>"},{"location":"wiki/logical_unit_operations/#standard-usage_1","title":"Standard Usage","text":"<pre><code>SetPoint setPoint = new SetPoint(\"Pressure Copy\");\nsetPoint.setSourceVariable(sourceStream, \"pressure\");\nsetPoint.setTargetVariable(targetStream, \"pressure\");\n</code></pre>"},{"location":"wiki/logical_unit_operations/#custom-source-calculation","title":"Custom Source Calculation","text":"<p>You can define a custom function to calculate the value to be set on the target equipment, based on the source equipment.</p> <pre><code>setPoint.setSourceValueCalculator((equipment) -&gt; {\n    Stream s = (Stream) equipment;\n    // Set target pressure to be 10% of source pressure\n    return s.getPressure(\"bara\") * 0.1;\n});\n</code></pre>"},{"location":"wiki/logical_unit_operations/#recycle","title":"Recycle","text":"<p>The <code>Recycle</code> unit operation is used to close loops in a process simulation. It compares the inlet and outlet streams of the recycle block and iterates until they converge within a specified tolerance.</p> <pre><code>Recycle recycle = new Recycle(\"Recycle\");\nrecycle.addStream(recycleStream);\nrecycle.setTolerance(1e-6);\n</code></pre>"},{"location":"wiki/membrane_separation/","title":"Membrane separation","text":"<p>This page outlines the basic model implemented in the <code>MembraneSeparator</code> unit. The unit is intended for simple simulations of gas separation membranes or pervaporation modules used in purification and CO2 capture.</p>"},{"location":"wiki/membrane_separation/#flux-model","title":"Flux model","text":"<p>For each component \\(i\\) a constant permeate fraction \\(f_i\\) can be specified. The molar amount transferred to the permeate side is $$ N_i^{\\text{perm}} = f_i N_i^{\\text{feed}} $$ where \\(N_i^{\\text{feed}}\\) is the molar amount in the feed stream. Components without a specified fraction use a global default value.</p> <p>A more rigorous model could employ Fick's law of diffusion through the membrane $$ J_i = P_i \\left(p_{i,\\text{feed}} - p_{i,\\text{perm}}\\right) $$ where \\(P_i\\) is the permeability of component \\(i\\) and \\(p_i\\) are partial pressures. The separator can now perform this calculation mode when permeabilities and a membrane area are supplied.</p>"},{"location":"wiki/membrane_separation/#usage","title":"Usage","text":"<p><pre><code>MembraneSeparator mem = new MembraneSeparator(\"mem\", feedStream);\nmem.setDefaultPermeateFraction(0.1); // 10 % of each component permeates\nmem.setPermeateFraction(\"CO2\", 0.5); // override CO2 fraction\n</code></pre> // Alternative using permeability coefficients mem.clearPermeateFractions(); mem.setMembraneArea(5.0); // m^2 mem.setPermeability(\"CO2\", 5e-6); // mol/(m2*s*Pa) mem.setPermeability(\"methane\", 1e-6); <code>`` After running the process, the permeate and retentate streams can be obtained via</code>getPermeateStream()<code>and</code>getRetentateStream()`.</p>"},{"location":"wiki/multiphase_transient_model/","title":"Multiphase 1D Transient Pipeline Model - Implementation Recommendations","text":""},{"location":"wiki/multiphase_transient_model/#executive-summary","title":"Executive Summary","text":"<p>This document outlines recommendations for implementing a full multiphase 1D transient pipeline model in NeqSim, similar to commercial tools like OLGA and LedaFlow. The model would handle:</p> <ul> <li>Liquid accumulation (holdup dynamics)</li> <li>Slug flow (terrain-induced and hydrodynamic slugs)</li> <li>Three-phase flow (gas, oil, water)</li> <li>Transient behavior (startup, shutdown, pigging, rate changes)</li> </ul>"},{"location":"wiki/multiphase_transient_model/#current-state-in-neqsim","title":"Current State in NeqSim","text":""},{"location":"wiki/multiphase_transient_model/#existing-capabilities","title":"Existing Capabilities","text":"Component Status Notes <code>PipeBeggsAndBrills</code> \u2705 Steady-state multiphase, quasi-transient advection <code>WaterHammerPipe</code> \u2705 Fast transients (MOC), single-phase Thermodynamics \u2705 Full EOS, flash calculations, physical properties Flow regime maps \u2705 Beggs &amp; Brill flow pattern detection Holdup correlations \u2705 Beggs &amp; Brill liquid holdup"},{"location":"wiki/multiphase_transient_model/#gaps-for-full-transient-multiphase","title":"Gaps for Full Transient Multiphase","text":"Feature Current Required Mass conservation Quasi-steady Full PDE Momentum Steady friction Full transient + interfacial Energy Optional heat loss Full enthalpy transport Liquid accumulation Not tracked Dynamic holdup evolution Slug tracking Not modeled Slug initiation, growth, dissipation Phase slip Correlations Mechanistic drift-flux or two-fluid"},{"location":"wiki/multiphase_transient_model/#recommended-model-architecture","title":"Recommended Model Architecture","text":""},{"location":"wiki/multiphase_transient_model/#two-fluid-model-recommended-for-accuracy","title":"Two-Fluid Model (Recommended for Accuracy)","text":"<p>The two-fluid model solves separate conservation equations for each phase:</p>"},{"location":"wiki/multiphase_transient_model/#conservation-equations","title":"Conservation Equations","text":"<p>Gas Mass: $\\(\\frac{\\partial}{\\partial t}(\\alpha_g \\rho_g A) + \\frac{\\partial}{\\partial x}(\\alpha_g \\rho_g v_g A) = \\Gamma_g\\)$</p> <p>Liquid Mass: $\\(\\frac{\\partial}{\\partial t}(\\alpha_L \\rho_L A) + \\frac{\\partial}{\\partial x}(\\alpha_L \\rho_L v_L A) = \\Gamma_L\\)$</p> <p>Gas Momentum: $\\(\\frac{\\partial}{\\partial t}(\\alpha_g \\rho_g v_g A) + \\frac{\\partial}{\\partial x}(\\alpha_g \\rho_g v_g^2 A) = -\\alpha_g A \\frac{\\partial P}{\\partial x} - \\tau_{wg} S_g - \\tau_i S_i - \\alpha_g \\rho_g g A \\sin\\theta\\)$</p> <p>Liquid Momentum: $\\(\\frac{\\partial}{\\partial t}(\\alpha_L \\rho_L v_L A) + \\frac{\\partial}{\\partial x}(\\alpha_L \\rho_L v_L^2 A) = -\\alpha_L A \\frac{\\partial P}{\\partial x} - \\tau_{wL} S_L + \\tau_i S_i - \\alpha_L \\rho_L g A \\sin\\theta\\)$</p> <p>Mixture Energy: $\\(\\frac{\\partial}{\\partial t}(E_{mix} A) + \\frac{\\partial}{\\partial x}((E_{mix} + P) v_{mix} A) = Q_{wall} + W_{friction}\\)$</p> <p>Where: - \\(\\alpha\\) = volume fraction - \\(\\rho\\) = density - \\(v\\) = velocity - \\(\\tau_w\\) = wall shear stress - \\(\\tau_i\\) = interfacial shear stress - \\(S\\) = wetted perimeter - \\(\\Gamma\\) = mass transfer rate (flashing/condensation) - \\(\\theta\\) = pipe inclination</p>"},{"location":"wiki/multiphase_transient_model/#alternative-drift-flux-model-simpler-faster","title":"Alternative: Drift-Flux Model (Simpler, Faster)","text":"<p>For less demanding applications, a drift-flux model combines phases:</p> <p>Mixture Mass: $\\(\\frac{\\partial}{\\partial t}(\\rho_m A) + \\frac{\\partial}{\\partial x}(\\rho_m v_m A) = 0\\)$</p> <p>Mixture Momentum: $\\(\\frac{\\partial}{\\partial t}(\\rho_m v_m A) + \\frac{\\partial}{\\partial x}(\\rho_m v_m^2 A + \\Delta P_{slip}) = -A \\frac{\\partial P}{\\partial x} - \\tau_w S - \\rho_m g A \\sin\\theta\\)$</p> <p>Drift-Flux Relation: $\\(v_g = C_0 v_m + v_{drift}\\)$</p> <p>Where \\(C_0\\) is the distribution parameter and \\(v_{drift}\\) is the drift velocity (from correlations).</p>"},{"location":"wiki/multiphase_transient_model/#proposed-class-structure","title":"Proposed Class Structure","text":"<pre><code>src/main/java/neqsim/process/equipment/pipeline/\n\u251c\u2500\u2500 MultiphasePipe.java              # Main transient solver\n\u251c\u2500\u2500 MultiphasePipeSection.java       # Single pipe section state\n\u251c\u2500\u2500 transient/\n\u2502   \u251c\u2500\u2500 ConservationEquations.java   # PDE discretization\n\u2502   \u251c\u2500\u2500 FluxCalculator.java          # Numerical flux (AUSM, HLL, etc.)\n\u2502   \u251c\u2500\u2500 SourceTerms.java             # Friction, gravity, mass transfer\n\u2502   \u251c\u2500\u2500 SlugTracker.java             # Slug initiation and tracking\n\u2502   \u2514\u2500\u2500 HoldupEvolution.java         # Liquid accumulation dynamics\n\u251c\u2500\u2500 closure/\n\u2502   \u251c\u2500\u2500 FlowRegimeMap.java           # Mechanistic flow regime\n\u2502   \u251c\u2500\u2500 InterfacialFriction.java     # \u03c4_i correlations\n\u2502   \u251c\u2500\u2500 WallFriction.java            # \u03c4_wg, \u03c4_wL correlations\n\u2502   \u251c\u2500\u2500 DriftFluxParameters.java     # C_0, v_drift correlations\n\u2502   \u2514\u2500\u2500 EntrainmentDeposition.java   # Droplet exchange\n\u2514\u2500\u2500 geometry/\n    \u251c\u2500\u2500 PipeProfile.java             # Elevation, diameter profile\n    \u2514\u2500\u2500 PipeNetwork.java             # Junctions, branches\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#key-implementation-components","title":"Key Implementation Components","text":""},{"location":"wiki/multiphase_transient_model/#1-state-vector-and-grid","title":"1. State Vector and Grid","text":"<pre><code>public class MultiphasePipeSection {\n    // Primary variables (conservative)\n    private double pressure;           // Pa\n    private double gasHoldup;          // \u03b1_g (0-1)\n    private double oilHoldup;          // \u03b1_o (0-1)\n    private double waterHoldup;        // \u03b1_w (0-1)\n    private double gasVelocity;        // m/s\n    private double liquidVelocity;     // m/s (or separate oil/water)\n    private double temperature;        // K\n\n    // Derived quantities\n    private double gasDensity;\n    private double liquidDensity;\n    private double mixtureVelocity;\n    private double liquidLevel;        // For stratified flow\n    private FlowRegime flowRegime;\n\n    // Slug tracking\n    private boolean isInSlug;\n    private double slugFrontPosition;\n    private double slugTailPosition;\n    private double slugHoldup;\n\n    // Geometry\n    private double diameter;\n    private double area;\n    private double inclination;        // radians\n    private double position;           // m from inlet\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#2-flow-regime-detection-mechanistic","title":"2. Flow Regime Detection (Mechanistic)","text":"<pre><code>public enum FlowRegime {\n    STRATIFIED_SMOOTH,\n    STRATIFIED_WAVY,\n    ANNULAR,\n    SLUG,\n    DISPERSED_BUBBLE,\n    BUBBLE,\n    CHURN,\n    MIST\n}\n\npublic class MechanisticFlowRegime {\n\n    /**\n     * Determine flow regime using Taitel-Dukler or similar mechanistic model.\n     */\n    public FlowRegime determine(double vsg, double vsl, double diameter,\n                                 double inclination, PhaseProperties gas,\n                                 PhaseProperties liquid) {\n\n        // Calculate dimensionless groups\n        double froude = calcFroudeNumber(vsg, vsl, diameter);\n        double lockhart = calcLockhartMartinelli(gas, liquid, vsg, vsl);\n\n        // Stratified stability (Kelvin-Helmholtz)\n        double criticalGasVelocity = calcKelvinHelmholtzLimit(\n            liquid.getDensity(), gas.getDensity(), \n            liquidLevel, diameter, inclination);\n\n        if (vsg &lt; criticalGasVelocity &amp;&amp; inclination &lt; Math.toRadians(10)) {\n            // Check wavy vs smooth\n            if (isWavyTransition(vsg, liquid)) {\n                return FlowRegime.STRATIFIED_WAVY;\n            }\n            return FlowRegime.STRATIFIED_SMOOTH;\n        }\n\n        // Slug formation criterion\n        if (isSlugCondition(vsg, vsl, liquidLevel, diameter)) {\n            return FlowRegime.SLUG;\n        }\n\n        // Annular transition\n        if (vsg &gt; calcAnnularTransition(diameter, gas, liquid)) {\n            return FlowRegime.ANNULAR;\n        }\n\n        // ... other transitions\n        return FlowRegime.INTERMITTENT;\n    }\n\n    /**\n     * Kelvin-Helmholtz instability criterion for stratified flow.\n     */\n    private double calcKelvinHelmholtzLimit(double rhoL, double rhoG,\n                                             double hL, double D, double theta) {\n        double g = 9.81;\n        double aG = calcGasArea(hL, D);\n        double aL = calcLiquidArea(hL, D);\n        double dAL_dhL = calcDerivativeArea(hL, D);\n\n        // Taitel-Dukler criterion\n        double term1 = (rhoL - rhoG) * g * Math.cos(theta) * aG;\n        double term2 = rhoG * aL * dAL_dhL;\n\n        return Math.sqrt(term1 / term2);\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#3-slug-flow-model","title":"3. Slug Flow Model","text":"<pre><code>public class SlugTracker {\n\n    private List&lt;Slug&gt; activeSlugs = new ArrayList&lt;&gt;();\n    private double minSlugLength;       // Minimum stable slug length\n    private double slugInitiationVoid;  // \u03b1_g threshold for slug formation\n\n    public class Slug {\n        double frontPosition;    // m\n        double tailPosition;     // m\n        double velocity;         // m/s\n        double holdup;           // liquid fraction in slug body\n        double bubbleHoldup;     // gas fraction in slug bubble\n        double frequency;        // slugs per unit time\n        boolean isTerrainInduced;\n    }\n\n    /**\n     * Check for slug initiation at each grid point.\n     */\n    public void checkSlugInitiation(MultiphasePipeSection[] sections, double dt) {\n        for (int i = 1; i &lt; sections.length - 1; i++) {\n            MultiphasePipeSection sec = sections[i];\n\n            // Terrain-induced slug: liquid accumulation at low point\n            if (isLowPoint(sections, i) &amp;&amp; sec.getLiquidHoldup() &gt; slugInitiationVoid) {\n                if (!sec.isInSlug() &amp;&amp; sec.getGasVelocity() &gt; getMinGasVelocityForSlug(sec)) {\n                    initiateSlug(sections, i);\n                }\n            }\n\n            // Hydrodynamic slug: wave growth in stratified-wavy\n            if (sec.getFlowRegime() == FlowRegime.STRATIFIED_WAVY) {\n                if (isWaveBlockage(sec)) {\n                    initiateSlug(sections, i);\n                }\n            }\n        }\n    }\n\n    /**\n     * Propagate existing slugs.\n     */\n    public void propagateSlugs(MultiphasePipeSection[] sections, double dt) {\n        Iterator&lt;Slug&gt; iter = activeSlugs.iterator();\n        while (iter.hasNext()) {\n            Slug slug = iter.next();\n\n            // Slug front velocity (Bendiksen correlation)\n            double vFront = calcSlugFrontVelocity(slug, sections);\n            slug.frontPosition += vFront * dt;\n\n            // Slug tail velocity\n            double vTail = calcSlugTailVelocity(slug, sections);\n            slug.tailPosition += vTail * dt;\n\n            // Slug length\n            double length = slug.frontPosition - slug.tailPosition;\n\n            // Slug dissipation\n            if (length &lt; minSlugLength || slug.frontPosition &gt; getPipeLength()) {\n                iter.remove();\n                dissipateSlug(slug, sections);\n            }\n\n            // Update holdup in slug region\n            updateSlugHoldup(slug, sections);\n        }\n    }\n\n    /**\n     * Bendiksen (1984) slug front velocity.\n     */\n    private double calcSlugFrontVelocity(Slug slug, MultiphasePipeSection[] sections) {\n        MultiphasePipeSection sec = getSectionAt(slug.frontPosition, sections);\n        double vm = sec.getMixtureVelocity();\n        double C = 1.2;  // Distribution parameter\n        double vd = 0.35 * Math.sqrt(9.81 * sec.getDiameter());  // Drift velocity\n        return C * vm + vd;\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#4-liquid-accumulation-model","title":"4. Liquid Accumulation Model","text":"<pre><code>public class LiquidAccumulation {\n\n    /**\n     * Track liquid inventory and low-point accumulation.\n     */\n    public void updateAccumulation(MultiphasePipeSection[] sections, \n                                    double dt, double inletLiquidRate) {\n\n        // Identify low points in terrain profile\n        List&lt;Integer&gt; lowPoints = findLowPoints(sections);\n\n        for (int lowIdx : lowPoints) {\n            MultiphasePipeSection low = sections[lowIdx];\n\n            // Liquid drainage into low point\n            double drainageIn = calcDrainageRate(sections, lowIdx, -1);  // From upstream\n            drainageIn += calcDrainageRate(sections, lowIdx, +1);        // From downstream\n\n            // Liquid carryover out of low point\n            double carryover = calcCarryoverRate(low);\n\n            // Net accumulation\n            double netRate = drainageIn - carryover;\n\n            // Update holdup\n            double dHoldup = netRate * dt / (low.getArea() * getSegmentLength());\n            low.setLiquidHoldup(low.getLiquidHoldup() + dHoldup);\n\n            // Check for slug initiation if holdup exceeds critical\n            if (low.getLiquidHoldup() &gt; getCriticalHoldup(low)) {\n                slugTracker.initiateSlug(sections, lowIdx);\n            }\n        }\n    }\n\n    /**\n     * Calculate liquid drainage rate into low point.\n     */\n    private double calcDrainageRate(MultiphasePipeSection[] sections, \n                                     int lowIdx, int direction) {\n        int neighborIdx = lowIdx + direction;\n        if (neighborIdx &lt; 0 || neighborIdx &gt;= sections.length) return 0;\n\n        MultiphasePipeSection neighbor = sections[neighborIdx];\n        MultiphasePipeSection low = sections[lowIdx];\n\n        // Height difference drives drainage\n        double dz = neighbor.getElevation() - low.getElevation();\n        if (dz &lt;= 0) return 0;  // No drainage if neighbor is lower\n\n        // Stratified film drainage (Wallis falling film)\n        double holdup = neighbor.getLiquidHoldup();\n        double filmThickness = calcFilmThickness(holdup, neighbor.getDiameter());\n        double drainageVelocity = calcFilmDrainageVelocity(filmThickness, \n            neighbor.getInclination(), neighbor.getLiquidViscosity());\n\n        return holdup * neighbor.getArea() * drainageVelocity;\n    }\n\n    /**\n     * Calculate liquid carryover (entrainment by gas).\n     */\n    private double calcCarryoverRate(MultiphasePipeSection section) {\n        // Critical gas velocity for liquid removal (Turner correlation)\n        double vgCrit = calcCriticalGasVelocity(section);\n        double vg = section.getGasVelocity();\n\n        if (vg &lt; vgCrit) return 0;\n\n        // Carryover rate increases with excess gas velocity\n        double excessVelocity = vg - vgCrit;\n        double entrainmentFraction = calcEntrainmentFraction(excessVelocity, section);\n\n        return entrainmentFraction * section.getLiquidHoldup() * \n               section.getArea() * section.getLiquidVelocity();\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#5-numerical-scheme","title":"5. Numerical Scheme","text":"<pre><code>public class MultiphaseFluxCalculator {\n\n    public enum FluxScheme {\n        AUSM_PLUS,      // Advection Upstream Splitting Method\n        HLL,            // Harten-Lax-van Leer\n        ROE,            // Roe approximate Riemann solver\n        UPWIND          // First-order upwind\n    }\n\n    /**\n     * Calculate numerical flux at cell interface using AUSM+ scheme.\n     * Good for multiphase flows with large density ratios.\n     */\n    public double[] calcFluxAUSMPlus(double[] UL, double[] UR, \n                                      PhaseProperties propsL, PhaseProperties propsR) {\n\n        // Primitive variables\n        double rhoL = UL[0], rhoR = UR[0];\n        double vL = UL[1] / rhoL, vR = UR[1] / rhoR;\n        double pL = propsL.getPressure(), pR = propsR.getPressure();\n        double cL = propsL.getSoundSpeed(), cR = propsR.getSoundSpeed();\n\n        // Interface speed of sound\n        double cHalf = 0.5 * (cL + cR);\n\n        // Mach numbers\n        double ML = vL / cHalf;\n        double MR = vR / cHalf;\n\n        // Split Mach numbers (AUSM+ splitting functions)\n        double Mplus = calcMachPlus(ML);\n        double Mminus = calcMachMinus(MR);\n        double Mhalf = Mplus + Mminus;\n\n        // Split pressures\n        double Pplus = calcPressurePlus(ML) * pL;\n        double Pminus = calcPressureMinus(MR) * pR;\n        double Phalf = Pplus + Pminus;\n\n        // Convective flux\n        double[] flux = new double[3];\n        if (Mhalf &gt;= 0) {\n            flux[0] = cHalf * Mhalf * rhoL;\n            flux[1] = cHalf * Mhalf * rhoL * vL + Phalf;\n            flux[2] = cHalf * Mhalf * rhoL * propsL.getEnthalpy();\n        } else {\n            flux[0] = cHalf * Mhalf * rhoR;\n            flux[1] = cHalf * Mhalf * rhoR * vR + Phalf;\n            flux[2] = cHalf * Mhalf * rhoR * propsR.getEnthalpy();\n        }\n\n        return flux;\n    }\n\n    /**\n     * MUSCL reconstruction for second-order accuracy.\n     */\n    public double[] reconstructMUSCL(double[] U, int i, double[] dx) {\n        // Slope limiter (minmod, van Leer, etc.)\n        double slope = slopeLimiter(U[i-1], U[i], U[i+1], dx[i-1], dx[i]);\n\n        double[] UL = new double[U.length];\n        double[] UR = new double[U.length];\n\n        UL[i] = U[i] - 0.5 * slope * dx[i];\n        UR[i] = U[i] + 0.5 * slope * dx[i];\n\n        return new double[][] {UL, UR};\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#6-time-integration","title":"6. Time Integration","text":"<pre><code>public class MultiphaseTimeIntegrator {\n\n    /**\n     * Explicit Runge-Kutta time stepping with CFL control.\n     */\n    public void stepRK4(MultiphasePipeSection[] sections, double dt) {\n        int n = sections.length;\n        double[][] U = getConservativeVariables(sections);\n\n        // RK4 stages\n        double[][] k1 = calcRHS(sections, U);\n        double[][] U1 = addArrays(U, scaleArray(k1, 0.5 * dt));\n\n        double[][] k2 = calcRHS(sections, U1);\n        double[][] U2 = addArrays(U, scaleArray(k2, 0.5 * dt));\n\n        double[][] k3 = calcRHS(sections, U2);\n        double[][] U3 = addArrays(U, scaleArray(k3, dt));\n\n        double[][] k4 = calcRHS(sections, U3);\n\n        // Combine stages\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; U[i].length; j++) {\n                U[i][j] += dt / 6.0 * (k1[i][j] + 2*k2[i][j] + 2*k3[i][j] + k4[i][j]);\n            }\n        }\n\n        setConservativeVariables(sections, U);\n    }\n\n    /**\n     * Calculate stable time step based on CFL condition.\n     */\n    public double calcTimeStep(MultiphasePipeSection[] sections, double cflNumber) {\n        double dtMin = Double.MAX_VALUE;\n\n        for (MultiphasePipeSection sec : sections) {\n            // Wave speeds\n            double cGas = sec.getGasSoundSpeed();\n            double cLiq = sec.getLiquidSoundSpeed();\n            double vg = Math.abs(sec.getGasVelocity());\n            double vl = Math.abs(sec.getLiquidVelocity());\n\n            // Maximum characteristic speed\n            double maxSpeed = Math.max(vg + cGas, vl + cLiq);\n\n            // CFL condition\n            double dt = cflNumber * sec.getSegmentLength() / maxSpeed;\n            dtMin = Math.min(dtMin, dt);\n        }\n\n        return dtMin;\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#7-thermodynamic-coupling","title":"7. Thermodynamic Coupling","text":"<pre><code>public class ThermodynamicCoupling {\n\n    /**\n     * Update phase properties using NeqSim flash calculations.\n     */\n    public void updatePhaseProperties(MultiphasePipeSection section) {\n        // Clone and update thermodynamic system\n        SystemInterface system = section.getThermoSystem().clone();\n        system.setPressure(section.getPressure() / 1e5);  // Convert to bar\n        system.setTemperature(section.getTemperature());\n\n        // Flash calculation\n        ThermodynamicOperations ops = new ThermodynamicOperations(system);\n        ops.TPflash();\n        system.initPhysicalProperties();\n\n        // Extract phase properties\n        if (system.hasPhaseType(\"gas\")) {\n            PhaseInterface gas = system.getPhase(\"gas\");\n            section.setGasDensity(gas.getDensity(\"kg/m3\"));\n            section.setGasViscosity(gas.getViscosity(\"kg/msec\"));\n            section.setGasSoundSpeed(gas.getSoundSpeed());\n            section.setGasEnthalpy(gas.getEnthalpy(\"J/mol\"));\n            section.setGasMoleFraction(system.getMoleFraction(gas.getPhaseIndex()));\n        }\n\n        if (system.hasPhaseType(\"oil\")) {\n            PhaseInterface oil = system.getPhase(\"oil\");\n            section.setOilDensity(oil.getDensity(\"kg/m3\"));\n            section.setOilViscosity(oil.getViscosity(\"kg/msec\"));\n            // ... other properties\n        }\n\n        if (system.hasPhaseType(\"aqueous\")) {\n            PhaseInterface water = system.getPhase(\"aqueous\");\n            section.setWaterDensity(water.getDensity(\"kg/m3\"));\n            // ... other properties\n        }\n\n        // Mass transfer rates (flashing/condensation)\n        section.setMassTransferRate(calcMassTransferRate(section, system));\n    }\n\n    /**\n     * Calculate mass transfer between phases (simplified).\n     */\n    private double calcMassTransferRate(MultiphasePipeSection section, \n                                         SystemInterface system) {\n        // Departure from equilibrium\n        double pBubble = system.getBubblePointPressure();\n        double pActual = section.getPressure() / 1e5;\n\n        if (pActual &lt; pBubble) {\n            // Flashing - liquid to gas\n            double dP = pBubble - pActual;\n            return section.getMassTransferCoefficient() * dP;\n        } else {\n            // Condensation - gas to liquid\n            double dP = pActual - pBubble;\n            return -section.getMassTransferCoefficient() * dP;\n        }\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#main-solver-class","title":"Main Solver Class","text":"<pre><code>public class MultiphasePipe extends Pipeline {\n\n    private MultiphasePipeSection[] sections;\n    private SlugTracker slugTracker;\n    private LiquidAccumulation liquidAccumulation;\n    private MultiphaseFluxCalculator fluxCalculator;\n    private MultiphaseTimeIntegrator timeIntegrator;\n    private ThermodynamicCoupling thermoCoupling;\n\n    private double cflNumber = 0.5;\n    private int numberOfSections = 100;\n    private double totalLength;\n    private double[] elevationProfile;\n    private double[] diameterProfile;\n\n    public MultiphasePipe(String name, StreamInterface inStream) {\n        super(name, inStream);\n        slugTracker = new SlugTracker();\n        liquidAccumulation = new LiquidAccumulation();\n        fluxCalculator = new MultiphaseFluxCalculator();\n        timeIntegrator = new MultiphaseTimeIntegrator();\n        thermoCoupling = new ThermodynamicCoupling();\n    }\n\n    @Override\n    public void run(UUID id) {\n        // Initialize grid\n        initializeSections();\n\n        // Steady-state initialization\n        runSteadyState();\n\n        setCalculationIdentifier(id);\n    }\n\n    @Override\n    public void runTransient(double dt, UUID id) {\n        // Adaptive time stepping\n        double dtStable = timeIntegrator.calcTimeStep(sections, cflNumber);\n        double dtActual = Math.min(dt, dtStable);\n\n        int subSteps = (int) Math.ceil(dt / dtActual);\n        dtActual = dt / subSteps;\n\n        for (int step = 0; step &lt; subSteps; step++) {\n            // 1. Update thermodynamic properties\n            for (MultiphasePipeSection sec : sections) {\n                thermoCoupling.updatePhaseProperties(sec);\n            }\n\n            // 2. Detect flow regimes\n            for (MultiphasePipeSection sec : sections) {\n                sec.setFlowRegime(flowRegimeMap.determine(sec));\n            }\n\n            // 3. Calculate fluxes and advance solution\n            timeIntegrator.stepRK4(sections, dtActual);\n\n            // 4. Track liquid accumulation\n            liquidAccumulation.updateAccumulation(sections, dtActual, \n                getInletLiquidRate());\n\n            // 5. Track and propagate slugs\n            slugTracker.checkSlugInitiation(sections, dtActual);\n            slugTracker.propagateSlugs(sections, dtActual);\n\n            // 6. Apply boundary conditions\n            applyBoundaryConditions();\n        }\n\n        // Update outlet stream\n        updateOutletStream();\n\n        setCalculationIdentifier(id);\n    }\n\n    /**\n     * Get liquid inventory in the pipeline.\n     */\n    public double getLiquidInventory(String unit) {\n        double volume = 0;\n        for (MultiphasePipeSection sec : sections) {\n            volume += sec.getLiquidHoldup() * sec.getArea() * sec.getSegmentLength();\n        }\n\n        switch (unit.toLowerCase()) {\n            case \"m3\": return volume;\n            case \"bbl\": return volume * 6.28981;\n            case \"l\": return volume * 1000;\n            default: return volume;\n        }\n    }\n\n    /**\n     * Get slug statistics.\n     */\n    public SlugStatistics getSlugStatistics() {\n        return slugTracker.getStatistics();\n    }\n\n    /**\n     * Get holdup profile.\n     */\n    public double[] getHoldupProfile() {\n        double[] holdup = new double[sections.length];\n        for (int i = 0; i &lt; sections.length; i++) {\n            holdup[i] = sections[i].getLiquidHoldup();\n        }\n        return holdup;\n    }\n}\n</code></pre>"},{"location":"wiki/multiphase_transient_model/#phased-implementation-plan","title":"Phased Implementation Plan","text":""},{"location":"wiki/multiphase_transient_model/#phase-1-drift-flux-model-3-4-months","title":"Phase 1: Drift-Flux Model (3-4 months)","text":"<p>Scope: - Single momentum equation (mixture) - Drift-flux slip relation - Basic slug unit model (not tracking individual slugs) - Liquid accumulation at low points - Explicit time stepping</p> <p>Deliverables: - <code>DriftFluxPipe</code> class - Mechanistic flow regime map - Low-point accumulation logic - Test cases: ramp-up, ramp-down, pigging</p>"},{"location":"wiki/multiphase_transient_model/#phase-2-two-fluid-model-4-6-months","title":"Phase 2: Two-Fluid Model (4-6 months)","text":"<p>Scope: - Separate gas and liquid momentum - Interfacial friction correlations - Full slug tracking (unit cell model) - AUSM+ numerical scheme - Three-phase (gas, oil, water)</p> <p>Deliverables: - <code>TwoFluidPipe</code> class - <code>SlugTracker</code> with individual slug dynamics - Terrain-induced and hydrodynamic slugs - Validation against OLGA/LedaFlow</p>"},{"location":"wiki/multiphase_transient_model/#phase-3-advanced-features-3-4-months","title":"Phase 3: Advanced Features (3-4 months)","text":"<p>Scope: - Pipe networks (junctions, branches) - Pig tracking - Wax deposition coupling - Hydrate risk monitoring - Corrosion rate estimation</p> <p>Deliverables: - <code>PipeNetwork</code> class - <code>PigTracker</code> class - Integration with NeqSim wax/hydrate modules</p>"},{"location":"wiki/multiphase_transient_model/#closure-relations-required","title":"Closure Relations Required","text":""},{"location":"wiki/multiphase_transient_model/#wall-friction","title":"Wall Friction","text":"Flow Regime Correlation Single-phase Haaland/Colebrook Stratified Taitel-Dukler (separate phases) Slug Slug body + film friction Annular Core + film model"},{"location":"wiki/multiphase_transient_model/#interfacial-friction","title":"Interfacial Friction","text":"Model Application Taitel-Dukler Stratified flow Andritsos-Hanratty Wavy stratified Wallis Annular film Oliemans Slug bubble zone"},{"location":"wiki/multiphase_transient_model/#holdup-correlations","title":"Holdup Correlations","text":"Model Type Taitel-Dukler Mechanistic stratified Gregory Slug holdup Beggs-Brill Empirical (backup) Bendiksen Slug bubble holdup"},{"location":"wiki/multiphase_transient_model/#drift-flux-parameters","title":"Drift-Flux Parameters","text":"Correlation C_0 v_drift Zuber-Findlay (vertical) 1.2 1.53(g\u03c3\u0394\u03c1/\u03c1_L\u00b2)^0.25 Bendiksen (horizontal) 1.05 0.35\u221a(gD) Ferschneider Variable Inclination-dependent"},{"location":"wiki/multiphase_transient_model/#validation-strategy","title":"Validation Strategy","text":""},{"location":"wiki/multiphase_transient_model/#unit-tests","title":"Unit Tests","text":"<ol> <li>Shock tube - Verify numerical scheme captures discontinuities</li> <li>Steady-state - Match existing Beggs &amp; Brill</li> <li>Single slug - Verify slug propagation velocity</li> <li>Low-point filling - Verify accumulation rate</li> </ol>"},{"location":"wiki/multiphase_transient_model/#integration-tests","title":"Integration Tests","text":"<ol> <li>Ramp-up scenario - Increasing rate, observe slug formation</li> <li>Ramp-down scenario - Decreasing rate, observe liquid fallback</li> <li>Pigging - Pig transit time and liquid delivery</li> <li>Blowdown - Depressurization with liquid holdup</li> </ol>"},{"location":"wiki/multiphase_transient_model/#validation-cases-vs-commercial-tools","title":"Validation Cases (vs. Commercial Tools)","text":"<ol> <li>Tordis flowline (Statoil benchmark)</li> <li>Sleipner riser (slug characteristics)</li> <li>Prudhoe Bay (cold restart)</li> <li>Academic data (Tulsa, SINTEF)</li> </ol>"},{"location":"wiki/multiphase_transient_model/#performance-considerations","title":"Performance Considerations","text":""},{"location":"wiki/multiphase_transient_model/#computational-cost","title":"Computational Cost","text":"Component Cost Optimization Flash calculations High Tabulation, caching Flow regime map Medium Skip if regime unchanged Flux calculation Low Vectorization Slug tracking Low Skip if no slugs"},{"location":"wiki/multiphase_transient_model/#recommended-approach","title":"Recommended Approach","text":"<ol> <li>Coarse grid for long-term (100-200 sections for 10 km)</li> <li>Flash tabulation - Pre-compute properties on P-T grid</li> <li>Adaptive time stepping - Large \u0394t when stable</li> <li>Parallel sections - OpenMP/SIMD for flux calculations</li> </ol>"},{"location":"wiki/multiphase_transient_model/#references","title":"References","text":"<ol> <li>Bendiksen, K.H. et al. (1991). \"The Dynamic Two-Fluid Model OLGA: Theory and Application\". SPE Production Engineering.</li> <li>Taitel, Y. &amp; Dukler, A.E. (1976). \"A Model for Predicting Flow Regime Transitions in Horizontal and Near Horizontal Gas-Liquid Flow\". AIChE Journal.</li> <li>Issa, R.I. &amp; Kempf, M.H.W. (2003). \"Simulation of Slug Flow in Horizontal and Nearly Horizontal Pipes with the Two-Fluid Model\". Int. J. Multiphase Flow.</li> <li>Kjeldby, T.K. et al. (2013). \"Lagrangian Slug Flow Modeling and Sensitivity on Hydrodynamic Slug Initiation Methods in a Severe Slugging Case\". Int. J. Multiphase Flow.</li> <li>Bonizzi, M. &amp; Issa, R.I. (2003). \"A Model for Simulating Gas Bubble Entrainment in Two-Phase Horizontal Slug Flow\". Int. J. Multiphase Flow.</li> </ol>"},{"location":"wiki/multiphase_transient_model/#conclusion","title":"Conclusion","text":"<p>Implementing a full multiphase transient model is a significant undertaking but highly valuable for:</p> <ul> <li>Liquid management (pigging optimization, slugcatcher sizing)</li> <li>Operability studies (startup, shutdown, rate changes)</li> <li>Flow assurance (hydrate risk during transients)</li> <li>Design optimization (pipeline sizing, riser configurations)</li> </ul> <p>The recommended approach is:</p> <ol> <li>Start with drift-flux for faster development and validation</li> <li>Graduate to two-fluid for slug tracking accuracy</li> <li>Leverage NeqSim thermodynamics throughout</li> <li>Validate against commercial tools and field data</li> </ol> <p>The existing NeqSim infrastructure (thermodynamics, physical properties, process equipment) provides an excellent foundation for this extension.</p>"},{"location":"wiki/pipe_wall_heat_transfer/","title":"Pipe Wall Construction and Heat Transfer Modeling","text":"<p>This document describes the pipe wall construction and heat transfer modeling capabilities in NeqSim, including material properties, multi-layer walls, and surrounding environment modeling.</p>"},{"location":"wiki/pipe_wall_heat_transfer/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Pipe Materials</li> <li>Material Layers</li> <li>Pipe Wall Assembly</li> <li>Surrounding Environment</li> <li>Heat Transfer Calculations</li> <li>API Reference</li> <li>Examples</li> </ol>"},{"location":"wiki/pipe_wall_heat_transfer/#overview","title":"Overview","text":"<p>The pipe wall modeling system in NeqSim provides: - Material database with thermal properties - Multi-layer wall construction (pipe + insulation + coating) - Surrounding environment models (air, water, soil) - Heat transfer resistance calculations - Integration with transient flow simulation</p>"},{"location":"wiki/pipe_wall_heat_transfer/#pipe-materials","title":"Pipe Materials","text":""},{"location":"wiki/pipe_wall_heat_transfer/#standard-materials","title":"Standard Materials","text":"<p>NeqSim includes pre-defined pipe materials with thermal properties:</p> Material Thermal Conductivity (W/m\u00b7K) Density (kg/m\u00b3) Specific Heat (J/kg\u00b7K) Carbon Steel 50.0 7850 490 Stainless Steel 316 16.3 8000 500 Duplex Steel 15.0 7800 500 Super Duplex 14.0 7800 500 Titanium 21.9 4500 523 Inconel 625 9.8 8440 410 Monel 400 21.8 8800 427 Copper 401.0 8960 385 HDPE 0.5 960 1800 PVC 0.19 1400 1000 GRP (Fiberglass) 0.3 1850 900"},{"location":"wiki/pipe_wall_heat_transfer/#creating-custom-materials","title":"Creating Custom Materials","text":"<pre><code>// Using standard material\nPipeMaterial steel = PipeMaterial.CARBON_STEEL;\n\n// Creating custom material\nPipeMaterial custom = new PipeMaterial(\n    \"Custom Alloy\",\n    25.0,    // thermalConductivity (W/m\u00b7K)\n    7500,    // density (kg/m\u00b3)\n    480      // specificHeatCapacity (J/kg\u00b7K)\n);\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#material-properties","title":"Material Properties","text":"<ul> <li>Thermal Conductivity (\\(k\\)): Ability to conduct heat (W/m\u00b7K)</li> <li>Density (\\(\\rho\\)): Material mass per unit volume (kg/m\u00b3)</li> <li>Specific Heat Capacity (\\(C_p\\)): Energy to raise temperature by 1 K (J/kg\u00b7K)</li> <li>Thermal Diffusivity: \\(\\alpha = k / (\\rho C_p)\\) (m\u00b2/s)</li> </ul>"},{"location":"wiki/pipe_wall_heat_transfer/#material-layers","title":"Material Layers","text":"<p>A <code>MaterialLayer</code> combines a material with its thickness:</p> <pre><code>// Create insulation layer\nMaterialLayer insulation = new MaterialLayer(\n    \"Polyurethane Foam\",\n    0.025,   // thermalConductivity (W/m\u00b7K)\n    40,      // density (kg/m\u00b3)\n    1500,    // specificHeatCapacity (J/kg\u00b7K)\n    0.05     // thickness (m) = 50 mm\n);\n\n// Using pipe material\nMaterialLayer pipeWall = new MaterialLayer(\n    PipeMaterial.CARBON_STEEL,\n    0.012    // thickness = 12 mm\n);\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#layer-properties","title":"Layer Properties","text":"Property Description Units <code>thickness</code> Layer thickness m <code>thermalConductivity</code> Heat conduction coefficient W/(m\u00b7K) <code>density</code> Material density kg/m\u00b3 <code>specificHeatCapacity</code> Thermal capacity J/(kg\u00b7K)"},{"location":"wiki/pipe_wall_heat_transfer/#pipe-wall-assembly","title":"Pipe Wall Assembly","text":""},{"location":"wiki/pipe_wall_heat_transfer/#multi-layer-construction","title":"Multi-Layer Construction","text":"<p>The <code>PipeWall</code> class represents a complete pipe wall with multiple layers:</p> <pre><code>// Method 1: Create layer by layer\nPipeWall wall = new PipeWall(0.15);  // inner radius = 150 mm\n\nwall.addLayer(new MaterialLayer(PipeMaterial.CARBON_STEEL, 0.012));\nwall.addLayer(new MaterialLayer(\"Insulation\", 0.025, 40, 1500, 0.050));\nwall.addLayer(new MaterialLayer(\"Coating\", 0.3, 1200, 1400, 0.005));\n\n// Method 2: Using PipeWallBuilder (fluent API)\nPipeWall wall = new PipeWallBuilder()\n    .innerRadius(0.15)\n    .addPipeLayer(PipeMaterial.CARBON_STEEL, 0.012)\n    .addInsulationLayer(0.025, 0.050)\n    .addCoatingLayer(0.3, 0.005)\n    .build();\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#thermal-resistance","title":"Thermal Resistance","text":"<p>The total radial thermal resistance through a cylindrical wall:</p> \\[ R_{total} = \\sum_{i=1}^{n} R_i = \\sum_{i=1}^{n} \\frac{\\ln(r_{i+1}/r_i)}{2\\pi k_i L} \\] <p>Where: - \\(r_i\\) = inner radius of layer \\(i\\) (m) - \\(r_{i+1}\\) = outer radius of layer \\(i\\) (m) - \\(k_i\\) = thermal conductivity of layer \\(i\\) (W/m\u00b7K) - \\(L\\) = pipe length (m)</p> <p>Per unit length:</p> \\[ R'_{total} = \\sum_{i=1}^{n} \\frac{\\ln(r_{i+1}/r_i)}{2\\pi k_i} \\quad \\text{(m\u00b7K/W)} \\]"},{"location":"wiki/pipe_wall_heat_transfer/#key-properties","title":"Key Properties","text":"<pre><code>double outerRadius = wall.getOuterRadius();           // m\ndouble totalThickness = wall.getTotalWallThickness(); // m\ndouble resistance = wall.getTotalResistancePerLength(); // m\u00b7K/W\ndouble heatCapacity = wall.getThermalMass();          // J/(m\u00b7K)\nint layerCount = wall.getLayerCount();\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#surrounding-environment","title":"Surrounding Environment","text":""},{"location":"wiki/pipe_wall_heat_transfer/#environment-types","title":"Environment Types","text":"<p>The <code>PipeSurroundingEnvironment</code> class models the external conditions:</p> Environment Description Typical \\(h\\) (W/m\u00b2\u00b7K) Still Air Natural convection 5-25 Moving Air Forced convection 10-200 Seawater Subsea pipelines 150-1000 Soil Buried pipelines 1-10"},{"location":"wiki/pipe_wall_heat_transfer/#creating-environments","title":"Creating Environments","text":"<pre><code>// Using factory methods\nPipeSurroundingEnvironment air = \n    PipeSurroundingEnvironment.stillAir(25.0);  // 25\u00b0C\n\nPipeSurroundingEnvironment seawater = \n    PipeSurroundingEnvironment.seawater(4.0);   // 4\u00b0C\n\nPipeSurroundingEnvironment soil = \n    PipeSurroundingEnvironment.soil(15.0, 1.5); // 15\u00b0C, k=1.5 W/m\u00b7K\n\n// Custom environment\nPipeSurroundingEnvironment custom = \n    new PipeSurroundingEnvironment(\"Wind\", 10.0, 50.0);\n    // 10\u00b0C ambient, h = 50 W/m\u00b2\u00b7K\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#convection-coefficients","title":"Convection Coefficients","text":"<p>Still Air (Natural Convection): $$ h \\approx 5 + 5\\sqrt{T_{surface} - T_{ambient}} \\quad \\text{W/(m\u00b2\u00b7K)} $$</p> <p>Seawater: $$ h \\approx 150 + 70 \\cdot v_{current}^{0.8} \\quad \\text{W/(m\u00b2\u00b7K)} $$</p> <p>Soil (Buried Pipe): $$ h_{equiv} = \\frac{k_{soil}}{r_o \\cdot \\ln(2H/r_o)} \\quad \\text{W/(m\u00b2\u00b7K)} $$</p> <p>Where \\(H\\) is burial depth and \\(r_o\\) is outer radius.</p>"},{"location":"wiki/pipe_wall_heat_transfer/#heat-transfer-calculations","title":"Heat Transfer Calculations","text":""},{"location":"wiki/pipe_wall_heat_transfer/#overall-heat-transfer-coefficient","title":"Overall Heat Transfer Coefficient","text":"<p>The overall U-value combining all resistances:</p> \\[ \\frac{1}{U A} = \\frac{1}{h_i A_i} + \\sum \\frac{\\ln(r_{o}/r_i)}{2\\pi k L} + \\frac{1}{h_o A_o} \\] <p>Based on outer surface area:</p> \\[ U_o = \\frac{1}{r_o \\left(\\frac{1}{h_i r_i} + \\sum \\frac{\\ln(r_{i+1}/r_i)}{k_i} + \\frac{1}{h_o}\\right)} \\]"},{"location":"wiki/pipe_wall_heat_transfer/#heat-transfer-rate","title":"Heat Transfer Rate","text":"<p>Heat flow per unit length:</p> \\[ q' = U_o \\cdot 2\\pi r_o \\cdot (T_{fluid} - T_{ambient}) \\quad \\text{W/m} \\] <p>Total heat flow:</p> \\[ Q = q' \\cdot L = U_o \\cdot A_o \\cdot \\Delta T \\quad \\text{W} \\]"},{"location":"wiki/pipe_wall_heat_transfer/#temperature-profile","title":"Temperature Profile","text":"<p>The fluid temperature along the pipe (steady-state):</p> \\[ T(x) = T_{ambient} + (T_{inlet} - T_{ambient}) \\exp\\left(-\\frac{U_o \\cdot \\pi D_o}{\\dot{m} C_p} x\\right) \\]"},{"location":"wiki/pipe_wall_heat_transfer/#wall-temperature-distribution","title":"Wall Temperature Distribution","text":"<p>Temperature at interface between layers \\(j\\) and \\(j+1\\):</p> \\[ T_j = T_{fluid} - q' \\cdot \\left(\\frac{1}{h_i \\cdot 2\\pi r_i} + \\sum_{k=1}^{j} \\frac{\\ln(r_{k+1}/r_k)}{2\\pi k_k}\\right) \\]"},{"location":"wiki/pipe_wall_heat_transfer/#api-reference","title":"API Reference","text":""},{"location":"wiki/pipe_wall_heat_transfer/#pipematerial-enum","title":"PipeMaterial Enum","text":"<pre><code>public enum PipeMaterial {\n    CARBON_STEEL(50.0, 7850, 490),\n    STAINLESS_316(16.3, 8000, 500),\n    // ... more materials\n\n    double getThermalConductivity();\n    double getDensity();\n    double getSpecificHeatCapacity();\n    double getThermalDiffusivity();\n}\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#materiallayer-class","title":"MaterialLayer Class","text":"<pre><code>public class MaterialLayer {\n    // Constructors\n    MaterialLayer(String name, double k, double rho, double cp, double t);\n    MaterialLayer(PipeMaterial material, double thickness);\n\n    // Properties\n    double getThickness();\n    double getThermalConductivity();\n    double getDensity();\n    double getSpecificHeatCapacity();\n\n    // Calculations\n    double getRadialResistance(double innerRadius);\n    double getHeatCapacityPerLength(double innerRadius);\n}\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#pipewall-class","title":"PipeWall Class","text":"<pre><code>public class PipeWall {\n    // Construction\n    PipeWall(double innerRadius);\n    void addLayer(MaterialLayer layer);\n\n    // Properties\n    double getInnerRadius();\n    double getOuterRadius();\n    double getTotalWallThickness();\n    int getLayerCount();\n\n    // Thermal calculations\n    double getTotalResistancePerLength();\n    double getUValuePerLength(double hInner, double hOuter);\n    double getThermalMass();\n}\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#pipesurroundingenvironment-class","title":"PipeSurroundingEnvironment Class","text":"<pre><code>public class PipeSurroundingEnvironment {\n    // Factory methods\n    static stillAir(double ambientTemp);\n    static movingAir(double ambientTemp, double windSpeed);\n    static seawater(double ambientTemp);\n    static soil(double ambientTemp, double thermalConductivity);\n\n    // Properties\n    double getAmbientTemperature();\n    double getConvectionCoefficient();\n}\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#pipewallbuilder-class","title":"PipeWallBuilder Class","text":"<pre><code>public class PipeWallBuilder {\n    PipeWallBuilder innerRadius(double r);\n    PipeWallBuilder innerDiameter(double d);\n    PipeWallBuilder addLayer(MaterialLayer layer);\n    PipeWallBuilder addPipeLayer(PipeMaterial material, double thickness);\n    PipeWallBuilder addInsulationLayer(double k, double thickness);\n    PipeWallBuilder addCoatingLayer(double k, double thickness);\n    PipeWall build();\n}\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#examples","title":"Examples","text":""},{"location":"wiki/pipe_wall_heat_transfer/#example-1-subsea-pipeline","title":"Example 1: Subsea Pipeline","text":"<pre><code>// Create multi-layer subsea pipe wall\nPipeWall subseaPipe = new PipeWallBuilder()\n    .innerDiameter(0.254)  // 10\" ID\n    .addPipeLayer(PipeMaterial.DUPLEX_STEEL, 0.0127)\n    .addInsulationLayer(0.15, 0.060)  // Syntactic foam\n    .addCoatingLayer(0.22, 0.006)     // Polypropylene\n    .build();\n\n// Seawater environment at 4\u00b0C\nPipeSurroundingEnvironment seawater = \n    PipeSurroundingEnvironment.seawater(4.0);\n\n// Calculate overall U-value\ndouble hInner = 500;   // W/m\u00b2\u00b7K (turbulent gas flow)\ndouble hOuter = seawater.getConvectionCoefficient();\ndouble U = subseaPipe.getUValuePerLength(hInner, hOuter);\n\nSystem.out.printf(\"U-value: %.2f W/(m\u00b2\u00b7K)%n\", U);\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#example-2-buried-gas-pipeline","title":"Example 2: Buried Gas Pipeline","text":"<pre><code>// Create insulated buried pipeline\nPipeWall buriedPipe = new PipeWallBuilder()\n    .innerDiameter(0.508)  // 20\" ID\n    .addPipeLayer(PipeMaterial.CARBON_STEEL, 0.0127)\n    .addCoatingLayer(0.22, 0.003)  // FBE coating\n    .build();\n\n// Soil at 12\u00b0C, buried 1.5m deep\nPipeSurroundingEnvironment soil = \n    PipeSurroundingEnvironment.soil(12.0, 1.2);\n\n// Print configuration\nSystem.out.printf(\"Wall thickness: %.1f mm%n\", \n    buriedPipe.getTotalWallThickness() * 1000);\nSystem.out.printf(\"Total resistance: %.4f m\u00b7K/W%n\", \n    buriedPipe.getTotalResistancePerLength());\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#example-3-temperature-profile-calculation","title":"Example 3: Temperature Profile Calculation","text":"<pre><code>// Pipeline parameters\ndouble length = 50000;     // 50 km\ndouble mDot = 15.0;        // kg/s\ndouble Cp = 2500;          // J/(kg\u00b7K) - gas\ndouble Tinlet = 80;        // \u00b0C\ndouble Tambient = 5;       // \u00b0C\ndouble Uo = 2.5;           // W/(m\u00b2\u00b7K) - overall U-value\ndouble Do = 0.32;          // m - outer diameter\n\n// Calculate outlet temperature\ndouble exponent = -Uo * Math.PI * Do * length / (mDot * Cp);\ndouble Toutlet = Tambient + (Tinlet - Tambient) * Math.exp(exponent);\n\nSystem.out.printf(\"Outlet temperature: %.1f \u00b0C%n\", Toutlet);\nSystem.out.printf(\"Heat loss: %.0f kW%n\", mDot * Cp * (Tinlet - Toutlet) / 1000);\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#example-4-integration-with-flow-simulation","title":"Example 4: Integration with Flow Simulation","text":"<pre><code>// Create fluid\nSystemInterface gas = new SystemSrkEos(323.15, 50e5);\ngas.addComponent(\"methane\", 0.9);\ngas.addComponent(\"ethane\", 0.07);\ngas.addComponent(\"propane\", 0.03);\ngas.setMixingRule(\"classic\");\n\n// Create inlet stream\nStream inlet = new Stream(\"Inlet\", gas);\ninlet.setFlowRate(500000, \"kg/hr\");\ninlet.run();\n\n// Create pipeline with heat transfer\nOnePhasePipeLine pipe = new OnePhasePipeLine(\"Export\", inlet);\npipe.setNumberOfLegs(1);\npipe.setNumberOfNodesInLeg(100);\npipe.setPipeDiameters(new double[] {0.508, 0.508});\npipe.setLegPositions(new double[] {0.0, 50000.0});\npipe.setOuterTemperature(278.15);  // 5\u00b0C ambient\n\n// Run steady-state\npipe.run();\n\n// Get outlet conditions\nSystem.out.printf(\"Outlet T: %.1f \u00b0C%n\", \n    pipe.getOutStream().getTemperature(\"C\"));\nSystem.out.printf(\"Outlet P: %.1f bara%n\", \n    pipe.getOutStream().getPressure(\"bara\"));\n</code></pre>"},{"location":"wiki/pipe_wall_heat_transfer/#references","title":"References","text":"<ol> <li>Incropera, F.P. &amp; DeWitt, D.P. (2011). Fundamentals of Heat and Mass Transfer. Wiley.</li> <li>GPSA Engineering Data Book. Gas Processors Suppliers Association.</li> <li>API 5L - Specification for Line Pipe.</li> <li>DNVGL-ST-F101 - Submarine Pipeline Systems.</li> </ol>"},{"location":"wiki/pipeline_flow_equations/","title":"Pipeline Flow Simulation: Governing Equations and Numerical Methods","text":"<p>This document provides a comprehensive reference for single-phase pipeline flow simulation in NeqSim, including the governing equations, discretization schemes, and numerical solution methods.</p>"},{"location":"wiki/pipeline_flow_equations/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Governing Equations</li> <li>Steady-State Solution</li> <li>Transient Solution</li> <li>Compositional Tracking</li> <li>Advection Schemes and Numerical Dispersion</li> <li>Boundary Conditions</li> <li>Solution Algorithm</li> </ol>"},{"location":"wiki/pipeline_flow_equations/#governing-equations","title":"Governing Equations","text":""},{"location":"wiki/pipeline_flow_equations/#conservation-of-mass-continuity","title":"Conservation of Mass (Continuity)","text":"<p>The one-dimensional continuity equation for compressible flow in a pipe:</p> \\[ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial (\\rho v)}{\\partial x} = 0 \\] <p>Where: - \\(\\rho\\) = fluid density (kg/m\u00b3) - \\(v\\) = flow velocity (m/s) - \\(t\\) = time (s) - \\(x\\) = axial position along pipe (m)</p>"},{"location":"wiki/pipeline_flow_equations/#conservation-of-momentum","title":"Conservation of Momentum","text":"<p>The momentum equation including friction and gravity:</p> \\[ \\frac{\\partial (\\rho v)}{\\partial t} + \\frac{\\partial (\\rho v^2)}{\\partial x} = -\\frac{\\partial P}{\\partial x} - \\frac{f \\rho v |v|}{2D} - \\rho g \\sin\\theta \\] <p>Where: - \\(P\\) = pressure (Pa) - \\(f\\) = Darcy friction factor (dimensionless) - \\(D\\) = pipe inner diameter (m) - \\(g\\) = gravitational acceleration (9.81 m/s\u00b2) - \\(\\theta\\) = pipe inclination angle from horizontal</p>"},{"location":"wiki/pipeline_flow_equations/#conservation-of-energy","title":"Conservation of Energy","text":"<p>The energy equation with heat transfer:</p> \\[ \\frac{\\partial (\\rho e)}{\\partial t} + \\frac{\\partial (\\rho v h)}{\\partial x} = \\frac{q_{wall}}{\\pi D^2 / 4} \\] <p>Where: - \\(e\\) = specific internal energy (J/kg) - \\(h\\) = specific enthalpy (J/kg) - \\(q_{wall}\\) = heat transfer rate per unit length (W/m)</p>"},{"location":"wiki/pipeline_flow_equations/#species-conservation-compositional-tracking","title":"Species Conservation (Compositional Tracking)","text":"<p>For each component \\(i\\):</p> \\[ \\frac{\\partial (\\rho w_i)}{\\partial t} + \\frac{\\partial (\\rho v w_i)}{\\partial x} = 0 \\] <p>Where: - \\(w_i\\) = mass fraction of component \\(i\\)</p>"},{"location":"wiki/pipeline_flow_equations/#steady-state-solution","title":"Steady-State Solution","text":""},{"location":"wiki/pipeline_flow_equations/#pressure-drop-calculation","title":"Pressure Drop Calculation","text":"<p>For steady-state flow, the momentum equation simplifies to:</p> \\[ \\frac{dP}{dx} = -\\frac{f \\rho v^2}{2D} - \\rho g \\sin\\theta \\] <p>The Darcy friction factor \\(f\\) is calculated using the Colebrook-White equation:</p> \\[ \\frac{1}{\\sqrt{f}} = -2 \\log_{10}\\left(\\frac{\\varepsilon/D}{3.7} + \\frac{2.51}{Re \\sqrt{f}}\\right) \\] <p>Where: - \\(\\varepsilon\\) = pipe wall roughness (m) - \\(Re\\) = Reynolds number = \\(\\rho v D / \\mu\\)</p>"},{"location":"wiki/pipeline_flow_equations/#discretization","title":"Discretization","text":"<p>The pipe is divided into \\(N\\) nodes. For node \\(i\\):</p> \\[ P_{i+1} = P_i - \\Delta x \\left(\\frac{f_i \\rho_i v_i^2}{2D} + \\rho_i g \\sin\\theta_i\\right) \\]"},{"location":"wiki/pipeline_flow_equations/#transient-solution","title":"Transient Solution","text":""},{"location":"wiki/pipeline_flow_equations/#finite-volume-method","title":"Finite Volume Method","text":"<p>NeqSim uses a staggered grid finite volume method. The pipe is divided into control volumes with: - Scalar quantities (P, T, \u03c1, composition) at cell centers - Velocities at cell faces</p>"},{"location":"wiki/pipeline_flow_equations/#time-discretization","title":"Time Discretization","text":"<p>Implicit (backward) Euler scheme for stability:</p> \\[ \\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} + \\frac{\\partial F}{\\partial x}\\bigg|^{n+1} = S^{n+1} \\] <p>Where: - \\(\\phi\\) = conserved variable - \\(F\\) = flux - \\(S\\) = source term - \\(n\\) = time step index</p>"},{"location":"wiki/pipeline_flow_equations/#cfl-condition","title":"CFL Condition","text":"<p>For numerical stability, the Courant-Friedrichs-Lewy (CFL) number should satisfy:</p> \\[ CFL = \\frac{(v + c) \\Delta t}{\\Delta x} \\leq 1 \\] <p>Where \\(c\\) is the speed of sound in the fluid.</p>"},{"location":"wiki/pipeline_flow_equations/#tdma-solver","title":"TDMA Solver","text":"<p>The discretized equations form a tri-diagonal matrix system:</p> \\[ a_i \\phi_{i-1} + b_i \\phi_i + c_i \\phi_{i+1} = r_i \\] <p>Solved using the Thomas algorithm (TDMA).</p>"},{"location":"wiki/pipeline_flow_equations/#compositional-tracking","title":"Compositional Tracking","text":""},{"location":"wiki/pipeline_flow_equations/#conservation-equation","title":"Conservation Equation","text":"<p>The mass fraction transport equation in conservative form:</p> \\[ \\frac{\\partial (\\rho A w)}{\\partial t} + \\frac{\\partial (\\dot{m} w)}{\\partial x} = 0 \\] <p>Where: - \\(A\\) = pipe cross-sectional area (m\u00b2) - \\(\\dot{m} = \\rho v A\\) = mass flow rate (kg/s)</p>"},{"location":"wiki/pipeline_flow_equations/#discretized-form","title":"Discretized Form","text":"<p>For control volume \\(i\\):</p> \\[ \\frac{(\\rho A w)_i^{n+1} - (\\rho A w)_i^{n}}{\\Delta t} + \\frac{F_e - F_w}{\\Delta x} = 0 \\] <p>Where \\(F_e\\) and \\(F_w\\) are the convective fluxes at east and west faces.</p>"},{"location":"wiki/pipeline_flow_equations/#first-order-upwind-scheme","title":"First-Order Upwind Scheme","text":"<p>The convective flux at a face is:</p> \\[ F_e = \\max(\\dot{m}_e, 0) w_i + \\min(\\dot{m}_e, 0) w_{i+1} \\] <p>This leads to the coefficient matrix: - \\(a_i = \\max(F_w, 0)\\) - \\(c_i = \\max(-F_e, 0)\\) - \\(b_i = a_i + c_i + (F_e - F_w) + \\frac{\\rho_i A_i \\Delta x}{\\Delta t}\\)</p>"},{"location":"wiki/pipeline_flow_equations/#advection-schemes-and-numerical-dispersion","title":"Advection Schemes and Numerical Dispersion","text":""},{"location":"wiki/pipeline_flow_equations/#the-numerical-dispersion-problem","title":"The Numerical Dispersion Problem","text":"<p>First-order upwind introduces artificial (numerical) diffusion:</p> \\[ D_{num} = \\frac{v \\Delta x}{2} (1 - CFL) \\] <p>This causes composition fronts to spread over distance:</p> \\[ \\sigma = \\sqrt{2 D_{num} t} = \\sqrt{\\Delta x \\cdot L \\cdot (1 - CFL)} \\] <p>Where \\(L\\) is the transport distance.</p>"},{"location":"wiki/pipeline_flow_equations/#available-advection-schemes","title":"Available Advection Schemes","text":"Scheme Order Numerical Dispersion Stability First-Order Upwind 1 High Unconditional Second-Order Upwind 2 Low CFL \u2264 0.5 QUICK 3 Very Low CFL \u2264 0.5 TVD Van Leer 2 Low CFL \u2264 1.0 TVD Minmod 2 Medium CFL \u2264 1.0 TVD Superbee 2 Very Low CFL \u2264 1.0 TVD Van Albada 2 Low CFL \u2264 1.0 MUSCL Van Leer 2 Low CFL \u2264 1.0"},{"location":"wiki/pipeline_flow_equations/#tvd-total-variation-diminishing-schemes","title":"TVD (Total Variation Diminishing) Schemes","text":"<p>TVD schemes use flux limiters to achieve high accuracy in smooth regions while preventing oscillations near discontinuities.</p> <p>The flux limiter \\(\\psi(r)\\) depends on the gradient ratio:</p> \\[ r = \\frac{\\phi_i - \\phi_{i-1}}{\\phi_{i+1} - \\phi_i} \\]"},{"location":"wiki/pipeline_flow_equations/#limiter-functions","title":"Limiter Functions","text":"<p>Minmod (most diffusive): $$ \\psi\u00ae = \\max(0, \\min(r, 1)) $$</p> <p>Van Leer (recommended): $$ \\psi\u00ae = \\frac{r + |r|}{1 + |r|} $$</p> <p>Superbee (least diffusive): $$ \\psi\u00ae = \\max(0, \\min(2r, 1), \\min(r, 2)) $$</p> <p>Van Albada (smooth): $$ \\psi\u00ae = \\frac{r^2 + r}{r^2 + 1} $$</p>"},{"location":"wiki/pipeline_flow_equations/#tvd-flux-correction","title":"TVD Flux Correction","text":"<p>The higher-order flux correction is:</p> \\[ F_{HO} = F_{LO} + \\frac{1}{2} \\psi(r) |F| (1 - |CFL|) (\\phi_{downstream} - \\phi_{upstream}) \\] <p>Where \\(F_{LO}\\) is the first-order upwind flux.</p>"},{"location":"wiki/pipeline_flow_equations/#dispersion-reduction","title":"Dispersion Reduction","text":"<p>The effective numerical diffusion with TVD schemes:</p> \\[ D_{eff} = D_{num} \\times \\text{ReductionFactor} \\] <p>Typical reduction factors: - Van Leer: 0.15 (7\u00d7 reduction) - Superbee: 0.08 (12\u00d7 reduction) - Minmod: 0.30 (3\u00d7 reduction)</p>"},{"location":"wiki/pipeline_flow_equations/#boundary-conditions","title":"Boundary Conditions","text":""},{"location":"wiki/pipeline_flow_equations/#inlet-boundary","title":"Inlet Boundary","text":"<p>Fixed conditions from upstream: - Pressure: \\(P_{inlet}\\) - Temperature: \\(T_{inlet}\\) - Composition: \\(w_{i,inlet}\\) - Flow rate: \\(\\dot{m}_{inlet}\\)</p>"},{"location":"wiki/pipeline_flow_equations/#outlet-boundary","title":"Outlet Boundary","text":"<p>Typically one of: - Fixed pressure: \\(P_{outlet}\\) - Fixed flow rate: \\(\\dot{m}_{outlet}\\) - Reservoir (pressure-flow relationship)</p>"},{"location":"wiki/pipeline_flow_equations/#implementation","title":"Implementation","text":"<pre><code>// Inlet: Dirichlet condition\na[0] = 0;\nb[0] = 1;\nc[0] = 0;\nr[0] = w_inlet;\n\n// Interior nodes: discretized conservation equation\n// ... (TDMA coefficients)\n\n// Outlet: extrapolation or fixed value\n</code></pre>"},{"location":"wiki/pipeline_flow_equations/#solution-algorithm","title":"Solution Algorithm","text":""},{"location":"wiki/pipeline_flow_equations/#steady-state-algorithm","title":"Steady-State Algorithm","text":"<ol> <li>Initialize with linear pressure profile</li> <li>Calculate fluid properties at each node</li> <li>Calculate friction factors</li> <li>Solve momentum equation for pressure</li> <li>Update velocities</li> <li>Repeat until convergence</li> </ol>"},{"location":"wiki/pipeline_flow_equations/#transient-algorithm","title":"Transient Algorithm","text":"<pre><code>for each time step:\n    1. Apply inlet boundary conditions\n    2. Calculate time step (CFL condition)\n    3. Assemble coefficient matrices\n    4. Solve TDMA for each conservation equation:\n       - Momentum (pressure/velocity)\n       - Energy (temperature)\n       - Species (composition)\n    5. Update fluid properties (EOS flash)\n    6. Update outlet stream\n    7. Store results\n</code></pre>"},{"location":"wiki/pipeline_flow_equations/#code-example","title":"Code Example","text":"<pre><code>// Create pipeline\nOnePhasePipeLine pipe = new OnePhasePipeLine(\"GasPipe\", inletStream);\npipe.setNumberOfLegs(1);\npipe.setNumberOfNodesInLeg(100);\npipe.setPipeDiameters(new double[] {0.3, 0.3});\npipe.setLegPositions(new double[] {0.0, 5000.0});\n\n// Enable compositional tracking with TVD scheme\npipe.setCompositionalTracking(true);\npipe.setAdvectionScheme(AdvectionScheme.TVD_VAN_LEER);\n\n// Run steady-state initialization\npipe.run();\n\n// Run transient simulation\nUUID id = UUID.randomUUID();\nfor (int step = 0; step &lt; 100; step++) {\n    pipe.runTransient(1.0, id);  // 1 second time step\n}\n</code></pre>"},{"location":"wiki/pipeline_flow_equations/#references","title":"References","text":"<ol> <li>Patankar, S.V. (1980). Numerical Heat Transfer and Fluid Flow. Taylor &amp; Francis.</li> <li>Versteeg, H.K. &amp; Malalasekera, W. (2007). An Introduction to Computational Fluid Dynamics. Pearson.</li> <li>LeVeque, R.J. (2002). Finite Volume Methods for Hyperbolic Problems. Cambridge University Press.</li> <li>Sweby, P.K. (1984). \"High Resolution Schemes Using Flux Limiters for Hyperbolic Conservation Laws\". SIAM J. Numer. Anal. 21(5): 995-1011.</li> </ol>"},{"location":"wiki/pipeline_heat_transfer/","title":"Heat Transfer in Pipelines","text":""},{"location":"wiki/pipeline_heat_transfer/#overview","title":"Overview","text":"<p>NeqSim's <code>PipeBeggsAndBrills</code> class supports non-adiabatic operation with heat exchange to/from the surroundings. This is important for:</p> <ul> <li>Subsea pipelines (cold seawater)</li> <li>Buried pipelines (ground temperature)</li> <li>Uninsulated surface lines</li> <li>Wax and hydrate risk assessment</li> </ul>"},{"location":"wiki/pipeline_heat_transfer/#heat-transfer-modes","title":"Heat Transfer Modes","text":""},{"location":"wiki/pipeline_heat_transfer/#1-adiabatic-default","title":"1. Adiabatic (Default)","text":"<p>No heat exchange with surroundings: <pre><code>pipe.setRunAdiabatic(true);  // Default\n</code></pre></p>"},{"location":"wiki/pipeline_heat_transfer/#2-constant-surface-temperature","title":"2. Constant Surface Temperature","text":"<p>Heat transfer with fixed ambient temperature: <pre><code>pipe.setRunAdiabatic(false);\npipe.setRunConstantSurfaceTemperature(true);\npipe.setConstantSurfaceTemperature(277.15);  // 4\u00b0C (seawater)\n</code></pre></p>"},{"location":"wiki/pipeline_heat_transfer/#3-specified-heat-transfer-coefficient","title":"3. Specified Heat Transfer Coefficient","text":"<pre><code>pipe.setHeatTransferCoefficient(50.0);  // W/m\u00b2K\n</code></pre>"},{"location":"wiki/pipeline_heat_transfer/#4-estimated-heat-transfer","title":"4. Estimated Heat Transfer","text":"<p>Uses internal correlations: <pre><code>pipe.setHeatTransferCoefficientMethod(\"Estimated\");\n</code></pre></p>"},{"location":"wiki/pipeline_heat_transfer/#heat-transfer-equations","title":"Heat Transfer Equations","text":""},{"location":"wiki/pipeline_heat_transfer/#overall-heat-balance","title":"Overall Heat Balance","text":"<p>The temperature change across a segment is calculated from:</p> \\[\\dot{Q} = U \\cdot A \\cdot \\Delta T_{lm}\\] <p>Where: - \\(U\\) = overall heat transfer coefficient (W/m\u00b2K) - \\(A = \\pi D L\\) = heat transfer area - \\(\\Delta T_{lm}\\) = log-mean temperature difference</p>"},{"location":"wiki/pipeline_heat_transfer/#log-mean-temperature-difference","title":"Log-Mean Temperature Difference","text":"\\[\\Delta T_{lm} = \\frac{(T_s - T_{out}) - (T_s - T_{in})}{\\ln\\left(\\frac{T_s - T_{out}}{T_s - T_{in}}\\right)}\\] <p>Where: - \\(T_s\\) = surface/ambient temperature - \\(T_{in}\\) = segment inlet temperature - \\(T_{out}\\) = segment outlet temperature</p>"},{"location":"wiki/pipeline_heat_transfer/#gnielinski-correlation","title":"Gnielinski Correlation","text":"<p>For internal convection in turbulent flow (3000 &lt; Re &lt; 5\u00d710\u2076):</p> \\[Nu = \\frac{(f/8)(Re - 1000)Pr}{1 + 12.7\\sqrt{f/8}(Pr^{2/3} - 1)}\\] <p>Where: - \\(Nu\\) = Nusselt number = \\(hD/k\\) - \\(f\\) = Darcy friction factor - \\(Re\\) = Reynolds number - \\(Pr\\) = Prandtl number = \\(c_p \\mu / k\\)</p> <p>The internal heat transfer coefficient: $\\(h_{internal} = \\frac{Nu \\cdot k}{D}\\)$</p>"},{"location":"wiki/pipeline_heat_transfer/#typical-heat-transfer-coefficients","title":"Typical Heat Transfer Coefficients","text":""},{"location":"wiki/pipeline_heat_transfer/#overall-u-values-pipeline-insulation","title":"Overall U-Values (Pipeline + Insulation)","text":"Configuration U (W/m\u00b2K) Application Bare steel in air 10-25 Onshore exposed Bare steel in water 300-500 Uninsulated subsea 25mm insulation 3-5 Standard insulated 50mm insulation 1.5-3 Well insulated 75mm+ insulation &lt;1.5 Heavily insulated Pipe-in-pipe 0.5-2 High spec subsea"},{"location":"wiki/pipeline_heat_transfer/#internal-convection-coefficients","title":"Internal Convection Coefficients","text":"Fluid h_internal (W/m\u00b2K) Gas (low P) 20-50 Gas (high P) 100-300 Light oil 100-300 Heavy oil 50-150 Water 1000-5000 Two-phase 200-1000"},{"location":"wiki/pipeline_heat_transfer/#usage-examples","title":"Usage Examples","text":""},{"location":"wiki/pipeline_heat_transfer/#subsea-pipeline-cooling","title":"Subsea Pipeline Cooling","text":"<pre><code>SystemInterface gas = new SystemSrkEos(353.15, 100.0);  // 80\u00b0C wellhead\ngas.addComponent(\"methane\", 0.85);\ngas.addComponent(\"ethane\", 0.10);\ngas.addComponent(\"propane\", 0.05);\ngas.setMixingRule(2);\n\nStream wellhead = new Stream(\"wellhead\", gas);\nwellhead.setFlowRate(100000, \"kg/hr\");\nwellhead.run();\n\nPipeBeggsAndBrills subsea = new PipeBeggsAndBrills(\"subsea\", wellhead);\nsubsea.setLength(20000);           // 20 km\nsubsea.setDiameter(0.254);         // 10 inch\nsubsea.setElevation(-200);         // 200m water depth\nsubsea.setPipeWallRoughness(4.6e-5);\nsubsea.setNumberOfIncrements(40);\n\n// Heat transfer to seawater\nsubsea.setRunAdiabatic(false);\nsubsea.setRunConstantSurfaceTemperature(true);\nsubsea.setConstantSurfaceTemperature(277.15);  // 4\u00b0C seabed\nsubsea.setHeatTransferCoefficient(5.0);        // Insulated\n\nsubsea.run();\n\ndouble outletTemp = subsea.getOutletTemperature() - 273.15;\nSystem.out.println(\"Arrival temperature: \" + outletTemp + \" \u00b0C\");\n</code></pre>"},{"location":"wiki/pipeline_heat_transfer/#temperature-profile","title":"Temperature Profile","text":"<pre><code>// Get temperature along the pipeline\nList&lt;Double&gt; tempProfile = subsea.getTemperatureProfile();\ndouble segmentLength = 20000.0 / 40;\n\nfor (int i = 0; i &lt; tempProfile.size(); i++) {\n    double distance = i * segmentLength / 1000.0;  // km\n    double tempC = tempProfile.get(i) - 273.15;\n    System.out.println(distance + \" km: \" + tempC + \" \u00b0C\");\n}\n</code></pre>"},{"location":"wiki/pipeline_heat_transfer/#hydrate-and-wax-considerations","title":"Hydrate and Wax Considerations","text":""},{"location":"wiki/pipeline_heat_transfer/#hydrate-formation","title":"Hydrate Formation","text":"<p>Monitor temperature relative to hydrate equilibrium: <pre><code>double hydroEqTemp = ...; // From hydrate flash\ndouble margin = outletTemp - hydroEqTemp;\nif (margin &lt; 5.0) {\n    System.out.println(\"WARNING: Close to hydrate region\");\n}\n</code></pre></p>"},{"location":"wiki/pipeline_heat_transfer/#wax-appearance","title":"Wax Appearance","text":"<p>Check against wax appearance temperature (WAT): <pre><code>double WAT = ...; // From wax analysis\nif (outletTemp &lt; WAT) {\n    System.out.println(\"WARNING: Below WAT - wax may deposit\");\n}\n</code></pre></p>"},{"location":"wiki/pipeline_heat_transfer/#limitations","title":"Limitations","text":"<ol> <li>Steady-state heat transfer: No thermal mass of pipe wall</li> <li>Constant ambient: No variation along pipe length</li> <li>Single U-value: Same coefficient for entire pipe</li> <li>No Joule-Thomson: Expansion cooling handled separately</li> </ol>"},{"location":"wiki/pipeline_heat_transfer/#best-practices","title":"Best Practices","text":""},{"location":"wiki/pipeline_heat_transfer/#1-segment-sizing-for-heat-transfer","title":"1. Segment Sizing for Heat Transfer","text":"<p>Use more segments for accurate temperature profiles: <pre><code>pipe.setNumberOfIncrements(50);  // For long, cooling pipelines\n</code></pre></p>"},{"location":"wiki/pipeline_heat_transfer/#2-validate-against-simple-cases","title":"2. Validate Against Simple Cases","text":"<p>For long pipes with large temperature change, check: $\\(T_{out} \\approx T_s + (T_{in} - T_s) \\cdot e^{-UAL/(\\dot{m}c_p)}\\)$</p>"},{"location":"wiki/pipeline_heat_transfer/#3-consider-two-phase-effects","title":"3. Consider Two-Phase Effects","text":"<p>Heat transfer coefficients are higher for two-phase flow due to turbulence.</p>"},{"location":"wiki/pipeline_heat_transfer/#see-also","title":"See Also","text":"<ul> <li>Pipeline Pressure Drop Overview</li> <li>Beggs &amp; Brill Correlation</li> <li>Thermodynamic Properties</li> </ul>"},{"location":"wiki/pipeline_index/","title":"Pipeline Modeling Documentation","text":""},{"location":"wiki/pipeline_index/#documentation-index","title":"Documentation Index","text":"<p>This documentation covers pipeline pressure drop, flow, and heat transfer calculations in NeqSim.</p>"},{"location":"wiki/pipeline_index/#overview-getting-started","title":"Overview &amp; Getting Started","text":"Document Description Pipeline Pressure Drop Overview of all pipeline models, quick start examples Model Recommendations Which model to use for your application"},{"location":"wiki/pipeline_index/#detailed-model-documentation","title":"Detailed Model Documentation","text":"Document Description Beggs &amp; Brill Correlation Multiphase flow correlation theory and usage Friction Factor Models Haaland, Colebrook-White, laminar/turbulent Heat Transfer Non-adiabatic operation, cooling, Gnielinski Transient Simulation Dynamic simulation, slow wave propagation Water Hammer Fast transients, pressure surges, MOC solver"},{"location":"wiki/pipeline_index/#quick-model-selection","title":"Quick Model Selection","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        PIPELINE MODELS                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  Single-Phase Gas         \u2192  AdiabaticPipe                     \u2502\n\u2502  Single-Phase Liquid      \u2192  PipeBeggsAndBrills                \u2502\n\u2502  Two-Phase (Gas-Liquid)   \u2192  PipeBeggsAndBrills                \u2502\n\u2502  Three-Phase (G-O-W)      \u2192  PipeBeggsAndBrills                \u2502\n\u2502  With Elevation           \u2192  PipeBeggsAndBrills                \u2502\n\u2502  With Heat Transfer       \u2192  PipeBeggsAndBrills                \u2502\n\u2502  Slow Transient/Dynamic   \u2192  PipeBeggsAndBrills                \u2502\n\u2502  Water Hammer/Fast Trans. \u2192  WaterHammerPipe                   \u2502\n\u2502  Quick Estimate           \u2192  AdiabaticTwoPhasePipe             \u2502\n\u2502                                                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"wiki/pipeline_index/#key-classes","title":"Key Classes","text":"Class Package Description <code>PipeBeggsAndBrills</code> <code>neqsim.process.equipment.pipeline</code> Multiphase, elevation, heat transfer, slow transient <code>WaterHammerPipe</code> <code>neqsim.process.equipment.pipeline</code> Water hammer, fast pressure transients (MOC) <code>AdiabaticPipe</code> <code>neqsim.process.equipment.pipeline</code> Single-phase compressible gas <code>AdiabaticTwoPhasePipe</code> <code>neqsim.process.equipment.pipeline</code> Two-phase, horizontal"},{"location":"wiki/pipeline_index/#common-parameters","title":"Common Parameters","text":""},{"location":"wiki/pipeline_index/#geometry","title":"Geometry","text":"<ul> <li><code>setLength(double meters)</code> - Pipe length</li> <li><code>setDiameter(double meters)</code> - Inside diameter</li> <li><code>setElevation(double meters)</code> - Elevation change (+ = uphill)</li> <li><code>setPipeWallRoughness(double meters)</code> - Surface roughness</li> </ul>"},{"location":"wiki/pipeline_index/#numerical","title":"Numerical","text":"<ul> <li><code>setNumberOfIncrements(int n)</code> - Number of calculation segments</li> </ul>"},{"location":"wiki/pipeline_index/#calculation-mode","title":"Calculation Mode","text":"<ul> <li><code>setOutletPressure(double bara)</code> - Specify outlet pressure, calculate flow rate</li> <li>Default mode: Specify flow rate, calculate outlet pressure</li> </ul>"},{"location":"wiki/pipeline_index/#heat-transfer","title":"Heat Transfer","text":"<ul> <li><code>setRunAdiabatic(boolean)</code> - Enable/disable heat exchange</li> <li><code>setConstantSurfaceTemperature(double K)</code> - Ambient temperature</li> <li><code>setHeatTransferCoefficient(double W_m2K)</code> - Overall U-value</li> </ul>"},{"location":"wiki/pipeline_index/#transient","title":"Transient","text":"<ul> <li><code>setCalculateSteadyState(boolean)</code> - Switch steady/transient mode</li> <li><code>runTransient(double dt, UUID id)</code> - Run one time step</li> </ul>"},{"location":"wiki/pipeline_index/#typical-roughness-values","title":"Typical Roughness Values","text":"Pipe Material Roughness (mm) Roughness (m) New steel 0.046 4.6\u00d710\u207b\u2075 Corroded steel 0.15-0.3 1.5-3\u00d710\u207b\u2074 Stainless 0.015 1.5\u00d710\u207b\u2075 Plastic/GRP 0.005 5\u00d710\u207b\u2076"},{"location":"wiki/pipeline_index/#validation-summary","title":"Validation Summary","text":"Test Case Model Deviation Gas (Darcy-Weisbach) All models &lt;1% Liquid turbulent Beggs-Brill -1.4% Liquid laminar Beggs-Brill 0% Uphill two-phase Beggs-Brill Validated Transient convergence Beggs-Brill &lt;15%"},{"location":"wiki/pipeline_index/#version-history","title":"Version History","text":"<ul> <li>2025: Added calculate flow from outlet pressure mode</li> <li>2025: Fixed AdiabaticPipe and AdiabaticTwoPhasePipe calcFlow() methods</li> <li>2024: Added transient with friction and hydrostatic</li> <li>2024: Fixed Haaland exponent (^1.11)</li> <li>2024: Fixed single-phase liquid handling</li> <li>2024: Added Gnielinski heat transfer</li> <li>2024: Added flow regime detection</li> </ul>"},{"location":"wiki/pipeline_index/#support","title":"Support","text":"<p>For questions or issues: - GitHub Issues: https://github.com/equinor/neqsim/issues - Documentation: https://equinor.github.io/neqsim/</p>"},{"location":"wiki/pipeline_model_recommendations/","title":"Pipeline Model Recommendations","text":""},{"location":"wiki/pipeline_model_recommendations/#quick-reference-guide","title":"Quick Reference Guide","text":""},{"location":"wiki/pipeline_model_recommendations/#which-model-should-i-use","title":"Which Model Should I Use?","text":"<pre><code>                         START\n                           \u2502\n                           \u25bc\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502 Is flow single    \u2502\n                 \u2502 phase (gas OR     \u2502\u2500\u2500\u2500\u2500 YES \u2500\u2500\u2500\u2510\n                 \u2502 liquid only)?     \u2502            \u2502\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2502\n                          \u2502                       \u25bc\n                         NO               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                          \u2502               \u2502 Is it primarily  \u2502\n                          \u25bc               \u2502 gas?             \u2502\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502 PipeBeggsAndBrills\u2502             \u2502\n                 \u2502 (Multiphase)      \u2502      YES \u25c4\u2500\u2500\u2534\u2500\u2500\u25ba NO\n                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502          \u2502\n                                             \u25bc          \u25bc\n                                      AdiabaticPipe   PipeBeggsAndBrills\n                                      (fast, accurate) (handles viscosity)\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#detailed-recommendations","title":"Detailed Recommendations","text":""},{"location":"wiki/pipeline_model_recommendations/#scenario-1-high-pressure-gas-transmission","title":"Scenario 1: High-Pressure Gas Transmission","text":"<p>Use: <code>AdiabaticPipe</code></p> <ul> <li>Long-distance pipelines (&gt;10 km)</li> <li>Pressure &gt;20 bara</li> <li>Single-phase gas</li> <li>Compressibility effects important</li> </ul> <pre><code>AdiabaticPipe pipe = new AdiabaticPipe(\"transmission\", feed);\npipe.setLength(100000);    // 100 km\npipe.setDiameter(0.8);     // 32 inch\npipe.setInletPressure(80); // bara\npipe.run();\n</code></pre> <p>Why? Fastest computation, accounts for gas compressibility, well-validated.</p>"},{"location":"wiki/pipeline_model_recommendations/#scenario-2-oil-pipeline","title":"Scenario 2: Oil Pipeline","text":"<p>Use: <code>PipeBeggsAndBrills</code></p> <ul> <li>Crude oil or condensate</li> <li>May have dissolved gas</li> <li>Viscosity effects important</li> <li>Any inclination</li> </ul> <pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"oil\", feed);\npipe.setLength(5000);\npipe.setDiameter(0.3);\npipe.setPipeWallRoughness(4.6e-5);\npipe.setNumberOfIncrements(20);\npipe.run();\n</code></pre> <p>Why? Handles liquid accurately, proper friction for viscous fluids.</p>"},{"location":"wiki/pipeline_model_recommendations/#scenario-3-well-tubing-flowline","title":"Scenario 3: Well Tubing / Flowline","text":"<p>Use: <code>PipeBeggsAndBrills</code></p> <ul> <li>Two-phase or three-phase flow</li> <li>Significant elevation change</li> <li>Need liquid holdup</li> <li>Need flow regime</li> </ul> <pre><code>PipeBeggsAndBrills tubing = new PipeBeggsAndBrills(\"tubing\", well);\ntubing.setLength(3000);       // 3 km vertical\ntubing.setElevation(2900);    // Almost vertical\ntubing.setDiameter(0.0762);   // 3 inch\ntubing.setNumberOfIncrements(30);\ntubing.run();\n\nSystem.out.println(\"Flow regime: \" + tubing.getFlowRegime());\nSystem.out.println(\"Liquid holdup: \" + tubing.getSegmentLiquidHoldup(30));\n</code></pre> <p>Why? Only model that handles multiphase + elevation properly.</p>"},{"location":"wiki/pipeline_model_recommendations/#scenario-4-processing-plant-piping","title":"Scenario 4: Processing Plant Piping","text":"<p>Use: <code>AdiabaticTwoPhasePipe</code> (for quick estimates) or <code>PipeBeggsAndBrills</code> (for accuracy)</p> <ul> <li>Short pipes (&lt;100 m)</li> <li>Moderate pressure drops</li> <li>Quick calculations needed</li> </ul> <pre><code>AdiabaticTwoPhasePipe pipe = new AdiabaticTwoPhasePipe(\"P-101\", feed);\npipe.setLength(50);\npipe.setDiameter(0.1);\npipe.run();\n</code></pre> <p>Why? Fast, adequate accuracy for short pipes.</p>"},{"location":"wiki/pipeline_model_recommendations/#scenario-5-transientdynamic-simulation","title":"Scenario 5: Transient/Dynamic Simulation","text":"<p>Use: <code>PipeBeggsAndBrills</code></p> <ul> <li>Startup/shutdown</li> <li>Valve operations</li> <li>Flow rate changes</li> </ul> <pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"dynamic\", feed);\npipe.setLength(1000);\npipe.setDiameter(0.2);\npipe.setNumberOfIncrements(20);\npipe.run();\n\npipe.setCalculateSteadyState(false);\nfor (int t = 0; t &lt; 300; t++) {\n    pipe.runTransient(1.0, uuid);\n}\n</code></pre> <p>Why? Only model with transient capability.</p>"},{"location":"wiki/pipeline_model_recommendations/#scenario-6-subsea-pipeline-with-cooling","title":"Scenario 6: Subsea Pipeline with Cooling","text":"<p>Use: <code>PipeBeggsAndBrills</code> with heat transfer</p> <ul> <li>Long subsea lines</li> <li>Temperature drop matters</li> <li>Hydrate/wax risk</li> </ul> <pre><code>PipeBeggsAndBrills subsea = new PipeBeggsAndBrills(\"subsea\", feed);\nsubsea.setLength(30000);\nsubsea.setDiameter(0.254);\nsubsea.setElevation(-500);\nsubsea.setRunAdiabatic(false);\nsubsea.setConstantSurfaceTemperature(277.15);\nsubsea.setHeatTransferCoefficient(5.0);\nsubsea.run();\n</code></pre> <p>Why? Handles elevation, multiphase, and heat transfer.</p>"},{"location":"wiki/pipeline_model_recommendations/#performance-comparison","title":"Performance Comparison","text":"Model Relative Speed Memory Accuracy AdiabaticPipe \u2605\u2605\u2605\u2605\u2605 Low Good for gas AdiabaticTwoPhasePipe \u2605\u2605\u2605\u2605\u2606 Low Moderate PipeBeggsAndBrills \u2605\u2605\u2605\u2606\u2606 Medium Best"},{"location":"wiki/pipeline_model_recommendations/#common-mistakes","title":"Common Mistakes","text":""},{"location":"wiki/pipeline_model_recommendations/#wrong-using-adiabaticpipe-for-liquid","title":"\u274c Wrong: Using AdiabaticPipe for liquid","text":"<pre><code>// Will give poor results for liquid\nAdiabaticPipe pipe = new AdiabaticPipe(\"oil\", liquidFeed);\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#correct-use-pipebeggsandbrills-for-liquid","title":"\u2705 Correct: Use PipeBeggsAndBrills for liquid","text":"<pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"oil\", liquidFeed);\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#wrong-ignoring-elevation-for-wells","title":"\u274c Wrong: Ignoring elevation for wells","text":"<pre><code>PipeBeggsAndBrills tubing = new PipeBeggsAndBrills(\"tubing\", well);\ntubing.setLength(3000);\n// Missing: tubing.setElevation(3000);  // Vertical well!\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#correct-set-elevation","title":"\u2705 Correct: Set elevation","text":"<pre><code>PipeBeggsAndBrills tubing = new PipeBeggsAndBrills(\"tubing\", well);\ntubing.setLength(3000);\ntubing.setElevation(3000);  // Important!\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#wrong-too-few-segments-for-long-pipes","title":"\u274c Wrong: Too few segments for long pipes","text":"<pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"long\", feed);\npipe.setLength(50000);  // 50 km\npipe.setNumberOfIncrements(5);  // Only 5 segments for 50 km!\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#correct-use-adequate-segments","title":"\u2705 Correct: Use adequate segments","text":"<pre><code>pipe.setNumberOfIncrements(50);  // 1 km per segment\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#wrong-roughness-in-wrong-units","title":"\u274c Wrong: Roughness in wrong units","text":"<pre><code>pipe.setPipeWallRoughness(0.046);  // This is 46 mm! Way too rough!\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#correct-use-meters","title":"\u2705 Correct: Use meters","text":"<pre><code>pipe.setPipeWallRoughness(4.6e-5);  // 0.046 mm = 4.6\u00d710\u207b\u2075 m\n</code></pre>"},{"location":"wiki/pipeline_model_recommendations/#validation-checklist","title":"Validation Checklist","text":"<p>Before trusting results, verify:</p> <ul> <li> Pressure drop is positive (unless downhill liquid)</li> <li> Temperature change is reasonable</li> <li> Reynolds number is in expected range (1000-10\u2077)</li> <li> Flow regime makes physical sense</li> <li> Results change appropriately with diameter/length</li> </ul>"},{"location":"wiki/pipeline_model_recommendations/#see-also","title":"See Also","text":"<ul> <li>Pipeline Pressure Drop Overview</li> <li>Beggs &amp; Brill Correlation</li> <li>Friction Factor Models</li> <li>Heat Transfer in Pipelines</li> <li>Transient Simulation</li> </ul>"},{"location":"wiki/pipeline_pressure_drop/","title":"Pipeline Pressure Drop Calculations in NeqSim","text":""},{"location":"wiki/pipeline_pressure_drop/#overview","title":"Overview","text":"<p>NeqSim provides three main pipeline models for calculating pressure drop:</p> Model Class Best For <code>AdiabaticPipe</code> Single-phase compressible gas High-pressure gas transmission <code>AdiabaticTwoPhasePipe</code> General two-phase flow Moderate accuracy, fast computation <code>PipeBeggsAndBrills</code> Multiphase flow with correlations Wells, flowlines, complex terrain"},{"location":"wiki/pipeline_pressure_drop/#quick-start","title":"Quick Start","text":""},{"location":"wiki/pipeline_pressure_drop/#single-phase-gas-pipeline","title":"Single-Phase Gas Pipeline","text":"<pre><code>// Create gas system\nSystemInterface gas = new SystemSrkEos(298.15, 100.0); // 25\u00b0C, 100 bara\ngas.addComponent(\"methane\", 0.9);\ngas.addComponent(\"ethane\", 0.1);\ngas.setMixingRule(\"classic\");\n\nStream feed = new Stream(\"feed\", gas);\nfeed.setFlowRate(50000, \"kg/hr\");\nfeed.run();\n\n// Simple pipe model\nAdiabaticPipe pipe = new AdiabaticPipe(\"pipeline\", feed);\npipe.setLength(10000);        // 10 km\npipe.setDiameter(0.3);        // 300 mm\npipe.run();\n\ndouble pressureDrop = feed.getPressure() - pipe.getOutletPressure();\n</code></pre>"},{"location":"wiki/pipeline_pressure_drop/#two-phase-gas-liquid-pipeline","title":"Two-Phase (Gas-Liquid) Pipeline","text":"<pre><code>// Create two-phase system\nSystemInterface fluid = new SystemSrkEos(333.15, 50.0); // 60\u00b0C, 50 bara\nfluid.addComponent(\"methane\", 5000, \"kg/hr\");\nfluid.addComponent(\"nC10\", 50000, \"kg/hr\");\nfluid.setMixingRule(2);\n\nStream feed = new Stream(\"feed\", fluid);\nfeed.run();\n\n// Beggs &amp; Brill correlation\nPipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"flowline\", feed);\npipe.setLength(1000);           // 1 km\npipe.setDiameter(0.1);          // 100 mm\npipe.setElevation(50);          // 50 m uphill\npipe.setPipeWallRoughness(4.6e-5); // Steel roughness\npipe.setNumberOfIncrements(20);\npipe.run();\n\n// Get results\ndouble dp = pipe.getInletPressure() - pipe.getOutletPressure();\nString flowRegime = pipe.getFlowRegime().toString();\ndouble liquidHoldup = pipe.getSegmentLiquidHoldup(20);\n</code></pre>"},{"location":"wiki/pipeline_pressure_drop/#calculate-flow-rate-from-outlet-pressure","title":"Calculate Flow Rate from Outlet Pressure","text":"<p>All pipeline models support a reverse calculation mode where you specify the desired outlet pressure and the model calculates the required flow rate:</p> <pre><code>// Create gas system with initial flow estimate\nSystemInterface gas = new SystemSrkEos(298.15, 100.0); // 25\u00b0C, 100 bara\ngas.addComponent(\"methane\", 1.0);\ngas.setMixingRule(\"classic\");\ngas.setTotalFlowRate(10000, \"kg/hr\"); // Initial estimate (will be recalculated)\n\nStream feed = new Stream(\"feed\", gas);\nfeed.run();\n\n// PipeBeggsAndBrills - most accurate for flow calculation\nPipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"pipeline\", feed);\npipe.setLength(10000);           // 10 km\npipe.setDiameter(0.3);           // 300 mm\npipe.setPipeWallRoughness(4.6e-5);\npipe.setNumberOfIncrements(10);\npipe.setOutletPressure(90.0);    // Specify target outlet pressure (bara)\npipe.run();\n\n// Get calculated flow rate\ndouble flowRate = pipe.getInletStream().getFlowRate(\"kg/hr\");\ndouble achievedOutletP = pipe.getOutletPressure();\n// flowRate \u2248 144,000 kg/hr for 10 bar pressure drop\n</code></pre>"},{"location":"wiki/pipeline_pressure_drop/#supported-models-for-flow-calculation","title":"Supported Models for Flow Calculation","text":"Model Method Accuracy Notes <code>PipeBeggsAndBrills</code> <code>setOutletPressure(double)</code> Best Uses bisection iteration <code>AdiabaticPipe</code> <code>setOutPressure(double)</code> Good Single-phase gas only <code>AdiabaticTwoPhasePipe</code> <code>setOutPressure(double)</code> Moderate Two-phase capable"},{"location":"wiki/pipeline_pressure_drop/#model-selection-guide","title":"Model Selection Guide","text":""},{"location":"wiki/pipeline_pressure_drop/#use-adiabaticpipe-when","title":"Use <code>AdiabaticPipe</code> when:","text":"<ul> <li>Single-phase gas flow</li> <li>Long-distance transmission pipelines</li> <li>High pressure (&gt;20 bara)</li> <li>Need fast computation</li> </ul>"},{"location":"wiki/pipeline_pressure_drop/#use-adiabatictwophasepipe-when","title":"Use <code>AdiabaticTwoPhasePipe</code> when:","text":"<ul> <li>Two-phase flow with moderate accuracy needs</li> <li>Processing facility piping</li> <li>Quick screening calculations</li> </ul>"},{"location":"wiki/pipeline_pressure_drop/#use-pipebeggsandbrills-when","title":"Use <code>PipeBeggsAndBrills</code> when:","text":"<ul> <li>Multiphase flow (gas-oil, gas-oil-water)</li> <li>Well tubing and flowlines</li> <li>Significant elevation changes</li> <li>Need flow regime identification</li> <li>Liquid holdup predictions required</li> <li>Transient simulations</li> </ul>"},{"location":"wiki/pipeline_pressure_drop/#accuracy-comparison","title":"Accuracy Comparison","text":"<p>Based on validation against Darcy-Weisbach reference:</p> Condition AdiabaticPipe TwoPhasePipe BeggsAndBrills Single-phase gas +0.9% -0.1% +0.5% Single-phase liquid (turbulent) -4.1% -1.4% -1.4% Single-phase liquid (laminar) N/A ~0% ~0% Two-phase horizontal N/A N/A Validated Inclined pipe N/A N/A Validated"},{"location":"wiki/pipeline_pressure_drop/#calculation-modes","title":"Calculation Modes","text":""},{"location":"wiki/pipeline_pressure_drop/#forward-mode-default","title":"Forward Mode (Default)","text":"<p>Specify flow rate \u2192 Calculate outlet pressure</p> <pre><code>feed.setFlowRate(50000, \"kg/hr\");  // Known flow rate\npipe.run();\ndouble pOut = pipe.getOutletPressure();  // Calculated\n</code></pre>"},{"location":"wiki/pipeline_pressure_drop/#reverse-mode","title":"Reverse Mode","text":"<p>Specify outlet pressure \u2192 Calculate flow rate</p> <pre><code>pipe.setOutletPressure(90.0);  // Target outlet pressure\npipe.run();\ndouble flow = feed.getFlowRate(\"kg/hr\");  // Calculated\n</code></pre> <p>The reverse calculation uses a bisection algorithm that iteratively adjusts the flow rate until the calculated outlet pressure matches the specified target.</p>"},{"location":"wiki/pipeline_pressure_drop/#see-also","title":"See Also","text":"<ul> <li>Beggs &amp; Brill Correlation Details</li> <li>Pipeline Transient Simulation</li> <li>Friction Factor Calculations</li> <li>Heat Transfer in Pipelines</li> </ul>"},{"location":"wiki/pipeline_transient_simulation/","title":"Pipeline Transient Simulation in NeqSim","text":""},{"location":"wiki/pipeline_transient_simulation/#overview","title":"Overview","text":"<p>NeqSim supports dynamic (transient) simulation of pipelines using the <code>PipeBeggsAndBrills</code> class. This allows modeling of:</p> <ul> <li>Flow rate step changes</li> <li>Pressure disturbances</li> <li>Startup and shutdown scenarios</li> <li>Valve opening/closing effects</li> </ul>"},{"location":"wiki/pipeline_transient_simulation/#steady-state-vs-transient-modes","title":"Steady-State vs Transient Modes","text":""},{"location":"wiki/pipeline_transient_simulation/#steady-state-mode-default","title":"Steady-State Mode (Default)","text":"<p>In steady-state mode, calling <code>run()</code> calculates the equilibrium pressure profile along the pipe assuming constant inlet conditions:</p> <pre><code>PipeBeggsAndBrills pipe = new PipeBeggsAndBrills(\"pipe\", feed);\npipe.setLength(1000);\npipe.setDiameter(0.2);\npipe.run();  // Steady-state calculation\n\n// Two calculation modes:\n// 1. Forward (default): Given flow rate \u2192 calculate outlet pressure\n// 2. Reverse: Given outlet pressure \u2192 calculate flow rate\npipe.setOutletPressure(45.0);  // Switch to reverse mode\npipe.run();\ndouble requiredFlow = pipe.getInletStream().getFlowRate(\"kg/hr\");\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#transient-mode","title":"Transient Mode","text":"<p>In transient mode, the pipe remembers its internal state between time steps, allowing simulation of dynamic behavior:</p> <pre><code>pipe.setCalculateSteadyState(false);  // Enable transient mode\nfor (int step = 0; step &lt; 100; step++) {\n    pipe.runTransient(1.0, id);  // 1 second time step\n}\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#physics-model","title":"Physics Model","text":""},{"location":"wiki/pipeline_transient_simulation/#governing-equations","title":"Governing Equations","text":"<p>The transient model solves simplified forms of the mass and momentum conservation equations using a finite-difference approach:</p> <p>Mass Conservation: $\\(\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial (\\rho v)}{\\partial x} = 0\\)$</p> <p>Momentum (simplified): $\\(\\frac{\\partial P}{\\partial x} = -\\frac{dP}{dx}_{friction} - \\rho g \\sin\\theta\\)$</p>"},{"location":"wiki/pipeline_transient_simulation/#numerical-method","title":"Numerical Method","text":"<p>The implementation uses a relaxation-based advection scheme:</p> <ol> <li>Pipe is divided into segments (nodes)</li> <li>Properties propagate from upstream to downstream</li> <li>Friction and hydrostatic losses are applied at each segment</li> <li>Relaxation factor based on transit time:</li> </ol> \\[\\alpha = \\min\\left(1, \\frac{\\Delta t}{\\tau}\\right)\\] <p>Where \\(\\tau = \\Delta x / v\\) is the segment transit time.</p>"},{"location":"wiki/pipeline_transient_simulation/#wave-propagation","title":"Wave Propagation","text":"<p>For a property \\(\\phi\\) (pressure, temperature, flow):</p> \\[\\phi_{i+1}^{n+1} = \\phi_{i+1}^{n} + \\alpha \\cdot (\\phi_i^{n+1} - \\phi_{i+1}^{n}) - \\Delta P_{losses}\\] <p>This gives physically realistic propagation delays.</p>"},{"location":"wiki/pipeline_transient_simulation/#usage","title":"Usage","text":""},{"location":"wiki/pipeline_transient_simulation/#basic-transient-setup","title":"Basic Transient Setup","text":"<pre><code>// Create and run steady-state first\nSystemInterface gas = new SystemSrkEos(298.15, 50.0);\ngas.addComponent(\"methane\", 50000, \"kg/hr\");\ngas.setMixingRule(2);\n\nStream feed = new Stream(\"feed\", gas);\nfeed.run();\n\nPipeBeggsAndBrills pipeline = new PipeBeggsAndBrills(\"pipe\", feed);\npipeline.setLength(1000);\npipeline.setDiameter(0.2);\npipeline.setPipeWallRoughness(4.6e-5);\npipeline.setNumberOfIncrements(20);\npipeline.run();  // Initialize with steady-state\n\n// Switch to transient mode\npipeline.setCalculateSteadyState(false);\n\n// Run transient simulation\nUUID id = UUID.randomUUID();\ndouble dt = 1.0;  // 1 second time step\n\nfor (int step = 0; step &lt; 100; step++) {\n    pipeline.runTransient(dt, id);\n\n    // Monitor outlet\n    double outletPressure = pipeline.getOutletPressure();\n    double outletFlow = pipeline.getOutletStream().getFlowRate(\"kg/hr\");\n}\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#applying-disturbances","title":"Applying Disturbances","text":"<pre><code>// After running for some time, apply inlet pressure change\nSystemInterface newGas = new SystemSrkEos(298.15, 55.0);  // +5 bar\nnewGas.addComponent(\"methane\", 50000, \"kg/hr\");\nnewGas.setMixingRule(2);\n\nfeed.setThermoSystem(newGas);\nfeed.run();\n\n// Continue transient - disturbance will propagate\nfor (int step = 0; step &lt; 200; step++) {\n    pipeline.runTransient(dt, id);\n    // ... monitor response\n}\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#integration-with-processsystem","title":"Integration with ProcessSystem","text":"<pre><code>ProcessSystem process = new ProcessSystem();\nprocess.add(feed);\nprocess.add(valve);\nprocess.add(pipeline);\nprocess.add(separator);\n\n// Initial steady-state\nprocess.run();\n\n// Configure for transient\nvalve.setCalculateSteadyState(false);\npipeline.setCalculateSteadyState(false);\nprocess.setTimeStep(1.0);\n\n// Run transient steps\nfor (int i = 0; i &lt; 500; i++) {\n    if (i == 50) {\n        valve.setPercentValveOpening(80);  // Change valve at t=50s\n    }\n    process.runTransient();\n}\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#chokevalve-closure-propagation","title":"Choke/Valve Closure Propagation","text":"<p>A common transient scenario is simulating the effect of closing a downstream valve or choke and observing how the pressure/flow disturbance propagates back through the pipeline.</p>"},{"location":"wiki/pipeline_transient_simulation/#example-downstream-valve-closure","title":"Example: Downstream Valve Closure","text":"<pre><code>// Setup: Source \u2192 Pipeline \u2192 Choke Valve \u2192 Separator\nSystemInterface gas = new SystemSrkEos(298.15, 100.0);\ngas.addComponent(\"methane\", 1.0);\ngas.setMixingRule(\"classic\");\ngas.setTotalFlowRate(50000, \"kg/hr\");\n\nStream source = new Stream(\"source\", gas);\nsource.run();\n\n// Pipeline\nPipeBeggsAndBrills pipeline = new PipeBeggsAndBrills(\"pipeline\", source);\npipeline.setLength(5000);        // 5 km\npipeline.setDiameter(0.2);       // 200 mm\npipeline.setNumberOfIncrements(50);\npipeline.run();\n\n// Downstream choke valve\nThrottlingValve choke = new ThrottlingValve(\"choke\", pipeline.getOutletStream());\nchoke.setOutletPressure(50.0);   // 50 bara downstream\nchoke.run();\n\n// Build process\nProcessSystem process = new ProcessSystem();\nprocess.add(source);\nprocess.add(pipeline);\nprocess.add(choke);\nprocess.run();\n\nSystem.out.println(\"Initial steady-state:\");\nSystem.out.println(\"  Choke inlet P: \" + pipeline.getOutletPressure() + \" bara\");\nSystem.out.println(\"  Choke opening: \" + choke.getPercentValveOpening() + \"%\");\nSystem.out.println(\"  Flow rate: \" + source.getFlowRate(\"kg/hr\") + \" kg/hr\");\n\n// Switch to transient\npipeline.setCalculateSteadyState(false);\nchoke.setCalculateSteadyState(false);\nprocess.setTimeStep(1.0);\n\nUUID id = UUID.randomUUID();\n\n// Run transient with valve closure event\nfor (int step = 0; step &lt; 300; step++) {\n    double t = step * 1.0;  // seconds\n\n    // Gradual valve closure from t=50s to t=100s\n    if (t &gt;= 50 &amp;&amp; t &lt;= 100) {\n        double closureFraction = (t - 50) / 50.0;  // 0 to 1\n        double opening = 100.0 - closureFraction * 50.0;  // 100% \u2192 50%\n        choke.setPercentValveOpening(opening);\n    }\n\n    process.runTransient();\n\n    // Monitor pressure wave propagation\n    if (step % 10 == 0) {\n        System.out.printf(\"t=%3.0fs: P_pipe_out=%.2f bara, Choke=%.0f%%, Flow=%.0f kg/hr%n\",\n            t, pipeline.getOutletPressure(), \n            choke.getPercentValveOpening(),\n            choke.getOutletStream().getFlowRate(\"kg/hr\"));\n    }\n}\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#expected-behavior-valve-closure","title":"Expected Behavior: Valve Closure","text":"<p>When a downstream valve closes:</p> <ol> <li>Immediate effect (t=0): Valve restriction increases, flow through valve decreases</li> <li>Pressure buildup: Pressure upstream of valve increases as flow backs up</li> <li>Wave propagation: Pressure increase travels upstream through pipeline</li> <li>New equilibrium: System reaches new steady-state with lower flow and higher upstream pressure</li> </ol> Time Pipeline Outlet Flow Rate Notes 0s 70 bara 50,000 kg/hr Initial steady-state 50s 70 bara 50,000 kg/hr Valve starts closing 75s 75 bara 40,000 kg/hr Pressure building 100s 82 bara 30,000 kg/hr Valve at 50% open 200s 85 bara 28,000 kg/hr New equilibrium"},{"location":"wiki/pipeline_transient_simulation/#example-emergency-shutdown-esd","title":"Example: Emergency Shutdown (ESD)","text":"<p>Simulate rapid valve closure for ESD scenario:</p> <pre><code>// Fast valve closure (slam shut in 5 seconds)\nfor (int step = 0; step &lt; 500; step++) {\n    double t = step * 0.1;  // 100 ms time step for fast transient\n\n    // ESD triggered at t=10s\n    if (t &gt;= 10 &amp;&amp; t &lt;= 15) {\n        double closureFraction = (t - 10) / 5.0;\n        choke.setPercentValveOpening(100.0 * (1 - closureFraction));\n    } else if (t &gt; 15) {\n        choke.setPercentValveOpening(0.0);  // Fully closed\n    }\n\n    process.runTransient();\n\n    // Log high-frequency data for pressure surge analysis\n    System.out.printf(\"%.1f, %.3f, %.1f%n\", \n        t, pipeline.getOutletPressure(), \n        choke.getOutletStream().getFlowRate(\"kg/hr\"));\n}\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#pressure-surge-considerations","title":"Pressure Surge Considerations","text":"<p>For rapid valve closure (water hammer / pressure surge):</p> Closure Time Pressure Rise Model Accuracy &gt; 2\u00d7L/c Gradual Good ~ L/c Moderate surge Approximate &lt;&lt; L/c Severe surge Not supported <p>Where L = pipe length, c = speed of sound (~400 m/s for gas, ~1200 m/s for liquid).</p> <p>Note: The current transient model uses advection-based propagation (fluid velocity), not acoustic waves. For severe water hammer analysis, specialized transient software may be needed.</p>"},{"location":"wiki/pipeline_transient_simulation/#water-hammer-limitations","title":"Water Hammer Limitations","text":""},{"location":"wiki/pipeline_transient_simulation/#what-is-water-hammer","title":"What is Water Hammer?","text":"<p>Water hammer (hydraulic shock) occurs when a valve closes rapidly, causing pressure waves to travel at the speed of sound through the fluid. The pressure surge can be calculated using the Joukowsky equation:</p> \\[\\Delta P = \\rho \\cdot c \\cdot \\Delta v\\] <p>Where: - \\(\\rho\\) = fluid density (kg/m\u00b3) - \\(c\\) = speed of sound in fluid (m/s) - \\(\\Delta v\\) = velocity change (m/s)</p>"},{"location":"wiki/pipeline_transient_simulation/#example-pressure-surge-calculation","title":"Example Pressure Surge Calculation","text":"<p>For water at 10 m/s suddenly stopped: - \u03c1 = 1000 kg/m\u00b3 - c = 1200 m/s (water) - \u0394v = 10 m/s - \u0394P = 1000 \u00d7 1200 \u00d7 10 = 12 MPa = 120 bar!</p>"},{"location":"wiki/pipeline_transient_simulation/#current-model-behavior-vs-water-hammer","title":"Current Model Behavior vs Water Hammer","text":"Aspect NeqSim Transient Model True Water Hammer Wave speed Fluid velocity (1-20 m/s) Speed of sound (400-1400 m/s) Pressure peak Gradual buildup Sharp spike Wave reflection Not modeled Multiple reflections Timing Minutes to equilibrate Milliseconds for surge"},{"location":"wiki/pipeline_transient_simulation/#when-current-model-is-adequate","title":"When Current Model is Adequate","text":"<p>The advection-based model is suitable for:</p> <p>\u2705 Slow valve operations (closure time &gt; 2L/c) - 1 km water pipe: closure &gt; 1.7 seconds OK - 10 km gas pipe: closure &gt; 50 seconds OK</p> <p>\u2705 Production rate changes - Gradual flow adjustments</p> <p>\u2705 Process upsets - Separator level changes, compressor trips</p> <p>\u2705 Quasi-steady analysis - New equilibrium after disturbance</p>"},{"location":"wiki/pipeline_transient_simulation/#when-water-hammer-analysis-is-needed","title":"When Water Hammer Analysis is Needed","text":"<p>\u274c Emergency shutdowns - Fast valve closure (&lt;1 second)</p> <p>\u274c Pump trips - Sudden flow stoppage</p> <p>\u274c Check valve slam - Reverse flow closure</p> <p>\u274c Pipe stress analysis - Peak pressure for mechanical design</p>"},{"location":"wiki/pipeline_transient_simulation/#workaround-estimate-surge-pressure","title":"Workaround: Estimate Surge Pressure","text":"<p>You can estimate the water hammer pressure surge separately:</p> <pre><code>// Calculate theoretical water hammer pressure rise\npublic static double joukowskyPressureSurge(double density, double soundSpeed, \n                                             double velocityChange) {\n    return density * soundSpeed * velocityChange;  // Pa\n}\n\n// Example usage\ndouble rho = 800;    // kg/m\u00b3 (oil)\ndouble c = 1100;     // m/s (speed of sound in oil)\ndouble dv = 5;       // m/s (velocity before closure)\n\ndouble surgePressure = joukowskyPressureSurge(rho, c, dv);\nSystem.out.println(\"Max surge: \" + surgePressure/1e5 + \" bar\");\n// Output: Max surge: 44.0 bar\n\n// Add to steady-state operating pressure for peak\ndouble operatingPressure = 50.0;  // bara\ndouble peakPressure = operatingPressure + surgePressure/1e5;\nSystem.out.println(\"Peak pressure: \" + peakPressure + \" bara\");\n// Output: Peak pressure: 94.0 bar\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#speed-of-sound-estimation","title":"Speed of Sound Estimation","text":"<p>For gases, use NeqSim's thermodynamic properties:</p> <pre><code>SystemInterface gas = new SystemSrkEos(298.15, 50.0);\ngas.addComponent(\"methane\", 1.0);\ngas.setMixingRule(\"classic\");\ngas.init(3);\ngas.initPhysicalProperties();\n\ndouble soundSpeed = gas.getSoundSpeed();  // m/s\nSystem.out.println(\"Speed of sound: \" + soundSpeed + \" m/s\");\n// Typical: 400-450 m/s for natural gas\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#recommended-tools-for-water-hammer","title":"Recommended Tools for Water Hammer","text":"<p>For detailed water hammer analysis, consider:</p> <ol> <li>Method of Characteristics (MOC) - Classical numerical method for transient pipe flow</li> <li>Specialized software: OLGA, PIPESIM, AFT Impulse, Synergi Pipeline Simulator</li> <li>CFD - For complex geometries or detailed surge vessel analysis</li> </ol>"},{"location":"wiki/pipeline_transient_simulation/#future-enhancement","title":"Future Enhancement","text":"<p>A proper water hammer model would require:</p> <ol> <li>Solving the full hyperbolic wave equations</li> <li>Method of Characteristics or finite volume scheme</li> <li>Acoustic wave speed (not fluid velocity)</li> <li>Wave reflection at boundaries</li> <li>Vapor cavity modeling for column separation</li> </ol> <p>This is a potential future enhancement for NeqSim.</p>"},{"location":"wiki/pipeline_transient_simulation/#choke-opening-flow-increase","title":"Choke Opening (Flow Increase)","text":"<p>The reverse scenario - opening a choke to increase flow:</p> <pre><code>// Start with choke partially closed\nchoke.setPercentValveOpening(30.0);\nprocess.run();\n\n// Switch to transient\npipeline.setCalculateSteadyState(false);\nprocess.setTimeStep(1.0);\n\n// Gradually open choke\nfor (int step = 0; step &lt; 200; step++) {\n    if (step &gt;= 20 &amp;&amp; step &lt;= 70) {\n        double opening = 30.0 + (step - 20) * 1.4;  // 30% \u2192 100%\n        choke.setPercentValveOpening(Math.min(opening, 100.0));\n    }\n    process.runTransient();\n}\n</code></pre> <p>When opening a valve: 1. Flow increases immediately at the valve 2. Pressure drops upstream of valve (flow accelerating) 3. Pressure drop propagates upstream 4. System equilibrates at higher flow, lower upstream pressure</p>"},{"location":"wiki/pipeline_transient_simulation/#time-step-selection","title":"Time Step Selection","text":""},{"location":"wiki/pipeline_transient_simulation/#guidelines","title":"Guidelines","text":"Pipe Length Velocity Transit Time Recommended \u0394t 100 m 10 m/s 10 s 0.5-2 s 1 km 10 m/s 100 s 1-5 s 10 km 10 m/s 1000 s 5-20 s"},{"location":"wiki/pipeline_transient_simulation/#stability-criteria","title":"Stability Criteria","text":"<p>The time step should satisfy: $\\(\\Delta t \\leq \\frac{\\Delta x}{v}\\)$</p> <p>Where \\(\\Delta x = L / N_{increments}\\)</p> <p>For fast transients (valve slam), use smaller time steps: $\\(\\Delta t \\leq \\frac{\\Delta x}{c}\\)$</p> <p>Where \\(c\\) is the speed of sound (~350-450 m/s for natural gas).</p>"},{"location":"wiki/pipeline_transient_simulation/#propagation-timing","title":"Propagation Timing","text":""},{"location":"wiki/pipeline_transient_simulation/#expected-behavior","title":"Expected Behavior","text":"<p>Based on validation tests:</p> Mechanism Propagation Speed Notes Mass flow Fluid velocity ~10-20 m/s (gas) Pressure wave ~0.4\u00d7 transit time Model uses advection Temperature Fluid velocity Advective transport"},{"location":"wiki/pipeline_transient_simulation/#example-1000m-pipeline","title":"Example: 1000m Pipeline","text":"<p>For a 1000m pipe with 12.5 m/s gas velocity: - Fluid transit time: ~80 seconds - Pressure detection: ~30 seconds (0.4\u00d7 transit) - Full equilibration: ~200 seconds</p>"},{"location":"wiki/pipeline_transient_simulation/#accessing-transient-results","title":"Accessing Transient Results","text":""},{"location":"wiki/pipeline_transient_simulation/#profile-data","title":"Profile Data","text":"<pre><code>// Pressure profile along pipe\nList&lt;Double&gt; pressures = pipeline.getPressureProfile();\n\n// Temperature profile\nList&lt;Double&gt; temperatures = pipeline.getTemperatureProfile();\n\n// Pressure drop per segment\nList&lt;Double&gt; dpProfile = pipeline.getPressureDropProfile();\n\n// Get segment-specific values\nint segment = 10;\ndouble p = pipeline.getSegmentPressure(segment);\ndouble T = pipeline.getSegmentTemperature(segment);\ndouble holdup = pipeline.getSegmentLiquidHoldup(segment);\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#outlet-stream","title":"Outlet Stream","text":"<pre><code>Stream outlet = pipeline.getOutletStream();\ndouble outP = outlet.getPressure(\"bara\");\ndouble outT = outlet.getTemperature(\"C\");\ndouble outFlow = outlet.getFlowRate(\"kg/hr\");\n</code></pre>"},{"location":"wiki/pipeline_transient_simulation/#physical-effects-included","title":"Physical Effects Included","text":""},{"location":"wiki/pipeline_transient_simulation/#1-friction-losses","title":"1. Friction Losses","text":"<ul> <li>Calculated each time step using Darcy-Weisbach</li> <li>Uses Haaland friction factor</li> <li>Accounts for current velocity and density</li> </ul>"},{"location":"wiki/pipeline_transient_simulation/#2-hydrostatic-pressure","title":"2. Hydrostatic Pressure","text":"<ul> <li>Applied for inclined pipes</li> <li>\\(\\Delta P = \\rho \\cdot g \\cdot \\Delta h\\)</li> <li>Uses local mixture density</li> </ul>"},{"location":"wiki/pipeline_transient_simulation/#3-mass-conservation","title":"3. Mass Conservation","text":"<ul> <li>Mass flow propagates through segments</li> <li>Outlet flow responds to inlet changes</li> </ul>"},{"location":"wiki/pipeline_transient_simulation/#4-density-updates","title":"4. Density Updates","text":"<ul> <li>Density propagates with flow</li> <li>Affects velocity and friction calculations</li> </ul>"},{"location":"wiki/pipeline_transient_simulation/#limitations","title":"Limitations","text":"<ol> <li>No acoustic effects: Pressure waves travel at fluid velocity, not speed of sound</li> <li>No liquid accumulation: Holdup is quasi-steady</li> <li>Simplified heat transfer: Optional, uses constant coefficient</li> <li>No phase change during transient: Composition remains constant</li> </ol>"},{"location":"wiki/pipeline_transient_simulation/#best-practices","title":"Best Practices","text":""},{"location":"wiki/pipeline_transient_simulation/#1-initialize-properly","title":"1. Initialize Properly","text":"<p>Always run steady-state first to establish baseline: <pre><code>pipeline.run();  // Steady-state\npipeline.setCalculateSteadyState(false);  // Then switch\n</code></pre></p>"},{"location":"wiki/pipeline_transient_simulation/#2-use-sufficient-segments","title":"2. Use Sufficient Segments","text":"<p>More segments = better resolution of waves: <pre><code>pipeline.setNumberOfIncrements(20);  // Minimum\npipeline.setNumberOfIncrements(50);  // Better for long pipes\n</code></pre></p>"},{"location":"wiki/pipeline_transient_simulation/#3-monitor-convergence","title":"3. Monitor Convergence","text":"<p>Check that outlet stabilizes after disturbances: <pre><code>double prevP = 0;\nfor (int step = 0; step &lt; 500; step++) {\n    pipeline.runTransient(dt, id);\n    double p = pipeline.getOutletPressure();\n    if (Math.abs(p - prevP) &lt; 0.001) {\n        System.out.println(\"Converged at step \" + step);\n        break;\n    }\n    prevP = p;\n}\n</code></pre></p>"},{"location":"wiki/pipeline_transient_simulation/#4-validate-with-steady-state","title":"4. Validate with Steady-State","text":"<p>Transient should converge to same result as steady-state: <pre><code>double steadyDp = ...; // From steady-state run\ndouble transientDp = ...; // After convergence\nassertTrue(Math.abs(transientDp - steadyDp) / steadyDp &lt; 0.15);\n</code></pre></p>"},{"location":"wiki/pipeline_transient_simulation/#5-transient-convergence-time","title":"5. Transient Convergence Time","text":"<p>For a step change in inlet conditions, expect: - Initial response: Starts within 1-2 time steps - 50% of change: ~0.4\u00d7 fluid transit time - Full equilibration: 2-3\u00d7 fluid transit time</p> <p>Example for 1000m pipe with 12.5 m/s velocity: - Transit time = 80 seconds - Pressure change detected at outlet: ~30 seconds - Fully converged: ~200 seconds</p>"},{"location":"wiki/pipeline_transient_simulation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"wiki/pipeline_transient_simulation/#problem-pressure-goes-negative","title":"Problem: Pressure goes negative","text":"<p>Cause: Time step too large or flow rate too high Solution: Reduce time step or increase inlet pressure</p>"},{"location":"wiki/pipeline_transient_simulation/#problem-no-response-at-outlet","title":"Problem: No response at outlet","text":"<p>Cause: Not enough transient steps Solution: Run more steps (at least 2\u00d7 transit time)</p>"},{"location":"wiki/pipeline_transient_simulation/#problem-oscillations","title":"Problem: Oscillations","text":"<p>Cause: Time step too small relative to physics Solution: Increase time step or reduce number of segments</p>"},{"location":"wiki/pipeline_transient_simulation/#future-water-hammer-implementation","title":"Future: Water Hammer Implementation","text":"<p>Water hammer simulation is now available in NeqSim through the <code>WaterHammerPipe</code> class, which uses the Method of Characteristics (MOC) to simulate fast pressure transients. The recommended approach for water hammer analysis is:</p> <ol> <li>Use <code>WaterHammerPipe</code> for fast transients - valve closures, pump trips, ESD events</li> <li>Leverage NeqSim thermodynamics - wave speed calculated from EOS</li> <li>Design for extensibility - supports reservoir, valve, and closed-end boundary conditions</li> <li>Validate against Joukowsky equation - built-in surge pressure calculation</li> </ol> <p>The existing <code>PipeBeggsAndBrills</code> advection model remains valuable for slow transients, while <code>WaterHammerPipe</code> handles fast acoustic phenomena.</p>"},{"location":"wiki/pipeline_transient_simulation/#quick-example","title":"Quick Example","text":"<pre><code>// Create water hammer pipe\nWaterHammerPipe pipe = new WaterHammerPipe(\"pipe\", feed);\npipe.setLength(1000);\npipe.setDiameter(0.2);\npipe.setNumberOfNodes(100);\npipe.setDownstreamBoundary(BoundaryType.VALVE);\npipe.run();\n\n// Transient with valve closure\nfor (int step = 0; step &lt; 1000; step++) {\n    if (step == 100) pipe.setValveOpening(0.0);  // Slam shut\n    pipe.runTransient(0.001, id);\n}\n\n// Get maximum pressure surge\ndouble maxP = pipe.getMaxPressure(\"bar\");\n</code></pre> <p>For detailed implementation, see Water Hammer Implementation Guide.</p>"},{"location":"wiki/pipeline_transient_simulation/#see-also","title":"See Also","text":"<ul> <li>Pipeline Pressure Drop Overview</li> <li>Beggs &amp; Brill Correlation</li> <li>Water Hammer Implementation Guide</li> <li>Process Simulation Basics</li> </ul>"},{"location":"wiki/process_control/","title":"Process control framework","text":"<p>NeqSim contains a flexible process control framework for dynamic simulations. The framework provides:</p> <ul> <li>PID controllers through <code>ControllerDeviceBaseClass</code> implementing proportional,   integral and derivative actions with anti-windup, derivative filtering and   configurable output limits.</li> <li>Auto\u2011tuning and gain scheduling for adapting controller parameters to   different operating conditions.</li> <li>Event logging and performance metrics such as integral absolute error and   settling time for evaluating controller behaviour.</li> <li>Advanced control structures \u2013 cascade, ratio and feed\u2011forward \u2013 built on the   common <code>ControlStructureInterface</code> for multi\u2011loop coordination.</li> <li>Measurement devices with explicit unit handling plus optional Gaussian noise   and sample delay to emulate realistic transmitters.</li> </ul> <p>See the unit tests in <code>src/test/java/neqsim/process/controllerdevice</code> for examples of how the controllers and control structures are used in simulations.</p>"},{"location":"wiki/process_control/#model-predictive-control","title":"Model predictive control","text":"<p>The <code>ModelPredictiveController</code> class adds multivariable model predictive control (MPC) to the framework. The controller uses a first-order process model with configurable gain, time constant, bias and prediction horizon to calculate an optimal control move that balances tracking accuracy, absolute energy usage and aggressive movement. MPC integrates with the rest of the process-control package through the common <code>ControllerDeviceInterface</code>, allowing it to replace or work alongside traditional PID loops.</p>"},{"location":"wiki/process_control/#single-loop-quick-start","title":"Single-loop quick start","text":"<ol> <li>Provide a measurement \u2013 connect a    <code>MeasurementDeviceInterface</code> (for example a temperature or pressure    transmitter) via <code>setTransmitter</code>. The MPC will read samples from the device    whenever <code>runTransient</code> is invoked.</li> <li>Instantiate and parameterise \u2013 create the controller, call    <code>setControllerSetPoint</code>, describe the internal process model with    <code>setProcessModel</code> and <code>setProcessBias</code>, then choose a prediction horizon and    tuning weights with <code>setPredictionHorizon</code> and <code>setWeights</code>.</li> <li>Apply limits and preferences \u2013 use <code>setOutputLimits</code> to cap the actuator    and <code>setPreferredControlValue</code> to encode an economic target such as minimum    heater duty.</li> <li>Execute in the simulation \u2013 call <code>runTransient(previousControl, dt)</code>    every control interval. The return value from <code>getResponse()</code> is the new    manipulated-variable value to apply to the process.</li> </ol> <pre><code>ModelPredictiveController controller = new ModelPredictiveController(\"heaterMpc\");\ncontroller.setTransmitter(temperatureSensor);\ncontroller.setControllerSetPoint(328.15, \"K\");\ncontroller.setProcessModel(0.18, 45.0);   // gain, time constant [s]\ncontroller.setProcessBias(298.15);\ncontroller.setPredictionHorizon(20);\ncontroller.setWeights(1.0, 0.03, 0.2);    // tracking, energy, move penalties\ncontroller.setPreferredControlValue(20.0);\ncontroller.setOutputLimits(0.0, 100.0);\n\ndouble manipulated = controller.getResponse();\nfor (double t = 0.0; t &lt; 1800.0; t += 5.0) {\n  controller.runTransient(manipulated, 5.0);\n  manipulated = controller.getResponse();\n  heater.setDuty(manipulated, \"kW\");\n}\n</code></pre> <p>The single-input mode automatically handles reverse-acting processes via <code>setReverseActing(true)</code> and can be paused/resumed with <code>setActive(false)</code>.</p>"},{"location":"wiki/process_control/#multivariable-optimisation","title":"Multivariable optimisation","text":"<p>For flowsheets with several manipulated variables the MPC is configured with an ordered control vector:</p> <pre><code>controller.configureControls(\"dewPointCooler\", \"stabiliserHeater\", \"compressorSpeed\");\ncontroller.setInitialControlValues(6.0, 65.0, 0.78);\ncontroller.setControlLimits(\"dewPointCooler\", -10.0, 25.0);\ncontroller.setControlLimits(\"stabiliserHeater\", 40.0, 90.0);\ncontroller.setControlLimits(\"compressorSpeed\", 0.5, 1.05);\ncontroller.setControlWeights(0.6, 0.2, 0.05);   // energy usage penalty\ncontroller.setMoveWeights(0.2, 0.05, 0.02);     // movement smoothing\ncontroller.setPreferredControlVector(0.0, 55.0, 0.8);\n</code></pre> <p><code>getControlVector()</code> returns the most recent actuation proposal for all manipulated variables, while <code>setPrimaryControlIndex</code> determines which entry is exposed via <code>getResponse()</code> for backwards compatibility with controller structures expecting a single output.</p>"},{"location":"wiki/process_control/#quality-constraints-and-product-specifications","title":"Quality constraints and product specifications","text":"<p>MPC quality constraints describe how key product indicators respond to each manipulated variable and to feed composition/rate changes. Limits are handled as soft constraints, letting the optimiser trade off specification margin and energy usage.</p> <pre><code>ModelPredictiveController.QualityConstraint wobbeConstraint =\n    ModelPredictiveController.QualityConstraint.builder(\"WobbeIndex\")\n        .measurement(wobbeTransmitter)\n        .unit(\"MJ/Sm3\")\n        .limit(51.7)\n        .margin(0.2)\n        .controlSensitivity(0.04, -0.01, 0.03)\n        .compositionSensitivity(\"nitrogen\", -2.8)\n        .rateSensitivity(0.005)\n        .build();\n\ncontroller.addQualityConstraint(wobbeConstraint);\n</code></pre> <p>The controller stores predicted specification values for diagnostics via <code>getPredictedQuality</code>. Call <code>clearQualityConstraints()</code> when the control structure changes or before reconfiguring sensitivities.</p>"},{"location":"wiki/process_control/#feedforward-updates","title":"Feedforward updates","text":"<p><code>updateFeedConditions</code> injects the expected upstream composition and rate into the next optimisation. Supplying these predictions enables proactive responses to known feed changes and improves constraint tracking on multivariate systems.</p> <pre><code>controller.updateFeedConditions(Map.of(\n    \"methane\", 0.82,\n    \"ethane\", 0.08,\n    \"propane\", 0.03),\n    12.4);    // kmol/hr\n</code></pre>"},{"location":"wiki/process_control/#moving-horizon-estimation","title":"Moving horizon estimation","text":"<p>When the underlying process characteristics drift, enable the embedded moving horizon estimator so the internal model follows the plant:</p> <pre><code>controller.enableMovingHorizonEstimation(60);   // keep the last 60 samples\n</code></pre> <p>After the estimator has gathered enough samples <code>getLastMovingHorizonEstimate()</code> returns identified gain, time constant, bias and prediction error. Call <code>clearMovingHorizonHistory()</code> to restart the identification window, or <code>disableMovingHorizonEstimation()</code> to lock the controller to its current model.</p>"},{"location":"wiki/process_control/#using-plant-measurements-alongside-the-model","title":"Using plant measurements alongside the model","text":"<p>Digital twins are most valuable when they continuously reconcile with plant data. The MPC supports blending measured values from a facility with simulated predictions:</p> <ul> <li>Primary loop samples \u2013 call   <code>ingestPlantSample(measurement, appliedControl, dt)</code> each time a fresh   transmitter value arrives from the plant. The controller uses the injected   sample as the baseline for optimisation and feeds it into the moving-horizon   estimator, allowing the internal model to track real-world drift even when no   NeqSim <code>MeasurementDeviceInterface</code> is configured.</li> <li>Product quality updates \u2013 for laboratory or analyser results that arrive   more slowly than the simulation, use <code>updateQualityMeasurement(\"wobbe\", value)</code>   (or the map-based overload) to store the real measurement against the relevant   constraint. The MPC then combines that measured baseline with the process   sensitivities and feedforward model to predict how upcoming moves will affect   the specification.</li> </ul> <p>This approach allows existing plant instrumentation to update the MPC while the NeqSim model still contributes predictive behaviour for future disturbances.</p>"},{"location":"wiki/process_control/#diagnostics-and-best-practices","title":"Diagnostics and best practices","text":"<ul> <li>Use <code>getLastSampledValue()</code>, <code>getLastAppliedControl()</code> and   <code>getPredictionHorizon()</code> to verify tuning.</li> <li>Clamp manual interventions through <code>setControlLimits</code> and   <code>setOutputLimits</code> to protect equipment.</li> <li>Combine MPC with conventional structures such as cascade controllers by   wiring the MPC output into an inner PID loop through the shared   <code>ControllerDeviceInterface</code>.</li> <li>Review <code>MovingHorizonEstimationExampleTest</code> and   <code>OffshoreProcessMpcIntegrationTest</code> in the test suite for end-to-end   demonstrations covering adaptive tuning and constrained optimisation.</li> </ul>"},{"location":"wiki/process_simulation/","title":"Process Simulation in NeqSim","text":"<p>NeqSim allows you to model complex process plants by connecting unit operations (like separators, compressors, heat exchangers) with streams. The core class for managing these simulations is <code>ProcessSystem</code>.</p>"},{"location":"wiki/process_simulation/#basic-concepts","title":"Basic Concepts","text":"<ul> <li>ProcessSystem: The container for all unit operations and streams. It manages the execution order and solving of the process.</li> <li>Stream: Represents a flow of fluid. It holds a reference to a thermodynamic system (fluid object) and defines flow rate, temperature, and pressure.</li> <li>Unit Operation: Equipment that modifies streams (e.g., <code>Separator</code>, <code>Compressor</code>, <code>Heater</code>) or measures properties.</li> <li>Process Module: A grouped set of unit operations that perform a specific task (e.g., TEG Dehydration, Separation Train).</li> </ul>"},{"location":"wiki/process_simulation/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"wiki/process_simulation/#1-define-the-fluid","title":"1. Define the Fluid","text":"<p>First, create a thermodynamic system using a fluid package (e.g., SRK, CPA).</p> <pre><code>SystemInterface fluid = new SystemSrkEos(298.15, 50.0); // 298.15 K, 50 bar\nfluid.addComponent(\"methane\", 90.0);\nfluid.addComponent(\"ethane\", 5.0);\nfluid.addComponent(\"propane\", 3.0);\nfluid.addComponent(\"n-heptane\", 2.0);\nfluid.setMixingRule(\"classic\");\n</code></pre>"},{"location":"wiki/process_simulation/#2-create-the-feed-stream","title":"2. Create the Feed Stream","text":"<p>Create a <code>Stream</code> object using the fluid. This acts as the inlet to your process.</p> <pre><code>Stream feedStream = new Stream(\"Feed Stream\", fluid);\nfeedStream.setFlowRate(1000.0, \"kg/hr\");\nfeedStream.setTemperature(30.0, \"C\");\nfeedStream.setPressure(50.0, \"bara\");\n</code></pre>"},{"location":"wiki/process_simulation/#3-add-unit-operations","title":"3. Add Unit Operations","text":"<p>Instantiate unit operations and connect them. Most units take an input stream in their constructor or via a <code>setInletStream</code> method.</p> <pre><code>// Add a valve to reduce pressure\nThrottlingValve valve = new ThrottlingValve(\"Inlet Valve\", feedStream);\nvalve.setOutletPressure(30.0); // bar\n\n// Add a separator connected to the valve outlet\nSeparator separator = new Separator(\"Test Separator\", valve.getOutletStream());\n</code></pre>"},{"location":"wiki/process_simulation/#4-create-the-process-system","title":"4. Create the Process System","text":"<p>Add all operations to a <code>ProcessSystem</code>.</p> <pre><code>ProcessSystem process = new ProcessSystem();\nprocess.add(feedStream);\nprocess.add(valve);\nprocess.add(separator);\n</code></pre>"},{"location":"wiki/process_simulation/#5-run-the-simulation","title":"5. Run the Simulation","text":"<p>Execute the simulation. NeqSim will solve the units in the order they were added (or automatically sort them if needed).</p> <pre><code>process.run();\n</code></pre>"},{"location":"wiki/process_simulation/#6-retrieve-results","title":"6. Retrieve Results","text":"<p>Access the results from the unit operations or streams.</p> <pre><code>double gasRate = separator.getGasOutStream().getFlowRate(\"kg/hr\");\ndouble liquidRate = separator.getLiquidOutStream().getFlowRate(\"kg/hr\");\nSystem.out.println(\"Gas Rate: \" + gasRate);\nSystem.out.println(\"Liquid Rate: \" + liquidRate);\n</code></pre>"},{"location":"wiki/process_simulation/#process-modules","title":"Process Modules","text":"<p>Process modules are pre-configured collections of unit operations designed to perform standard processing tasks. They are useful for quickly building complex plants without defining every single component.</p>"},{"location":"wiki/process_simulation/#using-a-standard-module","title":"Using a Standard Module","text":"<p>NeqSim comes with several built-in modules in <code>neqsim.process.processmodel.processmodules</code>.</p> <p>Example: TEG Dehydration Module</p> <pre><code>import neqsim.process.processmodel.processmodules.GlycolDehydrationlModule;\n\n// ... (Define feed stream as above) ...\n\n// Initialize the module\nGlycolDehydrationlModule tegModule = new GlycolDehydrationlModule(\"TEG Plant\");\ntegModule.addInputStream(\"GasFeed\", separator.getGasOutStream());\ntegModule.addInputStream(\"TEGFeed\", tegFeedStream); // Assuming you created a TEG feed stream\n\n// Configure module parameters\ntegModule.setSpecification(\"water content\", 50.0); // ppm\n\n// Add to process system\nprocess.add(tegModule);\n\n// Run\nprocess.run();\n</code></pre>"},{"location":"wiki/process_simulation/#creating-custom-modules","title":"Creating Custom Modules","text":"<p>You can create your own modules by extending <code>ProcessModuleBaseClass</code>. This allows you to encapsulate complex logic and reuse it across different projects.</p> <pre><code>public class MyCustomModule extends ProcessModuleBaseClass {\n    public MyCustomModule(String name) {\n        super(name);\n    }\n\n    @Override\n    public void initializeModule() {\n        // Define internal units and connections here\n        // operations.add(...)\n    }\n\n    // Implement other abstract methods...\n}\n</code></pre>"},{"location":"wiki/process_simulation/#advanced-features","title":"Advanced Features","text":"<ul> <li>Recycles: Use the <code>Recycle</code> class to close loops in the process.</li> <li>Controllers: Add PID controllers to adjust parameters dynamically during the simulation.</li> <li>Dynamic Simulation: <code>ProcessSystem</code> supports dynamic simulation for time-dependent analysis.</li> <li>Bottleneck Analysis: Analyze capacity utilization and identify system bottlenecks. See Bottleneck Analysis.</li> </ul> <p>For more examples, check the <code>src/test/java/neqsim/process</code> folder in the source code.</p>"},{"location":"wiki/process_transient_simulation_guide/","title":"Transient process simulation patterns from tests","text":"<p>Dynamic process behavior in NeqSim is validated through <code>ProcessSystemRunTransientTest</code>, which assembles streams, valves, separators, transmitters, and controllers before stepping a transient solver. Reusing the tested scaffolding ensures that custom flowsheets converge and maintain synchronized calculation identifiers across unit operations.</p>"},{"location":"wiki/process_transient_simulation_guide/#minimal-transient-loop-with-flow-control","title":"Minimal transient loop with flow control","text":"<p>The first scenario creates a single feed stream, lets it down through a valve into a separator, and attaches a flow controller to the inlet valve based on a volume-flow transmitter.\u3010F:src/test/java/neqsim/process/processmodel/ProcessSystemRunTransientTest.java\u2020L58-L120\u3011 Key steps reproduced below:</p> <ol> <li>Build a thermodynamic system with SRK EOS and set a mixing rule.</li> <li>Define a <code>Stream</code>, set mass flow and pressure, and connect it to a <code>ThrottlingValve</code> with a target outlet pressure.</li> <li>Route the valve outlet to a <code>Separator</code>, configure geometry (diameter, length) and initial liquid level.</li> <li>Add downstream valves for gas and liquid outlets to define back-pressure targets.</li> <li>Attach a <code>VolumeFlowTransmitter</code> to the inlet stream, wire it to a <code>ControllerDeviceBaseClass</code>, and assign the controller to the inlet valve.</li> <li>Run a steady-state initialization (<code>p.run()</code>), choose a transient timestep, and iterate <code>runTransient()</code> to observe controller action converging toward the setpoint (73.5 kg/hr in the test).</li> </ol> <p>The assertions in the test check that every unit operation shares the same calculation identifier during the loop and that the transmitter stabilizes near the requested flow, confirming correct coupling of controller logic and transport equations.\u3010F:src/test/java/neqsim/process/processmodel/ProcessSystemRunTransientTest.java\u2020L106-L120\u3011 Use this template when debugging control loops or valve responses in your own cases.</p>"},{"location":"wiki/process_transient_simulation_guide/#level-and-pressure-controlled-separator-case","title":"Level- and pressure-controlled separator case","text":"<p>A second scenario adds a purge stream to the separator, introduces level and pressure transmitters, and binds each to a dedicated controller that manipulates the liquid and gas outlet valves respectively.\u3010F:src/test/java/neqsim/process/processmodel/ProcessSystemRunTransientTest.java\u2020L122-L232\u3011 After a steady-state start, the process is marched forward with a 10-second timestep and the level transmitter reading is checked against the 0.45 m setpoint, demonstrating how controller gains drive the separator toward balanced holdup.</p> <p>When replicating this pattern:</p> <ul> <li>Set transmitter bounds (<code>setMaximumValue</code>, <code>setMinimumValue</code>) to guard against unrealistic signals.</li> <li>Apply <code>setCalculateSteadyState(false)</code> on dynamic equipment to ensure the transient integrator, not a steady solver, advances the state.</li> <li>Verify calculation identifiers after each <code>runTransient()</code> to confirm that all equipment is synchronized before trusting control trajectories.</li> </ul>"},{"location":"wiki/process_transient_simulation_guide/#why-calculation-identifiers-matter","title":"Why calculation identifiers matter","text":"<p>Throughout the transient loops the test asserts that each unit operation's <code>getCalculationIdentifier()</code> matches the process system's identifier.\u3010F:src/test/java/neqsim/process/processmodel/ProcessSystemRunTransientTest.java\u2020L114-L118\u3011\u3010F:src/test/java/neqsim/process/processmodel/ProcessSystemRunTransientTest.java\u2020L221-L229\u3011 This guards against stale states or partial updates when complex equipment is added. If you see divergence, reinitialize the process system or inspect units for disabled steady-state flags.</p>"},{"location":"wiki/property_flash_workflows/","title":"Property flash workflows proven by tests","text":"<p><code>ThermodynamicOperationsTest</code> exercises NeqSim's property flash API across PT/TP orderings, unit handling, and online composition updates. This guide distills the tested patterns so you can set up property flashes with confidence.</p>"},{"location":"wiki/property_flash_workflows/#pt-vs-tp-flash-symmetry","title":"PT vs TP flash symmetry","text":"<p><code>testFlash</code> creates a binary methane/ethane SRK system and runs both <code>flash(FlashType.PT, P, T, unitP, unitT)</code> and <code>flash(FlashType.TP, T, P, unitT, unitP)</code> on the same state, then compares all returned properties for equality.\u3010F:src/test/java/neqsim/thermodynamicoperations/ThermodynamicOperationsTest.java\u2020L25-L48\u3011 The test verifies that property flashes are order-invariant when pressure and temperature units are supplied explicitly.</p> <p>Takeaway: You can interchange PT and TP flash modes without changing results, as long as you reinitialize (<code>init(2)</code> and <code>initPhysicalProperties()</code>) before reading properties.</p>"},{"location":"wiki/property_flash_workflows/#validating-request-inputs","title":"Validating request inputs","text":"<p><code>testFluidDefined</code> builds several SRK air mixtures and calls <code>propertyFlash</code> with streaming pressure/temperature vectors and optional online compositions to mimic live analyzers.\u3010F:src/test/java/neqsim/thermodynamicoperations/ThermodynamicOperationsTest.java\u2020L50-L119\u3011 The test first omits <code>init(0)</code> to prove the API returns a descriptive error (<code>\"Sum of fractions must be approximately to 1 or 100...\"</code>), then reinitializes and confirms all calculation errors are null.</p> <p>Setup checklist from the test:</p> <ol> <li>Add components and set a mixing rule plus any volume corrections.</li> <li>Call <code>init(0)</code> before requesting properties to normalize molar fractions.</li> <li>Pass <code>FlashMode</code> 1, 2, or 3; any other mode yields the explicit error asserted in <code>testNeqSimPython</code>.\u3010F:src/test/java/neqsim/thermodynamicoperations/ThermodynamicOperationsTest.java\u2020L120-L152\u3011</li> <li>When streaming online composition updates, make sure each inner list matches the length of the pressure/temperature vectors.</li> </ol>"},{"location":"wiki/property_flash_workflows/#integration-pattern-for-external-clients","title":"Integration pattern for external clients","text":"<p><code>testNeqSimPython</code> and <code>testNeqSimPython2</code> illustrate how property flashes can be called from foreign interfaces (e.g., Python bindings) while maintaining result integrity.\u3010F:src/test/java/neqsim/thermodynamicoperations/ThermodynamicOperationsTest.java\u2020L120-L209\u3011 The tests check that:</p> <ul> <li>Returned <code>CalculationResult</code> objects are stable under equality and <code>hashCode()</code> comparisons.</li> <li>Invalid <code>FlashMode</code> inputs return clear error strings without throwing exceptions.</li> <li>Property arrays cover the full set of <code>SystemProperties.getPropertyNames()</code> even when only single-point requests are made.</li> </ul> <p>When wrapping the API externally, mirror these assertions to guard against transport or serialization errors.</p>"},{"location":"wiki/psd_valve_hihi_trip/","title":"PSD Valve with High-High Alarm Trip","text":""},{"location":"wiki/psd_valve_hihi_trip/#overview","title":"Overview","text":"<p>The <code>PSDValve</code> (Process Shutdown Valve) is a safety isolation valve that automatically closes when a High-High (HIHI) pressure alarm is triggered. It provides emergency shutdown protection by monitoring a pressure transmitter and rapidly closing to prevent overpressure conditions from propagating through the process.</p>"},{"location":"wiki/psd_valve_hihi_trip/#key-features","title":"Key Features","text":"<ul> <li>Automatic HIHI Trip: Monitors pressure transmitter and closes automatically on HIHI alarm</li> <li>Fast Closure: Configurable fast closure time (default 2 seconds)</li> <li>Trip State Tracking: Maintains trip state for safety interlock logic</li> <li>Manual Reset: Requires operator reset after trip before valve can be reopened</li> <li>Enable/Disable: Trip function can be enabled or disabled as needed</li> </ul>"},{"location":"wiki/psd_valve_hihi_trip/#how-it-works","title":"How It Works","text":"<ol> <li>Normal Operation: Valve operates fully open, allowing flow to pass through</li> <li>Pressure Monitoring: Linked pressure transmitter continuously evaluates pressure against alarm limits</li> <li>HIHI Alarm: When pressure exceeds highHighLimit, alarm activates after configured delay</li> <li>Automatic Trip: PSD valve detects HIHI alarm and commands closure</li> <li>Fast Closure: Valve closes in configured closure time (typically 2 seconds)</li> <li>Trip Latching: Valve remains closed even if pressure drops - manual reset required</li> <li>Reset &amp; Recovery: Operator resets trip, then manually opens valve</li> </ol>"},{"location":"wiki/psd_valve_hihi_trip/#basic-usage","title":"Basic Usage","text":""},{"location":"wiki/psd_valve_hihi_trip/#1-create-pressure-transmitter-with-alarm-configuration","title":"1. Create Pressure Transmitter with Alarm Configuration","text":"<pre><code>// Create pressure transmitter monitoring separator inlet\nPressureTransmitter PT = new PressureTransmitter(\"PT-101\", separatorInlet);\n\n// Configure HIHI alarm at 55 bara with 1 bara deadband and 0.5 second delay\nAlarmConfig alarmConfig = AlarmConfig.builder()\n    .highHighLimit(55.0)      // HIHI trip point\n    .deadband(1.0)             // Alarm clears at 54 bara\n    .delay(0.5)                // 0.5 second confirmation delay\n    .unit(\"bara\")\n    .build();\n\nPT.setAlarmConfig(alarmConfig);\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#2-create-psd-valve","title":"2. Create PSD Valve","text":"<pre><code>// Create PSD valve on separator inlet\nPSDValve psdValve = new PSDValve(\"PSD-101\", feedStream);\npsdValve.setPercentValveOpening(100.0);  // Start fully open\npsdValve.setCv(150.0);                    // Sizing coefficient\npsdValve.setClosureTime(2.0);            // 2 seconds fast closure\n\n// Link to pressure transmitter\npsdValve.linkToPressureTransmitter(PT);\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#3-run-dynamic-simulation","title":"3. Run Dynamic Simulation","text":"<pre><code>double time = 0.0;\ndouble dt = 1.0; // 1 second time step\n\nwhile (time &lt; simulationTime) {\n    // Update pressure measurement\n    double measuredPressure = psdValve.getOutletStream().getPressure(\"bara\");\n    PT.evaluateAlarm(measuredPressure, dt, time);\n\n    // Run equipment transient calculations\n    psdValve.runTransient(dt, UUID.randomUUID());\n    separator.runTransient(dt, UUID.randomUUID());\n\n    // Check if valve has tripped\n    if (psdValve.hasTripped()) {\n        System.out.println(\"PSD VALVE TRIPPED - Emergency shutdown activated!\");\n        // Implement emergency response...\n    }\n\n    time += dt;\n}\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#4-reset-after-trip","title":"4. Reset After Trip","text":"<pre><code>// After alarm clears and situation is safe\nif (psdValve.hasTripped()) {\n    psdValve.reset();                      // Clear trip state\n    psdValve.setPercentValveOpening(100.0); // Manually reopen valve\n}\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#complete-example","title":"Complete Example","text":"<pre><code>import neqsim.process.equipment.valve.PSDValve;\nimport neqsim.process.equipment.separator.Separator;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.process.alarm.AlarmConfig;\nimport neqsim.process.measurementdevice.PressureTransmitter;\nimport neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\nimport java.util.UUID;\n\npublic class PSDValveExample {\n    public static void main(String[] args) {\n        // Create natural gas mixture at 50 bara, 40\u00b0C\n        SystemInterface fluid = new SystemSrkEos(273.15 + 40, 50.0);\n        fluid.addComponent(\"nitrogen\", 0.5);\n        fluid.addComponent(\"CO2\", 1.0);\n        fluid.addComponent(\"methane\", 85.0);\n        fluid.addComponent(\"ethane\", 8.0);\n        fluid.addComponent(\"propane\", 4.0);\n        fluid.addComponent(\"i-butane\", 0.75);\n        fluid.addComponent(\"n-butane\", 0.75);\n        fluid.setMixingRule(2);\n\n        // Create feed stream\n        Stream feedStream = new Stream(\"Feed\", fluid);\n        feedStream.setFlowRate(5000.0, \"kg/hr\");\n        feedStream.setTemperature(40.0, \"C\");\n        feedStream.setPressure(50.0, \"bara\");\n        feedStream.run();\n\n        // Create PSD valve on separator inlet\n        PSDValve psdValve = new PSDValve(\"PSD-101\", feedStream);\n        psdValve.setPercentValveOpening(100.0);\n        psdValve.setCv(150.0);\n        psdValve.setClosureTime(2.0); // 2 second fast closure\n        psdValve.run();\n\n        // Create pressure transmitter monitoring PSD outlet (separator inlet)\n        PressureTransmitter PT = new PressureTransmitter(\"PT-101\", \n                                                         psdValve.getOutletStream());\n\n        // Configure HIHI alarm\n        AlarmConfig alarmConfig = AlarmConfig.builder()\n            .highHighLimit(55.0)  // PAHH at 55 bara\n            .deadband(1.0)\n            .delay(0.5)\n            .unit(\"bara\")\n            .build();\n        PT.setAlarmConfig(alarmConfig);\n\n        // Link PSD valve to pressure transmitter\n        psdValve.linkToPressureTransmitter(PT);\n\n        // Create separator\n        Separator separator = new Separator(\"Separator\", psdValve.getOutletStream());\n        separator.setInternalDiameter(1.5);\n        separator.setSeparatorLength(4.0);\n        separator.run();\n\n        // Dynamic simulation\n        double time = 0.0;\n        double dt = 1.0;\n\n        System.out.println(\"=== PSD VALVE PROTECTION SYSTEM ===\");\n        System.out.println(\"HIHI setpoint: 55.0 bara\");\n        System.out.println(\"PSD closure time: 2.0 seconds\\n\");\n\n        for (int i = 0; i &lt; 100; i++) {\n            // Run transient calculations\n            psdValve.runTransient(dt, UUID.randomUUID());\n            separator.runTransient(dt, UUID.randomUUID());\n\n            time += dt;\n\n            // Evaluate alarm\n            double pressure = psdValve.getOutletStream().getPressure(\"bara\");\n            PT.evaluateAlarm(pressure, dt, time);\n\n            // Status reporting\n            if (i % 10 == 0 || psdValve.hasTripped()) {\n                String alarmState = \"NONE\";\n                if (PT.getAlarmState().isActive()) {\n                    alarmState = PT.getAlarmState().getActiveLevel().toString();\n                }\n\n                System.out.printf(\"Time: %5.0f s | Pressure: %5.2f bara | \" +\n                                  \"Alarm: %4s | PSD: %5.1f %% | Tripped: %3s%n\",\n                    time, pressure, alarmState,\n                    psdValve.getPercentValveOpening(),\n                    psdValve.hasTripped() ? \"YES\" : \"NO\");\n            }\n\n            if (psdValve.hasTripped()) {\n                System.out.println(\"\\n*** EMERGENCY SHUTDOWN ACTIVATED ***\");\n                break;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#alarm-configuration","title":"Alarm Configuration","text":"<p>The PSD valve relies on NeqSim's alarm system. Key parameters:</p> Parameter Description Typical Value <code>highHighLimit</code> HIHI trip pressure 110% of MAWP <code>highLimit</code> High alarm (warning only) 105% of MAWP <code>deadband</code> Hysteresis to prevent chattering 1-2% of setpoint <code>delay</code> Confirmation time before alarm 0.1-2.0 seconds <code>unit</code> Engineering unit \"bara\", \"barg\", \"psia\""},{"location":"wiki/psd_valve_hihi_trip/#api-reference","title":"API Reference","text":""},{"location":"wiki/psd_valve_hihi_trip/#constructor","title":"Constructor","text":"<pre><code>PSDValve(String name)\nPSDValve(String name, StreamInterface inletStream)\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#configuration-methods","title":"Configuration Methods","text":"<pre><code>void linkToPressureTransmitter(MeasurementDeviceInterface transmitter)\nvoid setClosureTime(double closureTime)  // seconds\nvoid setTripEnabled(boolean enabled)\nvoid setCv(double Cv)  // Valve sizing coefficient\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#status-methods","title":"Status Methods","text":"<pre><code>boolean hasTripped()\nboolean isTripEnabled()\ndouble getClosureTime()\nMeasurementDeviceInterface getPressureTransmitter()\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#control-methods","title":"Control Methods","text":"<pre><code>void reset()  // Clear trip state\nvoid setPercentValveOpening(double opening)  // 0-100%\n@Override\nvoid runTransient(double dt, UUID id)\n</code></pre>"},{"location":"wiki/psd_valve_hihi_trip/#best-practices","title":"Best Practices","text":"<ol> <li>Alarm Setpoint: Set HIHI at safe margin below equipment MAWP (typically 95-98% of MAWP)</li> <li>Closure Time: Balance between fast response and avoiding water hammer (1-5 seconds typical)</li> <li>Deadband: Use 1-2% deadband to prevent alarm chattering at trip point</li> <li>Alarm Delay: Short delay (0.1-0.5s) to confirm trip, avoid nuisance trips</li> <li>Testing: Regularly test PSD functionality in simulation before deployment</li> <li>Documentation: Document trip setpoints in process safety documentation</li> <li>Redundancy: Consider redundant pressure transmitters for critical applications</li> </ol>"},{"location":"wiki/psd_valve_hihi_trip/#comparison-psd-valve-vs-safety-valve","title":"Comparison: PSD Valve vs Safety Valve","text":"Feature PSD Valve Safety Valve Activation HIHI alarm signal Pressure overcomes spring Response Time 1-5 seconds (fast) Milliseconds (immediate) Reopening Manual reset required Automatic reseating Primary Use Isolation/shutdown Pressure relief Flow Direction Stops inlet flow Vents to atmosphere/flare Typical Location Inlet to equipment Top of vessel/equipment Failure Mode Should fail closed Must fail open"},{"location":"wiki/psd_valve_hihi_trip/#integration-with-process-safety","title":"Integration with Process Safety","text":"<p>The PSD valve integrates with NeqSim's process safety features:</p> <ul> <li>ProcessAlarmManager: Coordinates all alarms across equipment</li> <li>AlarmEvent History: Tracks activation, acknowledgment, clearance</li> <li>Safety Interlock Logic: PSD valves can trigger cascade shutdowns</li> <li>Emergency Depressurization: Combine with relief devices for complete protection</li> </ul>"},{"location":"wiki/psd_valve_hihi_trip/#see-also","title":"See Also","text":"<ul> <li>Safety Valve Dynamic Sizing</li> <li>Rupture Disk Behavior</li> <li>Process Control Overview</li> <li>Alarm System Documentation</li> </ul>"},{"location":"wiki/psv_dynamic_sizing_example/","title":"Pressure Safety Valve (PSV) Dynamic Sizing Example","text":""},{"location":"wiki/psv_dynamic_sizing_example/#overview","title":"Overview","text":"<p>This example demonstrates how to perform a dynamic safety calculation for sizing a pressure safety valve (PSV) using NeqSim's transient simulation capabilities. The scenario simulates a blocked outlet condition where a pressure control valve suddenly closes, causing pressure to rise in a separator until the PSV opens to prevent overpressure.</p>"},{"location":"wiki/psv_dynamic_sizing_example/#process-description","title":"Process Description","text":""},{"location":"wiki/psv_dynamic_sizing_example/#equipment-configuration","title":"Equipment Configuration","text":"<ol> <li>Separator: High-pressure separator receiving gas feed at 50 bara</li> <li>Splitter: Splits the gas outlet into two streams</li> <li>Stream 1 (99.9%): Goes to the pressure control valve (PCV) for normal operation</li> <li>Stream 2 (0.1%): Goes to the pressure safety valve (PSV) for overpressure protection</li> <li>Pressure Control Valve (PCV-001): Controls normal outlet pressure (5 bara)</li> <li>Pressure Safety Valve (PSV-001): Protects against overpressure</li> <li>Set pressure: 55 bara</li> <li>Full open pressure: 60.5 bara (110% of set pressure)</li> </ol>"},{"location":"wiki/psv_dynamic_sizing_example/#safety-scenario","title":"Safety Scenario","text":"<p>The simulation models a sudden blocked outlet scenario:</p> <ul> <li>t = 0-50s: Normal operation with PCV at 50% opening</li> <li>t = 50s: PCV suddenly closes to 1% (simulating blocked outlet)</li> <li>t &gt; 50s: </li> <li>Pressure in separator begins to rise</li> <li>PSV opens when pressure exceeds 55 bara</li> <li>PSV modulates to maintain pressure below catastrophic levels</li> </ul>"},{"location":"wiki/psv_dynamic_sizing_example/#implementation","title":"Implementation","text":""},{"location":"wiki/psv_dynamic_sizing_example/#key-code-sections","title":"Key Code Sections","text":""},{"location":"wiki/psv_dynamic_sizing_example/#1-system-setup","title":"1. System Setup","text":"<pre><code>// Create gas system\nSystemInterface feedFluid = new SystemSrkEos(273.15 + 40.0, 50.0);\nfeedFluid.addComponent(\"nitrogen\", 1.0);\nfeedFluid.addComponent(\"methane\", 85.0);\n// ... additional components\n\n// Create separator\nSeparator separator = new Separator(\"HP Separator\", feedStream);\nseparator.setCalculateSteadyState(false); // Enable dynamic mode\n</code></pre>"},{"location":"wiki/psv_dynamic_sizing_example/#2-splitter-configuration","title":"2. Splitter Configuration","text":"<pre><code>// Split gas to PCV and PSV\nSplitter gasSplitter = new Splitter(\"Gas Splitter\", separator.getGasOutStream(), 2);\ngasSplitter.setSplitFactors(new double[] {0.999, 0.001});\ngasSplitter.setCalculateSteadyState(false);\n</code></pre>"},{"location":"wiki/psv_dynamic_sizing_example/#3-psv-automatic-opening","title":"3. PSV Automatic Opening","text":"<p>The <code>SafetyValve</code> class now automatically controls its opening based on inlet pressure during dynamic simulations. When <code>runTransient()</code> is called, the valve:</p> <ul> <li>Closes when pressure is below set pressure</li> <li>Opens proportionally between set pressure and full open pressure  </li> <li>Fully opens at or above full open pressure</li> </ul> <pre><code>// PSV configured with set and full open pressures\nSafetyValve pressureSafetyValve = new SafetyValve(\"PSV-001\", stream);\npressureSafetyValve.setPressureSpec(55.0);  // Set pressure\npressureSafetyValve.setFullOpenPressure(60.5);  // Full open pressure\npressureSafetyValve.setCalculateSteadyState(false);  // Enable dynamic mode\n\n// PSV automatically calculates opening in runTransient()\n// No manual opening calculation needed!\n</code></pre>"},{"location":"wiki/psv_dynamic_sizing_example/#4-transient-simulation-loop","title":"4. Transient Simulation Loop","text":"<pre><code>double dt = 0.5; // Time step in seconds\nfor (int i = 0; i &lt; numSteps; i++) {\n    currentTime = i * dt;\n\n    // Simulate blocked outlet at t=50s\n    if (currentTime &gt;= 50.0 &amp;&amp; currentTime &lt; 51.0) {\n        pressureControlValve.setPercentValveOpening(1.0);\n    }\n\n    // Run transient calculations\n    // PSV automatically adjusts its opening based on inlet pressure\n    separator.runTransient(dt, id);\n    gasSplitter.runTransient(dt, id);\n    pressureControlValve.runTransient(dt, id);\n    pressureSafetyValve.runTransient(dt, id);  // Automatic PSV control\n}\n</code></pre>"},{"location":"wiki/psv_dynamic_sizing_example/#results","title":"Results","text":""},{"location":"wiki/psv_dynamic_sizing_example/#typical-simulation-results","title":"Typical Simulation Results","text":"<ul> <li>Feed flow rate: 5000 kg/hr</li> <li>Normal operating pressure: ~50 bara</li> <li>PSV set pressure: 55 bara</li> <li>PSV full open pressure: 60.5 bara</li> <li>Maximum separator pressure: 58.69 bara (controlled by PSV)</li> <li>Maximum PSV relief flow: 4305 kg/hr (86% of feed rate)</li> <li>Required PSV Cv: 150</li> </ul>"},{"location":"wiki/psv_dynamic_sizing_example/#key-observations","title":"Key Observations","text":"<ol> <li>Pressure Response: When the PCV closes at t=50s, the separator pressure begins to rise steadily</li> <li>PSV Activation: PSV starts opening at ~140s when pressure reaches 55 bara</li> <li>Pressure Control: PSV successfully limits maximum pressure to 58.69 bara (6.7% above set pressure)</li> <li>Flow Distribution: PSV relieves approximately 86% of the feed flow rate at maximum opening</li> </ol>"},{"location":"wiki/psv_dynamic_sizing_example/#psv-sizing-validation","title":"PSV Sizing Validation","text":"<p>The test validates several critical aspects:</p> <ol> <li>\u2713 PSV remains closed during normal operation</li> <li>\u2713 PSV opens at the set pressure</li> <li>\u2713 Maximum pressure stays within acceptable limits (&lt; 130% of full open pressure)</li> <li>\u2713 PSV relief capacity exceeds minimum requirements (&gt; 80% of feed rate)</li> <li>\u2713 Pressure rise occurs after PCV blockage</li> <li>\u2713 Overall pressure limited to within 35% of set pressure</li> </ol>"},{"location":"wiki/psv_dynamic_sizing_example/#usage","title":"Usage","text":""},{"location":"wiki/psv_dynamic_sizing_example/#running-the-example","title":"Running the Example","text":"<p>The example is implemented as a JUnit test:</p> <pre><code>mvnw test -Dtest=SafetyValveDynamicSizingTest\n</code></pre>"},{"location":"wiki/psv_dynamic_sizing_example/#customization","title":"Customization","text":"<p>You can modify the following parameters to study different scenarios:</p> <ul> <li>Feed composition and flow rate: Adjust in <code>SystemInterface</code> setup</li> <li>Separator dimensions: <code>setInternalDiameter()</code>, <code>setSeparatorLength()</code></li> <li>PSV set pressure: <code>setPressureSpec()</code></li> <li>PSV full open pressure: <code>setFullOpenPressure()</code></li> <li>PSV Cv: <code>setCv()</code> - size the valve appropriately</li> <li>Time step: <code>dt</code> variable - smaller for better accuracy</li> <li>Blockage timing: Modify the condition checking <code>currentTime</code></li> </ul>"},{"location":"wiki/psv_dynamic_sizing_example/#best-practices-for-psv-sizing","title":"Best Practices for PSV Sizing","text":"<ol> <li>Set Pressure: Typically 10% above maximum allowable working pressure (MAWP)</li> <li>Accumulation: Full opening at 110% of set pressure (10% accumulation)</li> <li>Relief Capacity: PSV must handle the maximum credible flow rate</li> <li>Dynamic Simulation: Validates PSV response and pressure dynamics</li> <li>Time Step: Use 0.5-1.0 second time steps for valve dynamics</li> <li>Validation: Compare with API 520/521 or equivalent standards</li> </ol>"},{"location":"wiki/psv_dynamic_sizing_example/#related-examples","title":"Related Examples","text":"<ul> <li>Separator Test</li> <li>Throttling Valve Test</li> <li>Process System Transient Test</li> </ul>"},{"location":"wiki/psv_dynamic_sizing_example/#references","title":"References","text":"<ul> <li>API Standard 520: Sizing, Selection, and Installation of Pressure-relieving Devices</li> <li>API Standard 521: Pressure-relieving and Depressuring Systems</li> <li>ASME Boiler and Pressure Vessel Code, Section VIII</li> </ul>"},{"location":"wiki/pump_theory_and_implementation/","title":"Pump Theory and Implementation in NeqSim","text":""},{"location":"wiki/pump_theory_and_implementation/#overview","title":"Overview","text":"<p>NeqSim provides comprehensive centrifugal pump simulation through the <code>Pump</code> and <code>PumpChart</code> classes. The implementation supports:</p> <ul> <li>Manufacturer pump curves with affinity law scaling</li> <li>Head, efficiency, and NPSH curve interpolation</li> <li>Density correction for non-standard fluids</li> <li>Cavitation detection and operating status monitoring</li> <li>Surge and stonewall detection</li> </ul> <p>Also see pump usage guide.</p>"},{"location":"wiki/pump_theory_and_implementation/#theoretical-background","title":"Theoretical Background","text":""},{"location":"wiki/pump_theory_and_implementation/#affinity-laws-similarity-laws","title":"Affinity Laws (Similarity Laws)","text":"<p>The affinity laws relate pump performance at different speeds:</p> Parameter Relationship Flow Q\u2082/Q\u2081 = N\u2082/N\u2081 Head H\u2082/H\u2081 = (N\u2082/N\u2081)\u00b2 Power P\u2082/P\u2081 = (N\u2082/N\u2081)\u00b3 NPSH NPSH\u2082/NPSH\u2081 = (N\u2082/N\u2081)\u00b2"},{"location":"wiki/pump_theory_and_implementation/#hydraulic-power-and-efficiency","title":"Hydraulic Power and Efficiency","text":"<pre><code>P_hydraulic = \u03c1\u00b7g\u00b7Q\u00b7H = Q\u00b7\u0394P\nP_shaft = P_hydraulic / \u03b7\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#net-positive-suction-head-npsh","title":"Net Positive Suction Head (NPSH)","text":"<pre><code>NPSH\u2090 = (P_suction - P_vapor) / (\u03c1\u00b7g) + v\u00b2/(2g)\n</code></pre> <p>Cavitation occurs when NPSH\u2090 &lt; NPSH\u1d63. A safety margin of 1.3\u00d7 is typically required.</p>"},{"location":"wiki/pump_theory_and_implementation/#density-correction","title":"Density Correction","text":"<p>Pump curves measured with water require correction for other fluids:</p> <pre><code>H_actual = H_chart \u00d7 (\u03c1_chart / \u03c1_actual)\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#implementation","title":"Implementation","text":""},{"location":"wiki/pump_theory_and_implementation/#class-structure","title":"Class Structure","text":"<pre><code>Pump (PumpInterface)\n\u251c\u2500\u2500 PumpChart (PumpChartInterface)\n\u2502   \u251c\u2500\u2500 PumpCurve (individual speed curves)\n\u2502   \u2514\u2500\u2500 PumpChartAlternativeMapLookupExtrapolate (alternative implementation)\n\u2514\u2500\u2500 PumpMechanicalDesign\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#key-classes","title":"Key Classes","text":"Class Purpose <code>Pump</code> Main pump equipment model <code>PumpChart</code> Performance curve management <code>PumpChartInterface</code> Interface for pump chart implementations"},{"location":"wiki/pump_theory_and_implementation/#usage-guide","title":"Usage Guide","text":""},{"location":"wiki/pump_theory_and_implementation/#basic-pump-setup","title":"Basic Pump Setup","text":"<pre><code>// Create fluid and stream\nSystemInterface fluid = new SystemSrkEos(298.15, 2.0);\nfluid.addComponent(\"water\", 1.0);\nStream feedStream = new Stream(\"Feed\", fluid);\nfeedStream.run();\n\n// Create pump with outlet pressure\nPump pump = new Pump(\"MainPump\", feedStream);\npump.setOutletPressure(10.0, \"bara\");\npump.setIsentropicEfficiency(0.75);\npump.run();\n\nSystem.out.println(\"Power: \" + pump.getPower(\"kW\") + \" kW\");\nSystem.out.println(\"Outlet T: \" + pump.getOutletTemperature() + \" K\");\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#using-pump-curves","title":"Using Pump Curves","text":"<pre><code>// Define pump curves at multiple speeds\ndouble[] speed = {1000.0, 1500.0};\ndouble[][] flow = {\n    {10, 20, 30, 40, 50},      // m\u00b3/hr at 1000 rpm\n    {15, 30, 45, 60, 75}       // m\u00b3/hr at 1500 rpm\n};\ndouble[][] head = {\n    {120, 115, 108, 98, 85},   // meters at 1000 rpm\n    {270, 259, 243, 220, 191}  // meters at 1500 rpm\n};\ndouble[][] efficiency = {\n    {65, 75, 82, 80, 72},      // % at 1000 rpm\n    {67, 77, 84, 82, 74}       // % at 1500 rpm\n};\n\n// chartConditions: [refMW, refTemp, refPressure, refZ, refDensity]\ndouble[] chartConditions = {18.0, 298.15, 1.0, 1.0, 998.0};\n\nPump pump = new Pump(\"ChartPump\", feedStream);\npump.getPumpChart().setCurves(chartConditions, speed, flow, head, efficiency);\npump.getPumpChart().setHeadUnit(\"meter\");\npump.setSpeed(1200.0);\npump.run();\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#density-correction_1","title":"Density Correction","text":"<p>When pumping fluids with different density than the chart test fluid:</p> <pre><code>// Option 1: Set via chartConditions (5th element)\ndouble[] chartConditions = {18.0, 298.15, 1.0, 1.0, 998.0}; // 998 kg/m\u00b3 reference\npump.getPumpChart().setCurves(chartConditions, speed, flow, head, efficiency);\n\n// Option 2: Set directly\npump.getPumpChart().setReferenceDensity(998.0);\n\n// Check if correction is active\nif (pump.getPumpChart().hasDensityCorrection()) {\n    double correctedHead = pump.getPumpChart().getCorrectedHead(flow, speed, actualDensity);\n}\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#npsh-monitoring","title":"NPSH Monitoring","text":"<pre><code>// Enable NPSH checking\npump.setCheckNPSH(true);\npump.setNPSHMargin(1.3);  // Safety factor\n\n// Check cavitation risk\ndouble npshAvailable = pump.getNPSHAvailable();\ndouble npshRequired = pump.getNPSHRequired();\nboolean cavitating = pump.isCavitating();\n\n// Set NPSH curve from manufacturer data\ndouble[][] npshCurve = {\n    {2.0, 2.5, 3.2, 4.0, 5.2},  // NPSHr at 1000 rpm\n    {4.5, 5.6, 7.2, 9.0, 11.7}  // NPSHr at 1500 rpm\n};\npump.getPumpChart().setNPSHCurve(npshCurve);\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#operating-status-monitoring","title":"Operating Status Monitoring","text":"<pre><code>// Check operating status\nString status = pump.getPumpChart().getOperatingStatus(flowRate, speed);\n// Returns: \"OPTIMAL\", \"NORMAL\", \"LOW_EFFICIENCY\", \"SURGE\", or \"STONEWALL\"\n\n// Check specific conditions\nboolean surging = pump.getPumpChart().checkSurge2(flowRate, speed);\nboolean stonewall = pump.getPumpChart().checkStoneWall(flowRate, speed);\n\n// Get best efficiency point\ndouble bepFlow = pump.getPumpChart().getBestEfficiencyFlowRate();\ndouble specificSpeed = pump.getPumpChart().getSpecificSpeed();\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#complete-example-pump-with-suction-system-python","title":"Complete Example: Pump with Suction System (Python)","text":"<p>This example demonstrates a realistic pump system with: - Feed from an upstream separator - Control valve at separator outlet - Suction pipeline with elevation (static head) - Pump with manufacturer curves and NPSH monitoring</p> <pre><code>import neqsim\n\n# Get feed stream from upstream process (e.g., oil from separator)\npump_feed = oseberg_process.get('main process').getUnit('3RD stage separator').getOilOutStream()\n\n# === Separator Outlet Control Valve ===\n# Controls flow from separator to pump suction\nseparatorValve = neqsim.process.equipment.valve.ThrottlingValve(\"SeparatorOutletValve\", pump_feed)\nseparatorValve.setCv(200)                   # Valve Cv (flow coefficient in US gpm/psi^0.5)\nseparatorValve.setPercentValveOpening(80)   # 80% open - allows for control margin\nseparatorValve.setIsCalcOutPressure(True)   # Calculate outlet pressure from Cv\nseparatorValve.run()\n\n# === Suction Pipeline ===\n# Models pressure drop and elevation effects on NPSH\nsuctionLine = neqsim.process.equipment.pipeline.PipeBeggsAndBrills(\"SuctionLine\", separatorValve.getOutletStream())\nsuctionLine.setLength(20.0)              # Pipe length in meters\nsuctionLine.setDiameter(0.2)             # Pipe inner diameter in meters\nsuctionLine.setPipeWallRoughness(1.0e-5) # Internal roughness in meters\nsuctionLine.setElevation(-20)            # Negative = pump is 20m below separator (adds static head)\nsuctionLine.run()\n\n# === Centrifugal Pump ===\npump1 = neqsim.process.equipment.pump.Pump('oil pump', suctionLine.getOutStream())\npump1.setOutletPressure(60.0, 'bara')    # Target discharge pressure\n\n# Enable NPSH monitoring with 1.3x safety margin\npump1.setCheckNPSH(True)\npump1.setNPSHMargin(1.3)\n\n# Define manufacturer pump curves (single speed)\nspeed = [3259]                           # rpm\nflow = [[1, 50, 70, 130]]               # m\u00b3/hr\nhead = [[250, 240, 230, 180]]           # meters\neff = [[5, 40, 50, 52]]                 # efficiency %\n\n# NPSHr curve (meters) - must match flow array dimensions\nnpsh = [[2.0, 4.3, 6.0, 8.0]]\n\n# Configure pump chart\npump1.getPumpChart().setCurves([], speed, flow, head, eff)\npump1.getPumpChart().setNPSHCurve(npsh)\npump1.getPumpChart().setHeadUnit(\"meter\")\npump1.setSpeed(3259)\n\npump1.run()\n\n# === Results ===\nprint(\"=== Pump &amp; Suction Line Results ===\")\nprint(f\"Flow rate (m3/hr): {pump_feed.getFlowRate('idSm3/hr'):.2f}\")\nprint(f\"Separator outlet pressure (bara): {pump_feed.getPressure('bara'):.2f}\")\nprint(f\"Pump inlet pressure (bara): {pump1.getInletPressure():.2f}\")\nprint(f\"Pump outlet pressure (bara): {pump1.getOutletPressure():.2f}\")\nprint(f\"Pump head (m): {pump1.getPumpChart().getHead(pump_feed.getFlowRate('m3/hr'), 3259):.1f}\")\nprint(f\"Pump efficiency (%): {pump1.getPumpChart().getEfficiency(pump_feed.getFlowRate('m3/hr'), 3259):.1f}\")\nprint(f\"Pump NPSHa (meter): {pump1.getNPSHAvailable():.2f}\")\nprint(f\"Pump NPSHr (meter): {pump1.getNPSHRequired():.2f}\")\nprint(f\"Pump power (kW): {pump1.getPower('kW'):.1f}\")\nprint(f\"Cavitation risk: {'YES - INCREASE SUCTION PRESSURE' if pump1.isCavitating() else 'NO'}\")\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#key-points","title":"Key Points","text":"<ol> <li> <p>Suction System Design: The suction line elevation affects NPSH\u2090. Negative elevation (pump below source) adds static head, improving NPSH margin.</p> </li> <li> <p>Control Valve Sizing: The Cv value determines pressure drop at the given flow. Use <code>setIsCalcOutPressure(True)</code> to calculate outlet pressure from Cv.</p> </li> <li> <p>NPSH Monitoring: Enable with <code>setCheckNPSH(True)</code>. The pump calculates:</p> </li> <li>NPSH\u2090 from suction conditions (pressure, temperature, vapor pressure)</li> <li>NPSH\u1d63 from the manufacturer curve (interpolated at operating flow)</li> <li> <p>Warns if NPSH\u2090 &lt; margin \u00d7 NPSH\u1d63</p> </li> <li> <p>Pump Curves: The <code>setCurves()</code> method accepts:</p> </li> <li>Empty array <code>[]</code> for chartConditions (or include reference density as 5<sup>th</sup> element)</li> <li>Speed array (can be single or multiple speeds)</li> <li> <p>2D arrays for flow, head, efficiency (one row per speed)</p> </li> <li> <p>NPSH Curve: Must be set separately via <code>setNPSHCurve()</code> with same dimensions as flow array.</p> </li> </ol>"},{"location":"wiki/pump_theory_and_implementation/#api-reference","title":"API Reference","text":""},{"location":"wiki/pump_theory_and_implementation/#pump-class","title":"Pump Class","text":""},{"location":"wiki/pump_theory_and_implementation/#key-methods","title":"Key Methods","text":"Method Description <code>setOutletPressure(double, String)</code> Set target outlet pressure <code>setIsentropicEfficiency(double)</code> Set pump efficiency (0-1) <code>setSpeed(double)</code> Set pump speed in rpm <code>getPower()</code> Get shaft power in watts <code>getPower(String)</code> Get power in specified unit <code>getNPSHAvailable()</code> Calculate available NPSH in meters <code>getNPSHRequired()</code> Get required NPSH from chart or estimate <code>isCavitating()</code> Check if pump is at cavitation risk <code>setCheckNPSH(boolean)</code> Enable/disable NPSH monitoring <code>getPumpChart()</code> Get the pump chart object"},{"location":"wiki/pump_theory_and_implementation/#pumpchart-class","title":"PumpChart Class","text":""},{"location":"wiki/pump_theory_and_implementation/#curve-setup-methods","title":"Curve Setup Methods","text":"Method Description <code>setCurves(double[], double[], double[][], double[][], double[][])</code> Set complete pump curves <code>setHeadUnit(String)</code> Set head unit: \"meter\" or \"kJ/kg\" <code>setNPSHCurve(double[][])</code> Set NPSH required curves <code>setReferenceDensity(double)</code> Set reference density for correction"},{"location":"wiki/pump_theory_and_implementation/#performance-query-methods","title":"Performance Query Methods","text":"Method Description <code>getHead(double, double)</code> Get head at flow and speed <code>getCorrectedHead(double, double, double)</code> Get density-corrected head <code>getEfficiency(double, double)</code> Get efficiency at flow and speed <code>getNPSHRequired(double, double)</code> Get NPSH required at flow and speed <code>getSpeed(double, double)</code> Calculate speed for given flow and head"},{"location":"wiki/pump_theory_and_implementation/#monitoring-methods","title":"Monitoring Methods","text":"Method Description <code>getOperatingStatus(double, double)</code> Get operating status string <code>checkSurge2(double, double)</code> Check if in surge condition <code>checkStoneWall(double, double)</code> Check if at stonewall <code>getBestEfficiencyFlowRate()</code> Get flow at BEP <code>getSpecificSpeed()</code> Calculate pump specific speed <code>hasDensityCorrection()</code> Check if density correction is active <code>hasNPSHCurve()</code> Check if NPSH curve is available"},{"location":"wiki/pump_theory_and_implementation/#chart-conditions-array","title":"Chart Conditions Array","text":"<p>The <code>chartConditions</code> array passed to <code>setCurves()</code> contains reference conditions:</p> Index Parameter Unit Description 0 refMW kg/kmol Reference molecular weight 1 refTemperature K Reference temperature 2 refPressure bara Reference pressure 3 refZ - Reference compressibility 4 refDensity kg/m\u00b3 Reference fluid density (optional) <p>Note: Element [4] is optional for backward compatibility. If omitted, no density correction is applied.</p>"},{"location":"wiki/pump_theory_and_implementation/#viscosity-correction-heavy-oil-viscous-fluids","title":"Viscosity Correction (Heavy Oil / Viscous Fluids)","text":"<p>Pump performance is significantly affected by fluid viscosity. Curves measured with water or light oil require correction when pumping viscous fluids like heavy crude oil.</p>"},{"location":"wiki/pump_theory_and_implementation/#hydraulic-institute-hi-method","title":"Hydraulic Institute (HI) Method","text":"<p>NeqSim implements the Hydraulic Institute viscosity correction method for centrifugal pumps. The correction uses the B parameter:</p> <pre><code>B = 26.6 \u00d7 \u03bd^0.5 \u00d7 H^0.0625 / (Q^0.375 \u00d7 N^0.25)\n</code></pre> <p>Where: - \u03bd = kinematic viscosity (cSt) - H = head at BEP (meters) - Q = flow at BEP (m\u00b3/hr) - N = speed (rpm)</p>"},{"location":"wiki/pump_theory_and_implementation/#correction-factors","title":"Correction Factors","text":"Parameter Factor Description Flow Cq Q_viscous = Q_water \u00d7 Cq Head Ch H_viscous = H_water \u00d7 Ch Efficiency C\u03b7 \u03b7_viscous = \u03b7_water \u00d7 C\u03b7 <p>Valid range: 4 - 4000 cSt (below 4 cSt, water properties assumed)</p>"},{"location":"wiki/pump_theory_and_implementation/#usage-example-java","title":"Usage Example (Java)","text":"<pre><code>// Create pump with chart\nPump pump = new Pump(\"ViscousPump\", feedStream);\npump.getPumpChart().setCurves(chartConditions, speed, flow, head, efficiency);\n\n// Enable viscosity correction\npump.getPumpChart().setReferenceViscosity(1.0);       // Chart measured with water (1 cSt)\npump.getPumpChart().setUseViscosityCorrection(true);  // Enable correction\n\n// Set pump parameters\npump.getPumpChart().setReferenceFlow(100.0);          // BEP flow (m\u00b3/hr)\npump.getPumpChart().setReferenceHead(100.0);          // BEP head (meters)\npump.getPumpChart().setReferenceSpeed(1500.0);        // Reference speed (rpm)\n\npump.run();\n\n// Check applied corrections\nSystem.out.println(\"Flow correction factor Cq: \" + pump.getPumpChart().getFlowCorrectionFactor());\nSystem.out.println(\"Head correction factor Ch: \" + pump.getPumpChart().getHeadCorrectionFactor());\nSystem.out.println(\"Efficiency correction C\u03b7: \" + pump.getPumpChart().getEfficiencyCorrectionFactor());\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#usage-example-python","title":"Usage Example (Python)","text":"<pre><code>import neqsim\nfrom neqsim.process import stream, pump\n\n# Create stream with viscous oil\noil = neqsim.thermo.system.SystemSrkEos(323.15, 5.0)\noil.addComponent(\"nC20\", 1.0)  # Heavy hydrocarbon\noil.setMixingRule(\"classic\")\n\nfeed = stream.stream(\"ViscousOilFeed\", oil)\nfeed.setFlowRate(100.0, \"kg/hr\")\nfeed.run()\n\n# Create pump with viscosity correction\nviscous_pump = pump.pump(\"OilBooster\", feed)\nviscous_pump.getPumpChart().setReferenceViscosity(1.0)\nviscous_pump.getPumpChart().setUseViscosityCorrection(True)\nviscous_pump.setOutletPressure(10.0, \"bara\")\nviscous_pump.run()\n\nprint(f\"Actual viscosity: {feed.getFluid().getKinematicViscosity('cSt'):.1f} cSt\")\nprint(f\"Head correction: {viscous_pump.getPumpChart().getHeadCorrectionFactor():.3f}\")\nprint(f\"Efficiency correction: {viscous_pump.getPumpChart().getEfficiencyCorrectionFactor():.3f}\")\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#esp-pump-electric-submersible-pump","title":"ESP Pump (Electric Submersible Pump)","text":"<p>The <code>ESPPump</code> class extends <code>Pump</code> for handling multiphase gas-liquid flows commonly encountered in oil well production.</p>"},{"location":"wiki/pump_theory_and_implementation/#key-features","title":"Key Features","text":"<ul> <li>Multi-stage impeller design</li> <li>Gas Void Fraction (GVF) calculation at pump inlet</li> <li>Head degradation model for gassy conditions</li> <li>Gas separator modeling</li> <li>Surge and gas lock detection</li> </ul>"},{"location":"wiki/pump_theory_and_implementation/#gvf-degradation-model","title":"GVF Degradation Model","text":"<p>Head degradation follows a quadratic relationship:</p> <pre><code>f = 1 - A \u00d7 GVF - B \u00d7 GVF\u00b2\n</code></pre> <p>Where default coefficients are: A = 0.5, B = 2.0</p>"},{"location":"wiki/pump_theory_and_implementation/#operating-limits","title":"Operating Limits","text":"Condition Default Threshold Description Surging GVF &gt; 15% Unstable operation begins Gas Lock GVF &gt; 30% Pump loses prime, flow stops"},{"location":"wiki/pump_theory_and_implementation/#usage-example-java_1","title":"Usage Example (Java)","text":"<pre><code>// Create multiphase stream (gas + liquid)\nSystemInterface fluid = new SystemSrkEos(323.15, 30.0);\nfluid.addComponent(\"methane\", 0.05);     // 5% gas\nfluid.addComponent(\"n-heptane\", 0.95);   // 95% liquid\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\nStream wellStream = new Stream(\"WellProduction\", fluid);\nwellStream.setFlowRate(1000.0, \"kg/hr\");\nwellStream.run();\n\n// Create ESP pump\nESPPump esp = new ESPPump(\"ESP-1\", wellStream);\nesp.setNumberOfStages(100);           // 100-stage pump\nesp.setHeadPerStage(10.0);            // 10 m head per stage\n\n// Configure GVF handling\nesp.setMaxGVF(0.30);                  // 30% max GVF before gas lock\nesp.setSurgingGVF(0.15);              // 15% - surging onset\nesp.setHasGasSeparator(true);         // Include rotary gas separator\nesp.setGasSeparatorEfficiency(0.60);  // 60% gas separation\n\nesp.run();\n\n// Check operating status\nSystem.out.println(\"GVF at inlet: \" + (esp.getGasVoidFraction() * 100) + \"%\");\nSystem.out.println(\"Head degradation: \" + (1 - esp.getHeadDegradationFactor()) * 100 + \"% loss\");\nSystem.out.println(\"Surging: \" + esp.isSurging());\nSystem.out.println(\"Gas locked: \" + esp.isGasLocked());\nSystem.out.println(\"Pressure boost: \" + (esp.getOutletPressure() - esp.getInletPressure()) + \" bara\");\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#usage-example-python_1","title":"Usage Example (Python)","text":"<pre><code>import neqsim\nfrom neqsim.thermo.system import SystemSrkEos\nfrom neqsim.process.equipment.pump import ESPPump\n\n# Create multiphase well fluid\nwell_fluid = SystemSrkEos(353.15, 25.0)\nwell_fluid.addComponent(\"methane\", 0.08)\nwell_fluid.addComponent(\"n-heptane\", 0.92)\nwell_fluid.setMixingRule(\"classic\")\nwell_fluid.setMultiPhaseCheck(True)\n\nwell_stream = neqsim.process.stream.stream(\"WellStream\", well_fluid)\nwell_stream.setFlowRate(2000.0, \"kg/hr\")\nwell_stream.run()\n\n# Create and configure ESP\nesp = ESPPump(\"ESP-1\", well_stream)\nesp.setNumberOfStages(80)\nesp.setHeadPerStage(12.0)\nesp.setMaxGVF(0.25)\nesp.setHasGasSeparator(True)\nesp.setGasSeparatorEfficiency(0.70)\nesp.run()\n\n# Monitor performance\nprint(f\"Inlet GVF: {esp.getGasVoidFraction()*100:.1f}%\")\nprint(f\"Head degradation factor: {esp.getHeadDegradationFactor():.3f}\")\nprint(f\"Effective head: {esp.calculateTotalHead():.1f} m\")\nprint(f\"Is surging: {esp.isSurging()}\")\n</code></pre>"},{"location":"wiki/pump_theory_and_implementation/#esppump-api-reference","title":"ESPPump API Reference","text":"Method Description <code>setNumberOfStages(int)</code> Set number of impeller stages <code>setHeadPerStage(double)</code> Set head per stage (meters) <code>setMaxGVF(double)</code> Set gas lock threshold (0-1) <code>setSurgingGVF(double)</code> Set surging onset threshold (0-1) <code>setHasGasSeparator(boolean)</code> Enable rotary gas separator <code>setGasSeparatorEfficiency(double)</code> Set separator efficiency (0-1) <code>getGasVoidFraction()</code> Get calculated inlet GVF <code>getHeadDegradationFactor()</code> Get head degradation (0-1) <code>isSurging()</code> Check if pump is surging <code>isGasLocked()</code> Check if pump has lost prime <code>calculateTotalHead()</code> Get total developed head"},{"location":"wiki/pump_theory_and_implementation/#head-unit-options","title":"Head Unit Options","text":"Unit Description Pressure Calculation <code>\"meter\"</code> Meters of fluid \u0394P = \u03c1\u00b7g\u00b7H <code>\"kJ/kg\"</code> Specific energy \u0394P = E\u00b7\u03c1\u00b71000"},{"location":"wiki/pump_theory_and_implementation/#test-coverage","title":"Test Coverage","text":"<p>The pump implementation includes comprehensive tests:</p> Test Class Tests Coverage <code>PumpTest</code> 3 Basic pump operations <code>PumpChartTest</code> 3 Curve interpolation <code>PumpAffinityLawTest</code> 6 Affinity law scaling <code>PumpNPSHTest</code> 8 Cavitation detection <code>PumpNPSHCurveTest</code> 12 NPSH curve handling <code>PumpDensityCorrectionTest</code> 7 Density correction <code>PumpViscosityCorrectionTest</code> 12 HI viscosity correction method <code>ESPPumpTest</code> 12 ESP multiphase handling <p>Total: 63 tests</p>"},{"location":"wiki/pump_theory_and_implementation/#references","title":"References","text":"<ol> <li>Centrifugal Pumps, I.J. Karassik et al., McGraw-Hill</li> <li>Pump Handbook, Igor J. Karassik, McGraw-Hill</li> <li>API 610 - Centrifugal Pumps for Petroleum, Petrochemical and Natural Gas Industries</li> <li>ISO 9906 - Rotodynamic pumps - Hydraulic performance acceptance tests</li> </ol>"},{"location":"wiki/pump_usage_guide/","title":"Pump Usage Guide - Quick Reference","text":""},{"location":"wiki/pump_usage_guide/#basic-pump-setup","title":"Basic Pump Setup","text":""},{"location":"wiki/pump_usage_guide/#simple-pump-specified-pressure","title":"Simple Pump (Specified Pressure)","text":"<pre><code>SystemInterface fluid = new SystemSrkEos(298.15, 1.0);\nfluid.addComponent(\"water\", 1.0);\nfluid.setTotalFlowRate(100.0, \"m3/hr\");\n\nStream feed = new Stream(\"Feed\", fluid);\nfeed.setTemperature(20.0, \"C\");\nfeed.setPressure(1.0, \"bara\");\n\nPump pump = new Pump(\"Pump1\", feed);\npump.setOutletPressure(10.0, \"bara\");\npump.setIsentropicEfficiency(0.75); // 75% efficiency\npump.run();\n\ndouble power = pump.getPower(\"kW\");\ndouble outletTemp = pump.getOutletStream().getTemperature(\"C\");\n</code></pre>"},{"location":"wiki/pump_usage_guide/#using-pump-curves","title":"Using Pump Curves","text":""},{"location":"wiki/pump_usage_guide/#setting-up-pump-curves","title":"Setting Up Pump Curves","text":"<pre><code>// Define pump performance at different speeds\ndouble[] speed = new double[] {1000.0, 1500.0, 2000.0};\n\n// Flow rates in m\u00b3/hr for each speed\ndouble[][] flow = new double[][] {\n    {10.0, 20.0, 30.0, 40.0, 50.0, 60.0},\n    {15.0, 30.0, 45.0, 60.0, 75.0, 90.0},\n    {20.0, 40.0, 60.0, 80.0, 100.0, 120.0}\n};\n\n// Head in meters for each speed and flow\ndouble[][] head = new double[][] {\n    {120.0, 118.0, 115.0, 110.0, 103.0, 94.0},\n    {270.0, 265.5, 258.8, 247.5, 231.8, 211.5},\n    {480.0, 472.0, 460.0, 440.0, 412.0, 376.0}\n};\n\n// Efficiency in % for each speed and flow\ndouble[][] efficiency = new double[][] {\n    {65.0, 72.0, 78.0, 82.0, 80.0, 74.0},\n    {66.0, 73.0, 79.0, 83.0, 81.0, 75.0},\n    {67.0, 74.0, 80.0, 84.0, 82.0, 76.0}\n};\n\npump.getPumpChart().setCurves(new double[]{}, speed, flow, head, efficiency);\npump.getPumpChart().setHeadUnit(\"meter\"); // or \"kJ/kg\"\npump.setSpeed(1500.0); // Set operating speed in rpm\n</code></pre>"},{"location":"wiki/pump_usage_guide/#head-units","title":"Head Units","text":"<p>Meters (most common): <pre><code>pump.getPumpChart().setHeadUnit(\"meter\");\n// Head represents height of fluid column\n// \u0394P = \u03c1 \u00d7 g \u00d7 H\n</code></pre></p> <p>Specific Energy (kJ/kg): <pre><code>pump.getPumpChart().setHeadUnit(\"kJ/kg\");\n// Head represents specific energy\n// \u0394P = E \u00d7 \u03c1\n</code></pre></p>"},{"location":"wiki/pump_usage_guide/#npsh-monitoring","title":"NPSH Monitoring","text":""},{"location":"wiki/pump_usage_guide/#enable-cavitation-detection","title":"Enable Cavitation Detection","text":"<pre><code>pump.setCheckNPSH(true);\npump.setNPSHMargin(1.3); // Recommended: 1.1-1.5\n\npump.run();\n\n// Check for cavitation risk\nif (pump.isCavitating()) {\n    double npsha = pump.getNPSHAvailable();\n    double npshr = pump.getNPSHRequired();\n    System.out.println(\"Warning: NPSHa = \" + npsha + \" m, NPSHr = \" + npshr + \" m\");\n    // Take corrective action: increase suction pressure or decrease temperature\n}\n</code></pre>"},{"location":"wiki/pump_usage_guide/#manual-npsh-check","title":"Manual NPSH Check","text":"<pre><code>double npsha = pump.getNPSHAvailable();\ndouble npshr = pump.getNPSHRequired();\n\nif (npsha &lt; 1.3 * npshr) {\n    // Insufficient NPSH - risk of cavitation\n    // Solutions:\n    // 1. Increase suction pressure\n    // 2. Decrease fluid temperature\n    // 3. Reduce pump speed\n    // 4. Select different pump\n}\n</code></pre>"},{"location":"wiki/pump_usage_guide/#operating-status-monitoring","title":"Operating Status Monitoring","text":""},{"location":"wiki/pump_usage_guide/#check-pump-operating-region","title":"Check Pump Operating Region","text":"<pre><code>double flow = feed.getFlowRate(\"m3/hr\");\ndouble speed = pump.getSpeed();\n\nString status = pump.getPumpChart().getOperatingStatus(flow, speed);\n\nswitch (status) {\n    case \"OPTIMAL\":\n        // Operating near best efficiency point\n        break;\n    case \"NORMAL\":\n        // Operating within acceptable range\n        break;\n    case \"LOW_EFFICIENCY\":\n        // Operating far from BEP - inefficient\n        // Consider adjusting speed or selecting different pump\n        break;\n    case \"SURGE\":\n        // Flow too low - risk of instability and damage\n        // Increase flow or reduce speed immediately\n        break;\n    case \"STONEWALL\":\n        // Flow too high - maximum capacity reached\n        // Reduce flow or increase speed\n        break;\n}\n</code></pre>"},{"location":"wiki/pump_usage_guide/#find-best-efficiency-point","title":"Find Best Efficiency Point","text":"<pre><code>double bepFlow = pump.getPumpChart().getBestEfficiencyFlowRate();\ndouble bepHead = pump.getPumpChart().getHead(bepFlow, speed);\ndouble bepEfficiency = pump.getPumpChart().getEfficiency(bepFlow, speed);\n\nSystem.out.println(\"Best efficiency: \" + bepEfficiency + \"% at \" + bepFlow + \" m\u00b3/hr\");\n</code></pre>"},{"location":"wiki/pump_usage_guide/#pump-selection-and-sizing","title":"Pump Selection and Sizing","text":""},{"location":"wiki/pump_usage_guide/#calculate-specific-speed","title":"Calculate Specific Speed","text":"<pre><code>double ns = pump.getPumpChart().getSpecificSpeed();\n\nif (ns &lt; 1000) {\n    System.out.println(\"Radial flow (centrifugal) pump\");\n} else if (ns &lt; 4000) {\n    System.out.println(\"Mixed flow pump\");\n} else {\n    System.out.println(\"Axial flow pump\");\n}\n</code></pre>"},{"location":"wiki/pump_usage_guide/#variable-speed-operation","title":"Variable Speed Operation","text":"<pre><code>// Affinity laws: Q \u221d N, H \u221d N\u00b2, P \u221d N\u00b3\n\ndouble baseSpeed = 1500.0;\ndouble baseFlow = 50.0; // m\u00b3/hr\ndouble baseHead = pump.getPumpChart().getHead(baseFlow, baseSpeed);\n\n// To increase head by 44% (factor of 1.44 = 1.2\u00b2):\ndouble newSpeed = baseSpeed * 1.2;\ndouble newFlow = baseFlow * 1.2;\ndouble newHead = baseHead * 1.44;\n\npump.setSpeed(newSpeed);\n// Efficiency stays approximately constant at same reduced flow\n</code></pre>"},{"location":"wiki/pump_usage_guide/#common-patterns","title":"Common Patterns","text":""},{"location":"wiki/pump_usage_guide/#pump-with-minimum-flow-protection","title":"Pump with Minimum Flow Protection","text":"<pre><code>pump.setMinimumFlow(0.05); // kg/sec\n\n// When flow drops below minimum, pump idles with no pressure rise\n// In practice, add minimum flow recirculation loop\n</code></pre>"},{"location":"wiki/pump_usage_guide/#multi-stage-pump-system","title":"Multi-stage Pump System","text":"<pre><code>Stream stage1Out = new Stream(\"Stage 1 Out\");\nPump stage1 = new Pump(\"Stage 1\", feed);\nstage1.setOutletPressure(5.0, \"bara\");\nstage1.setOutStream(stage1Out);\n\nPump stage2 = new Pump(\"Stage 2\", stage1Out);\nstage2.setOutletPressure(10.0, \"bara\");\n\n// Total head = stage1 head + stage2 head\n</code></pre>"},{"location":"wiki/pump_usage_guide/#pump-with-different-chart-type","title":"Pump with Different Chart Type","text":"<pre><code>// Default: Simple fan law interpolation\npump.setPumpChartType(\"fan law\");\n\n// Alternative: Map lookup with extrapolation\npump.setPumpChartType(\"interpolate and extrapolate\");\n</code></pre>"},{"location":"wiki/pump_usage_guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"wiki/pump_usage_guide/#low-outlet-pressure","title":"Low Outlet Pressure","text":"<ol> <li>Check pump curve covers operating flow rate</li> <li>Verify speed setting matches curve</li> <li>Check for cavitation (low NPSH)</li> <li>Verify head unit setting (\"meter\" vs \"kJ/kg\")</li> </ol>"},{"location":"wiki/pump_usage_guide/#high-power-consumption","title":"High Power Consumption","text":"<ol> <li>Operating far from BEP - reduce or increase flow</li> <li>Check efficiency curve - may need different pump</li> <li>Verify outlet pressure requirement is reasonable</li> </ol>"},{"location":"wiki/pump_usage_guide/#cavitation-warnings","title":"Cavitation Warnings","text":"<ol> <li>Increase suction pressure</li> <li>Reduce fluid temperature</li> <li>Reduce pump speed</li> <li>Check for air entrainment</li> <li>Verify NPSH_r curve is accurate</li> </ol>"},{"location":"wiki/pump_usage_guide/#surgeinstability","title":"Surge/Instability","text":"<ol> <li>Increase minimum flow setpoint</li> <li>Add recirculation line from discharge to suction</li> <li>Reduce speed if possible</li> <li>Check for blockage downstream</li> </ol>"},{"location":"wiki/pump_usage_guide/#performance-calculations","title":"Performance Calculations","text":""},{"location":"wiki/pump_usage_guide/#hydraulic-power","title":"Hydraulic Power","text":"<pre><code>double rho = feed.getThermoSystem().getDensity(\"kg/m3\");\ndouble Q = feed.getFlowRate(\"m3/s\");\ndouble H = pump.getPumpChart().getHead(feed.getFlowRate(\"m3/hr\"), pump.getSpeed());\ndouble g = 9.81; // m/s\u00b2\n\ndouble hydraulicPower = rho * g * Q * H; // Watts\n</code></pre>"},{"location":"wiki/pump_usage_guide/#shaft-power-with-losses","title":"Shaft Power (with losses)","text":"<pre><code>double efficiency = pump.getIsentropicEfficiency() / 100.0; // Convert % to decimal\ndouble shaftPower = hydraulicPower / efficiency;\n</code></pre>"},{"location":"wiki/pump_usage_guide/#energy-cost-estimate","title":"Energy Cost Estimate","text":"<pre><code>double powerKW = pump.getPower(\"kW\");\ndouble hoursPerYear = 8760;\ndouble costPerKWh = 0.10; // $/kWh\n\ndouble annualEnergyCost = powerKW * hoursPerYear * costPerKWh;\nSystem.out.println(\"Annual energy cost: $\" + annualEnergyCost);\n</code></pre>"},{"location":"wiki/pump_usage_guide/#best-practices","title":"Best Practices","text":"<ol> <li>Always set pump curves when available - more accurate than fixed efficiency</li> <li>Enable NPSH checking for all liquid pumps</li> <li>Monitor operating status to avoid damage and inefficiency</li> <li>Operate near BEP (\u00b120% flow) when possible</li> <li>Use correct head units - \"meter\" for liquid pumps</li> <li>Set realistic efficiency - typical centrifugal pumps: 70-85%</li> <li>Consider minimum flow - typically 10-20% of BEP flow</li> <li>Document curve source - manufacturer data sheets</li> <li>Validate with measurements - adjust curves if needed</li> <li>Check affinity laws - verify speed changes follow theory</li> </ol>"},{"location":"wiki/pump_usage_guide/#example-complete-pump-system","title":"Example: Complete Pump System","text":"<pre><code>// Create fluid system\nSystemInterface water = new SystemSrkEos(298.15, 1.5);\nwater.addComponent(\"water\", 1.0);\nwater.setTemperature(25.0, \"C\");\nwater.setPressure(1.5, \"bara\");\nwater.setTotalFlowRate(75.0, \"m3/hr\");\n\nStream feed = new Stream(\"Pump Feed\", water);\nfeed.run();\n\n// Create pump with curve\nPump pump = new Pump(\"Booster Pump\", feed);\n\ndouble[] speed = new double[] {1450.0};\ndouble[] flowPoints = {30, 50, 70, 90, 110, 130};\ndouble[] headPoints = {45, 44, 42, 38, 32, 24};\ndouble[] effPoints = {68, 76, 82, 84, 80, 70};\ndouble[][] flow = new double[][] {flowPoints};\ndouble[][] head = new double[][] {headPoints};\ndouble[][] eff = new double[][] {effPoints};\n\npump.getPumpChart().setCurves(new double[]{}, speed, flow, head, eff);\npump.getPumpChart().setHeadUnit(\"meter\");\npump.setSpeed(1450.0);\npump.setCheckNPSH(true);\npump.setNPSHMargin(1.3);\n\n// Run simulation\npump.run();\n\n// Check results\nSystem.out.println(\"Outlet pressure: \" + pump.getOutletPressure() + \" bara\");\nSystem.out.println(\"Power: \" + pump.getPower(\"kW\") + \" kW\");\nSystem.out.println(\"Outlet temp: \" + pump.getOutletStream().getTemperature(\"C\") + \" \u00b0C\");\nSystem.out.println(\"NPSHa: \" + pump.getNPSHAvailable() + \" m\");\nSystem.out.println(\"Status: \" + pump.getPumpChart().getOperatingStatus(75.0, 1450.0));\n\nif (pump.isCavitating()) {\n    System.out.println(\"WARNING: Cavitation risk!\");\n}\n</code></pre>"},{"location":"wiki/pump_usage_guide/#example-pump-with-suction-line-python","title":"Example: Pump with Suction Line (Python)","text":"<p>This example demonstrates a realistic pump configuration where a suction line connects an upstream separator to the pump. The suction piping introduces pressure losses and static head changes that directly affect the NPSH available at the pump inlet. Properly modeling the suction line is critical for accurate cavitation assessment.</p>"},{"location":"wiki/pump_usage_guide/#why-model-the-suction-line","title":"Why Model the Suction Line?","text":"<p>In real installations, the pump does not receive fluid directly at separator conditions. The suction system introduces:</p> <ol> <li>Valve pressure drop - Control or isolation valves at the separator outlet cause pressure loss depending on Cv and flow rate</li> <li>Frictional pressure losses - Depends on pipe length, diameter, roughness, flow rate, and fluid properties</li> <li>Static head changes - Elevation difference between liquid source and pump centerline</li> <li>Minor losses - Elbows, filters, and other fittings</li> </ol> <p>These effects reduce the pressure at the pump suction flange relative to the source, directly impacting NPSHa. Ignoring suction system effects can lead to: - Underestimating cavitation risk - Pump damage in operation - Performance degradation and efficiency loss</p>"},{"location":"wiki/pump_usage_guide/#example-code","title":"Example Code","text":"<pre><code>import neqsim\n\n# Get the oil outlet stream from an upstream separator\n# (This would typically come from a configured process system)\npump_feed = oseberg_process.get('main process').getUnit('3RD stage separator').getOilOutStream()\n\n# --- Separator Outlet Valve ---\n# Model the isolation/control valve at the separator oil outlet\n# Cv sizing: For a 6\" valve (DN150) with full port, typical Cv \u2248 400-500\n# For a 4\" valve (DN100), typical Cv \u2248 150-200\n\nseparatorValve = neqsim.process.equipment.valve.ThrottlingValve(\"SeparatorOutletValve\", pump_feed)\nseparatorValve.setCv(350)              # Valve Cv (flow coefficient in US gpm/psi^0.5)\nseparatorValve.setIsCalcOutPressure(True) \nseparatorValve.setPercentValveOpening(80)  # 80% open - allows for control margin\n\nseparatorValve.run()\n\n# --- Suction Line Configuration ---\n# Model the piping between separator valve and pump using Beggs &amp; Brill correlation\n# This accounts for friction losses and elevation effects\n\nsuctionLine = neqsim.process.equipment.pipeline.PipeBeggsAndBrills(\"SuctionLine\", separatorValve.getOutletStream())\nsuctionLine.setLength(20.0)           # Pipe length in meters\nsuctionLine.setDiameter(0.2)          # Internal diameter in meters (200 mm)\nsuctionLine.setPipeWallRoughness(1.0e-5)  # Internal roughness in meters (~smooth pipe)\nsuctionLine.setElevation(-20)         # Pump is 20 m below separator (positive static head)\n\nsuctionLine.run()\n\n# --- Pump Configuration ---\n# Create the pump taking suction from the pipe outlet\n\npump1 = neqsim.process.equipment.pump.Pump('oil pump', suctionLine.getOutStream())\npump1.setOutletPressure(60.0, 'bara')  # Required discharge pressure\npump1.setCheckNPSH(True)               # Enable cavitation monitoring\npump1.setNPSHMargin(1.3)               # Require NPSHa &gt;= 1.3 \u00d7 NPSHr\n\n# --- Pump Performance Curves ---\n# Define pump characteristic curves at the operating speed\n# These are typically from manufacturer datasheets\n\nspeed = [3259]                            # Pump speed in RPM\nflow = [[1, 50, 70, 130]]                 # Flow points in m\u00b3/hr\nhead = [[250, 240, 230, 180]]             # Head in meters at each flow\neff = [[5, 40, 50, 52]]                   # Efficiency in % at each flow\nnpsh = [[2.0, 4.3, 6.0, 8.0]]             # NPSHr curve in meters\n\npump1.getPumpChart().setCurves([], speed, flow, head, eff)\npump1.getPumpChart().setNPSHCurve(npsh)\npump1.getPumpChart().setHeadUnit(\"meter\")\npump1.setSpeed(3259)\n\npump1.run()\n\n# --- Results Analysis ---\nprint(\"=== Pump &amp; Suction System Results ===\")\nprint(f\"Flow rate (m3/hr): {pump_feed.getFlowRate('idSm3/hr')}\")\nprint(f\"Separator outlet pressure (bara): {pump_feed.getPressure('bara')}\")\nprint(f\"Valve outlet pressure (bara): {separatorValve.getOutletPressure()}\")\nprint(f\"Valve pressure drop (bar): {separatorValve.getDeltaP()}\")\nprint(f\"Pump inlet pressure (bara): {pump1.getInletPressure()}\")\nprint(f\"Pump outlet pressure (bara): {pump1.getOutletPressure()}\")\nprint(f\"Pump NPSHa (meter): {pump1.getNPSHAvailable()}\")\nprint(f\"Pump NPSHr (meter): {pump1.getNPSHRequired()}\")\nprint(f\"Pump power (kW): {pump1.getPower('kW')}\")\nprint(f\"Cavitation risk: {'YES' if pump1.isCavitating() else 'NO'}\")\n</code></pre>"},{"location":"wiki/pump_usage_guide/#key-points","title":"Key Points","text":"Parameter Purpose <code>setCv(350)</code> Valve flow coefficient - determines pressure drop for given flow <code>setPercentValveOpening(80)</code> Valve position (0-100%); partially open for control margin <code>setLength(20.0)</code> Total equivalent length of suction piping including fittings <code>setDiameter(0.2)</code> Internal pipe diameter - larger diameter reduces friction loss <code>setPipeWallRoughness(1.0e-5)</code> Surface roughness; affects friction factor <code>setElevation(-20)</code> Negative elevation means pump is below source (increases NPSHa) <code>setCheckNPSH(True)</code> Enables automatic cavitation detection <code>setNPSHMargin(1.3)</code> Safety factor; typical values 1.1\u20131.5 <code>setNPSHCurve(npsh)</code> Required NPSH as function of flow from pump datasheet"},{"location":"wiki/pump_usage_guide/#understanding-the-results","title":"Understanding the Results","text":"<ul> <li> <p>Separator outlet pressure vs. Pump inlet pressure: The difference shows the pressure drop across the suction line. If the pump inlet pressure is much lower than expected, consider increasing pipe diameter or reducing length.</p> </li> <li> <p>NPSHa vs. NPSHr: NPSHa must exceed NPSHr by the specified margin. If <code>isCavitating()</code> returns <code>True</code>, consider:</p> </li> <li>Raising the liquid level in the source vessel</li> <li>Lowering the pump elevation (more negative elevation)</li> <li>Increasing pipe diameter to reduce friction losses</li> <li>Reducing fluid temperature (lowers vapor pressure)</li> <li> <p>Reducing pump speed (lowers NPSHr)</p> </li> <li> <p>Static head contribution: With a -20 m elevation (pump below separator), the static head adds approximately 20 m \u00d7 \u03c1 \u00d7 g to the suction pressure, which is beneficial for NPSHa.</p> </li> </ul>"},{"location":"wiki/pump_usage_guide/#design-considerations","title":"Design Considerations","text":"<ol> <li> <p>Suction pipe sizing: Velocity in suction lines should typically be 1\u20132 m/s for liquids to minimize friction losses while avoiding sedimentation.</p> </li> <li> <p>Elevation effects: Locating the pump below the liquid source is the most reliable way to ensure adequate NPSHa.</p> </li> <li> <p>Temperature sensitivity: Hot liquids have higher vapor pressure, reducing NPSHa. Consider subcooling or elevated suction pressure for near-boiling liquids.</p> </li> <li> <p>Transient conditions: During startup or upset conditions, flow rates may exceed design, increasing NPSHr while simultaneously increasing suction line losses\u2014always check NPSHa at maximum expected flow.</p> </li> </ol>"},{"location":"wiki/pvt_simulation_workflows/","title":"PVT simulation workflows backed by regression tests","text":"<p>The PVT simulation tests under <code>src/test/java/neqsim/pvtsimulation/simulation</code> capture end-to-end recipes for assembling fluids, configuring experiments, and validating outputs. This guide extracts the tested setups so you can reproduce them in your own studies.</p>"},{"location":"wiki/pvt_simulation_workflows/#constant-volume-depletion-cvd","title":"Constant-volume depletion (CVD)","text":"<p><code>ConstantVolumeDepletionTest</code> builds a lean-gas condensate fluid with TBP fractions, sets the SRK mixing rule, and drives a pressure staircase while keeping temperature fixed.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/ConstantVolumeDepletionTest.java\u2020L14-L41\u3011 After <code>runCalc()</code>, the simulation exposes relative volumes and phase properties that can be compared to laboratory measurements via <code>setExperimentalData(...)</code>. The test asserts that the calculated relative volume at a mid-range pressure (index 4) matches 2.1981, demonstrating how NeqSim preserves the reservoir volume constraint during depletion.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/ConstantVolumeDepletionTest.java\u2020L31-L41\u3011 A second test reads an Eclipse deck, flashes it to saturation pressure, and verifies that phase densities computed after <code>runCalc()</code> remain consistent when phases are split and re-flashed independently.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/ConstantVolumeDepletionTest.java\u2020L43-L74\u3011 Use this workflow when calibrating CVD curves or comparing simulator results to PVT lab data.</p> <p>Setup checklist</p> <ol> <li>Create a <code>SystemInterface</code> with EOS and add components/TBP fractions.</li> <li>Enable database use and select a mixing rule.</li> <li>Initialize the system (state 0 and 1) before constructing <code>ConstantVolumeDepletion</code>.</li> <li>Call <code>setTemperature(...)</code>, <code>setPressures(...)</code>, and <code>runCalc()</code>.</li> <li>Optionally load experimental matrices for regression and retrieve arrays such as <code>getRelativeVolume()</code>.</li> </ol>"},{"location":"wiki/pvt_simulation_workflows/#differential-liberation","title":"Differential liberation","text":"<p><code>DifferentialLiberationTest</code> prepares a rich oil system with extensive TBP characterization, including lumping of the plus fraction into 12 pseudo-components.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/DifferentialLiberationTest.java\u2020L11-L37\u3011 The test first computes saturation pressure at 97.5 \u00b0C, then steps down through 15 pressure stages while tracking formation volume factor (\\(B_o\\)), solution gas\u2013oil ratio (\\(R_s\\)), gas formation volume factor (\\(B_g\\)), and oil density.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/DifferentialLiberationTest.java\u2020L38-L65\u3011 Assertions span early, mid, and late pressures, confirming that flash results translate into monotonic \\(B_o\\) shrinkage and degassed densities as expected from the core differential liberation equations.</p> <p>Interpreting the outputs</p> <ul> <li>\\(B_o\\) in the test is computed as \\(V_{oil,\\,res}/V_{oil,\\,stock}\\) for each pressure step; values trend from 1.69 toward 1.05 as pressure decreases, consistent with expanding shrinkage.</li> <li>\\(R_s\\) (standard gas dissolved in stock-tank barrels of oil) declines to zero by the final stage, aligning with complete gas liberation.</li> <li>\\(B_g\\) is reported in reservoir volume per standard volume; the late-stage value of ~0.056 m\u00b3/Sm\u00b3 illustrates the increasing compressibility of liberated gas.</li> </ul> <p>Follow the same staged pressure list and temperature target to benchmark your own differential liberation runs against the regression suite.</p>"},{"location":"wiki/pvt_simulation_workflows/#general-simulation-hygiene","title":"General simulation hygiene","text":"<p>The tests highlight a few recurring best practices:</p> <ul> <li>Always set a mixing rule and initialize the system before running a PVT simulation to avoid inconsistent pseudo-component properties.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/ConstantVolumeDepletionTest.java\u2020L26-L31\u3011</li> <li>Use <code>ThermodynamicOperations</code> flashes to reinitialize separated phases when comparing densities or re-flashing isolated phases, as shown in the CVD Eclipse example.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/ConstantVolumeDepletionTest.java\u2020L54-L73\u3011</li> <li>Keep temperature explicit on each simulation (<code>setTemperature</code>) to avoid accidental reuse of a previous state across experiments.\u3010F:src/test/java/neqsim/pvtsimulation/simulation/DifferentialLiberationTest.java\u2020L41-L48\u3011</li> </ul>"},{"location":"wiki/solar_panel/","title":"Solar Panel Unit Operation","text":"<p>The <code>SolarPanel</code> unit converts solar irradiance into electrical power using a simple relation between the incoming radiation, panel area and efficiency:</p> <pre><code>Power = irradiance [W/m^2] \u00d7 panel area [m^2] \u00d7 efficiency\n</code></pre> <p>The produced power is available from the unit's energy stream as a negative duty (indicating power generation).</p>"},{"location":"wiki/solar_panel/#example","title":"Example","text":"<pre><code>SolarPanel panel = new SolarPanel(\"panel\");\npanel.setIrradiance(800.0); // W/m^2\npanel.setPanelArea(2.0);    // m^2\npanel.setEfficiency(0.2);   // 20%\npanel.run();\nSystem.out.println(panel.getPower());\n</code></pre>"},{"location":"wiki/steam_heater/","title":"Steam heater","text":"<p>The <code>SteamHeater</code> heats process streams while forcing the water property package. It estimates the required steam flow rate using the IAPWS IF97 steam tables.</p> <pre><code>SystemInterface water = new SystemSrkEos(298.15, 1.0);\nwater.addComponent(\"water\", 1.0);\nwater.setPhysicalPropertyModel(PhysicalPropertyModel.WATER);\n\nStream feed = new Stream(\"water feed\", water);\nfeed.setTemperature(25.0, \"C\");\n\nSteamHeater heater = new SteamHeater(\"heater\", feed);\nheater.setOutTemperature(80.0, \"C\");\nheater.setSteamInletTemperature(180.0, \"C\");\nheater.setSteamOutletTemperature(100.0, \"C\");\nheater.setSteamPressure(2.0, \"bara\");\n\n// After running the process system the calculated steam flow can be obtained\ndouble steamFlow = heater.getSteamFlowRate(\"kg/hr\");\n</code></pre>"},{"location":"wiki/steam_tables_if97/","title":"IF97 Steam Tables","text":"<p>This page documents the basic equations implemented in <code>Iapws_if97</code>.</p>"},{"location":"wiki/steam_tables_if97/#saturation-equations","title":"Saturation equations","text":"<p>For the saturation line (Region 4) the following equations are used:</p> <p>Pressure as function of temperature:</p> \\[ \\ln(p) = 4 \\cdot \\ln\\left(\\frac{2 C}{-B + \\sqrt{B^2-4 A C}}\\right) \\] <p>where</p> \\[ A = \\theta^2 + 1167.0521452767\\,\\theta - 724213.16703206\\\\ B = -17.073846940092\\,\\theta^2 + 12020.82470247\\,\\theta - 3232555.0322333\\\\ C = 14.91510861353\\,\\theta^2 - 4823.2657361591\\,\\theta + 405113.40542057\\\\ \\theta = T - \\frac{0.23855557567849}{T-650.17534844798} \\] <p>Temperature as function of pressure is obtained by solving the inverse relation.</p>"},{"location":"wiki/steam_tables_if97/#region-1-and-2","title":"Region 1 and 2","text":"<p>The specific Gibbs free energy is expressed with dimensionless variables \\(\\pi\\) and \\(\\tau\\). For region 1</p> \\[ \\gamma(\\pi,\\tau)=\\sum n_i (7.1-\\pi)^{I_i} (\\tau-1.222)^{J_i} \\] <p>while region 2 uses an ideal and residual part</p> \\[ \\gamma(\\pi,\\tau)=\\ln\\pi + \\sum n_i^0\\tau^{J_i^0} + \\sum n_i^r\\pi^{I_i^r}(\\tau-0.5)^{J_i^r} \\] <p>Thermodynamic properties follow from derivatives of \\(\\gamma\\):</p> \\[  v = \\frac{R T}{p}\\,\\pi\\, \\gamma_{\\pi} \\quad\\quad  h = R T\\tau\\, \\gamma_{\\tau} \\\\  s = R(\\tau\\gamma_{\\tau}-\\gamma) \\] <p>where \\(R=0.461526\\,\\mathrm{kJ\\,kg^{-1}\\,K^{-1}}\\).</p>"},{"location":"wiki/tbp_fraction_models/","title":"TBP Fraction Models in NeqSim","text":"<p>This guide provides comprehensive documentation on True Boiling Point (TBP) fraction models available in NeqSim for petroleum fluid characterization.</p>"},{"location":"wiki/tbp_fraction_models/#1-introduction","title":"1. Introduction","text":""},{"location":"wiki/tbp_fraction_models/#what-are-tbp-models","title":"What are TBP Models?","text":"<p>TBP (True Boiling Point) models are empirical correlations that estimate the critical properties of petroleum pseudo-components from easily measured bulk properties like molecular weight (MW) and specific gravity (SG). These critical properties are essential inputs for cubic equations of state (EOS) such as SRK and Peng-Robinson.</p>"},{"location":"wiki/tbp_fraction_models/#why-do-we-need-them","title":"Why Do We Need Them?","text":"<p>Petroleum fluids contain thousands of individual hydrocarbon species that cannot all be individually identified and characterized. Instead, heavy fractions (typically C7+) are lumped into pseudo-components. TBP models provide the thermodynamic properties needed for EOS calculations:</p> <ul> <li>Critical Temperature (Tc): Temperature above which a pure substance cannot exist as a liquid</li> <li>Critical Pressure (Pc): Pressure required to liquefy a gas at its critical temperature</li> <li>Acentric Factor (\u03c9): Measure of molecular non-sphericity, affects vapor pressure behavior</li> </ul>"},{"location":"wiki/tbp_fraction_models/#2-available-models","title":"2. Available Models","text":"<p>NeqSim provides 10 TBP models, each optimized for different applications:</p> Model Name Best Application Key Feature <code>PedersenSRK</code> General SRK EOS Default, auto light/heavy switching <code>PedersenSRKHeavyOil</code> Heavy oils with SRK Optimized for MW &gt; 500 g/mol <code>PedersenPR</code> General PR EOS Optimized for Peng-Robinson <code>PedersenPR2</code> PR EOS alternate S\u00f8reide boiling point correlation <code>PedersenPRHeavyOil</code> Heavy oils with PR For viscous/heavy crude <code>RiaziDaubert</code> Light fractions Best for MW &lt; 300 g/mol <code>Lee-Kesler</code> General purpose Uses Watson K-factor <code>Twu</code> Paraffinic fluids n-alkane reference method <code>Cavett</code> Refining industry API gravity corrections <code>Standing</code> Reservoir engineering Simple, widely used"},{"location":"wiki/tbp_fraction_models/#3-model-details","title":"3. Model Details","text":""},{"location":"wiki/tbp_fraction_models/#31-pedersen-models-pedersensrk-pedersenpr","title":"3.1 Pedersen Models (PedersenSRK, PedersenPR)","text":"<p>Best for: General purpose petroleum characterization</p> <p>The Pedersen correlations are the default and most widely used TBP models in NeqSim. They were specifically developed for use with cubic equations of state.</p>"},{"location":"wiki/tbp_fraction_models/#correlations","title":"Correlations","text":"<p>Critical Temperature: $\\(T_c = a_0 \\cdot \\rho + a_1 \\cdot \\ln(M) + a_2 \\cdot M + \\frac{a_3}{M}\\)$</p> <p>Critical Pressure: $\\(P_c = \\exp\\left(b_0 + b_1 \\cdot \\rho^{b_4} + \\frac{b_2}{M} + \\frac{b_3}{M^2}\\right)\\)$</p> <p>EOS m-parameter: $\\(m = c_0 + c_1 \\cdot M + c_2 \\cdot \\rho + c_3 \\cdot M^2\\)$</p> <p>The model automatically switches between light oil and heavy oil coefficients at MW = 1120 g/mol.</p>"},{"location":"wiki/tbp_fraction_models/#usage","title":"Usage","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\n\n// For SRK equation of state\nSystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"PedersenSRK\");\nfluid.addTBPfraction(\"C7\", 1.0, 0.092, 0.73);\n</code></pre> <pre><code>import neqsim.thermo.system.SystemPrEos;\n\n// For Peng-Robinson equation of state\nSystemPrEos fluid = new SystemPrEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"PedersenPR\");\nfluid.addTBPfraction(\"C7\", 1.0, 0.092, 0.73);\n</code></pre> <p>Reference: Pedersen, K.S., Thomassen, P., Fredenslund, A. (1984). \"Thermodynamics of Petroleum Mixtures Containing Heavy Hydrocarbons.\" Ind. Eng. Chem. Process Des. Dev., 23, 566-573.</p>"},{"location":"wiki/tbp_fraction_models/#32-riazi-daubert-model","title":"3.2 Riazi-Daubert Model","text":"<p>Best for: Light to medium petroleum fractions (MW &lt; 300 g/mol)</p> <p>The Riazi-Daubert model uses a simple exponential-power law form that works well for lighter fractions. For heavier fractions (MW &gt; 300), it automatically falls back to the Pedersen model.</p>"},{"location":"wiki/tbp_fraction_models/#correlations_1","title":"Correlations","text":"<p>Critical Temperature (K): $\\(T_c = \\frac{5}{9} \\times 554.4 \\times \\exp(-1.3478 \\times 10^{-4} \\cdot M - 0.61641 \\cdot SG) \\times M^{0.2998} \\times SG^{1.0555}\\)$</p> <p>Critical Pressure (bar): $\\(P_c = 0.068947 \\times 4.5203 \\times 10^{4} \\times \\exp(-1.8078 \\times 10^{-3} \\cdot M - 0.3084 \\cdot SG) \\times M^{-0.8063} \\times SG^{1.6015}\\)$</p> <p>Boiling Point (K): $\\(T_b = 97.58 \\times M^{0.3323} \\times SG^{0.04609}\\)$</p>"},{"location":"wiki/tbp_fraction_models/#applicability-range","title":"Applicability Range","text":"<ul> <li>Molecular weight: 70-300 g/mol</li> <li>Specific gravity: 0.65-0.90</li> </ul>"},{"location":"wiki/tbp_fraction_models/#usage_1","title":"Usage","text":"<pre><code>SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"RiaziDaubert\");\nfluid.addTBPfraction(\"C7\", 1.0, 0.092, 0.73);  // Light fraction - uses Riazi-Daubert\nfluid.addTBPfraction(\"C30\", 0.5, 0.400, 0.90); // Heavy fraction - falls back to Pedersen\n</code></pre> <p>Reference: Riazi, M.R. and Daubert, T.E. (1980). \"Simplify Property Predictions.\" Hydrocarbon Processing, 59(3), 115-116.</p>"},{"location":"wiki/tbp_fraction_models/#33-lee-kesler-model","title":"3.3 Lee-Kesler Model","text":"<p>Best for: General purpose characterization, especially when Watson K-factor is known</p> <p>The Lee-Kesler model is based on generalized correlations using boiling point and specific gravity as primary inputs. It is widely used in the petroleum industry.</p>"},{"location":"wiki/tbp_fraction_models/#correlations_2","title":"Correlations","text":"<p>Critical Temperature (K): $\\(T_c = 189.8 + 450.6 \\cdot SG + (0.4244 + 0.1174 \\cdot SG) \\cdot T_b + (0.1441 - 1.0069 \\cdot SG) \\times \\frac{10^5}{T_b}\\)$</p> <p>Critical Pressure (bar): $\\(\\ln(P_c) = 3.3864 - \\frac{0.0566}{SG} - f(T_b, SG)\\)$</p> <p>where \\(f(T_b, SG)\\) is a polynomial function of boiling point and specific gravity.</p> <p>Acentric Factor (Kesler-Lee):</p> <p>For \\(T_{br} &lt; 0.8\\): $\\(\\omega = \\frac{\\ln(P_{br}) - 5.92714 + \\frac{6.09649}{T_{br}} + 1.28862 \\cdot \\ln(T_{br}) - 0.169347 \\cdot T_{br}^6}{15.2518 - \\frac{15.6875}{T_{br}} - 13.4721 \\cdot \\ln(T_{br}) + 0.43577 \\cdot T_{br}^6}\\)$</p> <p>For \\(T_{br} \\geq 0.8\\): $\\(\\omega = -7.904 + 0.1352 \\cdot K_w - 0.007465 \\cdot K_w^2 + 8.359 \\cdot T_{br} + \\frac{1.408 - 0.01063 \\cdot K_w}{T_{br}}\\)$</p> <p>where \\(T_{br} = T_b/T_c\\) and \\(K_w\\) is the Watson characterization factor.</p>"},{"location":"wiki/tbp_fraction_models/#usage_2","title":"Usage","text":"<pre><code>SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"Lee-Kesler\");\nfluid.addTBPfraction(\"C10\", 1.0, 0.142, 0.78);\n</code></pre> <p>Reference: Kesler, M.G. and Lee, B.I. (1976). \"Improve Prediction of Enthalpy of Fractions.\" Hydrocarbon Processing, 55(3), 153-158.</p>"},{"location":"wiki/tbp_fraction_models/#34-twu-model","title":"3.4 Twu Model","text":"<p>Best for: Paraffinic fluids and gas condensates (Watson K &gt; 12)</p> <p>The Twu model uses n-alkanes as reference compounds and applies perturbation corrections based on specific gravity differences. This approach is particularly accurate for waxy/paraffinic petroleum fractions.</p>"},{"location":"wiki/tbp_fraction_models/#method-overview","title":"Method Overview","text":"<ol> <li>Calculate reference n-alkane properties from boiling point</li> <li>Apply perturbation corrections based on \\(\\Delta SG = SG_{alkane} - SG_{actual}\\)</li> <li>Iterate to find equivalent n-alkane molecular weight</li> </ol>"},{"location":"wiki/tbp_fraction_models/#key-equations","title":"Key Equations","text":"<p>n-Alkane Critical Temperature: $\\(T_{c,alk} = T_b \\times \\left[0.533272 + 0.343831 \\times 10^{-3} \\cdot T_b + 2.526167 \\times 10^{-7} \\cdot T_b^2 - 1.65848 \\times 10^{-10} \\cdot T_b^3 + \\frac{4.60774 \\times 10^{24}}{T_b^{13}}\\right]^{-1}\\)$</p> <p>Perturbation Function: $\\(f_T = \\Delta S_T \\times \\left(-0.270159 \\cdot T_b^{-0.5} + (0.0398285 - 0.706691 \\cdot T_b^{-0.5}) \\cdot \\Delta S_T\\right)\\)$</p> <p>where \\(\\Delta S_T = \\exp(5.0 \\cdot (SG_{alk} - SG)) - 1\\)</p> <p>Corrected Critical Temperature: $\\(T_c = T_{c,alk} \\times \\left(\\frac{1 + 2f_T}{1 - 2f_T}\\right)^2\\)$</p>"},{"location":"wiki/tbp_fraction_models/#when-to-use","title":"When to Use","text":"<ul> <li>Gas condensates with high paraffin content</li> <li>Waxy crudes</li> <li>Light oils with K_w &gt; 12</li> </ul>"},{"location":"wiki/tbp_fraction_models/#usage_3","title":"Usage","text":"<pre><code>SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"Twu\");\nfluid.addTBPfraction(\"C10\", 1.0, 0.142, 0.78);\n</code></pre> <p>Reference: Twu, C.H. (1984). \"An Internally Consistent Correlation for Predicting the Critical Properties and Molecular Weights of Petroleum and Coal-Tar Liquids.\" Fluid Phase Equilibria, 16, 137-150.</p>"},{"location":"wiki/tbp_fraction_models/#35-cavett-model","title":"3.5 Cavett Model","text":"<p>Best for: Refining industry applications, heavy oils with API gravity data</p> <p>The Cavett model in NeqSim uses a hybrid Lee-Kesler/Cavett approach with API gravity corrections. This provides robust results across a wide range of petroleum fractions while maintaining the API gravity sensitivity important for refining applications.</p>"},{"location":"wiki/tbp_fraction_models/#api-gravity-relationship","title":"API Gravity Relationship","text":"\\[API = \\frac{141.5}{SG} - 131.5\\] API Range Classification SG Range &gt; 31.1\u00b0 Light crude &lt; 0.87 22.3\u00b0 - 31.1\u00b0 Medium crude 0.87 - 0.92 &lt; 22.3\u00b0 Heavy crude &gt; 0.92"},{"location":"wiki/tbp_fraction_models/#correlations_3","title":"Correlations","text":"<p>The model uses Lee-Kesler correlations as the base, with API corrections for heavy fractions:</p> <p>Critical Temperature (API &lt; 30\u00b0): $\\(T_c = T_{c,LK} \\times [1 + 0.002 \\cdot (30 - API)]\\)$</p> <p>Critical Pressure (API &lt; 30\u00b0): $\\(P_c = P_{c,LK} \\times [1 + 0.001 \\cdot (30 - API)]\\)$</p> <p>Acentric Factor (Edmister): $\\(\\omega = \\frac{3}{7} \\times \\frac{\\log_{10}(P_c/P_{ref})}{T_c/T_b - 1} - 1\\)$</p> <p>Bounded to range [0.0, 1.5] for physical validity.</p>"},{"location":"wiki/tbp_fraction_models/#usage_4","title":"Usage","text":"<pre><code>SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"Cavett\");\n\n// Heavy oil example (API ~ 20\u00b0)\nfluid.addTBPfraction(\"HeavyFrac\", 1.0, 0.300, 0.93);\n</code></pre> <p>Reference: Cavett, R.H. (1962). \"Physical Data for Distillation Calculations, Vapor-Liquid Equilibria.\" Proc. 27<sup>th</sup> API Meeting, San Francisco.</p>"},{"location":"wiki/tbp_fraction_models/#36-standing-model","title":"3.6 Standing Model","text":"<p>Best for: Reservoir engineering, quick estimates, black oil PVT</p> <p>The Standing model uses Riazi-Daubert style correlations for robust critical property estimation. It's widely used in reservoir simulation tools.</p>"},{"location":"wiki/tbp_fraction_models/#correlations_4","title":"Correlations","text":"<p>Same as Riazi-Daubert (see Section 3.2).</p>"},{"location":"wiki/tbp_fraction_models/#usage_5","title":"Usage","text":"<pre><code>SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\nfluid.getCharacterization().setTBPModel(\"Standing\");\nfluid.addTBPfraction(\"C7\", 1.0, 0.092, 0.73);\n</code></pre> <p>Reference: Standing, M.B. (1977). \"Volumetric and Phase Behavior of Oil Field Hydrocarbon Systems.\" SPE, Dallas.</p>"},{"location":"wiki/tbp_fraction_models/#4-watson-characterization-factor","title":"4. Watson Characterization Factor","text":"<p>The Watson characterization factor (\\(K_w\\)) is useful for classifying petroleum fractions and selecting appropriate TBP models:</p> \\[K_w = \\frac{(1.8 \\cdot T_b)^{1/3}}{SG}\\] K_w Range Fluid Type Recommended Model &gt; 12.5 Paraffinic (gas condensates) Twu 11.5 - 12.5 Mixed/intermediate Pedersen or Lee-Kesler 10.5 - 11.5 Naphthenic Pedersen or RiaziDaubert &lt; 10.5 Aromatic Pedersen"},{"location":"wiki/tbp_fraction_models/#calculating-k_w-in-neqsim","title":"Calculating K_w in NeqSim","text":"<pre><code>TBPfractionModel tbpModel = new TBPfractionModel();\ndouble Kw = tbpModel.calcWatsonKFactor(0.142, 0.78);  // MW in kg/mol, density in g/cm\u00b3\nSystem.out.println(\"Watson K-factor: \" + Kw);\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#5-model-selection-guidelines","title":"5. Model Selection Guidelines","text":""},{"location":"wiki/tbp_fraction_models/#51-decision-tree","title":"5.1 Decision Tree","text":"<pre><code>Is EOS = Peng-Robinson?\n\u251c\u2500\u2500 Yes \u2192 Is fluid heavy (MW &gt; 500)?\n\u2502         \u251c\u2500\u2500 Yes \u2192 PedersenPRHeavyOil\n\u2502         \u2514\u2500\u2500 No \u2192 PedersenPR\n\u2514\u2500\u2500 No (SRK) \u2192 Is fluid heavy (MW &gt; 500)?\n              \u251c\u2500\u2500 Yes \u2192 PedersenSRKHeavyOil\n              \u2514\u2500\u2500 No \u2192 Is K_w &gt; 12 (paraffinic)?\n                        \u251c\u2500\u2500 Yes \u2192 Twu\n                        \u2514\u2500\u2500 No \u2192 Is MW &lt; 300?\n                                  \u251c\u2500\u2500 Yes \u2192 RiaziDaubert or Lee-Kesler\n                                  \u2514\u2500\u2500 No \u2192 PedersenSRK\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#52-automatic-model-recommendation","title":"5.2 Automatic Model Recommendation","text":"<p>NeqSim can recommend an appropriate model based on fluid properties:</p> <pre><code>TBPfractionModel tbpModel = new TBPfractionModel();\nString recommended = tbpModel.recommendTBPModel(\n    0.200,    // Average MW in kg/mol\n    0.85,     // Average density in g/cm\u00b3\n    \"SRK\"     // EOS type: \"SRK\" or \"PR\"\n);\nSystem.out.println(\"Recommended model: \" + recommended);\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#53-list-all-available-models","title":"5.3 List All Available Models","text":"<pre><code>String[] models = TBPfractionModel.getAvailableModels();\nfor (String model : models) {\n    System.out.println(model);\n}\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#6-typical-property-values","title":"6. Typical Property Values","text":"<p>Reference values for common petroleum fractions:</p> Component MW (g/mol) SG T_c (K) P_c (bar) \u03c9 n-Heptane (C7) 100 0.684 540 27.4 0.35 C7 (typical) 96-100 0.72-0.74 540-560 27-30 0.30-0.35 C10 134-142 0.76-0.79 600-640 20-25 0.45-0.55 C15 200-210 0.81-0.83 680-720 15-18 0.65-0.75 C20 275-285 0.85-0.87 750-800 12-15 0.85-0.95 C30 400-420 0.88-0.90 850-900 8-10 1.0-1.2"},{"location":"wiki/tbp_fraction_models/#7-complete-examples","title":"7. Complete Examples","text":""},{"location":"wiki/tbp_fraction_models/#71-basic-fluid-characterization","title":"7.1 Basic Fluid Characterization","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class BasicCharacterization {\n    public static void main(String[] args) {\n        // Create SRK fluid\n        SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\n\n        // Add light components\n        fluid.addComponent(\"methane\", 70.0);\n        fluid.addComponent(\"ethane\", 10.0);\n        fluid.addComponent(\"propane\", 5.0);\n\n        // Set TBP model before adding heavy fractions\n        fluid.getCharacterization().setTBPModel(\"PedersenSRK\");\n\n        // Add TBP fractions\n        fluid.addTBPfraction(\"C7\", 3.0, 0.092, 0.73);\n        fluid.addTBPfraction(\"C8\", 2.5, 0.104, 0.76);\n        fluid.addTBPfraction(\"C9\", 2.0, 0.118, 0.78);\n        fluid.addTBPfraction(\"C10\", 1.5, 0.134, 0.79);\n\n        // Set mixing rule and initialize\n        fluid.setMixingRule(\"classic\");\n\n        // Perform flash calculation\n        ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        // Print results\n        fluid.prettyPrint();\n\n        // Access individual component properties\n        System.out.println(\"\\nC7 Critical Properties:\");\n        System.out.println(\"Tc = \" + fluid.getComponent(\"C7_PC\").getTC() + \" K\");\n        System.out.println(\"Pc = \" + fluid.getComponent(\"C7_PC\").getPC() + \" bar\");\n        System.out.println(\"omega = \" + fluid.getComponent(\"C7_PC\").getAcentricFactor());\n    }\n}\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#72-comparing-different-tbp-models","title":"7.2 Comparing Different TBP Models","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\n\npublic class ModelComparison {\n    public static void main(String[] args) {\n        String[] models = {\"PedersenSRK\", \"Lee-Kesler\", \"RiaziDaubert\", \"Twu\", \"Cavett\", \"Standing\"};\n\n        System.out.println(\"=== TBP Model Comparison for C10 (MW=142 g/mol, SG=0.78) ===\");\n        System.out.printf(\"%-15s %10s %10s %10s%n\", \"Model\", \"Tc (K)\", \"Pc (bar)\", \"omega\");\n        System.out.println(\"-\".repeat(50));\n\n        for (String modelName : models) {\n            SystemSrkEos fluid = new SystemSrkEos(298.15, 50.0);\n            fluid.getCharacterization().setTBPModel(modelName);\n            fluid.addTBPfraction(\"C10\", 1.0, 0.142, 0.78);\n\n            double Tc = fluid.getComponent(0).getTC();\n            double Pc = fluid.getComponent(0).getPC();\n            double omega = fluid.getComponent(0).getAcentricFactor();\n\n            System.out.printf(\"%-15s %10.2f %10.2f %10.4f%n\", modelName, Tc, Pc, omega);\n        }\n    }\n}\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#73-gas-condensate-with-twu-model","title":"7.3 Gas Condensate with Twu Model","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class GasCondensateExample {\n    public static void main(String[] args) {\n        SystemSrkEos fluid = new SystemSrkEos(350.0, 150.0);\n\n        // Lean gas condensate composition\n        fluid.addComponent(\"nitrogen\", 1.5);\n        fluid.addComponent(\"CO2\", 2.0);\n        fluid.addComponent(\"methane\", 80.0);\n        fluid.addComponent(\"ethane\", 6.0);\n        fluid.addComponent(\"propane\", 3.0);\n        fluid.addComponent(\"i-butane\", 0.8);\n        fluid.addComponent(\"n-butane\", 1.2);\n        fluid.addComponent(\"i-pentane\", 0.5);\n        fluid.addComponent(\"n-pentane\", 0.5);\n\n        // Use Twu model for paraffinic gas condensate\n        fluid.getCharacterization().setTBPModel(\"Twu\");\n\n        // Add C6+ fractions\n        fluid.addTBPfraction(\"C6\", 1.0, 0.086, 0.68);\n        fluid.addTBPfraction(\"C7+\", 3.5, 0.130, 0.76);\n\n        fluid.setMixingRule(\"classic\");\n\n        ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        System.out.println(\"Gas Condensate Flash at \" + fluid.getTemperature() + \" K, \" \n            + fluid.getPressure() + \" bar\");\n        fluid.prettyPrint();\n    }\n}\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#74-heavy-oil-characterization","title":"7.4 Heavy Oil Characterization","text":"<pre><code>import neqsim.thermo.system.SystemPrEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class HeavyOilExample {\n    public static void main(String[] args) {\n        // Use Peng-Robinson for heavy oil\n        SystemPrEos fluid = new SystemPrEos(333.15, 10.0);\n\n        // Light ends\n        fluid.addComponent(\"methane\", 5.0);\n        fluid.addComponent(\"ethane\", 2.0);\n        fluid.addComponent(\"propane\", 3.0);\n        fluid.addComponent(\"n-butane\", 2.0);\n        fluid.addComponent(\"n-pentane\", 3.0);\n\n        // Use heavy oil model\n        fluid.getCharacterization().setTBPModel(\"PedersenPRHeavyOil\");\n\n        // Heavy fractions (API ~ 15\u00b0, SG ~ 0.96)\n        fluid.addTBPfraction(\"C6-C10\", 15.0, 0.120, 0.80);\n        fluid.addTBPfraction(\"C11-C20\", 25.0, 0.250, 0.88);\n        fluid.addTBPfraction(\"C21-C30\", 20.0, 0.380, 0.92);\n        fluid.addTBPfraction(\"C31+\", 25.0, 0.550, 0.96);\n\n        fluid.setMixingRule(\"classic\");\n\n        ThermodynamicOperations ops = new ThermodynamicOperations(fluid);\n        ops.TPflash();\n\n        System.out.println(\"Heavy Oil Flash at \" + fluid.getTemperature() + \" K\");\n        fluid.prettyPrint();\n    }\n}\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#8-python-neqsim-python-examples","title":"8. Python (neqsim-python) Examples","text":""},{"location":"wiki/tbp_fraction_models/#81-basic-usage","title":"8.1 Basic Usage","text":"<pre><code>from neqsim.thermo import fluid\n\n# Create fluid with TBP model selection\noil = fluid('srk')\noil.getCharacterization().setTBPModel(\"PedersenSRK\")\n\n# Add components\noil.addComponent(\"methane\", 70.0)\noil.addComponent(\"ethane\", 10.0)\noil.addTBPfraction(\"C7\", 5.0, 0.092, 0.73)\noil.addTBPfraction(\"C10\", 3.0, 0.142, 0.78)\n\noil.setMixingRule(\"classic\")\noil.setTemperature(298.15, \"K\")\noil.setPressure(50.0, \"bara\")\n\n# Flash and print\nfrom neqsim.thermodynamicoperations import TPflash\nTPflash(oil)\noil.prettyPrint()\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#82-direct-java-api-access","title":"8.2 Direct Java API Access","text":"<pre><code>from jpype import JClass\n\n# Import Java classes directly\nSystemSrkEos = JClass('neqsim.thermo.system.SystemSrkEos')\nTBPfractionModel = JClass('neqsim.thermo.characterization.TBPfractionModel')\n\n# Create fluid\nfluid = SystemSrkEos(298.15, 50.0)\n\n# Get model recommendation\ntbpModel = TBPfractionModel()\nrecommended = tbpModel.recommendTBPModel(0.200, 0.85, \"SRK\")\nprint(f\"Recommended model: {recommended}\")\n\n# Set model and add fractions\nfluid.getCharacterization().setTBPModel(recommended)\nfluid.addTBPfraction(\"C10\", 1.0, 0.142, 0.78)\n\n# Print critical properties\nprint(f\"Tc = {fluid.getComponent(0).getTC()} K\")\nprint(f\"Pc = {fluid.getComponent(0).getPC()} bar\")\n</code></pre>"},{"location":"wiki/tbp_fraction_models/#9-troubleshooting","title":"9. Troubleshooting","text":""},{"location":"wiki/tbp_fraction_models/#common-issues","title":"Common Issues","text":"<ol> <li>Unrealistic Tc values (&gt; 1000 K or &lt; 400 K)</li> <li>Check that MW is in kg/mol (not g/mol)</li> <li>Check that density is in g/cm\u00b3 (not kg/m\u00b3)</li> <li> <p>Try a different model (Pedersen is most robust)</p> </li> <li> <p>Negative acentric factor</p> </li> <li>Usually indicates incorrect input data</li> <li> <p>Cavett model has built-in bounds checking [0, 1.5]</p> </li> <li> <p>Flash convergence issues with heavy fractions</p> </li> <li>Use heavy oil variants (PedersenSRKHeavyOil, PedersenPRHeavyOil)</li> <li> <p>Check that fluid composition is normalized</p> </li> <li> <p>Model not found error</p> </li> <li>Model names are case-sensitive</li> <li>Use <code>TBPfractionModel.getAvailableModels()</code> to see valid names</li> </ol>"},{"location":"wiki/tbp_fraction_models/#input-unit-requirements","title":"Input Unit Requirements","text":"Property Required Unit Common Mistake Molecular Weight kg/mol Using g/mol (divide by 1000) Density g/cm\u00b3 Using kg/m\u00b3 (divide by 1000) Temperature K (internal) Pressure bar (internal)"},{"location":"wiki/tbp_fraction_models/#10-references","title":"10. References","text":"<ol> <li> <p>Pedersen, K.S., Thomassen, P., Fredenslund, A. (1984). \"Thermodynamics of Petroleum Mixtures Containing Heavy Hydrocarbons.\" Ind. Eng. Chem. Process Des. Dev., 23, 566-573.</p> </li> <li> <p>Kesler, M.G., Lee, B.I. (1976). \"Improve Prediction of Enthalpy of Fractions.\" Hydrocarbon Processing, 55(3), 153-158.</p> </li> <li> <p>Riazi, M.R., Daubert, T.E. (1980). \"Simplify Property Predictions.\" Hydrocarbon Processing, 59(3), 115-116.</p> </li> <li> <p>Twu, C.H. (1984). \"An Internally Consistent Correlation for Predicting the Critical Properties and Molecular Weights of Petroleum and Coal-Tar Liquids.\" Fluid Phase Equilibria, 16, 137-150.</p> </li> <li> <p>Cavett, R.H. (1962). \"Physical Data for Distillation Calculations, Vapor-Liquid Equilibria.\" Proc. 27<sup>th</sup> API Meeting, San Francisco.</p> </li> <li> <p>Standing, M.B. (1977). \"Volumetric and Phase Behavior of Oil Field Hydrocarbon Systems.\" SPE, Dallas.</p> </li> <li> <p>Edmister, W.C. (1958). \"Applied Hydrocarbon Thermodynamics, Part 4: Compressibility Factors and Equations of State.\" Petroleum Refiner, 37(4), 173-179.</p> </li> </ol>"},{"location":"wiki/tbp_fraction_models/#see-also","title":"See Also","text":"<ul> <li>Fluid Characterization - Plus fraction models and lumping</li> <li>PVT Simulation Workflows - Complete PVT analysis</li> <li>Thermodynamics Guide - Equation of state selection</li> </ul>"},{"location":"wiki/test-overview/","title":"JUnit Test Overview","text":"<p>The NeqSim project contains an extensive JUnit 5 test suite. The tests are grouped by feature area under <code>src/test/java/neqsim</code>. The main groups are summarised below.</p>"},{"location":"wiki/test-overview/#thermodynamic-operations","title":"Thermodynamic operations","text":"<p>Directory: <code>src/test/java/neqsim/thermodynamicoperations</code></p> <p>Tests for the core thermodynamic calculation utilities. The <code>flashops</code> package verifies different flash calculations (TP, PH, PS etc.) while <code>phaseenvelopeops</code> checks phase envelope algorithms. Utilities and common operations are tested under <code>util</code>.</p>"},{"location":"wiki/test-overview/#pvt-simulations","title":"PVT simulations","text":"<p>Directory: <code>src/test/java/neqsim/pvtsimulation/simulation</code></p> <p>Covers simulation models used for PVT studies such as constant volume depletion, differential liberation and slim\u2011tube simulations. These tests ensure that the simulation workflow and calculated properties are consistent.</p>"},{"location":"wiki/test-overview/#process-modelling","title":"Process modelling","text":"<p>Directory: <code>src/test/java/neqsim/process</code></p> <p>Tests of the dynamic process models and process equipment. Examples include separator, compressor and process controller behaviour.</p>"},{"location":"wiki/test-overview/#physical-properties-and-fluid-mechanics","title":"Physical properties and fluid mechanics","text":"<p>Directories: - <code>src/test/java/neqsim/physicalproperties</code> - <code>src/test/java/neqsim/fluidmechanics</code></p> <p>Focus on methods for viscosity, density and other property models together with flow system calculations.</p>"},{"location":"wiki/test-overview/#chemical-reactions-and-thermo","title":"Chemical reactions and thermo","text":"<p>Directories: - <code>src/test/java/neqsim/chemicalreactions</code> - <code>src/test/java/neqsim/thermo</code></p> <p>Verify reaction models and the underlying thermodynamic phase implementations.</p>"},{"location":"wiki/test-overview/#utilities-statistics-and-standards","title":"Utilities, statistics and standards","text":"<p>Directories: - <code>src/test/java/neqsim/util</code> - <code>src/test/java/neqsim/statistics</code> - <code>src/test/java/neqsim/standards</code></p> <p>Contain unit tests for helper utilities (database connectors, units), statistical calculations and implementation of industry standards.</p>"},{"location":"wiki/test-overview/#running-the-tests","title":"Running the tests","text":"<p>All tests can be executed with Maven:</p> <pre><code>mvn test\n</code></pre> <p>Use the Maven wrapper (<code>./mvnw test</code>) when Maven is not installed. To run a specific test class you can supply the class name:</p> <pre><code>mvn -Dtest=ClassName test\n</code></pre> <p>A code coverage report can be produced using Jacoco:</p> <pre><code>mvn jacoco:prepare-agent test install jacoco:report\n</code></pre> <p>The resulting report is written to <code>target/site/jacoco/index.html</code>.</p>"},{"location":"wiki/thermodynamics_guide/","title":"NeqSim Thermodynamics Guide","text":"<p>NeqSim (Non-Equilibrium Simulator) is a comprehensive library for thermodynamic calculations, specializing in oil and gas fluids, CO2 systems, and aqueous electrolytes. This guide provides an overview of the available models, methods, and how to use them.</p>"},{"location":"wiki/thermodynamics_guide/#1-thermodynamic-models-equations-of-state","title":"1. Thermodynamic Models (Equations of State)","text":"<p>The core of any simulation is the Equation of State (EOS). NeqSim supports a wide range of EOSs tailored for different applications.</p>"},{"location":"wiki/thermodynamics_guide/#11-cubic-equations-of-state","title":"1.1 Cubic Equations of State","text":"<p>Standard models for oil and gas processing. *   SRK (Soave-Redlich-Kwong): <code>SystemSrkEos</code>. The industry standard for general hydrocarbon systems. *   PR (Peng-Robinson): <code>SystemPrEos</code>. Often preferred for reservoir engineering and density predictions. *   Modifications:     *   Peneloux Volume Correction: Improves liquid density predictions (<code>SystemSrkPenelouxEos</code>).     *   Twu-Coon: Improved alpha functions for polar components.</p>"},{"location":"wiki/thermodynamics_guide/#12-cubic-plus-association-cpa","title":"1.2 Cubic Plus Association (CPA)","text":"<p>Essential for systems containing polar molecules (water, methanol, glycol) and hydrocarbons. It combines a cubic EOS (SRK or PR) with an association term (Wertheim). *   SRK-CPA: <code>SystemSrkCPAstatoil</code>. Recommended for gas-hydrate inhibition (MEG/MeOH) and water-hydrocarbon VLE/LLE. *   PR-CPA: <code>SystemPrCPA</code>.</p>"},{"location":"wiki/thermodynamics_guide/#13-reference-equations","title":"1.3 Reference Equations","text":"<p>High-precision multiparameter equations for specific fluids or mixtures. *   GERG-2008: <code>SystemGERG2008Eos</code>. The ISO standard for natural gas properties. Excellent for custody transfer and density calculation. *   Span-Wagner: <code>SystemSpanWagnerEos</code>. High-precision EOS for pure CO2. *   IAPWS-IF97: <code>SystemWaterIF97</code>. Industrial standard for water and steam.</p>"},{"location":"wiki/thermodynamics_guide/#14-electrolyte-models","title":"1.4 Electrolyte Models","text":"<p>For systems containing salts and ions. *   Electrolyte CPA: <code>SystemElectrolyteCPAstatoil</code>. Extends CPA to handle salt solubility and the effect of ions on phase equilibria. *   Furst-Renon: <code>SystemFurstElectrolyteEos</code>.</p>"},{"location":"wiki/thermodynamics_guide/#2-mixing-rules","title":"2. Mixing Rules","text":"<p>Mixing rules define how pure component parameters are combined for mixtures.</p> <ul> <li>Classic (van der Waals): The default for non-polar hydrocarbon mixtures.<ul> <li><code>system.setMixingRule(\"classic\")</code> or <code>system.setMixingRule(2)</code></li> </ul> </li> <li>Huron-Vidal (HV): Uses excess Gibbs energy models (like NRTL) to handle non-ideal mixtures.<ul> <li><code>system.setMixingRule(\"HV\", \"NRTL\")</code></li> </ul> </li> <li>Wong-Sandler (WS): Another advanced mixing rule for highly non-ideal systems.</li> </ul>"},{"location":"wiki/thermodynamics_guide/#3-flash-calculations","title":"3. Flash Calculations","text":"<p>NeqSim performs various types of equilibrium calculations (flashes) via the <code>ThermodynamicOperations</code> class.</p>"},{"location":"wiki/thermodynamics_guide/#31-standard-flashes","title":"3.1 Standard Flashes","text":"<ul> <li>TP Flash (Temperature-Pressure): Calculates phase distribution at fixed T and P.<ul> <li><code>ops.TPflash()</code></li> </ul> </li> <li>PH Flash (Pressure-Enthalpy): Used for isenthalpic processes (e.g., valves, throttling).<ul> <li><code>ops.PHflash(enthalpy, unit)</code></li> </ul> </li> <li>PS Flash (Pressure-Entropy): Used for isentropic processes (e.g., compressors, expanders).<ul> <li><code>ops.PSflash(entropy, unit)</code></li> </ul> </li> </ul>"},{"location":"wiki/thermodynamics_guide/#32-saturation-points","title":"3.2 Saturation Points","text":"<ul> <li>Bubble Point: <code>ops.bubblePointPressureFlash(false)</code> or <code>ops.bubblePointTemperatureFlash()</code></li> <li>Dew Point: <code>ops.dewPointPressureFlash()</code> or <code>ops.dewPointTemperatureFlash()</code></li> <li>Water Dew Point: <code>ops.waterDewPointTemperatureFlash()</code></li> </ul>"},{"location":"wiki/thermodynamics_guide/#33-solid-formation","title":"3.3 Solid Formation","text":"<ul> <li>Hydrates: Calculates hydrate formation temperature/pressure and inhibitor requirements.<ul> <li><code>ops.hydrateFormationTemperatureFlash()</code></li> </ul> </li> <li>Wax: Wax Appearance Temperature (WAT).<ul> <li><code>ops.calcWAT()</code></li> </ul> </li> <li>Scale: Mineral scale precipitation potential.<ul> <li><code>ops.checkScalePotential(phaseNumber)</code></li> </ul> </li> </ul>"},{"location":"wiki/thermodynamics_guide/#4-physical-properties","title":"4. Physical Properties","text":"<p>Once a flash is performed, physical properties are available from the <code>Phase</code> objects.</p> <ul> <li>Density: <code>phase.getDensity(\"kg/m3\")</code></li> <li>Viscosity: <code>phase.getViscosity(\"kg/msec\")</code>. See Viscosity Models.</li> <li>Thermal Conductivity: <code>phase.getThermalConductivity(\"W/mK\")</code></li> <li>Surface Tension: <code>system.getInterfacialTension(phase1, phase2)</code></li> <li>Heat Capacity (Cp/Cv): <code>phase.getCp()</code>, <code>phase.getCv()</code></li> </ul>"},{"location":"wiki/thermodynamics_guide/#5-code-examples","title":"5. Code Examples","text":""},{"location":"wiki/thermodynamics_guide/#java-example-natural-gas-dew-point","title":"Java Example: Natural Gas Dew Point","text":"<pre><code>import neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class DewPointExample {\n    public static void main(String[] args) {\n        // 1. Create System\n        SystemSrkEos gas = new SystemSrkEos(298.15, 50.0);\n        gas.addComponent(\"methane\", 90.0);\n        gas.addComponent(\"ethane\", 5.0);\n        gas.addComponent(\"propane\", 3.0);\n        gas.addComponent(\"water\", 0.1); // Saturated water\n\n        // 2. Set Mixing Rule\n        gas.setMixingRule(\"classic\");\n\n        // 3. Initialize Operations\n        ThermodynamicOperations ops = new ThermodynamicOperations(gas);\n\n        // 4. Calculate Hydrocarbon Dew Point\n        try {\n            ops.dewPointTemperatureFlash();\n            System.out.println(\"HC Dew Point: \" + gas.getTemperature(\"C\") + \" C\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 5. Calculate Water Dew Point\n        try {\n            ops.waterDewPointTemperatureFlash();\n            System.out.println(\"Water Dew Point: \" + gas.getTemperature(\"C\") + \" C\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"wiki/thermodynamics_guide/#python-example-co2-density-with-gerg-2008","title":"Python Example: CO2 Density with GERG-2008","text":"<pre><code>from neqsim.thermo import SystemGERG2008Eos\nfrom neqsim.thermodynamicoperations import ThermodynamicOperations\n\n# 1. Create System\nco2 = SystemGERG2008Eos(300.0, 100.0) # 300 K, 100 bar\nco2.addComponent(\"CO2\", 1.0)\n\n# 2. Flash\nops = ThermodynamicOperations(co2)\nops.TPflash()\n\n# 3. Get Properties\nrho = co2.getPhase(0).getDensity(\"kg/m3\")\nprint(f\"CO2 Density at 100 bar/300 K: {rho} kg/m3\")\n</code></pre>"},{"location":"wiki/thermodynamics_guide/#6-fluid-characterization","title":"6. Fluid Characterization","text":"<p>For real reservoir fluids containing heavy fractions (C7+), NeqSim provides tools to characterize the fluid based on specific gravity and molecular weight.</p> <ul> <li>Plus Fractions: Use <code>system.addTBPfraction()</code> or <code>system.addPlusFraction()</code>.</li> <li>Lumping: Reduce the number of components for faster simulation using <code>ModelLumping</code>.</li> </ul>"},{"location":"wiki/thermodynamics_guide/#advanced-options","title":"Advanced Options","text":"<ul> <li>Heavy Oil: For very heavy oils, use <code>setPlusFractionModel(\"Pedersen Heavy Oil\")</code>.</li> <li>Whitson Gamma: Use <code>setPlusFractionModel(\"Whitson Gamma\")</code> if you have specific gamma distribution parameters.</li> <li>No Lumping: To keep all individual carbon number components (C6, C7... C80), use <code>setLumpingModel(\"no lumping\")</code>.</li> </ul> <p>See Fluid Characterization for details.</p>"},{"location":"wiki/transient_multiphase_pipe/","title":"Transient Multiphase Pipe Model","text":""},{"location":"wiki/transient_multiphase_pipe/#overview","title":"Overview","text":"<p>The <code>TransientPipe</code> class provides a 1D transient multiphase (gas-liquid) flow simulator for pipelines. It uses the drift-flux formulation combined with mechanistic flow regime detection to model complex phenomena like terrain-induced slugging, liquid accumulation at low points, and transient pressure wave propagation.</p> <p>The model supports: - Two-phase flow: Gas + oil or gas + water - Three-phase flow: Gas + oil + water with volume-weighted liquid property averaging</p>"},{"location":"wiki/transient_multiphase_pipe/#key-features","title":"Key Features","text":"<ul> <li>Drift-Flux Model: Zuber-Findlay formulation with regime-dependent correlations</li> <li>Flow Regime Detection: Taitel-Dukler and Barnea mechanistic models</li> <li>Terrain Effects: Liquid accumulation at low points, terrain-induced slugging</li> <li>Lagrangian Slug Tracking: Individual slug units with growth/decay dynamics</li> <li>Adaptive Time Stepping: CFL-based stability control</li> <li>NeqSim Integration: Periodic thermodynamic flash updates using SRK, PR, or CPA equations of state</li> </ul>"},{"location":"wiki/transient_multiphase_pipe/#physical-models","title":"Physical Models","text":""},{"location":"wiki/transient_multiphase_pipe/#drift-flux-model","title":"Drift-Flux Model","text":"<p>The core model uses the Zuber-Findlay drift-flux formulation:</p> <pre><code>v_G = C\u2080 \u00b7 v_m + v_d\n</code></pre> <p>Where: - <code>v_G</code> = gas velocity (m/s) - <code>C\u2080</code> = distribution coefficient (typically 1.0-1.2) - <code>v_m</code> = mixture velocity (m/s) - <code>v_d</code> = drift velocity (m/s)</p> <p>The distribution coefficient <code>C\u2080</code> and drift velocity <code>v_d</code> depend on the flow regime:</p> Flow Regime C\u2080 Drift Velocity Correlation Bubble 1.2 Harmathy (1960) Slug 1.05-1.2 (Fr dependent) Bendiksen (1984) Annular 1.0 Film drainage model Stratified Calculated from momentum balance ~0"},{"location":"wiki/transient_multiphase_pipe/#three-phase-flow-handling","title":"Three-Phase Flow Handling","text":"<p>When both oil and aqueous (water) liquid phases are present, the model calculates volume-weighted average liquid properties:</p> <pre><code>\u03c1_L,avg = (V_oil / V_total) \u00d7 \u03c1_oil + (V_water / V_total) \u00d7 \u03c1_water\n\u03bc_L,avg = (V_oil / V_total) \u00d7 \u03bc_oil + (V_water / V_total) \u00d7 \u03bc_water\nH_L,avg = (V_oil / V_total) \u00d7 H_oil + (V_water / V_total) \u00d7 H_water\nc_L,avg = (V_oil / V_total) \u00d7 c_oil + (V_water / V_total) \u00d7 c_water\n</code></pre> <p>Where: - <code>V_oil</code>, <code>V_water</code> = volume of oil and water phases from thermodynamic flash - <code>V_total = V_oil + V_water</code> - <code>\u03c1</code>, <code>\u03bc</code>, <code>H</code>, <code>c</code> = density, viscosity, enthalpy, and sound speed</p> <p>This approach maintains the drift-flux framework while properly accounting for oil-water mixtures in the liquid phase. If only one liquid phase is present (oil OR water), that phase's properties are used directly.</p>"},{"location":"wiki/transient_multiphase_pipe/#flow-regime-detection","title":"Flow Regime Detection","text":"<p>The model supports two methods for flow regime detection:</p>"},{"location":"wiki/transient_multiphase_pipe/#mechanistic-approach-default","title":"Mechanistic Approach (Default)","text":"<p>Uses mechanistic criteria to determine the local flow pattern:</p> <ol> <li>Single-Phase Check: If liquid holdup &lt; 0.001 \u2192 Gas; if gas holdup &lt; 0.001 \u2192 Liquid</li> <li>Taitel-Dukler (1976) for horizontal/near-horizontal pipes:</li> <li>Stratified-Slug transition based on Kelvin-Helmholtz stability</li> <li>Uses Lockhart-Martinelli parameter and Froude numbers</li> <li>Barnea (1987) for inclined pipes:</li> <li>Unified model covering all inclinations</li> <li>Bubble-slug transition at void fraction \u2248 0.25</li> <li>Annular transition at high gas velocities</li> </ol>"},{"location":"wiki/transient_multiphase_pipe/#minimum-slip-criterion","title":"Minimum Slip Criterion","text":"<p>An alternative approach that selects the flow regime with the minimum slip ratio (closest to 1.0, i.e., homogeneous flow). This is based on the principle that the physical system naturally tends toward the flow pattern with minimum phase velocity difference.</p> <pre><code>FlowRegimeDetector detector = new FlowRegimeDetector();\n\n// Enable minimum slip criterion\ndetector.setUseMinimumSlipCriterion(true);\n\n// Or use the detection method enum\ndetector.setDetectionMethod(FlowRegimeDetector.DetectionMethod.MINIMUM_SLIP);\n\n// Detect flow regime\nFlowRegime regime = detector.detectFlowRegime(section);\n</code></pre> <p>The minimum slip criterion evaluates orientation-appropriate candidate regimes: - Horizontal pipes: Stratified (smooth/wavy), Slug, Annular, Dispersed Bubble - Upward inclined: Bubble, Slug, Churn, Annular, Dispersed Bubble - Downward inclined: Stratified (smooth/wavy), Slug, Annular</p>"},{"location":"wiki/transient_multiphase_pipe/#numerical-method","title":"Numerical Method","text":"<p>The model solves the conservation equations using:</p> <ul> <li>Spatial Discretization: Finite volume method with cell-centered values</li> <li>Flux Calculation: AUSM+ (Advection Upstream Splitting Method) scheme</li> <li>Time Integration: Explicit Euler with adaptive time stepping</li> <li>Stability: CFL condition with default CFL number = 0.5</li> </ul> <p>Conservative variables: <pre><code>U = [\u03c1_G\u00b7\u03b1_G, \u03c1_L\u00b7\u03b1_L, \u03c1_m\u00b7u, \u03c1_m\u00b7e]\n</code></pre></p>"},{"location":"wiki/transient_multiphase_pipe/#quick-start","title":"Quick Start","text":""},{"location":"wiki/transient_multiphase_pipe/#basic-horizontal-pipeline","title":"Basic Horizontal Pipeline","text":"<pre><code>import neqsim.process.equipment.pipeline.twophasepipe.TransientPipe;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create two-phase fluid\nSystemInterface fluid = new SystemSrkEos(300, 50); // 300 K, 50 bar\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"n-pentane\", 0.2);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\n// Create inlet stream\nStream inlet = new Stream(\"inlet\", fluid);\ninlet.setFlowRate(5, \"kg/sec\");\ninlet.run();\n\n// Create transient pipe\nTransientPipe pipe = new TransientPipe(\"Pipeline\", inlet);\npipe.setLength(1000);          // 1000 m\npipe.setDiameter(0.2);         // 200 mm\npipe.setRoughness(0.00005);    // 50 \u03bcm\npipe.setNumberOfSections(50);  // 50 cells\npipe.setMaxSimulationTime(60); // 60 seconds\n\n// Run simulation\npipe.run();\n\n// Get results\ndouble[] pressures = pipe.getPressureProfile();\ndouble[] holdups = pipe.getLiquidHoldupProfile();\ndouble[] gasVel = pipe.getGasVelocityProfile();\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#terrain-pipeline-with-low-points","title":"Terrain Pipeline with Low Points","text":"<pre><code>// Create pipe with terrain\nTransientPipe pipe = new TransientPipe(\"TerrainPipe\", inlet);\npipe.setLength(2000);\npipe.setDiameter(0.3);\npipe.setNumberOfSections(40);\npipe.setMaxSimulationTime(300);\n\n// Define elevation profile with a low point\ndouble[] elevations = new double[40];\nfor (int i = 0; i &lt; 40; i++) {\n    double x = i * 50.0; // Position along pipe\n    if (x &lt; 500) {\n        elevations[i] = 0;\n    } else if (x &lt; 1000) {\n        elevations[i] = -20 * (x - 500) / 500; // Downhill to -20m\n    } else if (x &lt; 1500) {\n        elevations[i] = -20 + 20 * (x - 1000) / 500; // Uphill\n    } else {\n        elevations[i] = 0;\n    }\n}\npipe.setElevationProfile(elevations);\n\npipe.run();\n\n// Check for liquid accumulation\nvar accumTracker = pipe.getAccumulationTracker();\nfor (var zone : accumTracker.getAccumulationZones()) {\n    System.out.println(\"Accumulation at position: \" + zone.getPosition());\n    System.out.println(\"Accumulated volume: \" + zone.getAccumulatedVolume() + \" m\u00b3\");\n}\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#vertical-riser","title":"Vertical Riser","text":"<pre><code>TransientPipe riser = new TransientPipe(\"Riser\", inlet);\nriser.setLength(200);\nriser.setDiameter(0.15);\nriser.setNumberOfSections(40);\n\n// Vertical profile\ndouble[] elevations = new double[40];\nfor (int i = 0; i &lt; 40; i++) {\n    elevations[i] = i * 5; // 5m per section\n}\nriser.setElevationProfile(elevations);\n\nriser.run();\n\n// Significant pressure drop due to hydrostatic head\ndouble[] P = riser.getPressureProfile();\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#three-phase-gas-oil-water-flow","title":"Three-Phase Gas-Oil-Water Flow","text":"<pre><code>// Create three-phase fluid\nSystemInterface fluid = new SystemSrkEos(300, 50);\nfluid.addComponent(\"methane\", 0.40);\nfluid.addComponent(\"propane\", 0.10);\nfluid.addComponent(\"n-heptane\", 0.20);\nfluid.addComponent(\"n-octane\", 0.10);\nfluid.addComponent(\"water\", 0.20);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\n// Create stream and pipe\nStream inlet = new Stream(\"inlet\", fluid);\ninlet.setFlowRate(15, \"kg/sec\");\ninlet.run();\n\nTransientPipe pipe = new TransientPipe(\"ThreePhasePipe\", inlet);\npipe.setLength(1000);\npipe.setDiameter(0.25);\npipe.setNumberOfSections(50);\npipe.run();\n\n// The model automatically uses volume-weighted averaging for liquid properties\n// when both oil and aqueous phases are present\ndouble deltaP = P[0] - P[39];\nSystem.out.println(\"Riser pressure drop: \" + deltaP/1e5 + \" bar\");\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#configuration-options","title":"Configuration Options","text":""},{"location":"wiki/transient_multiphase_pipe/#geometry","title":"Geometry","text":"Method Description Default <code>setLength(double)</code> Total pipe length (m) - <code>setDiameter(double)</code> Inner diameter (m) - <code>setRoughness(double)</code> Wall roughness (m) 0.0001 <code>setNumberOfSections(int)</code> Discretization cells 50 <code>setElevationProfile(double[])</code> Elevation at each node (m) null (horizontal) <code>setInclinationProfile(double[])</code> Inclination angles (rad) null"},{"location":"wiki/transient_multiphase_pipe/#simulation-control","title":"Simulation Control","text":"Method Description Default <code>setMaxSimulationTime(double)</code> Total simulation time (s) 3600 <code>setCflNumber(double)</code> CFL number (0.1-1.0) 0.5 <code>setThermodynamicUpdateInterval(int)</code> Flash update frequency 10 <code>setUpdateThermodynamics(boolean)</code> Enable/disable thermo updates true"},{"location":"wiki/transient_multiphase_pipe/#boundary-conditions","title":"Boundary Conditions","text":"<pre><code>// Available boundary condition types\npipe.setInletBoundaryCondition(BoundaryCondition.CONSTANT_FLOW);\npipe.setOutletBoundaryCondition(BoundaryCondition.CONSTANT_PRESSURE);\n\n// Set boundary values\npipe.setInletMassFlow(5.0);           // kg/s\npipe.setOutletPressure(30.0);         // bara\n</code></pre> Type Description <code>CONSTANT_PRESSURE</code> Fixed pressure boundary <code>CONSTANT_FLOW</code> Fixed mass flow rate <code>CONSTANT_VELOCITY</code> Fixed velocity <code>CLOSED</code> No-flow wall"},{"location":"wiki/transient_multiphase_pipe/#output-results","title":"Output Results","text":""},{"location":"wiki/transient_multiphase_pipe/#profile-data","title":"Profile Data","text":"<pre><code>// Spatial profiles at end of simulation\ndouble[] pressure = pipe.getPressureProfile();      // Pa\ndouble[] temperature = pipe.getTemperatureProfile(); // K\ndouble[] liquidHoldup = pipe.getLiquidHoldupProfile(); // fraction\ndouble[] gasVelocity = pipe.getGasVelocityProfile();   // m/s\ndouble[] liquidVelocity = pipe.getLiquidVelocityProfile(); // m/s\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#time-history","title":"Time History","text":"<pre><code>// Pressure history at all locations\ndouble[][] pressureHistory = pipe.getPressureHistory();\n// pressureHistory[time_index][position_index]\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#slug-statistics","title":"Slug Statistics","text":"<pre><code>SlugTracker slugTracker = pipe.getSlugTracker();\n\nint activeSlugCount = slugTracker.getSlugCount();\nint totalGenerated = slugTracker.getTotalSlugsGenerated();\ndouble avgLength = slugTracker.getAverageSlugLength();\ndouble frequency = slugTracker.getSlugFrequency();\n\n// Detailed statistics\nString stats = slugTracker.getStatisticsString();\nSystem.out.println(stats);\n</code></pre> <p>Note: Both <code>TransientPipe</code> (drift-flux) and <code>TwoFluidPipe</code> (two-fluid) use the same <code>SlugTracker</code> and <code>LiquidAccumulationTracker</code> components, but may predict different slug frequencies due to their underlying holdup models. See the Two-Fluid Model documentation for a detailed comparison.</p>"},{"location":"wiki/transient_multiphase_pipe/#accumulation-zones","title":"Accumulation Zones","text":"<pre><code>LiquidAccumulationTracker tracker = pipe.getAccumulationTracker();\n\nfor (var zone : tracker.getAccumulationZones()) {\n    System.out.println(\"Zone position: \" + zone.getPosition() + \" m\");\n    System.out.println(\"Accumulated volume: \" + zone.getAccumulatedVolume() + \" m\u00b3\");\n    System.out.println(\"Current holdup: \" + zone.getCurrentHoldup());\n    System.out.println(\"Is overflowing: \" + zone.isOverflowing());\n}\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#advanced-usage","title":"Advanced Usage","text":""},{"location":"wiki/transient_multiphase_pipe/#custom-flow-regime-detection","title":"Custom Flow Regime Detection","text":"<pre><code>PipeSection[] sections = pipe.getSections();\nFlowRegimeDetector detector = new FlowRegimeDetector();\n\nfor (PipeSection section : sections) {\n    FlowRegime regime = detector.detectFlowRegime(section);\n    System.out.println(\"Position \" + section.getPosition() + \n                       \": \" + regime);\n}\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#drift-flux-analysis","title":"Drift-Flux Analysis","text":"<pre><code>DriftFluxModel model = new DriftFluxModel();\n\nfor (PipeSection section : sections) {\n    DriftFluxParameters params = model.calculateDriftFlux(section);\n\n    System.out.println(\"C0 = \" + params.C0);\n    System.out.println(\"Drift velocity = \" + params.driftVelocity + \" m/s\");\n    System.out.println(\"Void fraction = \" + params.voidFraction);\n    System.out.println(\"Slip ratio = \" + params.slipRatio);\n}\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#accessing-individual-sections","title":"Accessing Individual Sections","text":"<pre><code>PipeSection[] sections = pipe.getSections();\n\nfor (int i = 0; i &lt; sections.length; i++) {\n    PipeSection s = sections[i];\n\n    System.out.printf(\"Section %d (x=%.1f m):%n\", i, s.getPosition());\n    System.out.printf(\"  Pressure: %.2f bar%n\", s.getPressure()/1e5);\n    System.out.printf(\"  Temperature: %.1f K%n\", s.getTemperature());\n    System.out.printf(\"  Liquid holdup: %.3f%n\", s.getLiquidHoldup());\n    System.out.printf(\"  Gas velocity: %.2f m/s%n\", s.getGasVelocity());\n    System.out.printf(\"  Liquid velocity: %.2f m/s%n\", s.getLiquidVelocity());\n    System.out.printf(\"  Flow regime: %s%n\", s.getFlowRegime());\n    System.out.printf(\"  Is low point: %b%n\", s.isLowPoint());\n}\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#integration-with-processsystem","title":"Integration with ProcessSystem","text":"<pre><code>import neqsim.process.processmodel.ProcessSystem;\n\nProcessSystem process = new ProcessSystem();\n\n// Add inlet stream\nStream inlet = new Stream(\"inlet\", fluid);\ninlet.setFlowRate(10, \"kg/sec\");\nprocess.add(inlet);\n\n// Add transient pipe\nTransientPipe pipeline = new TransientPipe(\"MainPipeline\", inlet);\npipeline.setLength(5000);\npipeline.setDiameter(0.4);\npipeline.setNumberOfSections(100);\npipeline.setMaxSimulationTime(600);\nprocess.add(pipeline);\n\n// Add downstream equipment\nStream outlet = pipeline.getOutletStream();\n// ... add separators, compressors, etc.\n\nprocess.run();\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#performance-considerations","title":"Performance Considerations","text":""},{"location":"wiki/transient_multiphase_pipe/#spatial-resolution","title":"Spatial Resolution","text":"<ul> <li>Guideline: dx \u2248 10-50 pipe diameters</li> <li>More sections = better accuracy but slower</li> <li>For slug tracking, use at least 20 sections</li> </ul>"},{"location":"wiki/transient_multiphase_pipe/#time-step","title":"Time Step","text":"<ul> <li>Controlled automatically via CFL condition</li> <li>Lower CFL number (e.g., 0.3) for more stability</li> <li>Higher CFL number (e.g., 0.8) for faster simulation</li> </ul>"},{"location":"wiki/transient_multiphase_pipe/#thermodynamic-updates","title":"Thermodynamic Updates","text":"<ul> <li>Flash calculations are expensive</li> <li><code>setThermodynamicUpdateInterval(20)</code> reduces frequency</li> <li>For isothermal flow, use <code>setUpdateThermodynamics(false)</code></li> </ul>"},{"location":"wiki/transient_multiphase_pipe/#flow-regime-definitions","title":"Flow Regime Definitions","text":"Regime Description Typical Conditions <code>SINGLE_PHASE_GAS</code> Gas only \u03b1_L &lt; 0.001 <code>SINGLE_PHASE_LIQUID</code> Liquid only \u03b1_G &lt; 0.001 <code>BUBBLE</code> Discrete bubbles in liquid Low gas velocity, vertical <code>SLUG</code> Alternating liquid slugs and gas bubbles Moderate velocities <code>STRATIFIED_SMOOTH</code> Separated phases, smooth interface Low velocities, horizontal <code>STRATIFIED_WAVY</code> Separated phases, wavy interface Moderate velocities, horizontal <code>ANNULAR</code> Liquid film on wall, gas core High gas velocity <code>CHURN</code> Chaotic, oscillating flow High velocities, vertical"},{"location":"wiki/transient_multiphase_pipe/#troubleshooting","title":"Troubleshooting","text":""},{"location":"wiki/transient_multiphase_pipe/#simulation-instability","title":"Simulation Instability","text":"<p>Symptoms: NaN values, oscillations, crashes</p> <p>Solutions: 1. Reduce CFL number: <code>pipe.setCflNumber(0.3)</code> 2. Increase number of sections 3. Check for unrealistic boundary conditions 4. Verify fluid properties are physical</p>"},{"location":"wiki/transient_multiphase_pipe/#slow-performance","title":"Slow Performance","text":"<p>Solutions: 1. Reduce number of sections 2. Increase thermodynamic update interval 3. Use simpler equation of state 4. Reduce simulation time</p>"},{"location":"wiki/transient_multiphase_pipe/#no-slugs-detected","title":"No Slugs Detected","text":"<p>Possible causes: 1. Flow is single-phase (check inlet conditions) 2. Pipe too short for slug development 3. Velocities outside slug regime 4. No terrain variation (add elevation profile)</p>"},{"location":"wiki/transient_multiphase_pipe/#references","title":"References","text":"<ol> <li> <p>Taitel, Y. and Dukler, A.E. (1976). \"A Model for Predicting Flow Regime Transitions in Horizontal and Near Horizontal Gas-Liquid Flow.\" AIChE Journal, 22(1), 47-55.</p> </li> <li> <p>Barnea, D. (1987). \"A Unified Model for Predicting Flow-Pattern Transitions for the Whole Range of Pipe Inclinations.\" Int. J. Multiphase Flow, 13(1), 1-12.</p> </li> <li> <p>Bendiksen, K.H. (1984). \"An Experimental Investigation of the Motion of Long Bubbles in Inclined Tubes.\" Int. J. Multiphase Flow, 10(4), 467-483.</p> </li> <li> <p>Zuber, N. and Findlay, J.A. (1965). \"Average Volumetric Concentration in Two-Phase Flow Systems.\" J. Heat Transfer, 87(4), 453-468.</p> </li> <li> <p>Harmathy, T.Z. (1960). \"Velocity of Large Drops and Bubbles in Media of Infinite or Restricted Extent.\" AIChE Journal, 6(2), 281-288.</p> </li> </ol>"},{"location":"wiki/transient_multiphase_pipe/#comparison-with-beggs-and-brill-correlation","title":"Comparison with Beggs and Brill Correlation","text":""},{"location":"wiki/transient_multiphase_pipe/#overview_1","title":"Overview","text":"<p>The <code>TransientPipe</code> model uses a different approach than empirical correlations like Beggs and Brill (1973). Understanding these differences helps in selecting the appropriate model for your application.</p>"},{"location":"wiki/transient_multiphase_pipe/#model-comparison","title":"Model Comparison","text":"Aspect TransientPipe Beggs and Brill Approach Mechanistic drift-flux with AUSM+ scheme Empirical correlation from experiments Basis Conservation equations + closure relations ~1500 experimental data points Flow Regimes Taitel-Dukler, Barnea criteria Froude number based map Transient Full transient capability Steady-state only Terrain Section-by-section integration Overall correlation"},{"location":"wiki/transient_multiphase_pipe/#expected-differences","title":"Expected Differences","text":"<p>Comparison tests show significant differences between the models, which is expected given their fundamentally different approaches:</p> Flow Condition Typical Difference Explanation Single-phase gas, horizontal 50-80% Different friction correlations Multiphase horizontal 100-300% Different holdup/slip models Uphill flow (+10\u00b0) 40-60% Hydrostatic term treatment Downhill flow (-10\u00b0) 40-60% Liquid drainage models differ High velocity gas 50-100% Compressibility effects"},{"location":"wiki/transient_multiphase_pipe/#when-to-use-each-model","title":"When to Use Each Model","text":"<p>Use TransientPipe when: - Transient phenomena are important (slugging, pressure waves, startup/shutdown) - Terrain-induced slugging needs to be captured - Liquid accumulation at low points is of interest - Detailed spatial profiles are needed along the pipe - Integration with NeqSim thermodynamics is beneficial</p> <p>Use Beggs and Brill when: - Quick steady-state pressure drop estimates are needed - Conditions are within the empirical correlation's validated range - Simple horizontal or inclined pipe calculations - Historical validation against field data used this correlation</p>"},{"location":"wiki/transient_multiphase_pipe/#validation-approach","title":"Validation Approach","text":"<p>For critical applications, it is recommended to:</p> <ol> <li>Benchmark both models against field data or detailed CFD simulations</li> <li>Understand model assumptions - TransientPipe uses mechanistic closure relations that may need tuning for specific fluids</li> <li>Consider uncertainty bands - differences of 50-100% between models indicate the inherent uncertainty in multiphase flow predictions</li> <li>Use multiple models - consensus from different approaches increases confidence</li> </ol>"},{"location":"wiki/transient_multiphase_pipe/#comparison-test-examples","title":"Comparison Test Examples","text":"<p>NeqSim includes comparison tests in <code>TransientPipeVsBeggsAndBrillsComparisonTest.java</code>:</p> <pre><code>// Example: Comparing models for horizontal multiphase flow\nSystemInterface fluid = new SystemSrkEos(300.0, 50.0);\nfluid.addComponent(\"methane\", 0.8);\nfluid.addComponent(\"n-pentane\", 0.2);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\n// Setup Beggs and Brill\nStream bbStream = new Stream(\"BB_inlet\", fluid);\nbbStream.setFlowRate(2.0, \"kg/sec\");\nbbStream.run();\n\nPipeBeggsAndBrills bb = new PipeBeggsAndBrills(\"BeggsAndBrill\", bbStream);\nbb.setDiameter(0.2);\nbb.setLength(500);\nbb.setAngle(0);\nbb.run();\ndouble dpBeggsBrill = bb.getPressureDrop();\n\n// Setup TransientPipe\nStream tpStream = new Stream(\"TP_inlet\", fluid.clone());\ntpStream.setFlowRate(2.0, \"kg/sec\");\ntpStream.run();\n\nTransientPipe tp = new TransientPipe(\"TransientPipe\", tpStream);\ntp.setLength(500);\ntp.setDiameter(0.2);\ntp.setNumberOfSections(25);\ntp.setMaxSimulationTime(60);\ntp.run();\ndouble[] pressures = tp.getPressureProfile();\ndouble dpTransient = (pressures[0] - pressures[pressures.length - 1]) / 1e5;\n\nSystem.out.println(\"Beggs &amp; Brill: \" + dpBeggsBrill + \" bar\");\nSystem.out.println(\"TransientPipe: \" + dpTransient + \" bar\");\n</code></pre>"},{"location":"wiki/transient_multiphase_pipe/#references-for-model-comparison","title":"References for Model Comparison","text":"<ol> <li> <p>Beggs, H.D. and Brill, J.P. (1973). \"A Study of Two-Phase Flow in Inclined Pipes.\" Journal of Petroleum Technology, 25(5), 607-617.</p> </li> <li> <p>Ishii, M. and Hibiki, T. (2011). Thermo-Fluid Dynamics of Two-Phase Flow. 2<sup>nd</sup> ed. Springer.</p> </li> </ol>"},{"location":"wiki/transient_multiphase_pipe/#see-also","title":"See Also","text":"<ul> <li>Pipe Flow Models</li> <li>Thermodynamic Operations</li> <li>Process Simulation</li> </ul>"},{"location":"wiki/two_fluid_model/","title":"Two-Fluid Transient Multiphase Flow Model","text":"<p>This document describes the two-fluid model implementation in NeqSim for transient multiphase pipeline simulation.</p>"},{"location":"wiki/two_fluid_model/#overview","title":"Overview","text":"<p>The two-fluid model solves separate conservation equations for each phase (gas and liquid), providing more accurate predictions than drift-flux models for:</p> <ul> <li>Countercurrent flow - Phases moving in opposite directions</li> <li>Slug flow dynamics - Formation and propagation of liquid slugs</li> <li>Terrain-induced liquid accumulation - Holdup in low points</li> <li>Transient pressure waves - Fast pressure transients</li> </ul>"},{"location":"wiki/two_fluid_model/#package-structure","title":"Package Structure","text":"<pre><code>neqsim.process.equipment.pipeline.twophasepipe/\n\u251c\u2500\u2500 PipeSection.java              # Base section state container\n\u251c\u2500\u2500 TwoFluidSection.java          # Two-fluid section with conservative variables\n\u251c\u2500\u2500 TwoFluidConservationEquations.java  # PDE RHS calculation\n\u251c\u2500\u2500 ThreeFluidSection.java        # Extension for gas-oil-water systems\n\u251c\u2500\u2500 ThreeFluidConservationEquations.java  # Three-phase equations\n\u251c\u2500\u2500 ThermodynamicCoupling.java    # Flash calculation interface\n\u251c\u2500\u2500 FlashTable.java               # Pre-computed property interpolation\n\u251c\u2500\u2500 EntrainmentDeposition.java    # Droplet exchange model\n\u251c\u2500\u2500 FlowRegimeDetector.java       # Flow pattern determination\n\u251c\u2500\u2500 LiquidAccumulationTracker.java  # Low-point detection\n\u251c\u2500\u2500 SlugTracker.java              # Slug tracking and statistics\n\u251c\u2500\u2500 closure/\n\u2502   \u251c\u2500\u2500 GeometryCalculator.java   # Stratified geometry\n\u2502   \u251c\u2500\u2500 WallFriction.java         # Wall shear correlations\n\u2502   \u2514\u2500\u2500 InterfacialFriction.java  # Interface shear correlations\n\u2514\u2500\u2500 numerics/\n    \u251c\u2500\u2500 TimeIntegrator.java       # Runge-Kutta integration\n    \u251c\u2500\u2500 AUSMPlusFluxCalculator.java  # Flux splitting scheme\n    \u2514\u2500\u2500 MUSCLReconstructor.java   # Higher-order reconstruction\n</code></pre>"},{"location":"wiki/two_fluid_model/#conservation-equations","title":"Conservation Equations","text":"<p>The two-fluid model solves the following 1D PDEs:</p>"},{"location":"wiki/two_fluid_model/#mass-conservation","title":"Mass Conservation","text":"<p>Gas phase: <pre><code>\u2202/\u2202t(\u03b1g\u00b7\u03c1g\u00b7A) + \u2202/\u2202x(\u03b1g\u00b7\u03c1g\u00b7ug\u00b7A) = \u0393g\n</code></pre></p> <p>Liquid phase: <pre><code>\u2202/\u2202t(\u03b1L\u00b7\u03c1L\u00b7A) + \u2202/\u2202x(\u03b1L\u00b7\u03c1L\u00b7uL\u00b7A) = \u0393L\n</code></pre></p> <p>Where: - <code>\u03b1g</code>, <code>\u03b1L</code> = Gas and liquid holdups (volume fractions) - <code>\u03c1g</code>, <code>\u03c1L</code> = Phase densities - <code>ug</code>, <code>uL</code> = Phase velocities - <code>\u0393</code> = Mass transfer rate (evaporation/condensation) - <code>A</code> = Pipe cross-sectional area</p>"},{"location":"wiki/two_fluid_model/#momentum-conservation","title":"Momentum Conservation","text":"<p>Gas phase: <pre><code>\u2202/\u2202t(\u03b1g\u00b7\u03c1g\u00b7ug\u00b7A) + \u2202/\u2202x(\u03b1g\u00b7\u03c1g\u00b7ug\u00b2\u00b7A + \u03b1g\u00b7P\u00b7A) = \n    -\u03c4wg\u00b7Swg - \u03c4i\u00b7Si + \u03b1g\u00b7\u03c1g\u00b7g\u00b7sin(\u03b8)\u00b7A\n</code></pre></p> <p>Liquid phase: <pre><code>\u2202/\u2202t(\u03b1L\u00b7\u03c1L\u00b7uL\u00b7A) + \u2202/\u2202x(\u03b1L\u00b7\u03c1L\u00b7uL\u00b2\u00b7A + \u03b1L\u00b7P\u00b7A) = \n    -\u03c4wL\u00b7SwL + \u03c4i\u00b7Si + \u03b1L\u00b7\u03c1L\u00b7g\u00b7sin(\u03b8)\u00b7A\n</code></pre></p> <p>Where: - <code>\u03c4wg</code>, <code>\u03c4wL</code> = Wall shear stresses - <code>\u03c4i</code> = Interfacial shear stress - <code>Swg</code>, <code>SwL</code>, <code>Si</code> = Wetted perimeters - <code>\u03b8</code> = Pipe inclination angle</p>"},{"location":"wiki/two_fluid_model/#energy-conservation-optional","title":"Energy Conservation (Optional)","text":"<pre><code>\u2202/\u2202t(E\u00b7A) + \u2202/\u2202x((E + P)\u00b7um\u00b7A) = Q - W\n</code></pre>"},{"location":"wiki/two_fluid_model/#heat-transfer-to-surroundings","title":"Heat Transfer to Surroundings","text":"<p>The model supports configurable heat transfer from the pipe wall using Newton's law of cooling:</p> <pre><code>Q_wall = U \u00d7 \u03c0 \u00d7 D \u00d7 (T_surface - T_fluid)  [W/m]\n</code></pre> <p>Where: - <code>U</code> = Overall heat transfer coefficient [W/(m\u00b2\u00b7K)] - <code>D</code> = Pipe diameter [m] - <code>T_surface</code> = Ambient/seabed temperature [K] - <code>T_fluid</code> = Fluid mixture temperature [K]</p> <p>API: <pre><code>pipe.setSurfaceTemperature(5.0, \"C\");      // Seabed at 5\u00b0C\npipe.setHeatTransferCoefficient(25.0);     // 25 W/(m\u00b2\u00b7K)\n</code></pre></p> <p>Typical U-values: | Condition | U [W/(m\u00b2\u00b7K)] | |-----------|------------| | Insulated subsea | 5-15 | | Uninsulated subsea | 20-30 | | Buried onshore | 2-5 | | Exposed onshore | 50-100 |</p>"},{"location":"wiki/two_fluid_model/#insulation-type-presets","title":"Insulation Type Presets","text":"<p>Convenience method for setting heat transfer coefficient based on insulation type:</p> <pre><code>pipe.setInsulationType(TwoFluidPipe.InsulationType.PU_FOAM);  // 10 W/(m\u00b2\u00b7K)\n</code></pre> <p>Available presets: | InsulationType | U [W/(m\u00b2\u00b7K)] | Description | |----------------|-------------|-------------| | <code>NONE</code> | 150 | Bare steel in seawater | | <code>UNINSULATED_SUBSEA</code> | 25 | Typical bare subsea pipe | | <code>PU_FOAM</code> | 10 | Standard PU foam insulation | | <code>MULTI_LAYER</code> | 5 | Multi-layer insulation | | <code>PIPE_IN_PIPE</code> | 2 | Pipe-in-pipe system | | <code>VIT</code> | 0.5 | Vacuum insulated tubing | | <code>BURIED_ONSHORE</code> | 3 | Buried onshore pipeline | | <code>EXPOSED_ONSHORE</code> | 75 | Wind-cooled exposed pipe |</p>"},{"location":"wiki/two_fluid_model/#variable-heat-transfer-profile","title":"Variable Heat Transfer Profile","text":"<p>Support for different U-values along the pipe (e.g., buried vs exposed sections):</p> <pre><code>double[] htcProfile = new double[numSections];\nfor (int i = 0; i &lt; numSections; i++) {\n    htcProfile[i] = (i &lt; 10) ? 5.0 : 50.0;  // First 1 km insulated, rest exposed\n}\npipe.setHeatTransferProfile(htcProfile);\n</code></pre>"},{"location":"wiki/two_fluid_model/#soil-thermal-resistance","title":"Soil Thermal Resistance","text":"<p>For buried pipelines, add soil thermal resistance:</p> <pre><code>pipe.setSoilThermalResistance(0.5);  // m\u00b2\u00b7K/W\n// Effective U = 1 / (1/U + R_soil)\n</code></pre>"},{"location":"wiki/two_fluid_model/#joule-thomson-effect","title":"Joule-Thomson Effect","text":"<p>Temperature change from pressure drop (enabled by default):</p> <pre><code>pipe.setEnableJouleThomson(true);   // Enable J-T cooling\n// dT = \u03bc_JT \u00d7 dP (typical: 0.4 K/bar for natural gas)\n</code></pre>"},{"location":"wiki/two_fluid_model/#pipe-wall-thermal-mass","title":"Pipe Wall Thermal Mass","text":"<p>For transient simulations, configure pipe wall properties:</p> <pre><code>pipe.setWallProperties(0.025, 7850.0, 500.0);  // 25mm steel wall\n// Parameters: thickness [m], density [kg/m\u00b3], heat capacity [J/(kg\u00b7K)]\n</code></pre>"},{"location":"wiki/two_fluid_model/#hydrate-and-wax-risk-monitoring","title":"Hydrate and Wax Risk Monitoring","text":"<p>Monitor for flow assurance issues:</p> <pre><code>pipe.setHydrateFormationTemperature(10.0, \"C\");\npipe.setWaxAppearanceTemperature(25.0, \"C\");\npipe.run();\n\nif (pipe.hasHydrateRisk()) {\n    int section = pipe.getFirstHydrateRiskSection();\n    double distance = pipe.getDistanceToHydrateRisk();\n    System.out.println(\"Hydrate risk at \" + distance + \" m\");\n}\n</code></pre>"},{"location":"wiki/two_fluid_model/#temperature-profile-with-units","title":"Temperature Profile with Units","text":"<p>Get temperature profile in different units:</p> <pre><code>double[] tempK = pipe.getTemperatureProfile(\"K\");   // Kelvin\ndouble[] tempC = pipe.getTemperatureProfile(\"C\");   // Celsius\ndouble[] tempF = pipe.getTemperatureProfile(\"F\");   // Fahrenheit\n</code></pre>"},{"location":"wiki/two_fluid_model/#closure-relations","title":"Closure Relations","text":""},{"location":"wiki/two_fluid_model/#flow-regime-detection","title":"Flow Regime Detection","text":"<p>The <code>FlowRegimeDetector</code> uses Taitel-Dukler maps to identify: - Stratified smooth/wavy - Intermittent (slug/plug) - Annular/mist - Dispersed bubble - Churn</p> <p>Two detection methods are available:</p> <pre><code>FlowRegimeDetector detector = new FlowRegimeDetector();\n\n// Default: Mechanistic approach (Taitel-Dukler, Barnea)\ndetector.setDetectionMethod(FlowRegimeDetector.DetectionMethod.MECHANISTIC);\n\n// Alternative: Minimum slip criterion\ndetector.setDetectionMethod(FlowRegimeDetector.DetectionMethod.MINIMUM_SLIP);\n// or\ndetector.setUseMinimumSlipCriterion(true);\n</code></pre> <p>The minimum slip criterion selects the flow regime that gives the minimum slip ratio (closest to 1.0), based on the principle that the system tends toward the flow pattern with minimum phase velocity difference.</p>"},{"location":"wiki/two_fluid_model/#wall-friction","title":"Wall Friction","text":"<p><code>WallFriction</code> calculates wall shear using: - Laminar: <code>f = 16/Re</code> - Turbulent: Haaland approximation of Colebrook-White - Stratified: Taitel-Dukler with hydraulic diameters</p>"},{"location":"wiki/two_fluid_model/#interfacial-friction","title":"Interfacial Friction","text":"<p>The <code>InterfacialFriction</code> class calculates the shear stress at the gas-liquid interface, which is a critical closure relation for the two-fluid model momentum equations. The interfacial friction affects the slip between phases and pressure drop distribution.</p>"},{"location":"wiki/two_fluid_model/#general-formulation","title":"General Formulation","text":"<p>The interfacial shear stress follows the standard form:</p> <pre><code>\u03c4_i = 0.5 \u00d7 f_i \u00d7 \u03c1_G \u00d7 (v_G - v_L) \u00d7 |v_G - v_L|\n</code></pre> <p>Where: - <code>f_i</code> = interfacial friction factor (dimensionless) - <code>\u03c1_G</code> = gas density (kg/m\u00b3) - <code>v_G - v_L</code> = slip velocity (m/s)</p> <p>The force per unit length appearing in the momentum equations is:</p> <pre><code>F_i = \u03c4_i \u00d7 S_i\n</code></pre> <p>Where <code>S_i</code> is the interfacial perimeter/width per unit length.</p>"},{"location":"wiki/two_fluid_model/#sign-convention","title":"Sign Convention","text":"<p>Positive interfacial shear acts to accelerate the liquid and decelerate the gas (when gas is faster than liquid). In the momentum equations: - Gas momentum: loses <code>\u03c4_i \u00d7 S_i</code> (negative term) - Liquid momentum: gains <code>\u03c4_i \u00d7 S_i</code> (positive term)</p>"},{"location":"wiki/two_fluid_model/#flow-regime-specific-correlations","title":"Flow Regime-Specific Correlations","text":"Flow Regime Correlation Reference Key Features Stratified Smooth Taitel-Dukler (1976) Treats interface as smooth wall; Blasius for turbulent: <code>f = 0.079/Re^0.25</code> Stratified Wavy Andritsos-Hanratty (1987) Wave roughness enhancement: <code>f_i = f_smooth \u00d7 (1 + 15\u221a(h_L/D) \u00d7 (v_G/v_G,t - 1))</code> Annular Wallis (1969) Film-core interaction: <code>f_i = f_G \u00d7 (1 + 300\u03b4/D)</code> where \u03b4 is film thickness Slug Oliemans (1986) Bubble swarm approach with Ishii-Zuber drag coefficient Bubble/Dispersed Schiller-Naumann - Drag on individual bubbles: <code>C_D = (24/Re_b) \u00d7 (1 + 0.15 \u00d7 Re_b^0.687)</code> for Re &lt; 1000 Churn Enhanced Annular - Uses annular correlation with 1.5\u00d7 enhancement factor"},{"location":"wiki/two_fluid_model/#stratified-smooth-flow-taitel-dukler-1976","title":"Stratified Smooth Flow (Taitel-Dukler 1976)","text":"<p>For smooth stratified flow, the interface is treated as a smooth wall with gas-side friction:</p> <pre><code>// Gas-side Reynolds number\nRe_G = \u03c1_G \u00d7 |v_slip| \u00d7 D_G / \u03bc_G\n\n// Friction factor\nif (Re_G &lt; 2300):\n    f_i = 16 / Re_G           // Laminar\nelse:\n    f_i = 0.079 / Re_G^0.25   // Blasius (turbulent)\n</code></pre>"},{"location":"wiki/two_fluid_model/#stratified-wavy-flow-andritsos-hanratty-1987","title":"Stratified Wavy Flow (Andritsos-Hanratty 1987)","text":"<p>Accounts for wave-induced roughness at the interface:</p> <pre><code>// Transition gas velocity\nv_G,t = 5.0 \u00d7 \u221a(\u03c1_L / \u03c1_G)\n\n// Enhancement factor (for v_G &gt; v_G,t)\nenhancement = 1.0 + 15 \u00d7 \u221a(h_L/D) \u00d7 (v_G/v_G,t - 1)\nenhancement = min(enhancement, 20.0)  // Cap\n\nf_i = f_smooth \u00d7 enhancement\n</code></pre>"},{"location":"wiki/two_fluid_model/#annular-flow-wallis-1969","title":"Annular Flow (Wallis 1969)","text":"<p>For gas-core / liquid-film interaction:</p> <pre><code>// Film thickness\n\u03b4 = D/2 \u00d7 (1 - \u221a(1 - \u03b1_L))\n\n// Core diameter\nD_core = D - 2\u03b4\n\n// Wallis enhancement\nenhancement = 1.0 + 300 \u00d7 \u03b4/D\nenhancement = min(enhancement, 50.0)  // Cap\n\nf_i = f_G \u00d7 enhancement\n</code></pre>"},{"location":"wiki/two_fluid_model/#bubbledispersed-flow-schiller-naumann","title":"Bubble/Dispersed Flow (Schiller-Naumann)","text":"<p>For drag on individual bubbles in liquid continuum:</p> <pre><code>// Bubble diameter (Hinze correlation)\nd_b = 2 \u00d7 (0.725 \u00d7 \u03c3 / ((\u03c1_L - \u03c1_G) \u00d7 g))^0.5\nd_b = min(d_b, D/5)\n\n// Bubble Reynolds number\nRe_b = \u03c1_L \u00d7 |v_slip| \u00d7 d_b / \u03bc_L\n\n// Drag coefficient\nif (Re_b &lt; 0.1):\n    C_D = 240           // Stokes limit\nelse if (Re_b &lt; 1000):\n    C_D = 24/Re_b \u00d7 (1 + 0.15 \u00d7 Re_b^0.687)\nelse:\n    C_D = 0.44          // Newton regime\n\n// Friction factor\nf_i = C_D \u00d7 d_b / (4 \u00d7 D)\n</code></pre>"},{"location":"wiki/two_fluid_model/#usage-example","title":"Usage Example","text":"<pre><code>InterfacialFriction interfacialFriction = new InterfacialFriction();\n\nInterfacialFrictionResult result = interfacialFriction.calculate(\n    FlowRegime.STRATIFIED_WAVY,\n    gasVelocity,        // m/s\n    liquidVelocity,     // m/s\n    gasDensity,         // kg/m\u00b3\n    liquidDensity,      // kg/m\u00b3\n    gasViscosity,       // Pa\u00b7s\n    liquidViscosity,    // Pa\u00b7s\n    liquidHoldup,       // 0-1\n    diameter,           // m\n    surfaceTension      // N/m\n);\n\ndouble shearStress = result.interfacialShear;           // Pa\ndouble frictionFactor = result.frictionFactor;          // dimensionless\ndouble slipVelocity = result.slipVelocity;              // m/s\ndouble interfacialArea = result.interfacialAreaPerLength;  // m\u00b2/m\n</code></pre>"},{"location":"wiki/two_fluid_model/#oil-water-interfacial-friction-three-phase","title":"Oil-Water Interfacial Friction (Three-Phase)","text":"<p>For three-phase gas-oil-water systems, the <code>ThreeFluidConservationEquations</code> uses a simplified Froude-based correlation for oil-water interfaces:</p> <pre><code>// Froude number based on relative velocity\nFr = |v_rel| / \u221a(g \u00d7 D \u00d7 |\u03c1_2 - \u03c1_1| / \u03c1_1)\n\n// Simplified correlation\nf_i = 0.01 \u00d7 (1 + 10 \u00d7 Fr\u00b2)    // capped at 0.1\n</code></pre> <p>This simplified approach is justified because: - Oil-water density differences are much smaller than gas-liquid (~1.0-1.2 vs 100-1000) - Slip velocities are typically lower - Wave formation is less pronounced</p> <p>The three-layer stratified geometry has two interfaces:</p> <pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502      Gas        \u2502  \u2190 \u03c4_wall,G + \u03c4_i,GO (gas-oil)\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502      Oil        \u2502  \u2190 \u03c4_wall,O + \u03c4_i,GO + \u03c4_i,OW\n    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n    \u2502     Water       \u2502  \u2190 \u03c4_wall,W + \u03c4_i,OW (oil-water)\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Momentum exchange: - Gas gains/loses momentum via gas-oil interface (\u03c4_i,GO) - Oil exchanges momentum with both gas (above) and water (below) - Water gains/loses momentum via oil-water interface (\u03c4_i,OW)</p>"},{"location":"wiki/two_fluid_model/#stratified-geometry","title":"Stratified Geometry","text":"<p><code>GeometryCalculator</code> computes for stratified flow: - Liquid level from holdup - Wetted perimeters (gas, liquid, interface) - Hydraulic diameters - Cross-sectional areas</p>"},{"location":"wiki/two_fluid_model/#numerical-methods","title":"Numerical Methods","text":""},{"location":"wiki/two_fluid_model/#spatial-discretization","title":"Spatial Discretization","text":"<p>The <code>AUSMPlusFluxCalculator</code> implements AUSM+ flux splitting for: - Pressure-velocity coupling - Shock capturing - Low diffusion</p>"},{"location":"wiki/two_fluid_model/#temporal-integration","title":"Temporal Integration","text":"<p><code>TimeIntegrator</code> supports: - Forward Euler - RK2 (Heun's method) - RK4 (Classical 4<sup>th</sup> order) - SSPRK3 (Strong stability preserving)</p>"},{"location":"wiki/two_fluid_model/#higher-order-reconstruction","title":"Higher-Order Reconstruction","text":"<p><code>MUSCLReconstructor</code> provides: - Piecewise linear reconstruction - Minmod, van Leer, superbee limiters - Second-order accuracy in smooth regions</p>"},{"location":"wiki/two_fluid_model/#thermodynamic-coupling","title":"Thermodynamic Coupling","text":""},{"location":"wiki/two_fluid_model/#flash-calculations","title":"Flash Calculations","text":"<p><code>ThermodynamicCoupling</code> interfaces with NeqSim's flash routines: <pre><code>ThermodynamicCoupling coupling = new ThermodynamicCoupling(referenceFluid);\nThermoProperties props = coupling.flashPT(pressure, temperature);\n</code></pre></p>"},{"location":"wiki/two_fluid_model/#flash-tables","title":"Flash Tables","text":"<p><code>FlashTable</code> provides fast property lookup via bilinear interpolation: <pre><code>FlashTable table = new FlashTable();\ntable.build(fluid, pMin, pMax, nP, tMin, tMax, nT);\nThermoProperties props = table.interpolate(pressure, temperature);\n</code></pre></p>"},{"location":"wiki/two_fluid_model/#three-phase-extension","title":"Three-Phase Extension","text":"<p>For gas-oil-water systems, <code>ThreeFluidSection</code> and <code>ThreeFluidConservationEquations</code> extend the model to 7 equations: - 3 mass conservation (gas, oil, water) - 3 momentum conservation - 1 energy conservation</p>"},{"location":"wiki/two_fluid_model/#three-layer-stratified-geometry","title":"Three-Layer Stratified Geometry","text":"<pre><code>        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502      Gas        \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2190 Gas-Oil Interface\n        \u2502      Oil        \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2190 Oil-Water Interface  \n        \u2502     Water       \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"wiki/two_fluid_model/#simulation-modes-steady-state-vs-transient","title":"Simulation Modes: Steady-State vs Transient","text":"<p>The <code>TwoFluidPipe</code> supports two simulation modes: steady-state initialization via <code>run()</code> and incremental transient simulation via <code>runTransient()</code>.</p>"},{"location":"wiki/two_fluid_model/#steady-state-simulation-run","title":"Steady-State Simulation: <code>run()</code>","text":"<p>The <code>run()</code> method performs a complete steady-state initialization of the pipeline. This is typically called once at the start to establish initial conditions before transient simulation.</p> <p>What happens during <code>run()</code>:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      run(UUID id)                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. initializeSections()                                      \u2502\n\u2502    \u251c\u2500 Create pipe sections with uniform spacing (dx)         \u2502\n\u2502    \u251c\u2500 Flash inlet fluid to get phase properties              \u2502\n\u2502    \u251c\u2500 Initialize all sections with inlet conditions          \u2502\n\u2502    \u251c\u2500 Set elevation/inclination from terrain profile         \u2502\n\u2502    \u251c\u2500 Set outlet pressure boundary condition                 \u2502\n\u2502    \u2514\u2500 Identify liquid accumulation zones                     \u2502\n\u2502                                                              \u2502\n\u2502 2. runSteadyState()                                          \u2502\n\u2502    \u251c\u2500 Iterative solver (max 100 iterations)                  \u2502\n\u2502    \u2502   \u251c\u2500 Update flow regimes for all sections               \u2502\n\u2502    \u2502   \u251c\u2500 Calculate pressure gradient (momentum balance)     \u2502\n\u2502    \u2502   \u251c\u2500 Update local holdups using drift-flux model        \u2502\n\u2502    \u2502   \u2502   \u2514\u2500 Account for terrain effects (low points)       \u2502\n\u2502    \u2502   \u251c\u2500 Update phase velocities from mass conservation     \u2502\n\u2502    \u2502   \u251c\u2500 Update oil/water holdups for three-phase flow      \u2502\n\u2502    \u2502   \u2514\u2500 Update temperature profile (if heat transfer on)   \u2502\n\u2502    \u2514\u2500 Converge when max change &lt; tolerance (1e-4)            \u2502\n\u2502                                                              \u2502\n\u2502 3. updateOutletStream()                                      \u2502\n\u2502    \u251c\u2500 Flash outlet fluid at outlet P, T                      \u2502\n\u2502    \u251c\u2500 Calculate outlet mass flow from section state          \u2502\n\u2502    \u2514\u2500 Set outlet stream properties                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key characteristics: - Fixed inlet conditions: Uses inlet stream pressure, temperature, composition - Iterative convergence: Pressure and holdup profiles converge simultaneously - Terrain-aware holdups: Liquid accumulates at low points - Single call: Establishes initial state for subsequent transient runs</p> <p>Example: <pre><code>TwoFluidPipe pipe = new TwoFluidPipe(\"Pipeline\", inletStream);\npipe.setLength(5000);\npipe.setDiameter(0.3);\npipe.setNumberOfSections(100);\npipe.run();  // Steady-state initialization\n\ndouble[] pressures = pipe.getPressureProfile();\ndouble[] holdups = pipe.getLiquidHoldupProfile();\n</code></pre></p>"},{"location":"wiki/two_fluid_model/#transient-simulation-runtransientdt-id","title":"Transient Simulation: <code>runTransient(dt, id)</code>","text":"<p>The <code>runTransient()</code> method advances the simulation by a specified time step. It solves the full time-dependent conservation equations and is called repeatedly in a loop.</p> <p>What happens during <code>runTransient(dt, id)</code>:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              runTransient(double dt, UUID id)                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1. Calculate stable time step                                \u2502\n\u2502    \u251c\u2500 dt_stable = CFL \u00d7 dx / max(wave_speed)                 \u2502\n\u2502    \u251c\u2500 dt_actual = min(dt, dt_stable)                         \u2502\n\u2502    \u2514\u2500 Determine number of sub-steps                          \u2502\n\u2502                                                              \u2502\n\u2502 2. For each sub-step:                                        \u2502\n\u2502    \u251c\u2500 Update thermodynamics (every N steps)                  \u2502\n\u2502    \u2502   \u2514\u2500 PT flash at each section P, T                      \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Store previous state U_prev                            \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Time integration (RK4 by default)                      \u2502\n\u2502    \u2502   \u251c\u2500 Calculate RHS of conservation equations            \u2502\n\u2502    \u2502   \u2502   \u251c\u2500 Mass fluxes: \u2202(\u03b1\u03c1uA)/\u2202x                        \u2502\n\u2502    \u2502   \u2502   \u251c\u2500 Momentum sources: wall friction, interfacial   \u2502\n\u2502    \u2502   \u2502   \u2502   friction, gravity, pressure gradient          \u2502\n\u2502    \u2502   \u2502   \u2514\u2500 Energy: heat transfer, work terms              \u2502\n\u2502    \u2502   \u2514\u2500 Advance state: U_new = U_prev + dt \u00d7 RHS           \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Validate and correct state                             \u2502\n\u2502    \u2502   \u251c\u2500 Check for NaN/Inf \u2192 revert to previous             \u2502\n\u2502    \u2502   \u251c\u2500 Ensure mass \u2265 0                                    \u2502\n\u2502    \u2502   \u2514\u2500 Limit rate of change (50% per sub-step max)        \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Apply state to sections                                \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Apply pressure gradient (semi-implicit)                \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Apply boundary conditions                              \u2502\n\u2502    \u2502   \u251c\u2500 Inlet: constant flow or constant pressure          \u2502\n\u2502    \u2502   \u2514\u2500 Outlet: constant pressure                          \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Validate section states                                \u2502\n\u2502    \u2502   \u251c\u2500 Fix invalid holdups (NaN, negative)                \u2502\n\u2502    \u2502   \u251c\u2500 Ensure holdup consistency (\u03b1L = \u03b1O + \u03b1W)           \u2502\n\u2502    \u2502   \u2514\u2500 Ensure P, T are positive                           \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Update accumulation tracking (if enabled)              \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u251c\u2500 Update temperature (if heat transfer enabled)          \u2502\n\u2502    \u2502                                                         \u2502\n\u2502    \u2514\u2500 Advance simulation time                                \u2502\n\u2502                                                              \u2502\n\u2502 3. Update outlet stream                                      \u2502\n\u2502                                                              \u2502\n\u2502 4. Update result arrays                                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key characteristics: - Time-accurate: Solves full transient PDEs with proper wave speeds - CFL-limited: Automatically sub-steps for numerical stability - RK4 integration: Fourth-order Runge-Kutta for accuracy - Robust validation: Prevents numerical blow-up with state limiting - Incremental: Can be called repeatedly with different time steps</p> <p>Example: <pre><code>// After steady-state initialization\npipe.run();\n\n// Transient simulation loop\nUUID simId = UUID.randomUUID();\nfor (int step = 0; step &lt; 1000; step++) {\n    // Change boundary conditions if needed\n    if (step == 100) {\n        inletStream.setFlowRate(15.0, \"kg/sec\");  // Flow increase\n        inletStream.run();\n    }\n\n    pipe.runTransient(0.1, simId);  // Advance 0.1 seconds\n\n    // Monitor results\n    double outletFlow = pipe.getOutletMassFlow();\n    double liquidInventory = pipe.getLiquidInventory(\"m3\");\n}\n</code></pre></p>"},{"location":"wiki/two_fluid_model/#integration-with-processsystem","title":"Integration with ProcessSystem","text":"<p>Both methods integrate seamlessly with <code>ProcessSystem</code> for coupled simulations:</p> <pre><code>ProcessSystem process = new ProcessSystem();\nprocess.add(inletStream);\nprocess.add(pipe);\nprocess.add(separator);\n\n// Steady-state initialization\nprocess.run();\n\n// Transient loop\nfor (int t = 0; t &lt; 300; t++) {\n    process.runTransient(1.0, UUID.randomUUID());\n}\n</code></pre>"},{"location":"wiki/two_fluid_model/#comparison-summary","title":"Comparison Summary","text":"Aspect <code>run()</code> <code>runTransient(dt, id)</code> Purpose Initialize steady-state Advance in time Call frequency Once at start Repeatedly in loop Time step N/A (iterative) User-specified + CFL limit Solver Iterative relaxation Runge-Kutta (RK4) Equations Simplified momentum balance Full conservation PDEs Computation Moderate Higher (per call) Use case Initial conditions Dynamic response"},{"location":"wiki/two_fluid_model/#usage-example_1","title":"Usage Example","text":"<pre><code>// Create two-phase fluid\nSystemInterface fluid = new SystemSrkEos(300, 50);\nfluid.addComponent(\"methane\", 0.85);\nfluid.addComponent(\"n-pentane\", 0.15);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\n// Create inlet stream\nStream inlet = new Stream(\"inlet\", fluid);\ninlet.setFlowRate(10, \"kg/sec\");\ninlet.run();\n\n// Create two-fluid pipe\nTwoFluidPipe pipe = new TwoFluidPipe(\"Pipeline\", inlet);\npipe.setLength(5000);        // 5 km\npipe.setDiameter(0.3);       // 300 mm\npipe.setNumberOfSections(100);\n\n// Set terrain profile\ndouble[] elevations = new double[100];\nfor (int i = 0; i &lt; 100; i++) {\n    elevations[i] = 50.0 * Math.sin(i * Math.PI / 50);\n}\npipe.setElevationProfile(elevations);\n\n// Optional: Configure heat transfer to surroundings\npipe.setSurfaceTemperature(5.0, \"C\");      // Seabed at 5\u00b0C\npipe.setHeatTransferCoefficient(25.0);     // 25 W/(m\u00b2\u00b7K)\n\n// Run steady-state initialization\npipe.run();\n\n// Transient simulation\nUUID id = UUID.randomUUID();\nfor (int step = 0; step &lt; 1000; step++) {\n    pipe.runTransient(0.1, id);  // 0.1 second steps\n}\n\n// Get results\ndouble[] pressures = pipe.getPressureProfile();\ndouble[] holdups = pipe.getLiquidHoldupProfile();\ndouble liquidInventory = pipe.getLiquidInventory(\"m3\");\n</code></pre>"},{"location":"wiki/two_fluid_model/#terrain-induced-slug-tracking","title":"Terrain-Induced Slug Tracking","text":"<p>The TwoFluidPipe model includes a comprehensive terrain-induced slug tracking system that detects liquid accumulation at terrain low points and tracks the formation, propagation, and arrival of slugs at the outlet.</p>"},{"location":"wiki/two_fluid_model/#enabling-slug-tracking","title":"Enabling Slug Tracking","text":"<pre><code>TwoFluidPipe pipe = new TwoFluidPipe(\"Pipeline\", inlet);\npipe.setLength(20000);        // 20 km\npipe.setDiameter(0.3);        // 300 mm\npipe.setNumberOfSections(100);\npipe.setElevationProfile(terrain);\n\n// Enable slug tracking\npipe.setEnableSlugTracking(true);\n\n// Optional: Tune accumulation threshold (default 0.25)\npipe.getAccumulationTracker().setCriticalHoldup(0.35);\n</code></pre>"},{"location":"wiki/two_fluid_model/#how-terrain-slugging-works","title":"How Terrain Slugging Works","text":"<p>The slug tracking system consists of two components working together:</p> <ol> <li>LiquidAccumulationTracker: Identifies terrain low points and monitors liquid accumulation</li> <li>SlugTracker: Tracks individual slugs using Lagrangian tracking with Bendiksen velocity correlation</li> </ol> <pre><code>Terrain Profile with Slug Formation:\n\n    Inlet \u2500\u2500\u2500\u2500\u2500\u2510                \u250c\u2500\u2500\u2500\u2500\u2500 Outlet\n               \u2502    Valley      \u2502\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u25b2\n                    \u2502\n            Liquid accumulates here\n            When zone overflows \u2192 slug released\n</code></pre>"},{"location":"wiki/two_fluid_model/#accumulation-zone-detection","title":"Accumulation Zone Detection","text":"<p>The tracker automatically identifies terrain low points where liquid accumulates:</p> <pre><code>// Get accumulation zones after running\nvar zones = pipe.getAccumulationTracker().getAccumulationZones();\n\nfor (var zone : zones) {\n    System.out.println(\"Zone at position: \" + zone.startPosition + \" m\");\n    System.out.println(\"  Volume: \" + zone.liquidVolume + \" m\u00b3\");\n    System.out.println(\"  Max capacity: \" + zone.maxVolume + \" m\u00b3\");\n    System.out.println(\"  Fill fraction: \" + (zone.liquidVolume / zone.maxVolume));\n    System.out.println(\"  Is overflowing: \" + zone.isOverflowing);\n}\n</code></pre>"},{"location":"wiki/two_fluid_model/#slug-statistics","title":"Slug Statistics","text":"<p>Access comprehensive slug statistics after simulation:</p> <pre><code>SlugTracker tracker = pipe.getSlugTracker();\n\n// Summary statistics\nSystem.out.println(\"Slugs generated: \" + tracker.getTotalSlugsGenerated());\nSystem.out.println(\"Slugs merged: \" + tracker.getTotalSlugsMerged());\nSystem.out.println(\"Active slugs: \" + tracker.getSlugs().size());\nSystem.out.println(\"Slugs at outlet: \" + pipe.getOutletSlugCount());\nSystem.out.println(\"Max slug length: \" + tracker.getMaxSlugLength() + \" m\");\nSystem.out.println(\"Avg slug length: \" + tracker.getAverageSlugLength() + \" m\");\nSystem.out.println(\"Slug frequency: \" + tracker.getSlugFrequency() + \" Hz\");\n\n// Detailed per-slug information\nfor (var slug : tracker.getSlugs()) {\n    System.out.println(\"Slug #\" + slug.id);\n    System.out.println(\"  Position: \" + slug.frontPosition + \" m\");\n    System.out.println(\"  Length: \" + slug.slugBodyLength + \" m\");\n    System.out.println(\"  Volume: \" + slug.liquidVolume + \" m\u00b3\");\n    System.out.println(\"  Velocity: \" + slug.frontVelocity + \" m/s\");\n    System.out.println(\"  Age: \" + slug.age + \" s\");\n    System.out.println(\"  Terrain-induced: \" + slug.isTerrainInduced);\n}\n</code></pre>"},{"location":"wiki/two_fluid_model/#complete-slug-tracking-example","title":"Complete Slug Tracking Example","text":"<pre><code>// Create gas-condensate fluid\nSystemInterface fluid = new SystemSrkEos(288.15, 50);\nfluid.addComponent(\"methane\", 0.70);\nfluid.addComponent(\"ethane\", 0.10);\nfluid.addComponent(\"propane\", 0.05);\nfluid.addComponent(\"n-pentane\", 0.10);\nfluid.addComponent(\"n-heptane\", 0.05);\nfluid.setMixingRule(\"classic\");\nfluid.setMultiPhaseCheck(true);\n\nStream inlet = new Stream(\"inlet\", fluid);\ninlet.setFlowRate(15, \"kg/sec\");\ninlet.setTemperature(15, \"C\");\ninlet.setPressure(50, \"bara\");\ninlet.run();\n\n// Create terrain with valleys\ndouble[] terrain = new double[100];\nfor (int i = 0; i &lt; 100; i++) {\n    double x = i * 200.0; // 20 km total\n    double xNorm = x / 20000.0;\n    terrain[i] = -20.0 * Math.exp(-Math.pow((xNorm - 0.4) / 0.1, 2));\n}\n\nTwoFluidPipe pipe = new TwoFluidPipe(\"SlugPipeline\", inlet);\npipe.setLength(20000);\npipe.setDiameter(0.3);\npipe.setNumberOfSections(100);\npipe.setElevationProfile(terrain);\npipe.setEnableSlugTracking(true);\npipe.getAccumulationTracker().setCriticalHoldup(0.35);\n\n// Steady-state initialization\npipe.run();\n\n// Transient simulation (2 hours)\nUUID id = UUID.randomUUID();\ndouble simTime = 2 * 60 * 60; // 2 hours\ndouble dt = 1.0;\nint steps = (int)(simTime / dt);\n\nfor (int i = 0; i &lt; steps; i++) {\n    pipe.runTransient(dt, id);\n\n    // Monitor progress every 15 minutes\n    if (i % 900 == 0 &amp;&amp; i &gt; 0) {\n        System.out.printf(\"Time: %.0f min, Slugs: %d, Outlet: %d%n\",\n            i / 60.0,\n            pipe.getSlugTracker().getTotalSlugsGenerated(),\n            pipe.getOutletSlugCount());\n    }\n}\n\n// Final report\nSystem.out.println(pipe.getSlugTrackingReport());\n</code></pre>"},{"location":"wiki/two_fluid_model/#comparison-with-drift-flux-model-transientpipe","title":"Comparison with Drift-Flux Model (TransientPipe)","text":"<p>Both <code>TwoFluidPipe</code> and <code>TransientPipe</code> use the same slug tracking infrastructure, but predict different slug frequencies due to their underlying physical models:</p> Aspect TwoFluidPipe TransientPipe Physical Model 7-equation two-fluid 4-equation drift-flux Holdup Prediction Lower (mechanistic) Higher (empirical slip) Accumulation Rate Slower Faster Slug Frequency Lower Higher (conservative) Oil-Water Tracking Separate phases Combined liquid Computation Time ~3x slower Faster <p>Typical behavior comparison:</p> Condition TwoFluidPipe TransientPipe Avg liquid holdup 0.25-0.35 0.90-0.95 Zone fill rate 6-15%/hour 70-80% quickly Time to first slug ~2 hours &lt; 1 minute Slug frequency 1 per 1-2 hours 2-3 per minute <p>When to use each:</p> <ul> <li>TwoFluidPipe: Three-phase systems, oil-water separation important, accurate phase slip needed</li> <li>TransientPipe: Conservative slug catcher sizing, faster computation, gas-liquid systems</li> </ul>"},{"location":"wiki/two_fluid_model/#tuning-slug-tracking-parameters","title":"Tuning Slug Tracking Parameters","text":"<pre><code>// Lower critical holdup \u2192 earlier slug initiation\npipe.getAccumulationTracker().setCriticalHoldup(0.20);\n\n// The overflow threshold in LiquidAccumulationTracker determines\n// when accumulated liquid is released as a slug\n// (set to 20% by default for terrain-induced slugging)\n</code></pre>"},{"location":"wiki/two_fluid_model/#integrated-system-example-slug-pipeline-to-separator","title":"Integrated System Example: Slug Pipeline to Separator","text":"<p>A complete example demonstrating a slugging pipeline connected to a choke valve and separator with level control is available in:</p> <p>Example file: <code>examples/neqsim/process/pipeline/SlugPipelineToSeparatorExample.java</code></p> <p>Test file: <code>src/test/java/neqsim/process/equipment/pipeline/SlugPipelineToSeparatorTest.java</code></p>"},{"location":"wiki/two_fluid_model/#system-configuration","title":"System Configuration","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Wellhead   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  Flowline   \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  Choke  \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 Separator \u2502\n\u2502  (Const P)  \u2502     \u2502 TwoFluidPipe\u2502     \u2502  Valve  \u2502     \u2502 (Level    \u2502\n\u2502  80 bara    \u2502     \u2502  3 km       \u2502     \u2502         \u2502     \u2502  Control) \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2502                                    \u2502\n                     Low point                            Level\n                     (Slugging)                          Controller\n</code></pre>"},{"location":"wiki/two_fluid_model/#boundary-conditions","title":"Boundary Conditions","text":"<ul> <li>Pipeline inlet: Stream-connected (constant pressure from wellhead at 80 bara)</li> <li>Pipeline outlet: Constant pressure boundary (55 bara, set by choke valve)</li> <li>Separator outlet: Controlled by PID level controller</li> </ul>"},{"location":"wiki/two_fluid_model/#transient-behavior","title":"Transient Behavior","text":"<p>The TwoFluidPipe model produces realistic transient dynamics:</p> Metric Observed Description Outlet flow variation 577% Flow decreases from 8.0 to 0.46 kg/s during blowdown Pressure range 55-58 bara Outlet pressure stabilizes to boundary value Holdup variation 0.3 \u2192 0.006 Pipeline drains liquid during transient"},{"location":"wiki/two_fluid_model/#key-code-snippet","title":"Key Code Snippet","text":"<pre><code>// Create TwoFluidPipe with stream-connected inlet\nTwoFluidPipe pipeline = new TwoFluidPipe(\"SubseaFlowline\", pipeInlet);\npipeline.setLength(3000.0);  // 3 km\npipeline.setDiameter(0.254); // 10 inch\npipeline.setNumberOfSections(30);\n\n// Set outlet pressure boundary condition\npipeline.setOutletPressure(60.0, \"bara\");\n\n// Terrain with low point for liquid accumulation\ndouble[] elevations = new double[30];\nfor (int i = 0; i &lt; 30; i++) {\n    double x = (i + 1.0) / 30.0;\n    if (x &lt; 0.5) {\n        elevations[i] = -35.0 * x / 0.5;  // Downhill to low point\n    } else {\n        elevations[i] = -35.0 + 85.0 * (x - 0.5) / 0.5;  // Riser to +50m\n    }\n}\npipeline.setElevationProfile(elevations);\n\n// Choke valve between pipeline and separator\nThrottlingValve choke = new ThrottlingValve(\"Choke\", pipeline.getOutletStream());\nchoke.setOutletPressure(55.0);  // bara\n\n// Separator with level control\nSeparator separator = new Separator(\"InletSeparator\");\nseparator.addStream(choke.getOutletStream());\nseparator.setInternalDiameter(2.5);\nseparator.setSeparatorLength(8.0);\n\n// Level controller on liquid outlet valve\nThrottlingValve liquidValve = new ThrottlingValve(\"LiquidValve\", \n    separator.getLiquidOutStream());\nLevelTransmitter levelTT = new LevelTransmitter(\"LT-100\", separator);\nControllerDeviceBaseClass levelController = new ControllerDeviceBaseClass(\"LIC-100\");\nlevelController.setTransmitter(levelTT);\nlevelController.setControllerSetPoint(0.50);  // 50% level\nlevelController.setControllerParameters(1.5, 180.0, 15.0);  // Kp, Ti, Td\nliquidValve.setController(levelController);\n\n// Build process system and run transient\nProcessSystem process = new ProcessSystem();\nprocess.add(pipeInlet);\nprocess.add(pipeline);\nprocess.add(choke);\nprocess.add(separator);\nprocess.add(liquidValve);\n\nprocess.run();  // Initial steady-state\n\n// Transient simulation\nUUID simId = UUID.randomUUID();\nfor (int step = 0; step &lt; 150; step++) {\n    process.runTransient(2.0, simId);\n\n    double pipeOutFlow = pipeline.getOutletStream().getFlowRate(\"kg/sec\");\n    double level = separator.getLiquidLevel();\n    // Track slug arrivals, level variations, etc.\n}\n</code></pre>"},{"location":"wiki/two_fluid_model/#physical-scenario","title":"Physical Scenario","text":"<p>The example simulates: 1. Terrain-induced slugging: Liquid accumulates in the pipeline low point and periodically releases as slugs 2. Transient blowdown: Pipeline drains from initial high holdup state to steady flow 3. Choke valve operation: Reduces pressure from ~60 bara (pipeline outlet) to 55 bara (separator) 4. Level control: PID controller adjusts liquid outlet valve to absorb flow variations 5. Outlet flow dynamics: Mass flow at pipeline outlet varies as the system reaches equilibrium</p>"},{"location":"wiki/two_fluid_model/#validation-against-published-data","title":"Validation Against Published Data","text":"<p>The TwoFluidPipe model has been validated against established correlations and published experimental data to ensure physically correct pressure drop predictions.</p>"},{"location":"wiki/two_fluid_model/#validation-test-suite","title":"Validation Test Suite","text":"<p>The validation test suite is implemented in <code>TwoPhasePressureDropValidationTest.java</code> and includes:</p> <ol> <li>Beggs &amp; Brill (1973) Comparison - Validation against the widely-used empirical correlation</li> <li>Lockhart-Martinelli (1949) Consistency - Cross-check with the classic two-phase multiplier method</li> <li>Industrial-Scale Pipeline Tests - Verification for typical North Sea conditions</li> <li>Inclination Effects - Validation of gravity effects for uphill/downhill flow</li> </ol>"},{"location":"wiki/two_fluid_model/#validation-results","title":"Validation Results","text":"<p>Comparison of TwoFluidPipe against Beggs &amp; Brill (1973) test cases:</p> Test Case D (mm) L (m) B&amp;B \u0394P (bar) TFP \u0394P (bar) Ratio Horizontal Segregated 100 500 0.844 0.587 0.70 Horizontal Intermittent 100 500 2.211 2.253 1.02 Horizontal Distributed 100 500 1.979 4.127 2.09 Uphill 10\u00b0 100 500 3.688 3.700 1.00 Downhill 10\u00b0 100 500 -0.850 -1.013 1.19 <p>Key Observations: - Horizontal Intermittent &amp; Uphill: Excellent agreement (ratio ~1.0) - Downhill: Good agreement (ratio 1.19) - both models correctly predict pressure gain - Horizontal Segregated: TwoFluidPipe predicts 30% lower (ratio 0.70) - Horizontal Distributed: TwoFluidPipe predicts ~2x higher (ratio 2.09)</p> <p>The differences are expected because: - TwoFluidPipe uses a mechanistic two-fluid model solving conservation equations - Beggs &amp; Brill uses empirical correlations fitted to 1\" and 1.5\" pipe experiments - Differences up to 50% are typical between mechanistic and empirical approaches</p>"},{"location":"wiki/two_fluid_model/#physical-validation","title":"Physical Validation","text":"<p>The model correctly captures the following physical behaviors:</p> Physical Effect Expected Behavior Model Result Pressure drop vs GLR Increases with gas-liquid ratio \u2713 Verified Uphill flow Higher \u0394P (gravity opposes) \u2713 Verified Downhill flow Negative \u0394P (pressure gain) \u2713 Verified Hydrostatic head Proportional to sin(\u03b8) \u2713 Verified Friction loss Increases with velocity\u00b2 \u2713 Verified"},{"location":"wiki/two_fluid_model/#running-validation-tests","title":"Running Validation Tests","text":"<p>To run the validation tests:</p> <pre><code># Run all two-phase pressure drop validation tests\n./mvnw test -Dtest=TwoPhasePressureDropValidationTest\n\n# Run specific validation test\n./mvnw test -Dtest=TwoPhasePressureDropValidationTest#testTwoFluidPipeValidation\n</code></pre>"},{"location":"wiki/two_fluid_model/#comparison-with-pipebeggsandbrills","title":"Comparison with PipeBeggsAndBrills","text":"<p>For applications where empirical accuracy is preferred over mechanistic modeling, NeqSim also provides <code>PipeBeggsAndBrills</code> which implements the original Beggs &amp; Brill correlation with the Payne et al. (1979) corrections.</p> Feature TwoFluidPipe PipeBeggsAndBrills Approach Mechanistic (conservation eqs) Empirical (correlations) Flow regimes Computed from physics Correlated flow map Transient capability Yes Steady-state only Heat transfer Configurable Built-in Terrain effects Elevation profile Single angle Best for Transient, complex terrain Quick steady-state"},{"location":"wiki/two_fluid_model/#references","title":"References","text":"<ol> <li>Bendiksen, K.H. et al. (1991) - \"The Dynamic Two-Fluid Model OLGA: Theory and Application\", SPE Production Engineering</li> <li>Taitel, Y. and Dukler, A.E. (1976) - \"A Model for Predicting Flow Regime Transitions in Horizontal and Near Horizontal Gas-Liquid Flow\", AIChE Journal</li> <li>Issa, R.I. and Kempf, M.H.W. (2003) - \"Simulation of Slug Flow in Horizontal and Nearly Horizontal Pipes with the Two-Fluid Model\", Int. J. Multiphase Flow</li> <li>Liou, M.S. (1996) - \"A Sequel to AUSM: AUSM+\", J. Computational Physics</li> </ol>"},{"location":"wiki/two_fluid_model/#test-coverage","title":"Test Coverage","text":"<p>The model includes comprehensive unit tests:</p>"},{"location":"wiki/two_fluid_model/#core-tests","title":"Core Tests","text":"<ul> <li>Closure relations: 14 tests</li> <li>Numerical methods: 11 tests  </li> <li>Core solver: 14 tests</li> <li>Thermodynamic coupling: 40 tests</li> <li>Three-phase extension: 28 tests</li> <li>Integration tests: 19 tests</li> <li>Temperature/heat transfer: 16 tests</li> </ul>"},{"location":"wiki/two_fluid_model/#validation-tests","title":"Validation Tests","text":"<ul> <li>Beggs &amp; Brill (1973) validation: 5 test cases</li> <li>Lockhart-Martinelli (1949) consistency: 3 test cases</li> <li>TwoFluidPipe vs B&amp;B comparison: 5 test cases</li> <li>Industrial-scale pipelines: 3 test cases</li> <li>Inclination effects: 9 test cases</li> <li>GLR sensitivity: 6 test cases</li> <li>Flow regime detection: 25 test cases</li> </ul>"},{"location":"wiki/two_fluid_model/#integration-tests-slugpipelinetoseparatortest","title":"Integration Tests (SlugPipelineToSeparatorTest)","text":"<ul> <li>Slug pipeline to separator system: Full integration test</li> <li>Constant inlet pressure boundary: Boundary condition validation</li> <li>Pipeline outlet variations: Transient dynamics verification (577% flow variation)</li> </ul>"},{"location":"wiki/two_fluid_model/#temperature-comparison-tests-temperaturedropcomparisontest","title":"Temperature Comparison Tests (TemperatureDropComparisonTest)","text":"<ul> <li>Basic temperature profile initialization</li> <li>Temperature monotonicity in cooling</li> <li>TwoFluidPipe vs PipeBeggsAndBrills comparison</li> <li>Uphill pipeline temperature behavior</li> <li>Reproducibility across runs</li> <li>Flow rate sensitivity</li> <li>Physical bounds validation</li> </ul> <p>Total: 160+ tests</p>"},{"location":"wiki/usage_examples/","title":"Usage examples","text":"<p>Below is a minimal Java code snippet showing how to perform a TPflash calculation with NeqSim.</p> <pre><code>import neqsim.thermo.system.SystemSrkCPA;\nimport neqsim.thermo.ThermodynamicOperations;\n\nSystemSrkCPA system = new SystemSrkCPA(298.15, 50.0);\nsystem.addComponent(\"methane\", 0.8);\nsystem.addComponent(\"ethane\", 0.2);\nsystem.createDatabase();\n\nThermodynamicOperations ops = new ThermodynamicOperations(system);\nops.TPflash();\n\nSystem.out.println(\"Phase fractions: \" + java.util.Arrays.toString(system.getPhaseFraction()));\n</code></pre> <p>More detailed examples are available in the test suite under <code>src/test/java</code>.</p>"},{"location":"wiki/usage_examples/#wind-turbine","title":"Wind turbine","text":"<p>The <code>WindTurbine</code> unit converts kinetic energy in wind into electrical power using a simple actuator-disk formulation. Air density is assumed constant at 1.225 kg/m\u00b3 and all inefficiencies are lumped into the power coefficient.</p> <pre><code>import neqsim.process.equipment.powergeneration.WindTurbine;\n\nWindTurbine turbine = new WindTurbine(\"turbine\");\nturbine.setWindSpeed(12.0);    // m/s\nturbine.setRotorArea(50.0);    // m^2\nturbine.setPowerCoefficient(0.4);\nturbine.run();\n\nSystem.out.println(\"Power produced: \" + turbine.getPower() + \" W\");\n</code></pre>"},{"location":"wiki/venturi_calculation/","title":"Venturi Flow Calculation in NeqSim","text":"<p>This document describes the Venturi flow meter calculation methods implemented in NeqSim for computing mass flow rates from differential pressure measurements, and vice versa.</p>"},{"location":"wiki/venturi_calculation/#overview","title":"Overview","text":"<p>NeqSim implements Venturi flow calculations primarily in the <code>DifferentialPressureFlowCalculator</code> class, which is a utility for calculating mass flow rates from various differential pressure devices using NeqSim thermodynamic properties. The calculator supports both:</p> <ol> <li>Flow from dP: Calculate mass flow rate given differential pressure</li> <li>dP from Flow: Calculate differential pressure given mass flow rate (inverse calculation)</li> </ol> <p>Location: DifferentialPressureFlowCalculator.java</p>"},{"location":"wiki/venturi_calculation/#supported-flow-meter-types","title":"Supported Flow Meter Types","text":"<p>The calculator supports multiple differential pressure device types:</p> Flow Type Default Discharge Coefficient Venturi 0.985 Orifice Calculated (Reader-Harris/Gallagher) V-Cone 0.82 Nozzle Calculated DallTube Calculated Annubar Calculated Simplified User-provided Cv Perrys-Orifice Subsonic: 0.62, Sonic: 0.75-0.84"},{"location":"wiki/venturi_calculation/#venturi-calculation-method","title":"Venturi Calculation Method","text":""},{"location":"wiki/venturi_calculation/#fundamental-equation","title":"Fundamental Equation","text":"<p>The Venturi flow calculation uses the compressible flow equation with an expansibility (expansion) factor:</p> \\[ \\dot{m} = \\frac{C}{\\sqrt{1 - \\beta^4}} \\cdot \\varepsilon \\cdot \\frac{\\pi d^2}{4} \\cdot \\sqrt{2 \\rho \\Delta P} \\] <p>Where: - \\(\\dot{m}\\) = mass flow rate (kg/s) - \\(C\\) = discharge coefficient (default: 0.985 for Venturi) - \\(\\beta\\) = diameter ratio = \\(d/D\\) - \\(d\\) = throat diameter (m) - \\(D\\) = upstream pipe diameter (m) - \\(\\varepsilon\\) = expansibility factor - \\(\\rho\\) = upstream fluid density (kg/m\u00b3) - \\(\\Delta P\\) = differential pressure (Pa)</p>"},{"location":"wiki/venturi_calculation/#expansibility-factor","title":"Expansibility Factor (\u03b5)","text":"<p>The expansibility factor accounts for compressibility effects in gas flow and is calculated using an isentropic expansion model:</p> \\[ \\varepsilon = \\sqrt{\\frac{\\kappa \\cdot \\tau^{2/\\kappa}}{\\kappa - 1} \\cdot \\frac{1 - \\beta^4}{1 - \\beta^4 \\tau^{2/\\kappa}} \\cdot \\frac{1 - \\tau^{(\\kappa-1)/\\kappa}}{1 - \\tau}} \\] <p>Where: - \\(\\tau\\) = pressure ratio = \\(P_1 / (P_1 + \\Delta P)\\) - \\(\\kappa\\) = isentropic exponent (Cp/Cv) of the fluid - \\(\\beta^4\\) = fourth power of diameter ratio</p>"},{"location":"wiki/venturi_calculation/#implementation-in-neqsim","title":"Implementation in NeqSim","text":"<pre><code>private static double[] calcVenturi(double[] dp, double[] p, double[] rho, double[] kappa,\n    double D, double d, double C) {\n  double beta = d / D;\n  double beta4 = Math.pow(beta, 4.0);\n  double betaTerm = Math.sqrt(Math.max(1.0 - beta4, 1e-30));\n  double[] massFlow = new double[dp.length];\n\n  for (int i = 0; i &lt; dp.length; i++) {\n    double tau = p[i] / (p[i] + dp[i]);\n    double k = kappa[i];\n    double tau2k = Math.pow(tau, 2.0 / k);\n\n    // Expansibility factor calculation\n    double numerator = k * tau2k / (k - 1.0) * (1.0 - beta4)\n        / (1.0 - beta4 * tau2k) * (1.0 - Math.pow(tau, (k - 1.0) / k)) / (1.0 - tau);\n    double eps = Math.sqrt(Math.max(numerator, 0.0));\n\n    // Mass flow calculation\n    double rootTerm = Math.sqrt(Math.max(dp[i] * rho[i] * 2.0, 0.0));\n    double value = C / betaTerm * eps * Math.PI / 4.0 * d * d * rootTerm;\n    massFlow[i] = tau == 1.0 ? 0.0 : value * 3600.0;  // Convert to kg/h\n  }\n  return massFlow;\n}\n</code></pre>"},{"location":"wiki/venturi_calculation/#inverse-calculation-differential-pressure-from-flow","title":"Inverse Calculation: Differential Pressure from Flow","text":""},{"location":"wiki/venturi_calculation/#fundamental-equation_1","title":"Fundamental Equation","text":"<p>To calculate the differential pressure from a known mass flow rate, we rearrange the Venturi equation:</p> \\[ \\Delta P = \\frac{1}{2\\rho} \\left( \\frac{\\dot{m} \\cdot \\sqrt{1 - \\beta^4}}{C \\cdot \\varepsilon \\cdot A} \\right)^2 \\] <p>Where: - \\(A\\) = throat area = \\(\\frac{\\pi d^2}{4}\\)</p> <p>Since the expansibility factor \\(\\varepsilon\\) depends on the differential pressure (through the pressure ratio \\(\\tau\\)), an iterative solution is required.</p>"},{"location":"wiki/venturi_calculation/#algorithm","title":"Algorithm","text":"<ol> <li> <p>Initial estimate (assuming incompressible flow, \\(\\varepsilon = 1\\)):    $$    \\Delta P_0 = \\frac{1}{2\\rho} \\left( \\frac{\\dot{m} \\cdot \\sqrt{1 - \\beta^4}}{C \\cdot A} \\right)^2    $$</p> </li> <li> <p>Iterate until convergence:</p> </li> <li>Calculate pressure ratio: \\(\\tau = \\frac{P_1}{P_1 + \\Delta P}\\)</li> <li>Calculate expansibility factor \\(\\varepsilon\\) from \\(\\tau\\) and \\(\\kappa\\)</li> <li>Update: \\(\\Delta P_{n+1} = \\frac{1}{2\\rho} \\left( \\frac{\\dot{m} \\cdot \\sqrt{1 - \\beta^4}}{C \\cdot \\varepsilon \\cdot A} \\right)^2\\)</li> <li>Check convergence: \\(|\\Delta P_{n+1} - \\Delta P_n| &lt; 0.01\\) Pa</li> </ol>"},{"location":"wiki/venturi_calculation/#implementation-in-neqsim_1","title":"Implementation in NeqSim","text":"<pre><code>public static double calculateDpFromFlowVenturi(double massFlowKgPerHour, double pressureBara,\n    double density, double kappa, double pipeDiameterMm, double throatDiameterMm,\n    double dischargeCoefficient) {\n\n  double D = pipeDiameterMm / 1000.0;\n  double d = throatDiameterMm / 1000.0;\n  double C = dischargeCoefficient;\n  double massFlowKgPerSec = massFlowKgPerHour / 3600.0;\n\n  double beta = d / D;\n  double beta4 = Math.pow(beta, 4.0);\n  double betaTerm = Math.sqrt(Math.max(1.0 - beta4, 1e-30));\n\n  // Initial estimate (incompressible)\n  double A = Math.PI / 4.0 * d * d;\n  double dpInitial = Math.pow(massFlowKgPerSec * betaTerm / (C * A), 2) / (2.0 * density);\n\n  // Iterate to account for expansibility factor\n  double dpPa = dpInitial;\n  double pPa = pressureBara * 1.0e5;\n\n  for (int iter = 0; iter &lt; 100; iter++) {\n    double tau = pPa / (pPa + dpPa);\n    double tau2k = Math.pow(tau, 2.0 / kappa);\n    double numerator = kappa * tau2k / (kappa - 1.0) * (1.0 - beta4)\n        / (1.0 - beta4 * tau2k) * (1.0 - Math.pow(tau, (kappa - 1.0) / kappa)) / (1.0 - tau);\n    double eps = Math.sqrt(Math.max(numerator, 1e-30));\n\n    double dpNew = Math.pow(massFlowKgPerSec * betaTerm / (C * eps * A), 2) / (2.0 * density);\n\n    if (Math.abs(dpNew - dpPa) &lt; 0.01) {\n      dpPa = dpNew;\n      break;\n    }\n    dpPa = dpNew;\n  }\n\n  return dpPa / 100.0;  // Convert Pa to mbar\n}\n</code></pre>"},{"location":"wiki/venturi_calculation/#input-parameters","title":"Input Parameters","text":"<p>The calculator requires the following inputs:</p>"},{"location":"wiki/venturi_calculation/#geometry-parameters-flowdata-array","title":"Geometry Parameters (flowData array)","text":"Index Parameter Unit 0 Pipe diameter (D) mm 1 Throat diameter (d) mm 2 Discharge coefficient (optional) -"},{"location":"wiki/venturi_calculation/#operating-conditions","title":"Operating Conditions","text":"Parameter Unit Pressure barg Temperature \u00b0C Differential Pressure mbar"},{"location":"wiki/venturi_calculation/#fluid-composition","title":"Fluid Composition","text":"<ul> <li>Component names (e.g., \"methane\", \"CO2\", \"N2\")</li> <li>Mole fractions</li> </ul>"},{"location":"wiki/venturi_calculation/#thermodynamic-properties","title":"Thermodynamic Properties","text":"<p>NeqSim uses the SRK (Soave-Redlich-Kwong) equation of state to calculate the required thermodynamic properties:</p> <ol> <li>Density (\u03c1) - Calculated at actual flowing conditions</li> <li>Viscosity (\u03bc) - Used for Reynolds number calculations in orifice/nozzle</li> <li>Isentropic exponent (\u03ba) - Cp/Cv ratio, calculated at low pressure conditions</li> <li>Molecular weight - For standard flow conversions</li> </ol>"},{"location":"wiki/venturi_calculation/#output-results","title":"Output Results","text":"<p>The <code>FlowCalculationResult</code> class provides:</p> Output Unit Mass flow rate kg/h Volumetric flow rate (actual) m\u00b3/h Standard volumetric flow MSm\u00b3/day Molecular weight g/mol"},{"location":"wiki/venturi_calculation/#usage-example","title":"Usage Example","text":"<pre><code>import neqsim.process.equipment.diffpressure.DifferentialPressureFlowCalculator;\nimport neqsim.process.equipment.diffpressure.DifferentialPressureFlowCalculator.FlowCalculationResult;\nimport java.util.Arrays;\nimport java.util.List;\n\n// Operating conditions\ndouble[] pressureBarg = {50.0};        // 50 barg\ndouble[] temperatureC = {25.0};        // 25\u00b0C\ndouble[] dpMbar = {200.0};             // 200 mbar differential pressure\n\n// Venturi geometry: D=300mm, d=200mm, Cd=0.985\ndouble[] flowData = {300.0, 200.0, 0.985};\n\n// Gas composition\nList&lt;String&gt; components = Arrays.asList(\"methane\", \"ethane\", \"propane\");\ndouble[] fractions = {0.85, 0.10, 0.05};\n\n// Calculate flow\nFlowCalculationResult result = DifferentialPressureFlowCalculator.calculate(\n    pressureBarg, temperatureC, dpMbar, \"Venturi\", flowData,\n    components, fractions, true);\n\ndouble massFlowKgH = result.getMassFlowKgPerHour()[0];\ndouble stdFlowMSm3Day = result.getStandardFlowMSm3PerDay()[0];\n</code></pre>"},{"location":"wiki/venturi_calculation/#example-2-calculate-differential-pressure-from-flow-inverse","title":"Example 2: Calculate Differential Pressure from Flow (Inverse)","text":"<pre><code>import neqsim.process.equipment.diffpressure.DifferentialPressureFlowCalculator;\nimport java.util.Arrays;\nimport java.util.List;\n\n// Known mass flow rate\ndouble massFlowKgPerHour = 50000.0;  // 50,000 kg/h\n\n// Operating conditions\ndouble pressureBarg = 50.0;          // 50 barg\ndouble temperatureC = 25.0;          // 25\u00b0C\n\n// Venturi geometry: D=300mm, d=200mm, Cd=0.985\ndouble[] flowData = {300.0, 200.0, 0.985};\n\n// Gas composition\nList&lt;String&gt; components = Arrays.asList(\"methane\", \"ethane\", \"propane\");\ndouble[] fractions = {0.85, 0.10, 0.05};\n\n// Calculate differential pressure\ndouble dpMbar = DifferentialPressureFlowCalculator.calculateDpFromFlow(\n    massFlowKgPerHour, pressureBarg, temperatureC, \"Venturi\", flowData,\n    components, fractions, true);\n\nSystem.out.println(\"Differential pressure: \" + dpMbar + \" mbar\");\n</code></pre>"},{"location":"wiki/venturi_calculation/#example-3-direct-calculation-with-known-fluid-properties","title":"Example 3: Direct Calculation with Known Fluid Properties","text":"<pre><code>// If you already have fluid properties calculated\ndouble massFlowKgPerHour = 50000.0;\ndouble pressureBara = 51.0125;       // bara\ndouble density = 42.5;               // kg/m\u00b3\ndouble kappa = 1.28;                 // isentropic exponent\ndouble pipeDiameterMm = 300.0;       // mm\ndouble throatDiameterMm = 200.0;     // mm\ndouble Cd = 0.985;                   // discharge coefficient\n\ndouble dpMbar = DifferentialPressureFlowCalculator.calculateDpFromFlowVenturi(\n    massFlowKgPerHour, pressureBara, density, kappa, \n    pipeDiameterMm, throatDiameterMm, Cd);\n\nSystem.out.println(\"Differential pressure: \" + dpMbar + \" mbar\");\n</code></pre>"},{"location":"wiki/venturi_calculation/#comparison-with-other-flow-meter-types","title":"Comparison with Other Flow Meter Types","text":""},{"location":"wiki/venturi_calculation/#orifice-plate","title":"Orifice Plate","text":"<p>Uses the Reader-Harris/Gallagher correlation (ISO 5167) for discharge coefficient with iterative solution:</p> \\[ C = 0.5961 + 0.0261\\beta^2 - 0.216\\beta^8 + 0.000521\\left(\\frac{10^6\\beta}{Re_D}\\right)^{0.7} + \\ldots \\] <p>Expansibility factor: $$ \\varepsilon = 1 - (0.351 + 0.256\\beta^4 + 0.93\\beta^8)\\left[1 - \\left(\\frac{P_2}{P_1}\\right)^{1/\\kappa}\\right] $$</p>"},{"location":"wiki/venturi_calculation/#isa-1932-nozzle","title":"ISA 1932 Nozzle","text":"<p>Uses a similar approach to Venturi but with a different discharge coefficient correlation: $$ C = 0.99 - 0.2262\\beta^{4.1} - (0.00175\\beta^2 - 0.0033\\beta<sup>{4.15})\\left(\\frac{10</sup>7}{Re_D}\\right)^{1.15} $$</p>"},{"location":"wiki/venturi_calculation/#v-cone","title":"V-Cone","text":"<p>Uses a modified beta ratio based on cone geometry: $$ \\beta_{V-Cone} = \\sqrt{1 - \\frac{d_{cone}<sup>2}{D</sup>2}} $$</p> <p>Expansibility factor: $$ \\varepsilon = 1 - (0.649 + 0.696\\beta^4)\\frac{\\Delta P}{\\kappa \\cdot P} $$</p>"},{"location":"wiki/venturi_calculation/#standards-and-references","title":"Standards and References","text":"<p>The implementations are based on: - ISO 5167 - Measurement of fluid flow by means of pressure differential devices - Reader-Harris/Gallagher correlation - For orifice discharge coefficients - Perry's Chemical Engineers' Handbook - For compressible flow through orifices</p>"},{"location":"wiki/venturi_calculation/#key-considerations","title":"Key Considerations","text":"<ol> <li>Compressibility: The expansibility factor is critical for gas flow; for liquids, \u03b5 \u2248 1.0</li> <li>Beta Ratio Limits: Typically valid for 0.2 \u2264 \u03b2 \u2264 0.75</li> <li>Reynolds Number: Correlations are valid for Re &gt; 4000 (turbulent flow)</li> <li>Pressure Recovery: Venturi meters have better pressure recovery (~90%) compared to orifice plates (~40%)</li> <li>Accuracy: Typical uncertainty is \u00b10.5% to \u00b11.5% depending on installation and calibration</li> </ol>"},{"location":"wiki/venturi_calculation/#related-classes","title":"Related Classes","text":"<ul> <li>Orifice.java - Equipment class for orifice calculations in process simulations</li> <li>VirtualFlowMeter.java - Virtual flow meter using differential pressure</li> </ul>"},{"location":"wiki/viscosity_models/","title":"Viscosity Models in NeqSim","text":"<p>NeqSim provides a comprehensive suite of methods for calculating fluid viscosity, ranging from standard empirical correlations to advanced corresponding states models and specialized pure-component equations. This document details the available models, their applications, and how to use them in simulations.</p>"},{"location":"wiki/viscosity_models/#overview","title":"Overview","text":"<p>NeqSim viscosity models are organized into several categories:</p> Category Models Applicability General Purpose LBC, PFCT, Friction Theory Hydrocarbon mixtures, reservoir fluids Pure Component Muzny, MethaneModel, CO2Model, KTA Specialized high-accuracy correlations Aqueous Systems Salt Water (Lalibert\u00e9), polynom Brine and water solutions Heavy Oils PFCT-Heavy-Oil Viscous crude oils, bitumen"},{"location":"wiki/viscosity_models/#available-models","title":"Available Models","text":""},{"location":"wiki/viscosity_models/#1-lohrenz-bray-clark-lbc","title":"1. Lohrenz-Bray-Clark (LBC)","text":"<p>The LBC method is the industry-standard correlation for calculating viscosity of reservoir fluids. It combines a low-pressure gas viscosity term with a dense-fluid contribution based on reduced density.</p> <ul> <li>Keyword: <code>\"LBC\"</code></li> <li>Best for: General oil and gas systems, reservoir fluids, PVT matching.</li> <li>Features:<ul> <li>Tunable Parameters: Five dense-fluid polynomial coefficients (\\(a_0\\) to \\(a_4\\)) can be adjusted to match laboratory data.</li> <li>Whitson Consistency: Implementation aligned with the standard \"Whitson\" interpretation.</li> <li>Linear Mixing Rule: Critical volume uses linear summation (\\(\\sum x_i V_{ci}\\)) for better heavy component handling.</li> <li>Unit Verified: Internal pressure and viscosity unit conversions rigorously verified against literature.</li> </ul> </li> </ul>"},{"location":"wiki/viscosity_models/#2-corresponding-states-principle-csppfct","title":"2. Corresponding States Principle (CSP/PFCT)","text":"<p>The CSP method (referred to as PFCT in NeqSim) uses the Corresponding States Principle to relate mixture viscosity to a reference substance (typically Methane) at corresponding thermodynamic conditions.</p> <ul> <li>Keyword: <code>\"PFCT\"</code></li> <li>Best for: Light to medium hydrocarbon mixtures, natural gas.</li> <li>Features:<ul> <li>Uses methane as reference fluid with well-characterized viscosity.</li> <li>Includes shape factor corrections for non-spherical molecules.</li> </ul> </li> </ul>"},{"location":"wiki/viscosity_models/#3-corresponding-states-principle-for-heavy-oil","title":"3. Corresponding States Principle for Heavy Oil","text":"<p>A variant of the CSP model specifically tuned for heavy oil systems with additional terms to represent the viscous behavior of heavy fractions.</p> <ul> <li>Keyword: <code>\"PFCT-Heavy-Oil\"</code></li> <li>Best for: Heavy oils, systems with significant TBP (True Boiling Point) fractions, bitumen.</li> </ul>"},{"location":"wiki/viscosity_models/#4-friction-theory","title":"4. Friction Theory","text":"<p>The Friction Theory (f-theory) model links viscosity to the equation of state (EOS) by separating total viscosity into a dilute gas contribution and a residual friction contribution.</p> <ul> <li>Keyword: <code>\"friction theory\"</code></li> <li>Best for: Wide range of fluids, consistent with EOS thermodynamics, high-pressure applications.</li> <li>Features:<ul> <li>Thermodynamically consistent with the EOS used for phase equilibrium.</li> <li>Robust near critical point and at high pressures.</li> <li>Uses Chung correlation for dilute-gas contribution.</li> </ul> </li> </ul>"},{"location":"wiki/viscosity_models/#5-chung-method-gas-phase","title":"5. Chung Method (Gas Phase)","text":"<p>The Chung method is a corresponding states correlation for gas-phase viscosity based on the Chapman-Enskog kinetic theory with empirical corrections.</p> <ul> <li>Keyword: Used internally by gas phase physical properties.</li> <li>Best for: Low-density gas mixtures.</li> <li>Features:<ul> <li>Wilke mixing rules for multicomponent systems.</li> <li>Correction factors for polar and associating molecules.</li> </ul> </li> </ul>"},{"location":"wiki/viscosity_models/#6-lee-gonzalez-eakin-correlation","title":"6. Lee-Gonzalez-Eakin Correlation","text":"<p>A simple empirical correlation for natural gas viscosity estimation.</p> <ul> <li>Keyword: Used as reference in LBC calculations.</li> <li>Best for: Quick first-order estimates for natural gas.</li> <li>Reference: Lee, Gonzalez, and Eakin, SPE-1340-PA, 1966.</li> </ul>"},{"location":"wiki/viscosity_models/#pure-component-models","title":"Pure Component Models","text":""},{"location":"wiki/viscosity_models/#7-muzny-hydrogen-viscosity","title":"7. Muzny Hydrogen Viscosity","text":"<p>High-accuracy correlation for pure hydrogen viscosity based on the work of Muzny et al. Includes dilute-gas, first-density, and higher-density contributions.</p> <ul> <li>Keyword: <code>\"Muzny\"</code></li> <li>Best for: Pure hydrogen systems across wide temperature and pressure ranges.</li> <li>Limitations: Only valid for pure hydrogen - throws error for mixtures.</li> <li>Features:<ul> <li>Uses Leachman equation of state for density.</li> <li>Valid from gas to dense fluid phases.</li> </ul> </li> </ul>"},{"location":"wiki/viscosity_models/#8-muzny-modified-hydrogen-viscosity","title":"8. Muzny Modified Hydrogen Viscosity","text":"<p>Extended version of the Muzny correlation with additional correction terms for improved accuracy at specific conditions.</p> <ul> <li>Keyword: <code>\"Muzny_mod\"</code></li> <li>Best for: Pure hydrogen with enhanced accuracy at certain T-P conditions.</li> </ul>"},{"location":"wiki/viscosity_models/#9-methane-viscosity-model","title":"9. Methane Viscosity Model","text":"<p>Specialized correlation for pure methane viscosity using LBC as base with empirical correction terms.</p> <ul> <li>Keyword: <code>\"MethaneModel\"</code></li> <li>Best for: Pure methane systems, LNG applications.</li> <li>Limitations: Only valid for pure methane - throws error for mixtures.</li> </ul>"},{"location":"wiki/viscosity_models/#10-co2-viscosity-model","title":"10. CO2 Viscosity Model","text":"<p>Reference-quality correlation for pure carbon dioxide based on Laesecke et al. (JPCRD 2017).</p> <ul> <li>Keyword: <code>\"CO2Model\"</code></li> <li>Best for: Pure CO2 systems, CCS applications, supercritical CO2.</li> <li>Limitations: Only valid for pure CO2 - throws error for mixtures.</li> <li>Features:<ul> <li>Dilute-gas and residual contributions from JPCRD 2017.</li> <li>Uses Span-Wagner EOS for density when needed.</li> </ul> </li> </ul>"},{"location":"wiki/viscosity_models/#11-kta-helium-viscosity","title":"11. KTA Helium Viscosity","text":"<p>Simple power-law correlation for pure helium viscosity.</p> <ul> <li>Keyword: <code>\"KTA\"</code></li> <li>Best for: Pure helium systems, cryogenic applications.</li> <li>Limitations: Only valid for pure helium.</li> <li>Reference: Based on KTA (Kerntechnischer Ausschuss) standard.</li> </ul>"},{"location":"wiki/viscosity_models/#12-kta-modified-helium-viscosity","title":"12. KTA Modified Helium Viscosity","text":"<p>Extended KTA model with pressure-dependent corrections for improved high-pressure accuracy.</p> <ul> <li>Keyword: <code>\"KTA_mod\"</code></li> <li>Best for: Pure helium at elevated pressures.</li> </ul>"},{"location":"wiki/viscosity_models/#aqueous-system-models","title":"Aqueous System Models","text":""},{"location":"wiki/viscosity_models/#13-salt-water-laliberte","title":"13. Salt Water (Lalibert\u00e9)","text":"<p>Viscosity correlation for aqueous salt solutions using the Lalibert\u00e9 (2007) model with erratum corrections.</p> <ul> <li>Keyword: <code>\"Salt Water\"</code></li> <li>Best for: Brine systems, produced water, salt solutions.</li> <li>Supported Salts:<ul> <li>NaCl (sodium chloride)</li> <li>KCl (potassium chloride)</li> <li>KCOOH (potassium formate)</li> <li>NaBr (sodium bromide)</li> <li>CaCl2 (calcium chloride)</li> <li>KBr (potassium bromide)</li> </ul> </li> <li>Reference: G. Lalibert\u00e9, Ind. Eng. Chem. Res., 2007, 46, 8865-8872.</li> </ul>"},{"location":"wiki/viscosity_models/#14-polynomial-liquid-viscosity","title":"14. Polynomial Liquid Viscosity","text":"<p>General liquid viscosity calculation using the Grunberg-Nissan mixing rule with pure-component correlations.</p> <ul> <li>Keyword: <code>\"polynom\"</code></li> <li>Best for: Liquid mixtures where component viscosity parameters are available in database.</li> </ul>"},{"location":"wiki/viscosity_models/#usage-in-neqsim","title":"Usage in NeqSim","text":"<p>To use a specific viscosity model, you must set it on the <code>PhysicalProperties</code> object of a phase. This is typically done after creating the system but before performing calculations.</p>"},{"location":"wiki/viscosity_models/#java-example","title":"Java Example","text":"<pre><code>import neqsim.thermo.system.SystemInterface;\nimport neqsim.thermo.system.SystemSrkEos;\nimport neqsim.thermodynamicoperations.ThermodynamicOperations;\n\npublic class ViscosityExample {\n    public static void main(String[] args) {\n        // 1. Create a system\n        SystemInterface system = new SystemSrkEos(298.15, 100.0); // 298.15 K, 100 bar\n        system.addComponent(\"methane\", 0.5);\n        system.addComponent(\"n-heptane\", 0.5);\n\n        // 2. Set mixing rule and initialize\n        system.setMixingRule(\"classic\");\n        ThermodynamicOperations ops = new ThermodynamicOperations(system);\n        ops.TPflash();\n\n        // 3. Set Viscosity Model for a specific phase (e.g., oil/liquid)\n        // Available options: \"LBC\", \"PFCT\", \"PFCT-Heavy-Oil\", \"friction theory\"\n\n        // Example: Using LBC\n        system.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"LBC\");\n        system.initProperties();\n        double lbcViscosity = system.getPhase(\"oil\").getViscosity();\n        System.out.println(\"LBC Viscosity: \" + lbcViscosity + \" kg/(m*s)\");\n\n        // Example: Using PFCT\n        system.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"PFCT\");\n        system.initProperties();\n        double pfctViscosity = system.getPhase(\"oil\").getViscosity();\n        System.out.println(\"PFCT Viscosity: \" + pfctViscosity + \" kg/(m*s)\");\n\n        // Example: Using PFCT for Heavy Oil\n        system.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"PFCT-Heavy-Oil\");\n        system.initProperties();\n        double pfctHeavyViscosity = system.getPhase(\"oil\").getViscosity();\n        System.out.println(\"PFCT Heavy Oil Viscosity: \" + pfctHeavyViscosity + \" kg/(m*s)\");\n\n        // Example: Using Friction Theory\n        system.getPhase(\"oil\").getPhysicalProperties().setViscosityModel(\"friction theory\");\n        system.initProperties();\n        double frictionViscosity = system.getPhase(\"oil\").getViscosity();\n        System.out.println(\"Friction Theory Viscosity: \" + frictionViscosity + \" kg/(m*s)\");\n    }\n}\n</code></pre>"},{"location":"wiki/viscosity_models/#tuning-lbc-dense-fluid-parameters","title":"Tuning LBC dense-fluid parameters","text":"<p>The LBC implementation exposes the dense-fluid polynomial coefficients (\"Whitson/Bray-Clark\" \\(a_0 \\dots a_4\\) parameters) so you can tune the model against laboratory data. After selecting the <code>\"LBC\"</code> viscosity model, update the coefficients via <code>setLbcParameters</code> or <code>setLbcParameter</code>, then re-initialize properties to apply them:</p> <pre><code>system.getPhase(1).getPhysicalProperties().setViscosityModel(\"LBC\");\nsystem.initProperties();\ndouble baseViscosity = system.getPhase(1).getViscosity();\n\ndouble[] tunedCoefficients = new double[] {0.11, 0.030, 0.065, -0.045, 0.010};\nsystem.getPhase(1).getPhysicalProperties().setLbcParameters(tunedCoefficients);\nsystem.getPhase(1).getPhysicalProperties().setLbcParameter(2, 0.070); // tweak a single term\nsystem.initProperties();\ndouble tunedViscosity = system.getPhase(1).getViscosity();\n\nSystem.out.println(\"Base viscosity:  \" + baseViscosity);\nSystem.out.println(\"Tuned viscosity: \" + tunedViscosity);\n</code></pre>"},{"location":"wiki/viscosity_models/#python-example-via-jpype","title":"Python Example (via JPype)","text":"<pre><code>from neqsim.thermo import SystemSrkEos\nfrom neqsim.thermodynamicoperations import ThermodynamicOperations\n\n# 1. Create system\nsystem = SystemSrkEos(298.15, 100.0)\nsystem.addComponent(\"methane\", 0.5)\nsystem.addComponent(\"n-heptane\", 0.5)\nsystem.setMixingRule(\"classic\")\n\n# 2. Flash\nops = ThermodynamicOperations(system)\nops.TPflash()\n\n# 3. Set Viscosity Model\n# Note: Phase index 0 is usually gas, 1 is oil/liquid\nsystem.getPhase(1).getPhysicalProperties().setViscosityModel(\"LBC\")\nsystem.initProperties()\nprint(\"LBC Viscosity:\", system.getPhase(1).getViscosity(), \"kg/(m*s)\")\n\nsystem.getPhase(1).getPhysicalProperties().setViscosityModel(\"PFCT\")\nsystem.initProperties()\nprint(\"PFCT Viscosity:\", system.getPhase(1).getViscosity(), \"kg/(m*s)\")\n\nsystem.getPhase(1).getPhysicalProperties().setViscosityModel(\"friction theory\")\nsystem.initProperties()\nprint(\"Friction Theory Viscosity:\", system.getPhase(1).getViscosity(), \"kg/(m*s)\")\n</code></pre>"},{"location":"wiki/viscosity_models/#mathematical-details","title":"Mathematical Details","text":""},{"location":"wiki/viscosity_models/#1-lohrenz-bray-clark-lbc-model","title":"1. Lohrenz-Bray-Clark (LBC) Model","text":"<p>The LBC model calculates the viscosity of a fluid (\\(\\eta\\)) as the sum of a low-pressure gas contribution (\\(\\eta^*\\)) and a dense-fluid contribution (\\(\\eta_{dense}\\)):</p> \\[ \\eta = \\eta^* + \\frac{\\eta_{dense}}{\\xi_m} \\] <p>where \\(\\xi_m\\) is the mixture viscosity parameter:</p> \\[ \\xi_m = \\frac{T_{cm}^{1/6}}{M_m^{1/2} P_{cm}^{2/3}} \\] <p>The dense-fluid contribution is a function of the reduced density \\(\\rho_r = \\rho_m / \\rho_{cm}\\):</p> \\[ [(\\eta - \\eta^*) \\xi_m + 10^{-4}]^{1/4} = a_0 + a_1 \\rho_r + a_2 \\rho_r^2 + a_3 \\rho_r^3 + a_4 \\rho_r^4 \\] <p>Mixing Rules: *   \\(T_{cm} = \\sum_i x_i T_{ci}\\) *   \\(P_{cm} = \\sum_i x_i P_{ci}\\) (Note: LBC typically uses specific mixing rules for \\(T_c, P_c\\) involving \\(V_c\\), but NeqSim implementations may vary. The critical volume mixing rule is key.) *   \\(M_m = \\sum_i x_i M_i\\) *   Critical Volume (\\(V_{cm}\\)):     $$ V_{cm} = \\sum_{i} x_i V_{ci} $$     (Note: This linear mixing rule replaces the previous cubic root rule \\(\\left(\\sum x_i V_{ci}^{1/3}\\right)^3\\) for better heavy oil prediction.)</p>"},{"location":"wiki/viscosity_models/#2-corresponding-states-principle-csp","title":"2. Corresponding States Principle (CSP)","text":"<p>The CSP model uses the Corresponding States Principle to relate the viscosity of a mixture to that of a reference substance (typically Methane) at a corresponding state (\\(T_0, P_0\\)).</p> <p>Viscosity Mapping: $$ \\eta_{mix}(T, P) = \\eta_{ref}(T_0, P_0) \\cdot F_{\\eta} \\cdot \\frac{\\alpha_{mix}}{\\alpha_{ref}} $$</p> <p>where the scaling factor \\(F_{\\eta}\\) is: $$ F_{\\eta} = \\left(\\frac{T_{cm}}{T_{c,ref}}\\right)^{-\u2159} \\left(\\frac{P_{cm}}{P_{c,ref}}\\right)^{\u2154} \\left(\\frac{M_{mix}}{M_{ref}}\\right)^{\u00bd} $$</p> <p>Corresponding State (\\(T_0, P_0\\)): The reference substance is evaluated at: $$ T_0 = T \\cdot \\frac{T_{c,ref}}{T_{cm}} \\cdot \\frac{\\alpha_{ref}}{\\alpha_{mix}} $$ $$ P_0 = P \\cdot \\frac{P_{c,ref}}{P_{cm}} \\cdot \\frac{\\alpha_{ref}}{\\alpha_{mix}} $$</p> <p>The parameter \\(\\alpha\\) accounts for deviations from the simple CSP and is typically a function of reduced density and molecular weight.</p>"},{"location":"wiki/viscosity_models/#3-friction-theory-f-theory","title":"3. Friction Theory (f-theory)","text":"<p>The Friction Theory model separates the total viscosity into a dilute gas term (\\(\\eta_0\\)) and a friction term (\\(\\eta_f\\)):</p> \\[ \\eta = \\eta_0 + \\eta_f \\] <p>The friction term is derived from mechanical friction concepts applied to the van der Waals repulsive and attractive pressure terms of the Equation of State (EOS):</p> \\[ \\eta_f = \\kappa_r P_r + \\kappa_a P_a + \\kappa_{rr} P_r^2 \\] <p>where: *   \\(P_r\\): Repulsive pressure term from the EOS (e.g., \\(RT/(v-b)\\) for SRK/PR). *   \\(P_a\\): Attractive pressure term from the EOS (e.g., \\(-a/(v(v+b))\\) for SRK). *   \\(\\kappa_r, \\kappa_a, \\kappa_{rr}\\): Friction coefficients, which are functions of temperature.</p> <p>This approach ensures that the viscosity model is consistent with the thermodynamic behavior predicted by the EOS, making it robust across a wide range of conditions, including high pressure and near-critical regions.</p>"},{"location":"wiki/viscosity_models/#4-muzny-hydrogen-viscosity-model","title":"4. Muzny Hydrogen Viscosity Model","text":"<p>The Muzny correlation for pure hydrogen viscosity follows a multi-term structure:</p> \\[ \\eta = \\eta_0 + \\eta_1 \\rho + \\Delta\\eta(\\rho_r, T_r) \\] <p>where: *   \\(\\eta_0\\): Dilute-gas viscosity from Chapman-Enskog theory *   \\(\\eta_1\\): First-density coefficient *   \\(\\Delta\\eta\\): Higher-order density contribution</p> <p>The dilute-gas term is:</p> \\[ \\eta_0 = \\frac{0.021357 \\sqrt{MT}}{\\sigma^2 S^*} \\] <p>where \\(S^*\\) is the reduced collision integral and \\(\\sigma = 0.297\\) nm is the Lennard-Jones size parameter.</p>"},{"location":"wiki/viscosity_models/#5-co2-viscosity-model-laesecke-jpcrd-2017","title":"5. CO2 Viscosity Model (Laesecke JPCRD 2017)","text":"<p>The CO2 viscosity correlation consists of dilute-gas and residual terms:</p> \\[ \\eta = \\eta_0(T) + \\Delta\\eta(\\rho, T) \\] <p>The dilute-gas term follows an empirical correlation, and the residual term is expressed as:</p> \\[ \\Delta\\eta = \\eta_{t,L} \\left[ c_1 T_r \\rho_r^3 + \\frac{\\rho_r^2 + \\rho_r^\\gamma}{T_r - c_2} \\right] \\] <p>where \\(T_t = 216.592\\) K is the triple point temperature and \\(\\rho_{t,L} = 1178.53\\) kg/m\u00b3 is the triple point liquid density.</p>"},{"location":"wiki/viscosity_models/#6-salt-water-laliberte-model","title":"6. Salt Water (Lalibert\u00e9 Model)","text":"<p>The Lalibert\u00e9 mixture rule for aqueous salt solutions:</p> \\[ \\eta_m = \\eta_w^{w_w} \\prod_i \\eta_i^{w_i} \\] <p>where \\(\\eta_w\\) is pure-water viscosity and \\(\\eta_i\\) are solute viscosities:</p> \\[ \\eta_i = \\frac{\\exp\\left[\\frac{\\nu_1(1-w_w)^{\\nu_2} + \\nu_3}{\\nu_4 t + 1}\\right]}{\\nu_5(1-w_w)^{\\nu_6} + 1} \\] <p>with \\(w_w\\) = water mass fraction and \\(t\\) = temperature in \u00b0C.</p>"},{"location":"wiki/viscosity_models/#quick-reference-table","title":"Quick Reference Table","text":"Model Keyword Applicability Phase Multi-Component <code>\"LBC\"</code> Hydrocarbons, reservoir fluids Gas/Liquid Yes <code>\"PFCT\"</code> Light-medium hydrocarbons Gas/Liquid Yes <code>\"PFCT-Heavy-Oil\"</code> Heavy oils, bitumen Liquid Yes <code>\"friction theory\"</code> General fluids, EOS-consistent Gas/Liquid Yes <code>\"polynom\"</code> Liquids with database parameters Liquid Yes <code>\"Muzny\"</code> Pure hydrogen Gas/Liquid No <code>\"Muzny_mod\"</code> Pure hydrogen (extended) Gas/Liquid No <code>\"MethaneModel\"</code> Pure methane Gas/Liquid No <code>\"CO2Model\"</code> Pure CO2 Gas/Liquid No <code>\"KTA\"</code> Pure helium Gas No <code>\"KTA_mod\"</code> Pure helium (extended) Gas No <code>\"Salt Water\"</code> Brine, salt solutions Liquid Yes (aqueous)"},{"location":"wiki/viscosity_models/#additional-examples","title":"Additional Examples","text":""},{"location":"wiki/viscosity_models/#using-pure-component-models","title":"Using Pure Component Models","text":"<pre><code>// Pure Hydrogen Viscosity\nSystemInterface h2System = new SystemSrkEos(300.0, 50.0);\nh2System.addComponent(\"hydrogen\", 1.0);\nh2System.setMixingRule(\"classic\");\nThermodynamicOperations h2Ops = new ThermodynamicOperations(h2System);\nh2Ops.TPflash();\n\nh2System.getPhase(0).getPhysicalProperties().setViscosityModel(\"Muzny\");\nh2System.initProperties();\nSystem.out.println(\"H2 Viscosity (Muzny): \" + h2System.getPhase(0).getViscosity() + \" Pa\u00b7s\");\n\n// Pure CO2 Viscosity\nSystemInterface co2System = new SystemSrkEos(350.0, 100.0);\nco2System.addComponent(\"CO2\", 1.0);\nco2System.setMixingRule(\"classic\");\nThermodynamicOperations co2Ops = new ThermodynamicOperations(co2System);\nco2Ops.TPflash();\n\nco2System.getPhase(0).getPhysicalProperties().setViscosityModel(\"CO2Model\");\nco2System.initProperties();\nSystem.out.println(\"CO2 Viscosity (Laesecke): \" + co2System.getPhase(0).getViscosity() + \" Pa\u00b7s\");\n</code></pre>"},{"location":"wiki/viscosity_models/#salt-water-viscosity","title":"Salt Water Viscosity","text":"<pre><code>// Brine viscosity calculation\nSystemInterface brine = new SystemSrkCPAstatoil(323.15, 10.0);\nbrine.addComponent(\"water\", 0.95);\nbrine.addComponent(\"NaCl\", 0.05);\nbrine.setMixingRule(10); // CPA mixing rule\n\nThermodynamicOperations brineOps = new ThermodynamicOperations(brine);\nbrineOps.TPflash();\n\n// Set Lalibert\u00e9 salt water model\nbrine.getPhase(\"aqueous\").getPhysicalProperties().setViscosityModel(\"Salt Water\");\nbrine.initProperties();\nSystem.out.println(\"Brine Viscosity: \" + brine.getPhase(\"aqueous\").getViscosity() + \" Pa\u00b7s\");\n</code></pre>"},{"location":"wiki/viscosity_models/#troubleshooting","title":"Troubleshooting","text":""},{"location":"wiki/viscosity_models/#common-issues","title":"Common Issues","text":"<ol> <li> <p>\"Model only supports PURE X\" error: Pure-component models (Muzny, CO2Model, MethaneModel, KTA) only work with single-component systems. Use LBC or PFCT for mixtures.</p> </li> <li> <p>Unexpected viscosity values: Ensure <code>initProperties()</code> is called after setting the viscosity model and after any flash calculations.</p> </li> <li> <p>Phase selection: Use <code>getPhase(\"oil\")</code>, <code>getPhase(\"gas\")</code>, or <code>getPhase(\"aqueous\")</code> to select the correct phase, or use phase index (0, 1, 2).</p> </li> <li> <p>Heavy oil predictions too low: Try <code>\"PFCT-Heavy-Oil\"</code> or tune LBC parameters using <code>setLbcParameters()</code>.</p> </li> </ol>"},{"location":"wiki/viscosity_models/#references","title":"References","text":"<ol> <li>Lohrenz, J., Bray, B.G., and Clark, C.R., \"Calculating Viscosities of Reservoir Fluids from Their Compositions\", JPT, 1964.</li> <li>Pedersen, K.S., and Fredenslund, A., \"An Improved Corresponding States Model for the Prediction of Oil and Gas Viscosities\", Chemical Engineering Science, 1987.</li> <li>Qui\u00f1ones-Cisneros, S.E., and Deiters, U.K., \"Generalization of the Friction Theory for Viscosity Modeling\", J. Phys. Chem. B, 2006.</li> <li>Muzny, C.D., et al., \"Correlation for the Viscosity of Normal Hydrogen\", J. Chem. Eng. Data, 2013.</li> <li>Laesecke, A., and Muzny, C.D., \"Reference Correlation for the Viscosity of Carbon Dioxide\", JPCRD, 2017.</li> <li>Lalibert\u00e9, M., \"Model for Calculating the Viscosity of Aqueous Solutions\", Ind. Eng. Chem. Res., 2007.</li> <li>Lee, A.L., Gonzalez, M.H., and Eakin, B.E., \"The Viscosity of Natural Gases\", SPE-1340-PA, 1966.</li> <li>Chung, T.H., et al., \"Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties\", Ind. Eng. Chem. Res., 1988.</li> </ol>"},{"location":"wiki/water_cooler/","title":"Water cooler","text":"<p>The <code>WaterCooler</code> equipment cools water streams using the dedicated water physical property package. It also estimates the required cooling water flow rate using the IAPWS IF97 steam tables. Both the inlet and outlet process streams are forced to use <code>PhysicalPropertyModel.WATER</code>.</p> <pre><code>SystemInterface water = new SystemSrkEos(298.15, 1.0);\nwater.addComponent(\"water\", 1.0);\nwater.setPhysicalPropertyModel(PhysicalPropertyModel.WATER);\n\nStream feed = new Stream(\"water feed\", water);\nfeed.setTemperature(40.0, \"C\");\n\nWaterCooler cooler = new WaterCooler(\"cooler\", feed);\ncooler.setOutTemperature(20.0, \"C\");\ncooler.setWaterInletTemperature(25.0, \"C\");\ncooler.setWaterOutletTemperature(35.0, \"C\");\ncooler.setWaterPressure(1.0, \"bara\");\n\n// After running the process system the calculated cooling water flow can be obtained\ndouble cwFlow = cooler.getCoolingWaterFlowRate(\"kg/hr\");\n</code></pre>"},{"location":"wiki/water_hammer_implementation/","title":"Water Hammer Simulation in NeqSim","text":""},{"location":"wiki/water_hammer_implementation/#overview","title":"Overview","text":"<p>NeqSim provides water hammer (hydraulic transient) simulation through the <code>WaterHammerPipe</code> class. This model uses the Method of Characteristics (MOC) to simulate fast pressure transients caused by:</p> <ul> <li>Rapid valve closures (emergency shutdown)</li> <li>Pump trips</li> <li>Check valve slam</li> <li>Sudden flow changes</li> </ul> <p>Unlike the advection-based transient model in <code>PipeBeggsAndBrills</code>, <code>WaterHammerPipe</code> propagates pressure waves at the speed of sound, enabling accurate simulation of pressure surges.</p>"},{"location":"wiki/water_hammer_implementation/#quick-start","title":"Quick Start","text":"<pre><code>import neqsim.process.equipment.pipeline.WaterHammerPipe;\nimport neqsim.process.equipment.pipeline.WaterHammerPipe.BoundaryType;\nimport neqsim.process.equipment.stream.Stream;\nimport neqsim.thermo.system.SystemSrkEos;\n\n// Create fluid\nSystemInterface water = new SystemSrkEos(298.15, 10.0);\nwater.addComponent(\"water\", 1.0);\nwater.setMixingRule(\"classic\");\nwater.setTotalFlowRate(100.0, \"kg/hr\");\n\nStream feed = new Stream(\"feed\", water);\nfeed.run();\n\n// Create water hammer pipe\nWaterHammerPipe pipe = new WaterHammerPipe(\"pipeline\", feed);\npipe.setLength(1000);              // 1 km\npipe.setDiameter(0.2);             // 200 mm\npipe.setNumberOfNodes(100);        // Grid resolution\npipe.setDownstreamBoundary(BoundaryType.VALVE);\npipe.run();                        // Initialize steady state\n\n// Simulate valve closure\nUUID id = UUID.randomUUID();\ndouble dt = pipe.getMaxStableTimeStep();\n\nfor (int step = 0; step &lt; 1000; step++) {\n    double t = step * dt;\n\n    // Close valve from t=0.1s to t=0.2s\n    if (t &gt;= 0.1 &amp;&amp; t &lt;= 0.2) {\n        double tau = (t - 0.1) / 0.1;\n        pipe.setValveOpening(1.0 - tau);  // 100% \u2192 0%\n    }\n\n    pipe.runTransient(dt, id);\n}\n\n// Get maximum pressure surge\ndouble maxPressure = pipe.getMaxPressure(\"bar\");\nSystem.out.println(\"Max surge pressure: \" + maxPressure + \" bar\");\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#physics-model","title":"Physics Model","text":""},{"location":"wiki/water_hammer_implementation/#method-of-characteristics-moc","title":"Method of Characteristics (MOC)","text":"<p>The MOC transforms the hyperbolic partial differential equations for 1D transient pipe flow into ordinary differential equations along characteristic lines.</p> <p>Governing Equations:</p> <p>Continuity: $\\(\\frac{\\partial H}{\\partial t} + \\frac{c^2}{gA}\\frac{\\partial Q}{\\partial x} = 0\\)$</p> <p>Momentum: $\\(\\frac{\\partial Q}{\\partial t} + gA\\frac{\\partial H}{\\partial x} + \\frac{f}{2DA}Q|Q| = 0\\)$</p> <p>Characteristic Lines: - C\u207a line: dx/dt = +c (forward wave) - C\u207b line: dx/dt = -c (backward wave)</p> <p>Compatibility Equations:</p> <p>Along C\u207a: \\(H_P - H_A + B(Q_P - Q_A) + R \\cdot Q_A|Q_A| = 0\\)</p> <p>Along C\u207b: \\(H_P - H_B - B(Q_P - Q_B) - R \\cdot Q_B|Q_B| = 0\\)</p> <p>Where: - H = piezometric head (m) - Q = volumetric flow rate (m\u00b3/s) - c = wave speed (m/s) - B = c/(gA) \u2014 characteristic impedance - R = f\u0394x/(2gDA\u00b2) \u2014 friction term</p>"},{"location":"wiki/water_hammer_implementation/#wave-speed-calculation","title":"Wave Speed Calculation","text":"<p>The wave speed includes pipe elasticity using the Korteweg-Joukowsky formula:</p> \\[c = \\frac{c_{fluid}}{\\sqrt{1 + \\frac{K \\cdot D}{E \\cdot e}}}\\] <p>Where: - \\(c_{fluid}\\) = speed of sound in fluid (from NeqSim thermodynamics) - K = fluid bulk modulus = \u03c1c\u00b2 - D = pipe diameter - E = pipe elastic modulus (default: 200 GPa for steel) - e = pipe wall thickness</p> <pre><code>// Wave speed is automatically calculated, but can be overridden\npipe.setPipeElasticModulus(200e9);  // Steel\npipe.setWallThickness(0.01);        // 10 mm\ndouble waveSpeed = pipe.getWaveSpeed();  // After run()\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#joukowsky-pressure-surge","title":"Joukowsky Pressure Surge","text":"<p>The theoretical pressure surge for instantaneous velocity change:</p> \\[\\Delta P = \\rho \\cdot c \\cdot \\Delta v\\] <pre><code>// Calculate theoretical surge\ndouble surgePa = pipe.calcJoukowskyPressureSurge(velocityChange);\ndouble surgeBar = pipe.calcJoukowskyPressureSurge(velocityChange, \"bar\");\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#boundary-conditions","title":"Boundary Conditions","text":""},{"location":"wiki/water_hammer_implementation/#available-types","title":"Available Types","text":"Type Description Use Case <code>RESERVOIR</code> Constant pressure head Upstream tank/reservoir <code>VALVE</code> Variable opening (0-1) Downstream control valve <code>CLOSED_END</code> No flow (Q=0) Dead end, closed valve <code>CONSTANT_FLOW</code> Fixed flow rate Pump at constant speed"},{"location":"wiki/water_hammer_implementation/#setting-boundary-conditions","title":"Setting Boundary Conditions","text":"<pre><code>// Upstream: constant pressure reservoir\npipe.setUpstreamBoundary(BoundaryType.RESERVOIR);\n\n// Downstream: valve that can be opened/closed\npipe.setDownstreamBoundary(BoundaryType.VALVE);\npipe.setValveOpening(1.0);  // Initially fully open\n\n// During simulation, close the valve\npipe.setValveOpening(0.5);  // 50% open\npipe.setValveOpening(0.0);  // Fully closed\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#time-step-and-stability","title":"Time Step and Stability","text":""},{"location":"wiki/water_hammer_implementation/#courant-condition","title":"Courant Condition","text":"<p>For numerical stability, the time step must satisfy:</p> \\[\\Delta t \\leq \\frac{\\Delta x}{c}\\] <p>Where \u0394x = length / (numberOfNodes - 1).</p> <pre><code>// Get maximum stable time step\ndouble maxDt = pipe.getMaxStableTimeStep();\n\n// Use smaller time step for safety\ndouble dt = maxDt * 0.5;\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#wave-round-trip-time","title":"Wave Round-Trip Time","text":"<p>The time for a pressure wave to travel the pipe length and back:</p> \\[T_{round-trip} = \\frac{2L}{c}\\] <pre><code>double roundTrip = pipe.getWaveRoundTripTime();\n// For 1 km pipe with c=1000 m/s: roundTrip = 2 seconds\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#output-and-results","title":"Output and Results","text":""},{"location":"wiki/water_hammer_implementation/#pressure-profile","title":"Pressure Profile","text":"<pre><code>// Pressure along pipe (Pa)\ndouble[] pressures = pipe.getPressureProfile();\n\n// Pressure in bar\ndouble[] pressuresBar = pipe.getPressureProfile(\"bar\");\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#velocity-and-flow-profiles","title":"Velocity and Flow Profiles","text":"<pre><code>double[] velocities = pipe.getVelocityProfile();  // m/s\ndouble[] flows = pipe.getFlowProfile();           // m\u00b3/s\ndouble[] heads = pipe.getHeadProfile();           // m\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#pressure-envelopes","title":"Pressure Envelopes","text":"<p>Track maximum and minimum pressures during simulation:</p> <pre><code>double[] maxEnvelope = pipe.getMaxPressureEnvelope();\ndouble[] minEnvelope = pipe.getMinPressureEnvelope();\n\ndouble overallMax = pipe.getMaxPressure(\"bar\");\ndouble overallMin = pipe.getMinPressure(\"bar\");\n\n// Reset envelopes (e.g., after reaching steady state)\npipe.resetEnvelopes();\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#time-history","title":"Time History","text":"<pre><code>List&lt;Double&gt; pressureHistory = pipe.getPressureHistory();  // At outlet\nList&lt;Double&gt; timeHistory = pipe.getTimeHistory();\ndouble currentTime = pipe.getCurrentTime();\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#example-emergency-shutdown","title":"Example: Emergency Shutdown","text":"<pre><code>// Setup: 5 km oil pipeline\nSystemInterface oil = new SystemSrkEos(298.15, 50.0);\noil.addComponent(\"nC10\", 1.0);\noil.setMixingRule(\"classic\");\noil.setTotalFlowRate(500000, \"kg/hr\");\n\nStream feed = new Stream(\"feed\", oil);\nfeed.run();\n\nWaterHammerPipe pipeline = new WaterHammerPipe(\"export pipeline\", feed);\npipeline.setLength(5, \"km\");\npipeline.setDiameter(300, \"mm\");\npipeline.setNumberOfNodes(200);\npipeline.setDownstreamBoundary(BoundaryType.VALVE);\npipeline.run();\n\nSystem.out.println(\"Wave speed: \" + pipeline.getWaveSpeed() + \" m/s\");\nSystem.out.println(\"Round-trip time: \" + pipeline.getWaveRoundTripTime() + \" s\");\n\n// Initial conditions\ndouble initialPressure = pipeline.getMaxPressure(\"bar\");\ndouble velocity = pipeline.getVelocityProfile()[0];\n\n// Simulate ESD - valve closes in 5 seconds\nUUID id = UUID.randomUUID();\ndouble dt = 0.01;  // 10 ms time step\ndouble closureTime = 5.0;\n\nfor (double t = 0; t &lt; 30; t += dt) {\n    // Linear valve closure from t=0 to t=closureTime\n    if (t &lt;= closureTime) {\n        pipeline.setValveOpening(1.0 - t / closureTime);\n    }\n\n    pipeline.runTransient(dt, id);\n\n    if (t % 1.0 &lt; dt) {\n        System.out.printf(\"t=%.1fs: P_max=%.1f bar, valve=%.0f%%%n\",\n            t, pipeline.getMaxPressure(\"bar\"), pipeline.getValveOpening() * 100);\n    }\n}\n\n// Results\ndouble maxSurge = pipeline.getMaxPressure(\"bar\");\ndouble minPressure = pipeline.getMinPressure(\"bar\");\n\nSystem.out.println(\"Initial pressure: \" + initialPressure + \" bar\");\nSystem.out.println(\"Maximum surge: \" + maxSurge + \" bar\");\nSystem.out.println(\"Minimum pressure: \" + minPressure + \" bar\");\nSystem.out.println(\"Surge increase: \" + (maxSurge - initialPressure) + \" bar\");\n\n// Compare with Joukowsky theoretical value\ndouble joukowskySurge = pipeline.calcJoukowskyPressureSurge(velocity, \"bar\");\nSystem.out.println(\"Joukowsky theoretical: \" + joukowskySurge + \" bar\");\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#example-gas-pipeline","title":"Example: Gas Pipeline","text":"<pre><code>// Natural gas pipeline\nSystemInterface gas = new SystemSrkEos(298.15, 70.0);\ngas.addComponent(\"methane\", 0.90);\ngas.addComponent(\"ethane\", 0.05);\ngas.addComponent(\"propane\", 0.03);\ngas.addComponent(\"CO2\", 0.02);\ngas.setMixingRule(\"classic\");\ngas.setTotalFlowRate(1000000, \"Sm3/day\");\n\nStream gasFeed = new Stream(\"gas feed\", gas);\ngasFeed.run();\n\nWaterHammerPipe gasPipe = new WaterHammerPipe(\"gas pipeline\", gasFeed);\ngasPipe.setLength(100, \"km\");\ngasPipe.setDiameter(0.5);           // 500 mm\ngasPipe.setNumberOfNodes(500);\ngasPipe.setDownstreamBoundary(BoundaryType.VALVE);\ngasPipe.run();\n\n// Gas has lower wave speed (~400 m/s) and lower density\n// So pressure surges are typically smaller than for liquids\nSystem.out.println(\"Gas wave speed: \" + gasPipe.getWaveSpeed() + \" m/s\");\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#api-reference","title":"API Reference","text":""},{"location":"wiki/water_hammer_implementation/#constructor","title":"Constructor","text":"<pre><code>WaterHammerPipe(String name)\nWaterHammerPipe(String name, StreamInterface inStream)\n</code></pre>"},{"location":"wiki/water_hammer_implementation/#geometry-methods","title":"Geometry Methods","text":"Method Description <code>setLength(double meters)</code> Pipe length in meters <code>setLength(double value, String unit)</code> Length with unit (\"m\", \"km\", \"ft\") <code>setDiameter(double meters)</code> Inside diameter in meters <code>setDiameter(double value, String unit)</code> Diameter with unit (\"m\", \"mm\", \"in\") <code>setWallThickness(double meters)</code> Pipe wall thickness <code>setRoughness(double meters)</code> Surface roughness <code>setElevationChange(double meters)</code> Outlet - inlet elevation <code>setNumberOfNodes(int nodes)</code> Computational grid size"},{"location":"wiki/water_hammer_implementation/#material-properties","title":"Material Properties","text":"Method Description <code>setPipeElasticModulus(double Pa)</code> Pipe material modulus (default: 200 GPa) <code>setWaveSpeed(double m_per_s)</code> Override calculated wave speed"},{"location":"wiki/water_hammer_implementation/#boundary-conditions_1","title":"Boundary Conditions","text":"Method Description <code>setUpstreamBoundary(BoundaryType)</code> Set upstream BC type <code>setDownstreamBoundary(BoundaryType)</code> Set downstream BC type <code>setValveOpening(double fraction)</code> Valve opening 0-1 <code>getValveOpening()</code> Current valve opening"},{"location":"wiki/water_hammer_implementation/#simulation-control","title":"Simulation Control","text":"Method Description <code>run(UUID id)</code> Initialize steady state <code>runTransient(double dt, UUID id)</code> Run one time step <code>getMaxStableTimeStep()</code> Get Courant-limited time step <code>setCourantNumber(double cn)</code> Set Courant number (default: 1.0) <code>reset()</code> Reset to initial state <code>resetEnvelopes()</code> Reset min/max tracking"},{"location":"wiki/water_hammer_implementation/#results","title":"Results","text":"Method Description <code>getPressureProfile()</code> Pressure array (Pa) <code>getPressureProfile(String unit)</code> Pressure in unit (\"bar\", \"psi\") <code>getVelocityProfile()</code> Velocity array (m/s) <code>getFlowProfile()</code> Flow rate array (m\u00b3/s) <code>getHeadProfile()</code> Piezometric head (m) <code>getMaxPressureEnvelope()</code> Max pressure at each node <code>getMinPressureEnvelope()</code> Min pressure at each node <code>getMaxPressure(String unit)</code> Overall maximum pressure <code>getMinPressure(String unit)</code> Overall minimum pressure <code>getPressureHistory()</code> Outlet pressure vs time <code>getTimeHistory()</code> Time values <code>getCurrentTime()</code> Current simulation time"},{"location":"wiki/water_hammer_implementation/#calculations","title":"Calculations","text":"Method Description <code>calcJoukowskyPressureSurge(double dv)</code> Theoretical surge (Pa) <code>calcJoukowskyPressureSurge(double dv, String unit)</code> Surge in unit <code>calcEffectiveWaveSpeed()</code> Korteweg wave speed <code>getWaveSpeed()</code> Current wave speed (m/s) <code>getWaveRoundTripTime()</code> 2L/c in seconds"},{"location":"wiki/water_hammer_implementation/#comparison-with-pipebeggsandbrills","title":"Comparison with PipeBeggsAndBrills","text":"Aspect PipeBeggsAndBrills WaterHammerPipe Wave speed Fluid velocity (~10-20 m/s) Speed of sound (400-1500 m/s) Time scale Minutes to hours Milliseconds to seconds Use case Slow transients, process upsets Fast transients, valve slam Physics Advection Acoustic waves Two-phase Full correlation Single-phase (liquid or gas) Heat transfer Included Not included <p>When to use which:</p> <ul> <li>PipeBeggsAndBrills: Production rate changes, separator upsets, slow valve operations</li> <li>WaterHammerPipe: ESD events, pump trips, check valve slam, pipe stress analysis</li> </ul>"},{"location":"wiki/water_hammer_implementation/#limitations","title":"Limitations","text":"<p>Current implementation limitations:</p> <ol> <li>Single-phase only - liquid or gas, no two-phase</li> <li>No heat transfer - isothermal assumption</li> <li>No column separation - vapor cavity modeling not included</li> <li>Simple friction - quasi-steady friction model</li> <li>No pipe networks - single pipe only</li> </ol>"},{"location":"wiki/water_hammer_implementation/#references","title":"References","text":"<ol> <li>Wylie, E.B. &amp; Streeter, V.L. (1993). Fluid Transients in Systems. Prentice Hall.</li> <li>Chaudhry, M.H. (2014). Applied Hydraulic Transients. Springer.</li> <li>Ghidaoui, M.S. et al. (2005). \"A Review of Water Hammer Theory and Practice\". Applied Mechanics Reviews.</li> </ol>"},{"location":"wiki/water_hammer_implementation/#see-also","title":"See Also","text":"<ul> <li>Pipeline Transient Simulation - Slow transients with PipeBeggsAndBrills</li> <li>Pipeline Pressure Drop - Steady-state pressure drop</li> <li>Pipeline Index - All pipeline documentation</li> </ul>"}]}