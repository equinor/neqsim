package neqsim.process.processmodel.diagram;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import neqsim.process.equipment.ProcessEquipmentInterface;
import neqsim.process.equipment.stream.StreamInterface;
import neqsim.process.processmodel.graph.ProcessEdge;
import neqsim.process.processmodel.graph.ProcessGraph;
import neqsim.process.processmodel.graph.ProcessGraphBuilder;
import neqsim.process.processmodel.graph.ProcessNode;
import neqsim.process.processmodel.ProcessSystem;
import neqsim.thermo.system.SystemInterface;

/**
 * Exports ProcessSystem as professional oil &amp; gas style process flow diagrams.
 *
 * <p>
 * This class generates PFDs that follow industry conventions:
 * </p>
 * <ul>
 * <li><b>Gravity logic</b> - Gas flows upward, liquids flow downward</li>
 * <li><b>Functional zoning</b> - Separation center, gas processing upper, liquid lower</li>
 * <li><b>Equipment semantics</b> - Separator outlets positioned correctly</li>
 * <li><b>Phase-aware styling</b> - Stream colors based on phase</li>
 * <li><b>Stable layout</b> - Same model produces same diagram every time</li>
 * </ul>
 *
 * <p>
 * Supported output formats:
 * </p>
 * <ul>
 * <li><b>DOT</b> - Graphviz DOT format (text)</li>
 * <li><b>SVG</b> - Scalable Vector Graphics (requires Graphviz installed)</li>
 * <li><b>PNG</b> - Portable Network Graphics (requires Graphviz installed)</li>
 * <li><b>PDF</b> - Portable Document Format (requires Graphviz installed)</li>
 * </ul>
 *
 * <p>
 * Usage:
 * </p>
 *
 * <pre>
 * ProcessDiagramExporter exporter = new ProcessDiagramExporter(processSystem);
 * String dot = exporter.toDOT();
 * exporter.exportSVG(Path.of("diagram.svg"));
 * </pre>
 *
 * @author NeqSim
 * @version 1.0
 */
public class ProcessDiagramExporter implements Serializable {
  private static final long serialVersionUID = 1000L;
  private static final Logger logger = LogManager.getLogger(ProcessDiagramExporter.class);

  /** The process system to export. */
  private final ProcessSystem processSystem;

  /** The layout policy for determining equipment positions. */
  private final PFDLayoutPolicy layoutPolicy;

  /** Detail level for the diagram. */
  private DiagramDetailLevel detailLevel = DiagramDetailLevel.ENGINEERING;

  /** Graph title. */
  private String title = "Process Flow Diagram";

  /** Whether to use vertical (top-down) layout. */
  private boolean verticalLayout = true;

  /** Whether to group equipment by role into clusters. */
  private boolean useClusters = true;

  /** Whether to show the legend. */
  private boolean showLegend = true;

  /** Whether to show stream values on edges. */
  private boolean showStreamValues = true;

  /** Whether to show stream values as tables (HTML labels). */
  private boolean useStreamTables = false;

  /** Whether to highlight recycle streams with special styling. */
  private boolean highlightRecycles = true;

  /** Whether to show control equipment (adjusters, calculators). */
  private boolean showControlEquipment = true;

  /**
   * Creates a new diagram exporter for a process system.
   *
   * @param processSystem the process system to export
   */
  public ProcessDiagramExporter(ProcessSystem processSystem) {
    this.processSystem = processSystem;
    this.layoutPolicy = new PFDLayoutPolicy();
  }

  /**
   * Creates a new diagram exporter with custom layout policy.
   *
   * @param processSystem the process system
   * @param layoutPolicy the layout policy to use
   */
  public ProcessDiagramExporter(ProcessSystem processSystem, PFDLayoutPolicy layoutPolicy) {
    this.processSystem = processSystem;
    this.layoutPolicy = layoutPolicy;
  }

  /**
   * Exports the process system as a DOT format string.
   *
   * @return Graphviz DOT format string
   */
  public String toDOT() {
    ProcessGraph graph = ProcessGraphBuilder.buildGraph(processSystem);
    return generateDOT(graph);
  }

  /**
   * Generates DOT format from a ProcessGraph.
   *
   * @param graph the process graph
   * @return DOT format string
   */
  private String generateDOT(ProcessGraph graph) {
    StringBuilder sb = new StringBuilder();

    // Graph header
    sb.append("digraph ProcessFlowDiagram {\n");
    sb.append("  // Generated by NeqSim ProcessDiagramExporter\n");
    sb.append("  // ").append(title).append("\n\n");

    // Graph attributes (always uses LR for industry-standard left-to-right flow)
    appendGraphAttributes(sb);

    // Rank groups for gravity-based layout
    Map<Integer, List<ProcessNode>> rankGroups = groupNodesByRank(graph);

    // Generate industry PFD layout: left-to-right with vertical phase zones
    appendRankSubgraphs(sb, rankGroups, graph);

    // Generate clusters if enabled
    if (useClusters) {
      appendClusters(sb, graph);
    }

    // Generate nodes
    sb.append("  // Equipment Nodes\n");
    for (ProcessNode node : graph.getNodes()) {
      if (shouldIncludeNode(node)) {
        appendNode(sb, node);
      }
    }
    sb.append("\n");

    // Generate edges
    sb.append("  // Stream Connections\n");
    for (ProcessEdge edge : graph.getEdges()) {
      if (shouldIncludeEdge(edge)) {
        appendEdge(sb, edge);
      }
    }
    sb.append("\n");

    // Legend
    if (showLegend) {
      appendLegend(sb);
    }

    sb.append("}\n");
    return sb.toString();
  }

  /**
   * Appends graph-level attributes for professional appearance.
   *
   * <p>
   * Industry-standard oil &amp; gas PFD layout:
   * </p>
   * <ul>
   * <li>Left-to-right process flow (rankdir=LR)</li>
   * <li>Vertical phase stratification via subgraphs and ordering</li>
   * <li>Feed streams enter from left, products exit right</li>
   * <li>Gas at top, oil in middle, water at bottom</li>
   * </ul>
   *
   * @param sb the string builder
   */
  private void appendGraphAttributes(StringBuilder sb) {
    sb.append("  // Graph attributes - Industry PFD conventions\n");
    sb.append("  // Left-to-right flow with vertical phase stratification\n");
    sb.append("  graph [\n");
    // Always use LR for industry-standard left-to-right flow
    // Vertical stratification is handled via subgraphs and ordering
    sb.append("    rankdir=LR\n");
    sb.append("    splines=ortho\n"); // Orthogonal routing like P&IDs
    sb.append("    nodesep=0.8\n");
    sb.append("    ranksep=1.2\n"); // Increased for clearer horizontal separation
    sb.append("    fontname=\"Arial\"\n");
    sb.append("    fontsize=12\n");
    sb.append("    label=\"").append(escapeString(title)).append("\"\n");
    sb.append("    labelloc=t\n");
    sb.append("    labeljust=c\n");
    sb.append("    bgcolor=white\n");
    sb.append("    pad=0.5\n");
    sb.append("    newrank=true\n"); // Enable new rank algorithm for better control
    sb.append("    ordering=out\n"); // Maintain edge ordering
    sb.append("  ];\n\n");

    sb.append("  // Default node attributes\n");
    sb.append("  node [\n");
    sb.append("    fontname=\"Arial\"\n");
    sb.append("    fontsize=10\n");
    sb.append("  ];\n\n");

    sb.append("  // Default edge attributes\n");
    sb.append("  edge [\n");
    sb.append("    fontname=\"Arial\"\n");
    sb.append("    fontsize=8\n");
    sb.append("    arrowsize=0.7\n");
    sb.append("  ];\n\n");
  }

  /**
   * Groups nodes by their rank level for vertical layout.
   *
   * @param graph the process graph
   * @return map of rank level to nodes
   */
  private Map<Integer, List<ProcessNode>> groupNodesByRank(ProcessGraph graph) {
    Map<Integer, List<ProcessNode>> rankGroups = new HashMap<>();
    for (ProcessNode node : graph.getNodes()) {
      int rank = layoutPolicy.getRankLevel(node);
      rankGroups.computeIfAbsent(rank, k -> new ArrayList<>()).add(node);
    }
    return rankGroups;
  }

  /**
   * Appends rank and ordering constraints for industry PFD layout.
   *
   * <p>
   * Creates a layout where:
   * </p>
   * <ul>
   * <li>Feed streams are on the LEFT (same horizontal rank)</li>
   * <li>Product streams are on the RIGHT (same horizontal rank)</li>
   * <li>Gas processing is at TOP (min vertical position)</li>
   * <li>Oil processing is in MIDDLE</li>
   * <li>Water processing is at BOTTOM (max vertical position)</li>
   * </ul>
   *
   * @param sb the string builder
   * @param rankGroups the rank groups (by phase)
   * @param graph the process graph
   */
  private void appendRankSubgraphs(StringBuilder sb, Map<Integer, List<ProcessNode>> rankGroups,
      ProcessGraph graph) {
    sb.append("  // Industry PFD layout: left-to-right flow with vertical phase zones\n\n");

    // Get source and sink nodes
    List<ProcessNode> sourceNodes = graph.getSourceNodes();
    List<ProcessNode> sinkNodes = graph.getSinkNodes();

    // Force feed streams to be on the left (same rank)
    if (!sourceNodes.isEmpty()) {
      sb.append("  // Feed streams (left side)\n");
      sb.append("  { rank=same; ");
      for (ProcessNode node : sourceNodes) {
        if (shouldIncludeNode(node)) {
          sb.append("\"").append(escapeString(node.getName())).append("\"; ");
        }
      }
      sb.append("}\n");
    }

    // Force product streams to be on the right (same rank)
    if (!sinkNodes.isEmpty()) {
      sb.append("  // Product streams (right side)\n");
      sb.append("  { rank=same; ");
      for (ProcessNode node : sinkNodes) {
        if (shouldIncludeNode(node)) {
          sb.append("\"").append(escapeString(node.getName())).append("\"; ");
        }
      }
      sb.append("}\n");
    }

    sb.append("\n");

    // Group processing equipment by phase zone for vertical ordering
    appendPhaseZoneOrdering(sb, graph, sourceNodes, sinkNodes);
  }

  /**
   * Appends vertical ordering constraints based on phase zones.
   *
   * <p>
   * Uses invisible edges to enforce vertical ordering: Gas → Oil → Water
   * </p>
   *
   * @param sb the string builder
   * @param graph the process graph
   * @param sourceNodes feed streams (excluded from phase ordering)
   * @param sinkNodes product streams (excluded from phase ordering)
   */
  private void appendPhaseZoneOrdering(StringBuilder sb, ProcessGraph graph,
      List<ProcessNode> sourceNodes, List<ProcessNode> sinkNodes) {
    // Collect nodes by phase zone (excluding feeds and products)
    Map<PFDLayoutPolicy.PhaseZone, List<ProcessNode>> phaseGroups = new HashMap<>();

    for (ProcessNode node : graph.getNodes()) {
      if (sourceNodes.contains(node) || sinkNodes.contains(node)) {
        continue; // Skip feeds and products - they use horizontal positioning only
      }
      if (!shouldIncludeNode(node)) {
        continue;
      }

      PFDLayoutPolicy.PhaseZone zone = layoutPolicy.classifyPhaseZone(node);
      phaseGroups.computeIfAbsent(zone, k -> new ArrayList<>()).add(node);
    }

    sb.append("  // Vertical phase zone ordering (Gas top → Oil middle → Water bottom)\n");

    // Create invisible edges between zone representative nodes to enforce vertical order
    ProcessNode gasRep = null;
    ProcessNode oilRep = null;
    ProcessNode waterRep = null;

    if (phaseGroups.containsKey(PFDLayoutPolicy.PhaseZone.GAS_TOP)) {
      List<ProcessNode> gasNodes = phaseGroups.get(PFDLayoutPolicy.PhaseZone.GAS_TOP);
      if (!gasNodes.isEmpty()) {
        gasRep = gasNodes.get(0);
      }
    }

    if (phaseGroups.containsKey(PFDLayoutPolicy.PhaseZone.OIL_MIDDLE)
        || phaseGroups.containsKey(PFDLayoutPolicy.PhaseZone.SEPARATION_CENTER)) {
      List<ProcessNode> oilNodes = phaseGroups.get(PFDLayoutPolicy.PhaseZone.OIL_MIDDLE);
      if (oilNodes != null && !oilNodes.isEmpty()) {
        oilRep = oilNodes.get(0);
      } else {
        List<ProcessNode> sepNodes = phaseGroups.get(PFDLayoutPolicy.PhaseZone.SEPARATION_CENTER);
        if (sepNodes != null && !sepNodes.isEmpty()) {
          oilRep = sepNodes.get(0);
        }
      }
    }

    if (phaseGroups.containsKey(PFDLayoutPolicy.PhaseZone.WATER_BOTTOM)) {
      List<ProcessNode> waterNodes = phaseGroups.get(PFDLayoutPolicy.PhaseZone.WATER_BOTTOM);
      if (!waterNodes.isEmpty()) {
        waterRep = waterNodes.get(0);
      }
    }

    // Create ordering edges (invisible, no weight on horizontal flow)
    if (gasRep != null && oilRep != null) {
      sb.append("  \"").append(escapeString(gasRep.getName())).append("\" -> \"");
      sb.append(escapeString(oilRep.getName()));
      sb.append("\" [style=invis, constraint=false];\n");
    }

    if (oilRep != null && waterRep != null) {
      sb.append("  \"").append(escapeString(oilRep.getName())).append("\" -> \"");
      sb.append(escapeString(waterRep.getName()));
      sb.append("\" [style=invis, constraint=false];\n");
    }

    sb.append("\n");
  }

  /**
   * Appends rank subgraphs for enforcing vertical ordering (legacy method).
   *
   * <p>
   * Deprecated: Use {@link #appendRankSubgraphs(StringBuilder, Map, ProcessGraph)} instead.
   * </p>
   *
   * @param sb the string builder
   * @param rankGroups the rank groups
   */
  @SuppressWarnings("unused")
  private void appendRankSubgraphsLegacy(StringBuilder sb,
      Map<Integer, List<ProcessNode>> rankGroups) {
    sb.append("  // Rank enforcement for gravity-based layout\n");

    // Gas equipment at top (rank 0)
    if (rankGroups.containsKey(0)) {
      sb.append("  { rank=min; ");
      for (ProcessNode node : rankGroups.get(0)) {
        sb.append("\"").append(escapeString(node.getName())).append("\"; ");
      }
      sb.append("}\n");
    }

    // Liquid equipment at bottom (rank 2)
    if (rankGroups.containsKey(2)) {
      sb.append("  { rank=max; ");
      for (ProcessNode node : rankGroups.get(2)) {
        sb.append("\"").append(escapeString(node.getName())).append("\"; ");
      }
      sb.append("}\n");
    }

    sb.append("\n");
  }

  /**
   * Appends cluster subgraphs for grouping equipment by phase zone.
   *
   * <p>
   * Creates visual clusters with vertical ordering:
   * </p>
   * <ul>
   * <li>Gas Processing (top) - light blue background</li>
   * <li>Separation (center anchor) - yellow/gold background</li>
   * <li>Oil Processing (middle) - tan/brown background</li>
   * <li>Water Processing (bottom) - blue background</li>
   * </ul>
   *
   * @param sb the string builder
   * @param graph the process graph
   */
  private void appendClusters(StringBuilder sb, ProcessGraph graph) {
    // Group by phase zone for proper vertical ordering
    Map<PFDLayoutPolicy.PhaseZone, List<ProcessNode>> zoneGroups = new HashMap<>();
    List<ProcessNode> sourceNodes = graph.getSourceNodes();
    List<ProcessNode> sinkNodes = graph.getSinkNodes();

    for (ProcessNode node : graph.getNodes()) {
      // Skip feeds and products - they're positioned by rank constraints
      if (sourceNodes.contains(node) || sinkNodes.contains(node)) {
        continue;
      }
      if (!shouldIncludeNode(node)) {
        continue;
      }

      PFDLayoutPolicy.PhaseZone zone = layoutPolicy.classifyPhaseZone(node);
      zoneGroups.computeIfAbsent(zone, k -> new ArrayList<>()).add(node);
    }

    sb.append("  // Phase zone clusters (Gas top → Oil middle → Water bottom)\n");

    // Gas processing cluster (top)
    if (zoneGroups.containsKey(PFDLayoutPolicy.PhaseZone.GAS_TOP)) {
      sb.append("  subgraph cluster_gas {\n");
      sb.append("    label=\"Gas Processing\"\n");
      sb.append("    style=dashed\n");
      sb.append("    color=\"#87CEEB\"\n");
      sb.append("    bgcolor=\"#F0F8FF\"\n");
      sb.append("    rank=min\n"); // Force to top
      for (ProcessNode node : zoneGroups.get(PFDLayoutPolicy.PhaseZone.GAS_TOP)) {
        sb.append("    \"").append(escapeString(node.getName())).append("\";\n");
      }
      sb.append("  }\n\n");
    }

    // Separation cluster (center anchor)
    if (zoneGroups.containsKey(PFDLayoutPolicy.PhaseZone.SEPARATION_CENTER)) {
      sb.append("  subgraph cluster_separation {\n");
      sb.append("    label=\"Separation\"\n");
      sb.append("    style=dashed\n");
      sb.append("    color=\"#FFD700\"\n");
      sb.append("    bgcolor=\"#FFFACD\"\n");
      for (ProcessNode node : zoneGroups.get(PFDLayoutPolicy.PhaseZone.SEPARATION_CENTER)) {
        sb.append("    \"").append(escapeString(node.getName())).append("\";\n");
      }
      sb.append("  }\n\n");
    }

    // Oil processing cluster (middle)
    if (zoneGroups.containsKey(PFDLayoutPolicy.PhaseZone.OIL_MIDDLE)) {
      sb.append("  subgraph cluster_oil {\n");
      sb.append("    label=\"Oil Processing\"\n");
      sb.append("    style=dashed\n");
      sb.append("    color=\"#8B4513\"\n");
      sb.append("    bgcolor=\"#FAEBD7\"\n");
      for (ProcessNode node : zoneGroups.get(PFDLayoutPolicy.PhaseZone.OIL_MIDDLE)) {
        sb.append("    \"").append(escapeString(node.getName())).append("\";\n");
      }
      sb.append("  }\n\n");
    }

    // Water processing cluster (bottom)
    if (zoneGroups.containsKey(PFDLayoutPolicy.PhaseZone.WATER_BOTTOM)) {
      sb.append("  subgraph cluster_water {\n");
      sb.append("    label=\"Water Processing\"\n");
      sb.append("    style=dashed\n");
      sb.append("    color=\"#1E90FF\"\n");
      sb.append("    bgcolor=\"#F0F8FF\"\n");
      sb.append("    rank=max\n"); // Force to bottom
      for (ProcessNode node : zoneGroups.get(PFDLayoutPolicy.PhaseZone.WATER_BOTTOM)) {
        sb.append("    \"").append(escapeString(node.getName())).append("\";\n");
      }
      sb.append("  }\n\n");
    }
  }

  /**
   * Determines if a node should be included in the diagram.
   *
   * @param node the process node
   * @return true if the node should be included
   */
  private boolean shouldIncludeNode(ProcessNode node) {
    if (showControlEquipment) {
      return true;
    }

    // Filter out control equipment if not shown
    EquipmentRole role = layoutPolicy.classifyEquipment(node.getEquipment());
    return role != EquipmentRole.CONTROL;
  }

  /**
   * Determines if an edge should be included in the diagram.
   *
   * @param edge the process edge
   * @return true if the edge should be included
   */
  private boolean shouldIncludeEdge(ProcessEdge edge) {
    if (showControlEquipment) {
      return true;
    }

    // Filter out edges connected to control equipment if not shown
    EquipmentRole sourceRole = layoutPolicy.classifyEquipment(edge.getSource().getEquipment());
    EquipmentRole targetRole = layoutPolicy.classifyEquipment(edge.getTarget().getEquipment());
    return sourceRole != EquipmentRole.CONTROL && targetRole != EquipmentRole.CONTROL;
  }

  /**
   * Appends a node definition to the DOT output.
   *
   * @param sb the string builder
   * @param node the process node
   */
  private void appendNode(StringBuilder sb, ProcessNode node) {
    ProcessEquipmentInterface equipment = node.getEquipment();
    String name = node.getName();
    String type = node.getEquipmentType();

    // Get visual style
    EquipmentVisualStyle style = EquipmentVisualStyle.getStyle(type);

    // Build label based on detail level
    String label = buildNodeLabel(equipment, name, type);

    sb.append("  \"").append(escapeString(name)).append("\" ");
    sb.append(style.toGraphvizAttributes(label));
    sb.append(";\n");
  }

  /**
   * Builds a node label based on the detail level.
   *
   * @param equipment the equipment
   * @param name the equipment name
   * @param type the equipment type
   * @return the formatted label
   */
  private String buildNodeLabel(ProcessEquipmentInterface equipment, String name, String type) {
    StringBuilder label = new StringBuilder();

    if (detailLevel.useCompactLabels()) {
      label.append(name);
    } else {
      label.append(name).append("\\n");
      label.append("(").append(type).append(")");

      if (detailLevel.showConditions()) {
        try {
          SystemInterface fluid = equipment.getFluid();
          if (fluid != null) {
            label.append("\\n");
            label.append(String.format("%.1f °C / %.1f bar", fluid.getTemperature("C"),
                fluid.getPressure("bara")));
          }
        } catch (Exception e) {
          // Ignore - conditions not available
        }
      }

      if (detailLevel.showFlowRates()) {
        try {
          if (equipment instanceof StreamInterface) {
            StreamInterface stream = (StreamInterface) equipment;
            double flowRate = stream.getFlowRate("kg/hr");
            label.append("\\n");
            label.append(String.format("%.1f kg/hr", flowRate));
          }
        } catch (Exception e) {
          // Ignore
        }
      }
    }

    return label.toString();
  }

  /**
   * Appends an edge definition to the DOT output.
   *
   * @param sb the string builder
   * @param edge the process edge
   */
  private void appendEdge(StringBuilder sb, ProcessEdge edge) {
    String sourceName = edge.getSource().getName();
    String targetName = edge.getTarget().getName();

    // Get phase-based styling
    PFDLayoutPolicy.StreamPhase phase = layoutPolicy.classifyEdgePhase(edge);

    sb.append("  \"").append(escapeString(sourceName)).append("\" -> \"");
    sb.append(escapeString(targetName)).append("\" ");
    sb.append("[");

    // Check if this is a recycle stream
    boolean isRecycle = edge.isBackEdge() || edge.isRecycle();

    // Edge color based on phase (or special for recycle)
    if (isRecycle && highlightRecycles) {
      sb.append("color=\"#9932CC\""); // Dark Orchid for recycles
    } else {
      sb.append("color=\"").append(phase.getColor()).append("\"");
    }

    // Edge style based on phase or recycle
    if (isRecycle && highlightRecycles) {
      sb.append(", style=\"dashed,bold\", penwidth=2");
      sb.append(", constraint=false"); // Allow recycles to go backwards
    } else if ("dashed".equals(phase.getLineStyle())) {
      sb.append(", style=dashed");
    } else if ("bold".equals(phase.getLineStyle())) {
      sb.append(", style=bold, penwidth=2");
    }

    // Stream value label
    if (showStreamValues && edge.getStream() != null) {
      String label = buildStreamLabel(edge.getStream(), isRecycle);
      if (!label.isEmpty()) {
        if (useStreamTables) {
          sb.append(", label=<").append(label).append(">");
        } else {
          sb.append(", label=\"").append(escapeString(label)).append("\"");
        }
      }
    }

    // Port positioning for separator outlets
    if (isSeparator(edge.getSource().getEquipment()) && edge.getStream() != null) {
      PFDLayoutPolicy.SeparatorOutlet outlet =
          layoutPolicy.classifySeparatorOutlet(edge.getSource().getEquipment(), edge.getStream());
      sb.append(", tailport=").append(outlet.getPort());
    }

    sb.append("];\n");
  }

  /**
   * Builds a stream label based on display settings.
   *
   * @param stream the stream
   * @param isRecycle whether this is a recycle stream
   * @return the label string (plain text or HTML)
   */
  private String buildStreamLabel(StreamInterface stream, boolean isRecycle) {
    try {
      if (useStreamTables) {
        return buildStreamTableLabel(stream, isRecycle);
      } else {
        return buildStreamTextLabel(stream, isRecycle);
      }
    } catch (Exception e) {
      return stream.getName();
    }
  }

  /**
   * Builds a simple text label for a stream.
   *
   * @param stream the stream
   * @param isRecycle whether this is a recycle stream
   * @return the text label
   */
  private String buildStreamTextLabel(StreamInterface stream, boolean isRecycle) {
    StringBuilder label = new StringBuilder();
    label.append(stream.getName());

    if (isRecycle) {
      label.append(" (R)");
    }

    if (detailLevel.showConditions()) {
      try {
        SystemInterface fluid = stream.getFluid();
        if (fluid != null) {
          label.append("\\n");
          label.append(String.format("%.1f°C, %.1f bar", fluid.getTemperature("C"),
              fluid.getPressure("bara")));
        }
      } catch (Exception e) {
        // Ignore
      }
    }

    if (detailLevel.showFlowRates()) {
      try {
        double flowRate = stream.getFlowRate("kg/hr");
        label.append("\\n");
        label.append(String.format("%.0f kg/hr", flowRate));
      } catch (Exception e) {
        // Ignore
      }
    }

    return label.toString();
  }

  /**
   * Builds an HTML table label for a stream (professional engineering style).
   *
   * @param stream the stream
   * @param isRecycle whether this is a recycle stream
   * @return the HTML table label
   */
  private String buildStreamTableLabel(StreamInterface stream, boolean isRecycle) {
    StringBuilder html = new StringBuilder();
    html.append("<TABLE BORDER=\"1\" CELLBORDER=\"0\" CELLSPACING=\"0\" CELLPADDING=\"2\"");
    html.append(" BGCOLOR=\"white\">");

    // Stream name header
    html.append("<TR><TD COLSPAN=\"2\" BGCOLOR=\"#E0E0E0\"><B>");
    html.append(escapeHtml(stream.getName()));
    if (isRecycle) {
      html.append(" <FONT COLOR=\"#9932CC\">(R)</FONT>");
    }
    html.append("</B></TD></TR>");

    try {
      SystemInterface fluid = stream.getFluid();
      if (fluid != null && detailLevel.showConditions()) {
        // Temperature row
        html.append("<TR><TD ALIGN=\"LEFT\">T:</TD><TD ALIGN=\"RIGHT\">");
        html.append(String.format("%.1f °C", fluid.getTemperature("C")));
        html.append("</TD></TR>");

        // Pressure row
        html.append("<TR><TD ALIGN=\"LEFT\">P:</TD><TD ALIGN=\"RIGHT\">");
        html.append(String.format("%.1f bar", fluid.getPressure("bara")));
        html.append("</TD></TR>");
      }

      if (detailLevel.showFlowRates()) {
        // Flow rate row
        double flowRate = stream.getFlowRate("kg/hr");
        html.append("<TR><TD ALIGN=\"LEFT\">F:</TD><TD ALIGN=\"RIGHT\">");
        html.append(String.format("%.0f kg/hr", flowRate));
        html.append("</TD></TR>");
      }
    } catch (Exception e) {
      // Ignore
    }

    html.append("</TABLE>");
    return html.toString();
  }

  /**
   * Escapes special characters for HTML labels.
   *
   * @param s the string
   * @return the escaped string
   */
  private String escapeHtml(String s) {
    if (s == null) {
      return "";
    }
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;");
  }

  /**
   * Checks if equipment is a separator type.
   *
   * @param equipment the equipment
   * @return true if separator
   */
  private boolean isSeparator(ProcessEquipmentInterface equipment) {
    EquipmentRole role = layoutPolicy.classifyEquipment(equipment);
    return role == EquipmentRole.SEPARATOR;
  }

  /**
   * Appends a legend to the diagram.
   *
   * @param sb the string builder
   */
  private void appendLegend(StringBuilder sb) {
    sb.append("  // Legend\n");
    sb.append("  subgraph cluster_legend {\n");
    sb.append("    label=\"Legend\"\n");
    sb.append("    style=rounded\n");
    sb.append("    color=gray\n");
    sb.append("    fontsize=10\n");
    sb.append("    \n");

    // Gas stream
    sb.append("    legend_gas [label=\"Gas Stream\" shape=plaintext];\n");
    sb.append("    legend_gas_line [label=\"\" shape=point width=0];\n");
    sb.append(
        "    legend_gas -> legend_gas_line [style=dashed, color=\"#87CEEB\", arrowhead=none];\n");
    sb.append("    \n");

    // Oil stream
    sb.append("    legend_oil [label=\"Oil Stream\" shape=plaintext];\n");
    sb.append("    legend_oil_line [label=\"\" shape=point width=0];\n");
    sb.append(
        "    legend_oil -> legend_oil_line [style=solid, color=\"#8B4513\", arrowhead=none];\n");
    sb.append("    \n");

    // Liquid stream
    sb.append("    legend_liquid [label=\"Liquid Stream\" shape=plaintext];\n");
    sb.append("    legend_liquid_line [label=\"\" shape=point width=0];\n");
    sb.append(
        "    legend_liquid -> legend_liquid_line [style=solid, color=\"#4169E1\", arrowhead=none];\n");
    sb.append("    \n");

    // Water/Aqueous stream
    sb.append("    legend_water [label=\"Water Stream\" shape=plaintext];\n");
    sb.append("    legend_water_line [label=\"\" shape=point width=0];\n");
    sb.append(
        "    legend_water -> legend_water_line [style=solid, color=\"#00CED1\", arrowhead=none];\n");
    sb.append("    \n");

    // Mixed stream
    sb.append("    legend_mixed [label=\"Mixed Stream\" shape=plaintext];\n");
    sb.append("    legend_mixed_line [label=\"\" shape=point width=0];\n");
    sb.append(
        "    legend_mixed -> legend_mixed_line [style=bold, color=\"#FFD700\", penwidth=2, arrowhead=none];\n");

    // Recycle stream (if enabled)
    if (highlightRecycles) {
      sb.append("    \n");
      sb.append("    legend_recycle [label=\"Recycle Stream\" shape=plaintext];\n");
      sb.append("    legend_recycle_line [label=\"\" shape=point width=0];\n");
      sb.append(
          "    legend_recycle -> legend_recycle_line [style=\"dashed,bold\", color=\"#9932CC\", penwidth=2, arrowhead=none];\n");
    }

    sb.append("  }\n");
  }

  /**
   * Escapes a string for use in DOT format.
   *
   * @param s the string
   * @return escaped string
   */
  private String escapeString(String s) {
    if (s == null) {
      return "";
    }
    return s.replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", "\\n");
  }

  /**
   * Exports the diagram to a file in DOT format.
   *
   * @param path the output file path
   * @throws IOException if writing fails
   */
  public void exportDOT(Path path) throws IOException {
    String dot = toDOT();
    Files.write(path, dot.getBytes(StandardCharsets.UTF_8));
    logger.info("Exported DOT diagram to: {}", path);
  }

  /**
   * Exports the diagram to SVG format using Graphviz.
   *
   * <p>
   * Requires Graphviz (dot) to be installed and in PATH.
   * </p>
   *
   * @param path the output file path
   * @throws IOException if export fails
   */
  public void exportSVG(Path path) throws IOException {
    exportWithGraphviz(path, "svg");
  }

  /**
   * Exports the diagram to PNG format using Graphviz.
   *
   * <p>
   * Requires Graphviz (dot) to be installed and in PATH.
   * </p>
   *
   * @param path the output file path
   * @throws IOException if export fails
   */
  public void exportPNG(Path path) throws IOException {
    exportWithGraphviz(path, "png");
  }

  /**
   * Exports the diagram to PDF format using Graphviz.
   *
   * <p>
   * Requires Graphviz (dot) to be installed and in PATH.
   * </p>
   *
   * @param path the output file path
   * @throws IOException if export fails
   */
  public void exportPDF(Path path) throws IOException {
    exportWithGraphviz(path, "pdf");
  }

  /**
   * Exports using Graphviz command-line tool.
   *
   * @param path output path
   * @param format output format (svg, png, pdf)
   * @throws IOException if export fails
   */
  private void exportWithGraphviz(Path path, String format) throws IOException {
    String dot = toDOT();

    // Write temporary DOT file
    Path tempDot = Files.createTempFile("neqsim_pfd_", ".dot");
    try {
      Files.write(tempDot, dot.getBytes(StandardCharsets.UTF_8));

      // Run Graphviz
      ProcessBuilder pb =
          new ProcessBuilder("dot", "-T" + format, tempDot.toString(), "-o", path.toString());
      pb.redirectErrorStream(true);

      Process process = pb.start();

      // Read output for error handling
      StringBuilder output = new StringBuilder();
      try (BufferedReader reader =
          new BufferedReader(new InputStreamReader(process.getInputStream()))) {
        String line;
        while ((line = reader.readLine()) != null) {
          output.append(line).append("\n");
        }
      }

      int exitCode = process.waitFor();
      if (exitCode != 0) {
        throw new IOException("Graphviz failed with exit code " + exitCode + ": " + output);
      }

      logger.info("Exported {} diagram to: {}", format.toUpperCase(), path);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new IOException("Graphviz execution interrupted", e);
    } finally {
      Files.deleteIfExists(tempDot);
    }
  }

  /**
   * Checks if Graphviz is available on the system.
   *
   * @return true if Graphviz (dot) is available
   */
  public static boolean isGraphvizAvailable() {
    try {
      ProcessBuilder pb = new ProcessBuilder("dot", "-V");
      pb.redirectErrorStream(true);
      Process process = pb.start();
      int exitCode = process.waitFor();
      return exitCode == 0;
    } catch (Exception e) {
      return false;
    }
  }

  // Setters for configuration

  /**
   * Sets the diagram title.
   *
   * @param title the title
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setTitle(String title) {
    this.title = title;
    return this;
  }

  /**
   * Sets the detail level.
   *
   * @param detailLevel the detail level
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setDetailLevel(DiagramDetailLevel detailLevel) {
    this.detailLevel = detailLevel;
    return this;
  }

  /**
   * Sets whether to use vertical (top-down) layout.
   *
   * @param verticalLayout true for vertical, false for horizontal
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setVerticalLayout(boolean verticalLayout) {
    this.verticalLayout = verticalLayout;
    return this;
  }

  /**
   * Sets whether to group equipment into clusters.
   *
   * @param useClusters true to use clusters
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setUseClusters(boolean useClusters) {
    this.useClusters = useClusters;
    return this;
  }

  /**
   * Sets whether to show the legend.
   *
   * @param showLegend true to show legend
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setShowLegend(boolean showLegend) {
    this.showLegend = showLegend;
    return this;
  }

  /**
   * Sets whether to show stream values on edges.
   *
   * @param showStreamValues true to show values
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setShowStreamValues(boolean showStreamValues) {
    this.showStreamValues = showStreamValues;
    return this;
  }

  /**
   * Sets whether to use HTML tables for stream values.
   *
   * <p>
   * When true, stream values are displayed in professional table format with temperature, pressure,
   * and flow rate. When false, values are shown as simple text labels.
   * </p>
   *
   * @param useStreamTables true to use tables
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setUseStreamTables(boolean useStreamTables) {
    this.useStreamTables = useStreamTables;
    return this;
  }

  /**
   * Sets whether to highlight recycle streams.
   *
   * @param highlightRecycles true to highlight recycles
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setHighlightRecycles(boolean highlightRecycles) {
    this.highlightRecycles = highlightRecycles;
    return this;
  }

  /**
   * Sets whether to show control equipment (adjusters, calculators, recycles).
   *
   * @param showControlEquipment true to show control equipment
   * @return this exporter for chaining
   */
  public ProcessDiagramExporter setShowControlEquipment(boolean showControlEquipment) {
    this.showControlEquipment = showControlEquipment;
    return this;
  }
}
