package neqsim.process.safety.risk.realtime;

import java.io.Serializable;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import com.google.gson.GsonBuilder;
import neqsim.process.equipment.ProcessEquipmentInterface;
import neqsim.process.processmodel.ProcessSystem;
import neqsim.process.safety.risk.OperationalRiskSimulator;
import neqsim.process.safety.risk.RiskMatrix;

/**
 * Real-time Risk Monitor for Digital Twin Integration.
 *
 * <p>
 * Provides continuous risk monitoring for process systems, enabling integration with digital twin
 * platforms, SCADA systems, and control room displays. Features include:
 * </p>
 * <ul>
 * <li>Continuous risk assessment with configurable update intervals</li>
 * <li>Risk trend tracking and anomaly detection</li>
 * <li>Alert generation for risk threshold breaches</li>
 * <li>REST API-compatible data formats for dashboard integration</li>
 * <li>Support for multiple monitoring points across a process</li>
 * </ul>
 *
 * @author NeqSim Development Team
 * @version 1.0
 */
public class RealTimeRiskMonitor implements Serializable, Runnable {

  private static final long serialVersionUID = 1000L;

  /** Monitor name. */
  private String name;

  /** Process system being monitored. */
  private transient ProcessSystem processSystem;

  /** Risk simulator. */
  private transient OperationalRiskSimulator riskSimulator;

  /** Update interval in seconds. */
  private int updateIntervalSeconds = 60;

  /** History retention (number of assessments). */
  private int historySize = 1440; // 24 hours at 1-minute intervals

  /** Current risk assessment. */
  private RealTimeRiskAssessment currentAssessment;

  /** Historical assessments. */
  private Queue<RealTimeRiskAssessment> assessmentHistory;

  /** Equipment-specific risk levels. */
  private Map<String, EquipmentRiskStatus> equipmentStatus;

  /** Alert thresholds. */
  private AlertThresholds alertThresholds;

  /** Active alerts. */
  private List<RiskAlert> activeAlerts;

  /** Alert listeners. */
  private transient List<AlertListener> alertListeners;

  /** Monitoring active flag. */
  private volatile boolean monitoringActive = false;

  /** Executor for scheduled monitoring. */
  private transient ScheduledExecutorService scheduler;

  /** Baseline risk level for anomaly detection. */
  private double baselineRiskLevel = 0;

  /** Standard deviation of baseline. */
  private double baselineStdDev = 0;

  /**
   * Risk alert generated by monitor.
   */
  public static class RiskAlert implements Serializable {
    private static final long serialVersionUID = 1L;

    public enum AlertSeverity {
      INFO, WARNING, HIGH, CRITICAL
    }

    public enum AlertType {
      RISK_THRESHOLD_EXCEEDED, RISK_TRENDING_UP, EQUIPMENT_DEGRADATION, ANOMALY_DETECTED, SIF_DEMAND, NEAR_MISS
    }

    private String alertId;
    private Instant timestamp;
    private AlertSeverity severity;
    private AlertType type;
    private String source;
    private String message;
    private double currentValue;
    private double thresholdValue;
    private boolean acknowledged;

    public RiskAlert(AlertSeverity severity, AlertType type, String source, String message) {
      this.alertId = java.util.UUID.randomUUID().toString();
      this.timestamp = Instant.now();
      this.severity = severity;
      this.type = type;
      this.source = source;
      this.message = message;
      this.acknowledged = false;
    }

    // Getters and setters
    public String getAlertId() {
      return alertId;
    }

    public Instant getTimestamp() {
      return timestamp;
    }

    public AlertSeverity getSeverity() {
      return severity;
    }

    public AlertType getType() {
      return type;
    }

    public String getSource() {
      return source;
    }

    public String getMessage() {
      return message;
    }

    public double getCurrentValue() {
      return currentValue;
    }

    public void setCurrentValue(double value) {
      this.currentValue = value;
    }

    public double getThresholdValue() {
      return thresholdValue;
    }

    public void setThresholdValue(double value) {
      this.thresholdValue = value;
    }

    public boolean isAcknowledged() {
      return acknowledged;
    }

    public void acknowledge() {
      this.acknowledged = true;
    }

    public Map<String, Object> toMap() {
      Map<String, Object> map = new HashMap<>();
      map.put("alertId", alertId);
      map.put("timestamp", timestamp.toString());
      map.put("severity", severity.name());
      map.put("type", type.name());
      map.put("source", source);
      map.put("message", message);
      map.put("currentValue", currentValue);
      map.put("thresholdValue", thresholdValue);
      map.put("acknowledged", acknowledged);
      return map;
    }
  }

  /**
   * Alert thresholds configuration.
   */
  public static class AlertThresholds implements Serializable {
    private static final long serialVersionUID = 1L;

    private double warningRiskLevel = 3.0; // Risk matrix score
    private double highRiskLevel = 6.0;
    private double criticalRiskLevel = 9.0;
    private double trendChangePercent = 20.0; // % increase triggers alert
    private double anomalyStdDevs = 3.0; // Standard deviations for anomaly

    public double getWarningRiskLevel() {
      return warningRiskLevel;
    }

    public void setWarningRiskLevel(double level) {
      this.warningRiskLevel = level;
    }

    public double getHighRiskLevel() {
      return highRiskLevel;
    }

    public void setHighRiskLevel(double level) {
      this.highRiskLevel = level;
    }

    public double getCriticalRiskLevel() {
      return criticalRiskLevel;
    }

    public void setCriticalRiskLevel(double level) {
      this.criticalRiskLevel = level;
    }

    public double getTrendChangePercent() {
      return trendChangePercent;
    }

    public void setTrendChangePercent(double percent) {
      this.trendChangePercent = percent;
    }

    public double getAnomalyStdDevs() {
      return anomalyStdDevs;
    }

    public void setAnomalyStdDevs(double stdDevs) {
      this.anomalyStdDevs = stdDevs;
    }
  }

  /**
   * Equipment-specific risk status.
   */
  public static class EquipmentRiskStatus implements Serializable {
    private static final long serialVersionUID = 1L;

    private String equipmentId;
    private String equipmentName;
    private double failureProbability;
    private double riskScore;
    private RiskMatrix.RiskLevel category;
    private Instant lastUpdated;
    private String healthStatus;

    public EquipmentRiskStatus(String id, String name) {
      this.equipmentId = id;
      this.equipmentName = name;
      this.lastUpdated = Instant.now();
      this.healthStatus = "NORMAL";
    }

    public String getEquipmentId() {
      return equipmentId;
    }

    public String getEquipmentName() {
      return equipmentName;
    }

    public double getFailureProbability() {
      return failureProbability;
    }

    public void setFailureProbability(double prob) {
      this.failureProbability = prob;
      this.lastUpdated = Instant.now();
    }

    public double getRiskScore() {
      return riskScore;
    }

    public void setRiskScore(double score) {
      this.riskScore = score;
    }

    public RiskMatrix.RiskLevel getCategory() {
      return category;
    }

    public void setCategory(RiskMatrix.RiskLevel cat) {
      this.category = cat;
    }

    public Instant getLastUpdated() {
      return lastUpdated;
    }

    public String getHealthStatus() {
      return healthStatus;
    }

    public void setHealthStatus(String status) {
      this.healthStatus = status;
    }

    public Map<String, Object> toMap() {
      Map<String, Object> map = new HashMap<>();
      map.put("equipmentId", equipmentId);
      map.put("equipmentName", equipmentName);
      map.put("failureProbability", failureProbability);
      map.put("riskScore", riskScore);
      map.put("category", category != null ? category.name() : "UNKNOWN");
      map.put("lastUpdated", lastUpdated.toString());
      map.put("healthStatus", healthStatus);
      return map;
    }
  }

  /**
   * Interface for alert listeners.
   */
  public interface AlertListener {
    void onAlert(RiskAlert alert);
  }

  /**
   * Creates a real-time risk monitor.
   *
   * @param name monitor name
   */
  public RealTimeRiskMonitor(String name) {
    this.name = name;
    this.assessmentHistory = new LinkedList<>();
    this.equipmentStatus = new ConcurrentHashMap<>();
    this.alertThresholds = new AlertThresholds();
    this.activeAlerts = new ArrayList<>();
    this.alertListeners = new ArrayList<>();
  }

  /**
   * Creates a real-time risk monitor for a process system.
   *
   * @param name monitor name
   * @param processSystem process system to monitor
   */
  public RealTimeRiskMonitor(String name, ProcessSystem processSystem) {
    this(name);
    setProcessSystem(processSystem);
  }

  /**
   * Sets the process system to monitor.
   *
   * @param processSystem process system
   */
  public void setProcessSystem(ProcessSystem processSystem) {
    this.processSystem = processSystem;
    this.riskSimulator = new OperationalRiskSimulator(processSystem);
    initializeEquipmentStatus();
  }

  private void initializeEquipmentStatus() {
    if (processSystem == null) {
      return;
    }
    // Initialize status for all equipment
    List<ProcessEquipmentInterface> units = processSystem.getUnitOperations();
    for (ProcessEquipmentInterface unit : units) {
      String name = unit.getName();
      equipmentStatus.put(name, new EquipmentRiskStatus(name, name));
    }
  }

  /**
   * Sets update interval.
   *
   * @param seconds interval in seconds
   */
  public void setUpdateIntervalSeconds(int seconds) {
    this.updateIntervalSeconds = seconds;
  }

  /**
   * Gets alert thresholds.
   *
   * @return alert thresholds
   */
  public AlertThresholds getAlertThresholds() {
    return alertThresholds;
  }

  /**
   * Adds an alert listener.
   *
   * @param listener alert listener
   */
  public void addAlertListener(AlertListener listener) {
    if (alertListeners == null) {
      alertListeners = new ArrayList<>();
    }
    alertListeners.add(listener);
  }

  /**
   * Starts continuous monitoring.
   */
  public void startMonitoring() {
    if (monitoringActive) {
      return;
    }
    monitoringActive = true;
    scheduler = Executors.newSingleThreadScheduledExecutor();
    scheduler.scheduleAtFixedRate(this, 0, updateIntervalSeconds, TimeUnit.SECONDS);
  }

  /**
   * Stops continuous monitoring.
   */
  public void stopMonitoring() {
    monitoringActive = false;
    if (scheduler != null) {
      scheduler.shutdown();
    }
  }

  /**
   * Performs a single risk assessment.
   *
   * @return current risk assessment
   */
  public RealTimeRiskAssessment assess() {
    if (riskSimulator == null) {
      throw new IllegalStateException("No process system configured for monitoring");
    }

    // Run simulation with 100 iterations over 1 day for quick assessment
    neqsim.process.safety.risk.OperationalRiskResult result = riskSimulator.runSimulation(100, 1.0);

    // Create assessment
    RealTimeRiskAssessment assessment = new RealTimeRiskAssessment();
    assessment.setTimestamp(Instant.now());
    assessment.setOverallRiskScore(calculateOverallRiskScore(result));
    assessment
        .setExpectedProductionLoss(result.getMaxPossibleProduction() - result.getMeanProduction());
    assessment.setAvailability(result.getMeanAvailability());

    // Update equipment status from simulation
    updateEquipmentStatus(assessment);

    // Add to history
    synchronized (assessmentHistory) {
      assessmentHistory.add(assessment);
      while (assessmentHistory.size() > historySize) {
        assessmentHistory.poll();
      }
    }

    // Check for alerts
    checkAlerts(assessment);

    // Calculate trends
    calculateTrends(assessment);

    currentAssessment = assessment;
    return assessment;
  }

  private double calculateOverallRiskScore(
      neqsim.process.safety.risk.OperationalRiskResult result) {
    // Simple scoring based on availability - lower availability means higher risk
    double availability = result.getMeanAvailability();
    // Convert to 0-10 scale: 100% availability = 0 risk, 0% availability = 10 risk
    return Math.min(10, (1.0 - availability) * 10);
  }

  private void updateEquipmentStatus(RealTimeRiskAssessment assessment) {
    // Update each equipment's risk status based on simulation results
    for (EquipmentRiskStatus status : equipmentStatus.values()) {
      // Simplified - in real implementation, get from simulation
      status.setFailureProbability(0.01);
      status.setRiskScore(status.getFailureProbability() * 10);
      status.setCategory(RiskMatrix.RiskLevel.LOW);
    }
    assessment.setEquipmentStatuses(new ArrayList<>(equipmentStatus.values()));
  }

  private void checkAlerts(RealTimeRiskAssessment assessment) {
    double riskScore = assessment.getOverallRiskScore();

    // Check threshold breaches
    if (riskScore >= alertThresholds.getCriticalRiskLevel()) {
      generateAlert(RiskAlert.AlertSeverity.CRITICAL, RiskAlert.AlertType.RISK_THRESHOLD_EXCEEDED,
          "System", "Critical risk level exceeded", riskScore,
          alertThresholds.getCriticalRiskLevel());
    } else if (riskScore >= alertThresholds.getHighRiskLevel()) {
      generateAlert(RiskAlert.AlertSeverity.HIGH, RiskAlert.AlertType.RISK_THRESHOLD_EXCEEDED,
          "System", "High risk level exceeded", riskScore, alertThresholds.getHighRiskLevel());
    } else if (riskScore >= alertThresholds.getWarningRiskLevel()) {
      generateAlert(RiskAlert.AlertSeverity.WARNING, RiskAlert.AlertType.RISK_THRESHOLD_EXCEEDED,
          "System", "Warning risk level exceeded", riskScore,
          alertThresholds.getWarningRiskLevel());
    }

    // Check for anomalies
    if (baselineRiskLevel > 0 && baselineStdDev > 0) {
      double deviation = Math.abs(riskScore - baselineRiskLevel) / baselineStdDev;
      if (deviation > alertThresholds.getAnomalyStdDevs()) {
        generateAlert(RiskAlert.AlertSeverity.WARNING, RiskAlert.AlertType.ANOMALY_DETECTED,
            "System",
            String.format("Risk level anomaly detected (%.1f std devs from baseline)", deviation),
            riskScore, baselineRiskLevel);
      }
    }
  }

  private void generateAlert(RiskAlert.AlertSeverity severity, RiskAlert.AlertType type,
      String source, String message, double current, double threshold) {
    RiskAlert alert = new RiskAlert(severity, type, source, message);
    alert.setCurrentValue(current);
    alert.setThresholdValue(threshold);
    activeAlerts.add(alert);

    // Notify listeners
    if (alertListeners != null) {
      for (AlertListener listener : alertListeners) {
        listener.onAlert(alert);
      }
    }
  }

  private void calculateTrends(RealTimeRiskAssessment assessment) {
    synchronized (assessmentHistory) {
      if (assessmentHistory.size() < 10) {
        return;
      }

      // Calculate trend over last 10 assessments
      List<RealTimeRiskAssessment> recent = new ArrayList<>();
      int count = 0;
      for (RealTimeRiskAssessment a : assessmentHistory) {
        if (count++ >= assessmentHistory.size() - 10) {
          recent.add(a);
        }
      }

      // Simple linear regression for trend
      double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
      int n = recent.size();
      for (int i = 0; i < n; i++) {
        sumX += i;
        sumY += recent.get(i).getOverallRiskScore();
        sumXY += i * recent.get(i).getOverallRiskScore();
        sumX2 += i * i;
      }
      double slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      assessment
          .setRiskTrend(slope > 0.01 ? "INCREASING" : slope < -0.01 ? "DECREASING" : "STABLE");
      assessment.setTrendSlope(slope);
    }
  }

  /**
   * Sets baseline for anomaly detection.
   *
   * @param baseline baseline risk level
   * @param stdDev standard deviation
   */
  public void setBaseline(double baseline, double stdDev) {
    this.baselineRiskLevel = baseline;
    this.baselineStdDev = stdDev;
  }

  /**
   * Calculates baseline from history.
   */
  public void calculateBaseline() {
    synchronized (assessmentHistory) {
      if (assessmentHistory.isEmpty()) {
        return;
      }

      double sum = 0, sumSq = 0;
      int n = assessmentHistory.size();
      for (RealTimeRiskAssessment a : assessmentHistory) {
        sum += a.getOverallRiskScore();
        sumSq += a.getOverallRiskScore() * a.getOverallRiskScore();
      }
      baselineRiskLevel = sum / n;
      baselineStdDev = Math.sqrt((sumSq - sum * sum / n) / (n - 1));
    }
  }

  @Override
  public void run() {
    try {
      assess();
    } catch (Exception e) {
      // Log error but continue monitoring
      System.err.println("Error in risk assessment: " + e.getMessage());
    }
  }

  // Getters

  public String getName() {
    return name;
  }

  public RealTimeRiskAssessment getCurrentAssessment() {
    return currentAssessment;
  }

  public List<RealTimeRiskAssessment> getAssessmentHistory() {
    synchronized (assessmentHistory) {
      return new ArrayList<>(assessmentHistory);
    }
  }

  public List<RiskAlert> getActiveAlerts() {
    return new ArrayList<>(activeAlerts);
  }

  public List<RiskAlert> getUnacknowledgedAlerts() {
    List<RiskAlert> unacked = new ArrayList<>();
    for (RiskAlert alert : activeAlerts) {
      if (!alert.isAcknowledged()) {
        unacked.add(alert);
      }
    }
    return unacked;
  }

  public void acknowledgeAlert(String alertId) {
    for (RiskAlert alert : activeAlerts) {
      if (alert.getAlertId().equals(alertId)) {
        alert.acknowledge();
        break;
      }
    }
  }

  public void clearAcknowledgedAlerts() {
    activeAlerts.removeIf(RiskAlert::isAcknowledged);
  }

  public Map<String, EquipmentRiskStatus> getEquipmentStatus() {
    return new HashMap<>(equipmentStatus);
  }

  public boolean isMonitoringActive() {
    return monitoringActive;
  }

  /**
   * Gets current status as JSON for dashboard integration.
   *
   * @return JSON string
   */
  public String toJson() {
    Map<String, Object> map = new HashMap<>();
    map.put("monitorName", name);
    map.put("monitoringActive", monitoringActive);
    map.put("updateIntervalSeconds", updateIntervalSeconds);

    if (currentAssessment != null) {
      map.put("currentAssessment", currentAssessment.toMap());
    }

    // Equipment status
    List<Map<String, Object>> statusList = new ArrayList<>();
    for (EquipmentRiskStatus status : equipmentStatus.values()) {
      statusList.add(status.toMap());
    }
    map.put("equipmentStatus", statusList);

    // Active alerts
    List<Map<String, Object>> alertList = new ArrayList<>();
    for (RiskAlert alert : activeAlerts) {
      alertList.add(alert.toMap());
    }
    map.put("activeAlerts", alertList);

    // Thresholds
    Map<String, Object> thresholds = new HashMap<>();
    thresholds.put("warning", alertThresholds.getWarningRiskLevel());
    thresholds.put("high", alertThresholds.getHighRiskLevel());
    thresholds.put("critical", alertThresholds.getCriticalRiskLevel());
    map.put("thresholds", thresholds);

    return new GsonBuilder().setPrettyPrinting().serializeSpecialFloatingPointValues().create()
        .toJson(map);
  }

  @Override
  public String toString() {
    return String.format("RealTimeRiskMonitor[%s, active=%s, score=%.2f]", name, monitoringActive,
        currentAssessment != null ? currentAssessment.getOverallRiskScore() : 0);
  }
}
